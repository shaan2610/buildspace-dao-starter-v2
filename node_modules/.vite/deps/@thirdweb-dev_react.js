import {
  require_react_dom
} from "./chunk-TTCSVPSE.js";
import {
  __commonJS,
  __esm,
  __export,
  __publicField,
  __reExport,
  __require,
  __toCommonJS,
  __toESM,
  require_react
} from "./chunk-FXCCUXWO.js";

// node_modules/cross-fetch/dist/browser-polyfill.js
var require_browser_polyfill = __commonJS({
  "node_modules/cross-fetch/dist/browser-polyfill.js"(exports2) {
    (function(self2) {
      var irrelevant = function(exports3) {
        var support = {
          searchParams: "URLSearchParams" in self2,
          iterable: "Symbol" in self2 && "iterator" in Symbol,
          blob: "FileReader" in self2 && "Blob" in self2 && function() {
            try {
              new Blob();
              return true;
            } catch (e6) {
              return false;
            }
          }(),
          formData: "FormData" in self2,
          arrayBuffer: "ArrayBuffer" in self2
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name2) {
          if (typeof name2 !== "string") {
            name2 = String(name2);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name2)) {
            throw new TypeError("Invalid character in header field name");
          }
          return name2.toLowerCase();
        }
        function normalizeValue(value2) {
          if (typeof value2 !== "string") {
            value2 = String(value2);
          }
          return value2;
        }
        function iteratorFor(items) {
          var iterator2 = {
            next: function() {
              var value2 = items.shift();
              return { done: value2 === void 0, value: value2 };
            }
          };
          if (support.iterable) {
            iterator2[Symbol.iterator] = function() {
              return iterator2;
            };
          }
          return iterator2;
        }
        function Headers(headers) {
          this.map = {};
          if (headers instanceof Headers) {
            headers.forEach(function(value2, name2) {
              this.append(name2, value2);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name2) {
              this.append(name2, headers[name2]);
            }, this);
          }
        }
        Headers.prototype.append = function(name2, value2) {
          name2 = normalizeName(name2);
          value2 = normalizeValue(value2);
          var oldValue = this.map[name2];
          this.map[name2] = oldValue ? oldValue + ", " + value2 : value2;
        };
        Headers.prototype["delete"] = function(name2) {
          delete this.map[normalizeName(name2)];
        };
        Headers.prototype.get = function(name2) {
          name2 = normalizeName(name2);
          return this.has(name2) ? this.map[name2] : null;
        };
        Headers.prototype.has = function(name2) {
          return this.map.hasOwnProperty(normalizeName(name2));
        };
        Headers.prototype.set = function(name2, value2) {
          this.map[normalizeName(name2)] = normalizeValue(value2);
        };
        Headers.prototype.forEach = function(callback, thisArg) {
          for (var name2 in this.map) {
            if (this.map.hasOwnProperty(name2)) {
              callback.call(thisArg, this.map[name2], name2, this);
            }
          }
        };
        Headers.prototype.keys = function() {
          var items = [];
          this.forEach(function(value2, name2) {
            items.push(name2);
          });
          return iteratorFor(items);
        };
        Headers.prototype.values = function() {
          var items = [];
          this.forEach(function(value2) {
            items.push(value2);
          });
          return iteratorFor(items);
        };
        Headers.prototype.entries = function() {
          var items = [];
          this.forEach(function(value2, name2) {
            items.push([name2, value2]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        }
        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsText(blob);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i6 = 0; i6 < view.length; i6++) {
            chars[i6] = String.fromCharCode(view[i6]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this._bodyInit = body;
            if (!body) {
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
              } else {
                return this.blob().then(readBlobAsArrayBuffer);
              }
            };
          }
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode3);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function normalizeMethod(method2) {
          var upcased = method2.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method2;
        }
        function Request(input, options) {
          options = options || {};
          var body = options.body;
          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal;
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
        }
        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit });
        };
        function decode3(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split("=");
              var name2 = split.shift().replace(/\+/g, " ");
              var value2 = split.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name2), decodeURIComponent(value2));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
            var parts = line.split(":");
            var key2 = parts.shift().trim();
            if (key2) {
              var value2 = parts.join(":").trim();
              headers.append(key2, value2);
            }
          });
          return headers;
        }
        Body.call(Request.prototype);
        function Response(bodyInit, options) {
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = "statusText" in options ? options.statusText : "OK";
          this.headers = new Headers(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response.prototype);
        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          });
        };
        Response.error = function() {
          var response = new Response(null, { status: 0, statusText: "" });
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response(null, { status, headers: { location: url } });
        };
        exports3.DOMException = self2.DOMException;
        try {
          new exports3.DOMException();
        } catch (err) {
          exports3.DOMException = function(message, name2) {
            this.message = message;
            this.name = name2;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports3.DOMException.prototype = Object.create(Error.prototype);
          exports3.DOMException.prototype.constructor = exports3.DOMException;
        }
        function fetch3(input, init2) {
          return new Promise(function(resolve, reject) {
            var request = new Request(input, init2);
            if (request.signal && request.signal.aborted) {
              return reject(new exports3.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              resolve(new Response(body, options));
            };
            xhr.onerror = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.ontimeout = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.onabort = function() {
              reject(new exports3.DOMException("Aborted", "AbortError"));
            };
            xhr.open(request.method, request.url, true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr && support.blob) {
              xhr.responseType = "blob";
            }
            request.headers.forEach(function(value2, name2) {
              xhr.setRequestHeader(name2, value2);
            });
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch3.polyfill = true;
        if (!self2.fetch) {
          self2.fetch = fetch3;
          self2.Headers = Headers;
          self2.Request = Request;
          self2.Response = Response;
        }
        exports3.Headers = Headers;
        exports3.Request = Request;
        exports3.Response = Response;
        exports3.fetch = fetch3;
        Object.defineProperty(exports3, "__esModule", { value: true });
        return exports3;
      }({});
    })(typeof self !== "undefined" ? self : exports2);
  }
});

// browser-external:buffer
var require_buffer = __commonJS({
  "browser-external:buffer"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_8, key2) {
        if (key2 !== "__esModule" && key2 !== "__proto__" && key2 !== "constructor" && key2 !== "splice") {
          throw new Error(`Module "buffer" has been externalized for browser compatibility. Cannot access "buffer.${key2}" in client code.`);
        }
      }
    }));
  }
});

// node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "node_modules/bn.js/lib/bn.js"(exports2, module2) {
    (function(module3, exports3) {
      "use strict";
      function assert3(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN4(number, base2, endian) {
        if (BN4.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base2 === "le" || base2 === "be") {
            endian = base2;
            base2 = 10;
          }
          this._init(number || 0, base2 || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN4;
      } else {
        exports3.BN = BN4;
      }
      BN4.BN = BN4;
      BN4.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = require_buffer().Buffer;
        }
      } catch (e6) {
      }
      BN4.isBN = function isBN(num) {
        if (num instanceof BN4) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN4.wordSize && Array.isArray(num.words);
      };
      BN4.max = function max2(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN4.min = function min2(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN4.prototype._init = function init2(number, base2, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base2, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base2, endian);
        }
        if (base2 === "hex") {
          base2 = 16;
        }
        assert3(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base2 === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base2, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base2, endian);
            }
          }
        }
      };
      BN4.prototype._initNumber = function _initNumber(number, base2, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert3(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN4.prototype._initArray = function _initArray(number, base2, endian) {
        assert3(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i6 = 0; i6 < this.length; i6++) {
          this.words[i6] = 0;
        }
        var j8, w8;
        var off = 0;
        if (endian === "be") {
          for (i6 = number.length - 1, j8 = 0; i6 >= 0; i6 -= 3) {
            w8 = number[i6] | number[i6 - 1] << 8 | number[i6 - 2] << 16;
            this.words[j8] |= w8 << off & 67108863;
            this.words[j8 + 1] = w8 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j8++;
            }
          }
        } else if (endian === "le") {
          for (i6 = 0, j8 = 0; i6 < number.length; i6 += 3) {
            w8 = number[i6] | number[i6 + 1] << 8 | number[i6 + 2] << 16;
            this.words[j8] |= w8 << off & 67108863;
            this.words[j8 + 1] = w8 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j8++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string, index) {
        var c5 = string.charCodeAt(index);
        if (c5 >= 65 && c5 <= 70) {
          return c5 - 55;
        } else if (c5 >= 97 && c5 <= 102) {
          return c5 - 87;
        } else {
          return c5 - 48 & 15;
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r6 = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r6 |= parseHex4Bits(string, index - 1) << 4;
        }
        return r6;
      }
      BN4.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i6 = 0; i6 < this.length; i6++) {
          this.words[i6] = 0;
        }
        var off = 0;
        var j8 = 0;
        var w8;
        if (endian === "be") {
          for (i6 = number.length - 1; i6 >= start; i6 -= 2) {
            w8 = parseHexByte(number, start, i6) << off;
            this.words[j8] |= w8 & 67108863;
            if (off >= 18) {
              off -= 18;
              j8 += 1;
              this.words[j8] |= w8 >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i6 = parseLength % 2 === 0 ? start + 1 : start; i6 < number.length; i6 += 2) {
            w8 = parseHexByte(number, start, i6) << off;
            this.words[j8] |= w8 & 67108863;
            if (off >= 18) {
              off -= 18;
              j8 += 1;
              this.words[j8] |= w8 >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul3) {
        var r6 = 0;
        var len = Math.min(str.length, end);
        for (var i6 = start; i6 < len; i6++) {
          var c5 = str.charCodeAt(i6) - 48;
          r6 *= mul3;
          if (c5 >= 49) {
            r6 += c5 - 49 + 10;
          } else if (c5 >= 17) {
            r6 += c5 - 17 + 10;
          } else {
            r6 += c5;
          }
        }
        return r6;
      }
      BN4.prototype._parseBase = function _parseBase(number, base2, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base2 | 0;
        var total = number.length - start;
        var mod2 = total % limbLen;
        var end = Math.min(total, total - mod2) + start;
        var word = 0;
        for (var i6 = start; i6 < end; i6 += limbLen) {
          word = parseBase(number, i6, i6 + limbLen, base2);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod2 !== 0) {
          var pow = 1;
          word = parseBase(number, i6, number.length, base2);
          for (i6 = 0; i6 < mod2; i6++) {
            pow *= base2;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN4.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i6 = 0; i6 < this.length; i6++) {
          dest.words[i6] = this.words[i6];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN4.prototype.clone = function clone() {
        var r6 = new BN4(null);
        this.copy(r6);
        return r6;
      };
      BN4.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN4.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN4.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN4.prototype.inspect = function inspect4() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros2 = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN4.prototype.toString = function toString2(base2, padding2) {
        base2 = base2 || 10;
        padding2 = padding2 | 0 || 1;
        var out;
        if (base2 === 16 || base2 === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i6 = 0; i6 < this.length; i6++) {
            var w8 = this.words[i6];
            var word = ((w8 << off | carry) & 16777215).toString(16);
            carry = w8 >>> 24 - off & 16777215;
            if (carry !== 0 || i6 !== this.length - 1) {
              out = zeros2[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i6--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
          var groupSize = groupSizes[base2];
          var groupBase = groupBases[base2];
          out = "";
          var c5 = this.clone();
          c5.negative = 0;
          while (!c5.isZero()) {
            var r6 = c5.modn(groupBase).toString(base2);
            c5 = c5.idivn(groupBase);
            if (!c5.isZero()) {
              out = zeros2[groupSize - r6.length] + r6 + out;
            } else {
              out = r6 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert3(false, "Base should be between 2 and 36");
      };
      BN4.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert3(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN4.prototype.toJSON = function toJSON2() {
        return this.toString(16);
      };
      BN4.prototype.toBuffer = function toBuffer(endian, length) {
        assert3(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length);
      };
      BN4.prototype.toArray = function toArray2(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN4.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert3(byteLength <= reqLength, "byte array longer than desired length");
        assert3(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b4, i6;
        var q8 = this.clone();
        if (!littleEndian) {
          for (i6 = 0; i6 < reqLength - byteLength; i6++) {
            res[i6] = 0;
          }
          for (i6 = 0; !q8.isZero(); i6++) {
            b4 = q8.andln(255);
            q8.iushrn(8);
            res[reqLength - i6 - 1] = b4;
          }
        } else {
          for (i6 = 0; !q8.isZero(); i6++) {
            b4 = q8.andln(255);
            q8.iushrn(8);
            res[i6] = b4;
          }
          for (; i6 < reqLength; i6++) {
            res[i6] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN4.prototype._countBits = function _countBits(w8) {
          return 32 - Math.clz32(w8);
        };
      } else {
        BN4.prototype._countBits = function _countBits(w8) {
          var t6 = w8;
          var r6 = 0;
          if (t6 >= 4096) {
            r6 += 13;
            t6 >>>= 13;
          }
          if (t6 >= 64) {
            r6 += 7;
            t6 >>>= 7;
          }
          if (t6 >= 8) {
            r6 += 4;
            t6 >>>= 4;
          }
          if (t6 >= 2) {
            r6 += 2;
            t6 >>>= 2;
          }
          return r6 + t6;
        };
      }
      BN4.prototype._zeroBits = function _zeroBits(w8) {
        if (w8 === 0)
          return 26;
        var t6 = w8;
        var r6 = 0;
        if ((t6 & 8191) === 0) {
          r6 += 13;
          t6 >>>= 13;
        }
        if ((t6 & 127) === 0) {
          r6 += 7;
          t6 >>>= 7;
        }
        if ((t6 & 15) === 0) {
          r6 += 4;
          t6 >>>= 4;
        }
        if ((t6 & 3) === 0) {
          r6 += 2;
          t6 >>>= 2;
        }
        if ((t6 & 1) === 0) {
          r6++;
        }
        return r6;
      };
      BN4.prototype.bitLength = function bitLength() {
        var w8 = this.words[this.length - 1];
        var hi2 = this._countBits(w8);
        return (this.length - 1) * 26 + hi2;
      };
      function toBitArray(num) {
        var w8 = new Array(num.bitLength());
        for (var bit = 0; bit < w8.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w8[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w8;
      }
      BN4.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r6 = 0;
        for (var i6 = 0; i6 < this.length; i6++) {
          var b4 = this._zeroBits(this.words[i6]);
          r6 += b4;
          if (b4 !== 26)
            break;
        }
        return r6;
      };
      BN4.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN4.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN4.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN4.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN4.prototype.neg = function neg3() {
        return this.clone().ineg();
      };
      BN4.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN4.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i6 = 0; i6 < num.length; i6++) {
          this.words[i6] = this.words[i6] | num.words[i6];
        }
        return this.strip();
      };
      BN4.prototype.ior = function ior(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN4.prototype.or = function or2(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN4.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN4.prototype.iuand = function iuand(num) {
        var b4;
        if (this.length > num.length) {
          b4 = num;
        } else {
          b4 = this;
        }
        for (var i6 = 0; i6 < b4.length; i6++) {
          this.words[i6] = this.words[i6] & num.words[i6];
        }
        this.length = b4.length;
        return this.strip();
      };
      BN4.prototype.iand = function iand(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN4.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN4.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN4.prototype.iuxor = function iuxor(num) {
        var a5;
        var b4;
        if (this.length > num.length) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        for (var i6 = 0; i6 < b4.length; i6++) {
          this.words[i6] = a5.words[i6] ^ b4.words[i6];
        }
        if (this !== a5) {
          for (; i6 < a5.length; i6++) {
            this.words[i6] = a5.words[i6];
          }
        }
        this.length = a5.length;
        return this.strip();
      };
      BN4.prototype.ixor = function ixor(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN4.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN4.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN4.prototype.inotn = function inotn(width) {
        assert3(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i6 = 0; i6 < bytesNeeded; i6++) {
          this.words[i6] = ~this.words[i6] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i6] = ~this.words[i6] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN4.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN4.prototype.setn = function setn(bit, val) {
        assert3(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN4.prototype.iadd = function iadd(num) {
        var r6;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r6 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r6 = this.isub(num);
          num.negative = 1;
          return r6._normSign();
        }
        var a5, b4;
        if (this.length > num.length) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        var carry = 0;
        for (var i6 = 0; i6 < b4.length; i6++) {
          r6 = (a5.words[i6] | 0) + (b4.words[i6] | 0) + carry;
          this.words[i6] = r6 & 67108863;
          carry = r6 >>> 26;
        }
        for (; carry !== 0 && i6 < a5.length; i6++) {
          r6 = (a5.words[i6] | 0) + carry;
          this.words[i6] = r6 & 67108863;
          carry = r6 >>> 26;
        }
        this.length = a5.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a5 !== this) {
          for (; i6 < a5.length; i6++) {
            this.words[i6] = a5.words[i6];
          }
        }
        return this;
      };
      BN4.prototype.add = function add3(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN4.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r6 = this.iadd(num);
          num.negative = 1;
          return r6._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a5, b4;
        if (cmp > 0) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        var carry = 0;
        for (var i6 = 0; i6 < b4.length; i6++) {
          r6 = (a5.words[i6] | 0) - (b4.words[i6] | 0) + carry;
          carry = r6 >> 26;
          this.words[i6] = r6 & 67108863;
        }
        for (; carry !== 0 && i6 < a5.length; i6++) {
          r6 = (a5.words[i6] | 0) + carry;
          carry = r6 >> 26;
          this.words[i6] = r6 & 67108863;
        }
        if (carry === 0 && i6 < a5.length && a5 !== this) {
          for (; i6 < a5.length; i6++) {
            this.words[i6] = a5.words[i6];
          }
        }
        this.length = Math.max(this.length, i6);
        if (a5 !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN4.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a5 = self2.words[0] | 0;
        var b4 = num.words[0] | 0;
        var r6 = a5 * b4;
        var lo = r6 & 67108863;
        var carry = r6 / 67108864 | 0;
        out.words[0] = lo;
        for (var k8 = 1; k8 < len; k8++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k8, num.length - 1);
          for (var j8 = Math.max(0, k8 - self2.length + 1); j8 <= maxJ; j8++) {
            var i6 = k8 - j8 | 0;
            a5 = self2.words[i6] | 0;
            b4 = num.words[j8] | 0;
            r6 = a5 * b4 + rword;
            ncarry += r6 / 67108864 | 0;
            rword = r6 & 67108863;
          }
          out.words[k8] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k8] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a5 = self2.words;
        var b4 = num.words;
        var o6 = out.words;
        var c5 = 0;
        var lo;
        var mid;
        var hi2;
        var a02 = a5[0] | 0;
        var al0 = a02 & 8191;
        var ah0 = a02 >>> 13;
        var a1 = a5[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a5[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a5[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a42 = a5[4] | 0;
        var al4 = a42 & 8191;
        var ah4 = a42 >>> 13;
        var a52 = a5[5] | 0;
        var al5 = a52 & 8191;
        var ah5 = a52 >>> 13;
        var a6 = a5[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a5[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a5[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a5[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b02 = b4[0] | 0;
        var bl0 = b02 & 8191;
        var bh0 = b02 >>> 13;
        var b1 = b4[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b4[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b4[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b42 = b4[4] | 0;
        var bl4 = b42 & 8191;
        var bh4 = b42 >>> 13;
        var b5 = b4[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b4[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b4[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b4[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b4[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi2 = Math.imul(ah0, bh0);
        var w02 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w02 >>> 26) | 0;
        w02 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi2 = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi2 = hi2 + Math.imul(ah0, bh1) | 0;
        var w1 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi2 = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi2 = hi2 + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi2 = hi2 + Math.imul(ah0, bh2) | 0;
        var w22 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi2 = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi2 = hi2 + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi2 = hi2 + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi2 = hi2 + Math.imul(ah0, bh3) | 0;
        var w32 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi2 = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi2 = hi2 + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi2 = hi2 + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi2 = hi2 + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi2 = hi2 + Math.imul(ah0, bh4) | 0;
        var w42 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
        w42 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi2 = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi2 = hi2 + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi2 = hi2 + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi2 = hi2 + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi2 = hi2 + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi2 = hi2 + Math.imul(ah0, bh5) | 0;
        var w52 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w52 >>> 26) | 0;
        w52 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi2 = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi2 = hi2 + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi2 = hi2 + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi2 = hi2 + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi2 = hi2 + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi2 = hi2 + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi2 = hi2 + Math.imul(ah0, bh6) | 0;
        var w62 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w62 >>> 26) | 0;
        w62 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi2 = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi2 = hi2 + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi2 = hi2 + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi2 = hi2 + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi2 = hi2 + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi2 = hi2 + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi2 = hi2 + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi2 = hi2 + Math.imul(ah0, bh7) | 0;
        var w72 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w72 >>> 26) | 0;
        w72 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi2 = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi2 = hi2 + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi2 = hi2 + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi2 = hi2 + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi2 = hi2 + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi2 = hi2 + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi2 = hi2 + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi2 = hi2 + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi2 = hi2 + Math.imul(ah0, bh8) | 0;
        var w8 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi2 = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi2 = hi2 + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi2 = hi2 + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi2 = hi2 + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi2 = hi2 + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi2 = hi2 + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi2 = hi2 + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi2 = hi2 + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi2 = hi2 + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi2 = hi2 + Math.imul(ah0, bh9) | 0;
        var w9 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi2 = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi2 = hi2 + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi2 = hi2 + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi2 = hi2 + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi2 = hi2 + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi2 = hi2 + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi2 = hi2 + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi2 = hi2 + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi2 = hi2 + Math.imul(ah1, bh9) | 0;
        var w10 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi2 = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi2 = hi2 + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi2 = hi2 + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi2 = hi2 + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi2 = hi2 + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi2 = hi2 + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi2 = hi2 + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi2 = hi2 + Math.imul(ah2, bh9) | 0;
        var w11 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi2 = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi2 = hi2 + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi2 = hi2 + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi2 = hi2 + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi2 = hi2 + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi2 = hi2 + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi2 = hi2 + Math.imul(ah3, bh9) | 0;
        var w12 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi2 = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi2 = hi2 + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi2 = hi2 + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi2 = hi2 + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi2 = hi2 + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi2 = hi2 + Math.imul(ah4, bh9) | 0;
        var w13 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi2 = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi2 = hi2 + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi2 = hi2 + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi2 = hi2 + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi2 = hi2 + Math.imul(ah5, bh9) | 0;
        var w14 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi2 = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi2 = hi2 + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi2 = hi2 + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi2 = hi2 + Math.imul(ah6, bh9) | 0;
        var w15 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi2 = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi2 = hi2 + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi2 = hi2 + Math.imul(ah7, bh9) | 0;
        var w16 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi2 = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi2 = hi2 + Math.imul(ah8, bh9) | 0;
        var w17 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi2 = Math.imul(ah9, bh9);
        var w18 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o6[0] = w02;
        o6[1] = w1;
        o6[2] = w22;
        o6[3] = w32;
        o6[4] = w42;
        o6[5] = w52;
        o6[6] = w62;
        o6[7] = w72;
        o6[8] = w8;
        o6[9] = w9;
        o6[10] = w10;
        o6[11] = w11;
        o6[12] = w12;
        o6[13] = w13;
        o6[14] = w14;
        o6[15] = w15;
        o6[16] = w16;
        o6[17] = w17;
        o6[18] = w18;
        if (c5 !== 0) {
          o6[19] = c5;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k8 = 0; k8 < out.length - 1; k8++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k8, num.length - 1);
          for (var j8 = Math.max(0, k8 - self2.length + 1); j8 <= maxJ; j8++) {
            var i6 = k8 - j8;
            var a5 = self2.words[i6] | 0;
            var b4 = num.words[j8] | 0;
            var r6 = a5 * b4;
            var lo = r6 & 67108863;
            ncarry = ncarry + (r6 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k8] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k8] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN4.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x6, y5) {
        this.x = x6;
        this.y = y5;
      }
      FFTM.prototype.makeRBT = function makeRBT(N7) {
        var t6 = new Array(N7);
        var l6 = BN4.prototype._countBits(N7) - 1;
        for (var i6 = 0; i6 < N7; i6++) {
          t6[i6] = this.revBin(i6, l6, N7);
        }
        return t6;
      };
      FFTM.prototype.revBin = function revBin(x6, l6, N7) {
        if (x6 === 0 || x6 === N7 - 1)
          return x6;
        var rb = 0;
        for (var i6 = 0; i6 < l6; i6++) {
          rb |= (x6 & 1) << l6 - i6 - 1;
          x6 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N7) {
        for (var i6 = 0; i6 < N7; i6++) {
          rtws[i6] = rws[rbt[i6]];
          itws[i6] = iws[rbt[i6]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N7, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N7);
        for (var s6 = 1; s6 < N7; s6 <<= 1) {
          var l6 = s6 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l6);
          var itwdf = Math.sin(2 * Math.PI / l6);
          for (var p7 = 0; p7 < N7; p7 += l6) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j8 = 0; j8 < s6; j8++) {
              var re = rtws[p7 + j8];
              var ie2 = itws[p7 + j8];
              var ro3 = rtws[p7 + j8 + s6];
              var io3 = itws[p7 + j8 + s6];
              var rx = rtwdf_ * ro3 - itwdf_ * io3;
              io3 = rtwdf_ * io3 + itwdf_ * ro3;
              ro3 = rx;
              rtws[p7 + j8] = re + ro3;
              itws[p7 + j8] = ie2 + io3;
              rtws[p7 + j8 + s6] = re - ro3;
              itws[p7 + j8 + s6] = ie2 - io3;
              if (j8 !== l6) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n4, m6) {
        var N7 = Math.max(m6, n4) | 1;
        var odd = N7 & 1;
        var i6 = 0;
        for (N7 = N7 / 2 | 0; N7; N7 = N7 >>> 1) {
          i6++;
        }
        return 1 << i6 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N7) {
        if (N7 <= 1)
          return;
        for (var i6 = 0; i6 < N7 / 2; i6++) {
          var t6 = rws[i6];
          rws[i6] = rws[N7 - i6 - 1];
          rws[N7 - i6 - 1] = t6;
          t6 = iws[i6];
          iws[i6] = -iws[N7 - i6 - 1];
          iws[N7 - i6 - 1] = -t6;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws2, N7) {
        var carry = 0;
        for (var i6 = 0; i6 < N7 / 2; i6++) {
          var w8 = Math.round(ws2[2 * i6 + 1] / N7) * 8192 + Math.round(ws2[2 * i6] / N7) + carry;
          ws2[i6] = w8 & 67108863;
          if (w8 < 67108864) {
            carry = 0;
          } else {
            carry = w8 / 67108864 | 0;
          }
        }
        return ws2;
      };
      FFTM.prototype.convert13b = function convert13b(ws2, len, rws, N7) {
        var carry = 0;
        for (var i6 = 0; i6 < len; i6++) {
          carry = carry + (ws2[i6] | 0);
          rws[2 * i6] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i6 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i6 = 2 * len; i6 < N7; ++i6) {
          rws[i6] = 0;
        }
        assert3(carry === 0);
        assert3((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N7) {
        var ph = new Array(N7);
        for (var i6 = 0; i6 < N7; i6++) {
          ph[i6] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x6, y5, out) {
        var N7 = 2 * this.guessLen13b(x6.length, y5.length);
        var rbt = this.makeRBT(N7);
        var _8 = this.stub(N7);
        var rws = new Array(N7);
        var rwst = new Array(N7);
        var iwst = new Array(N7);
        var nrws = new Array(N7);
        var nrwst = new Array(N7);
        var niwst = new Array(N7);
        var rmws = out.words;
        rmws.length = N7;
        this.convert13b(x6.words, x6.length, rws, N7);
        this.convert13b(y5.words, y5.length, nrws, N7);
        this.transform(rws, _8, rwst, iwst, N7, rbt);
        this.transform(nrws, _8, nrwst, niwst, N7, rbt);
        for (var i6 = 0; i6 < N7; i6++) {
          var rx = rwst[i6] * nrwst[i6] - iwst[i6] * niwst[i6];
          iwst[i6] = rwst[i6] * niwst[i6] + iwst[i6] * nrwst[i6];
          rwst[i6] = rx;
        }
        this.conjugate(rwst, iwst, N7);
        this.transform(rwst, iwst, rmws, _8, N7, rbt);
        this.conjugate(rmws, _8, N7);
        this.normalize13b(rmws, N7);
        out.negative = x6.negative ^ y5.negative;
        out.length = x6.length + y5.length;
        return out.strip();
      };
      BN4.prototype.mul = function mul3(num) {
        var out = new BN4(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN4.prototype.mulf = function mulf(num) {
        var out = new BN4(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN4.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN4.prototype.imuln = function imuln(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        var carry = 0;
        for (var i6 = 0; i6 < this.length; i6++) {
          var w8 = (this.words[i6] | 0) * num;
          var lo = (w8 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w8 / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i6] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i6] = carry;
          this.length++;
        }
        return this;
      };
      BN4.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN4.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN4.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN4.prototype.pow = function pow(num) {
        var w8 = toBitArray(num);
        if (w8.length === 0)
          return new BN4(1);
        var res = this;
        for (var i6 = 0; i6 < w8.length; i6++, res = res.sqr()) {
          if (w8[i6] !== 0)
            break;
        }
        if (++i6 < w8.length) {
          for (var q8 = res.sqr(); i6 < w8.length; i6++, q8 = q8.sqr()) {
            if (w8[i6] === 0)
              continue;
            res = res.mul(q8);
          }
        }
        return res;
      };
      BN4.prototype.iushln = function iushln(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r6 = bits % 26;
        var s6 = (bits - r6) / 26;
        var carryMask = 67108863 >>> 26 - r6 << 26 - r6;
        var i6;
        if (r6 !== 0) {
          var carry = 0;
          for (i6 = 0; i6 < this.length; i6++) {
            var newCarry = this.words[i6] & carryMask;
            var c5 = (this.words[i6] | 0) - newCarry << r6;
            this.words[i6] = c5 | carry;
            carry = newCarry >>> 26 - r6;
          }
          if (carry) {
            this.words[i6] = carry;
            this.length++;
          }
        }
        if (s6 !== 0) {
          for (i6 = this.length - 1; i6 >= 0; i6--) {
            this.words[i6 + s6] = this.words[i6];
          }
          for (i6 = 0; i6 < s6; i6++) {
            this.words[i6] = 0;
          }
          this.length += s6;
        }
        return this.strip();
      };
      BN4.prototype.ishln = function ishln(bits) {
        assert3(this.negative === 0);
        return this.iushln(bits);
      };
      BN4.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert3(typeof bits === "number" && bits >= 0);
        var h6;
        if (hint) {
          h6 = (hint - hint % 26) / 26;
        } else {
          h6 = 0;
        }
        var r6 = bits % 26;
        var s6 = Math.min((bits - r6) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r6 << r6;
        var maskedWords = extended;
        h6 -= s6;
        h6 = Math.max(0, h6);
        if (maskedWords) {
          for (var i6 = 0; i6 < s6; i6++) {
            maskedWords.words[i6] = this.words[i6];
          }
          maskedWords.length = s6;
        }
        if (s6 === 0) {
        } else if (this.length > s6) {
          this.length -= s6;
          for (i6 = 0; i6 < this.length; i6++) {
            this.words[i6] = this.words[i6 + s6];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i6 = this.length - 1; i6 >= 0 && (carry !== 0 || i6 >= h6); i6--) {
          var word = this.words[i6] | 0;
          this.words[i6] = carry << 26 - r6 | word >>> r6;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN4.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert3(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN4.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN4.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN4.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN4.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN4.prototype.testn = function testn(bit) {
        assert3(typeof bit === "number" && bit >= 0);
        var r6 = bit % 26;
        var s6 = (bit - r6) / 26;
        var q8 = 1 << r6;
        if (this.length <= s6)
          return false;
        var w8 = this.words[s6];
        return !!(w8 & q8);
      };
      BN4.prototype.imaskn = function imaskn(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r6 = bits % 26;
        var s6 = (bits - r6) / 26;
        assert3(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s6) {
          return this;
        }
        if (r6 !== 0) {
          s6++;
        }
        this.length = Math.min(s6, this.length);
        if (r6 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r6 << r6;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN4.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN4.prototype.iaddn = function iaddn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN4.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i6 = 0; i6 < this.length && this.words[i6] >= 67108864; i6++) {
          this.words[i6] -= 67108864;
          if (i6 === this.length - 1) {
            this.words[i6 + 1] = 1;
          } else {
            this.words[i6 + 1]++;
          }
        }
        this.length = Math.max(this.length, i6 + 1);
        return this;
      };
      BN4.prototype.isubn = function isubn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i6 = 0; i6 < this.length && this.words[i6] < 0; i6++) {
            this.words[i6] += 67108864;
            this.words[i6 + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN4.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN4.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN4.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN4.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN4.prototype._ishlnsubmul = function _ishlnsubmul(num, mul3, shift) {
        var len = num.length + shift;
        var i6;
        this._expand(len);
        var w8;
        var carry = 0;
        for (i6 = 0; i6 < num.length; i6++) {
          w8 = (this.words[i6 + shift] | 0) + carry;
          var right = (num.words[i6] | 0) * mul3;
          w8 -= right & 67108863;
          carry = (w8 >> 26) - (right / 67108864 | 0);
          this.words[i6 + shift] = w8 & 67108863;
        }
        for (; i6 < this.length - shift; i6++) {
          w8 = (this.words[i6 + shift] | 0) + carry;
          carry = w8 >> 26;
          this.words[i6 + shift] = w8 & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert3(carry === -1);
        carry = 0;
        for (i6 = 0; i6 < this.length; i6++) {
          w8 = -(this.words[i6] | 0) + carry;
          carry = w8 >> 26;
          this.words[i6] = w8 & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN4.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a5 = this.clone();
        var b4 = num;
        var bhi = b4.words[b4.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b4 = b4.ushln(shift);
          a5.iushln(shift);
          bhi = b4.words[b4.length - 1] | 0;
        }
        var m6 = a5.length - b4.length;
        var q8;
        if (mode !== "mod") {
          q8 = new BN4(null);
          q8.length = m6 + 1;
          q8.words = new Array(q8.length);
          for (var i6 = 0; i6 < q8.length; i6++) {
            q8.words[i6] = 0;
          }
        }
        var diff = a5.clone()._ishlnsubmul(b4, 1, m6);
        if (diff.negative === 0) {
          a5 = diff;
          if (q8) {
            q8.words[m6] = 1;
          }
        }
        for (var j8 = m6 - 1; j8 >= 0; j8--) {
          var qj = (a5.words[b4.length + j8] | 0) * 67108864 + (a5.words[b4.length + j8 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a5._ishlnsubmul(b4, qj, j8);
          while (a5.negative !== 0) {
            qj--;
            a5.negative = 0;
            a5._ishlnsubmul(b4, 1, j8);
            if (!a5.isZero()) {
              a5.negative ^= 1;
            }
          }
          if (q8) {
            q8.words[j8] = qj;
          }
        }
        if (q8) {
          q8.strip();
        }
        a5.strip();
        if (mode !== "div" && shift !== 0) {
          a5.iushrn(shift);
        }
        return {
          div: q8 || null,
          mod: a5
        };
      };
      BN4.prototype.divmod = function divmod(num, mode, positive) {
        assert3(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN4(0),
            mod: new BN4(0)
          };
        }
        var div, mod2, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.iadd(num);
            }
          }
          return {
            div,
            mod: mod2
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.isub(num);
            }
          }
          return {
            div: res.div,
            mod: mod2
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN4(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN4(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN4(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN4.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN4.prototype.mod = function mod2(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN4.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN4.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r22 = num.andln(1);
        var cmp = mod2.cmp(half);
        if (cmp < 0 || r22 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN4.prototype.modn = function modn(num) {
        assert3(num <= 67108863);
        var p7 = (1 << 26) % num;
        var acc = 0;
        for (var i6 = this.length - 1; i6 >= 0; i6--) {
          acc = (p7 * acc + (this.words[i6] | 0)) % num;
        }
        return acc;
      };
      BN4.prototype.idivn = function idivn(num) {
        assert3(num <= 67108863);
        var carry = 0;
        for (var i6 = this.length - 1; i6 >= 0; i6--) {
          var w8 = (this.words[i6] | 0) + carry * 67108864;
          this.words[i6] = w8 / num | 0;
          carry = w8 % num;
        }
        return this.strip();
      };
      BN4.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN4.prototype.egcd = function egcd(p7) {
        assert3(p7.negative === 0);
        assert3(!p7.isZero());
        var x6 = this;
        var y5 = p7.clone();
        if (x6.negative !== 0) {
          x6 = x6.umod(p7);
        } else {
          x6 = x6.clone();
        }
        var A8 = new BN4(1);
        var B4 = new BN4(0);
        var C5 = new BN4(0);
        var D5 = new BN4(1);
        var g7 = 0;
        while (x6.isEven() && y5.isEven()) {
          x6.iushrn(1);
          y5.iushrn(1);
          ++g7;
        }
        var yp = y5.clone();
        var xp = x6.clone();
        while (!x6.isZero()) {
          for (var i6 = 0, im = 1; (x6.words[0] & im) === 0 && i6 < 26; ++i6, im <<= 1)
            ;
          if (i6 > 0) {
            x6.iushrn(i6);
            while (i6-- > 0) {
              if (A8.isOdd() || B4.isOdd()) {
                A8.iadd(yp);
                B4.isub(xp);
              }
              A8.iushrn(1);
              B4.iushrn(1);
            }
          }
          for (var j8 = 0, jm = 1; (y5.words[0] & jm) === 0 && j8 < 26; ++j8, jm <<= 1)
            ;
          if (j8 > 0) {
            y5.iushrn(j8);
            while (j8-- > 0) {
              if (C5.isOdd() || D5.isOdd()) {
                C5.iadd(yp);
                D5.isub(xp);
              }
              C5.iushrn(1);
              D5.iushrn(1);
            }
          }
          if (x6.cmp(y5) >= 0) {
            x6.isub(y5);
            A8.isub(C5);
            B4.isub(D5);
          } else {
            y5.isub(x6);
            C5.isub(A8);
            D5.isub(B4);
          }
        }
        return {
          a: C5,
          b: D5,
          gcd: y5.iushln(g7)
        };
      };
      BN4.prototype._invmp = function _invmp(p7) {
        assert3(p7.negative === 0);
        assert3(!p7.isZero());
        var a5 = this;
        var b4 = p7.clone();
        if (a5.negative !== 0) {
          a5 = a5.umod(p7);
        } else {
          a5 = a5.clone();
        }
        var x1 = new BN4(1);
        var x22 = new BN4(0);
        var delta = b4.clone();
        while (a5.cmpn(1) > 0 && b4.cmpn(1) > 0) {
          for (var i6 = 0, im = 1; (a5.words[0] & im) === 0 && i6 < 26; ++i6, im <<= 1)
            ;
          if (i6 > 0) {
            a5.iushrn(i6);
            while (i6-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j8 = 0, jm = 1; (b4.words[0] & jm) === 0 && j8 < 26; ++j8, jm <<= 1)
            ;
          if (j8 > 0) {
            b4.iushrn(j8);
            while (j8-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a5.cmp(b4) >= 0) {
            a5.isub(b4);
            x1.isub(x22);
          } else {
            b4.isub(a5);
            x22.isub(x1);
          }
        }
        var res;
        if (a5.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p7);
        }
        return res;
      };
      BN4.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a5 = this.clone();
        var b4 = num.clone();
        a5.negative = 0;
        b4.negative = 0;
        for (var shift = 0; a5.isEven() && b4.isEven(); shift++) {
          a5.iushrn(1);
          b4.iushrn(1);
        }
        do {
          while (a5.isEven()) {
            a5.iushrn(1);
          }
          while (b4.isEven()) {
            b4.iushrn(1);
          }
          var r6 = a5.cmp(b4);
          if (r6 < 0) {
            var t6 = a5;
            a5 = b4;
            b4 = t6;
          } else if (r6 === 0 || b4.cmpn(1) === 0) {
            break;
          }
          a5.isub(b4);
        } while (true);
        return b4.iushln(shift);
      };
      BN4.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN4.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN4.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN4.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN4.prototype.bincn = function bincn(bit) {
        assert3(typeof bit === "number");
        var r6 = bit % 26;
        var s6 = (bit - r6) / 26;
        var q8 = 1 << r6;
        if (this.length <= s6) {
          this._expand(s6 + 1);
          this.words[s6] |= q8;
          return this;
        }
        var carry = q8;
        for (var i6 = s6; carry !== 0 && i6 < this.length; i6++) {
          var w8 = this.words[i6] | 0;
          w8 += carry;
          carry = w8 >>> 26;
          w8 &= 67108863;
          this.words[i6] = w8;
        }
        if (carry !== 0) {
          this.words[i6] = carry;
          this.length++;
        }
        return this;
      };
      BN4.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN4.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert3(num <= 67108863, "Number is too big");
          var w8 = this.words[0] | 0;
          res = w8 === num ? 0 : w8 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN4.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN4.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i6 = this.length - 1; i6 >= 0; i6--) {
          var a5 = this.words[i6] | 0;
          var b4 = num.words[i6] | 0;
          if (a5 === b4)
            continue;
          if (a5 < b4) {
            res = -1;
          } else if (a5 > b4) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN4.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN4.prototype.gt = function gt2(num) {
        return this.cmp(num) === 1;
      };
      BN4.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN4.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN4.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN4.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN4.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN4.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN4.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN4.prototype.eq = function eq4(num) {
        return this.cmp(num) === 0;
      };
      BN4.red = function red(num) {
        return new Red(num);
      };
      BN4.prototype.toRed = function toRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        assert3(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN4.prototype.fromRed = function fromRed() {
        assert3(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN4.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN4.prototype.forceRed = function forceRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN4.prototype.redAdd = function redAdd(num) {
        assert3(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN4.prototype.redIAdd = function redIAdd(num) {
        assert3(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN4.prototype.redSub = function redSub(num) {
        assert3(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN4.prototype.redISub = function redISub(num) {
        assert3(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN4.prototype.redShl = function redShl(num) {
        assert3(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN4.prototype.redMul = function redMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN4.prototype.redIMul = function redIMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN4.prototype.redSqr = function redSqr() {
        assert3(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN4.prototype.redISqr = function redISqr() {
        assert3(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN4.prototype.redSqrt = function redSqrt() {
        assert3(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN4.prototype.redInvm = function redInvm() {
        assert3(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN4.prototype.redNeg = function redNeg() {
        assert3(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN4.prototype.redPow = function redPow(num) {
        assert3(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name2, p7) {
        this.name = name2;
        this.p = new BN4(p7, 16);
        this.n = this.p.bitLength();
        this.k = new BN4(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN4(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r6 = num;
        var rlen;
        do {
          this.split(r6, this.tmp);
          r6 = this.imulK(r6);
          r6 = r6.iadd(this.tmp);
          rlen = r6.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r6.ucmp(this.p);
        if (cmp === 0) {
          r6.words[0] = 0;
          r6.length = 1;
        } else if (cmp > 0) {
          r6.isub(this.p);
        } else {
          if (r6.strip !== void 0) {
            r6.strip();
          } else {
            r6._strip();
          }
        }
        return r6;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i6 = 0; i6 < outLen; i6++) {
          output.words[i6] = input.words[i6];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i6 = 10; i6 < input.length; i6++) {
          var next = input.words[i6] | 0;
          input.words[i6 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i6 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i6 = 0; i6 < num.length; i6++) {
          var w8 = num.words[i6] | 0;
          lo += w8 * 977;
          num.words[i6] = lo & 67108863;
          lo = w8 * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i6 = 0; i6 < num.length; i6++) {
          var hi2 = (num.words[i6] | 0) * 19 + carry;
          var lo = hi2 & 67108863;
          hi2 >>>= 26;
          num.words[i6] = lo;
          carry = hi2;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN4._prime = function prime(name2) {
        if (primes[name2])
          return primes[name2];
        var prime2;
        if (name2 === "k256") {
          prime2 = new K256();
        } else if (name2 === "p224") {
          prime2 = new P224();
        } else if (name2 === "p192") {
          prime2 = new P192();
        } else if (name2 === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name2);
        }
        primes[name2] = prime2;
        return prime2;
      };
      function Red(m6) {
        if (typeof m6 === "string") {
          var prime = BN4._prime(m6);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert3(m6.gtn(1), "modulus must be greater than 1");
          this.m = m6;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a5) {
        assert3(a5.negative === 0, "red works only with positives");
        assert3(a5.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a5, b4) {
        assert3((a5.negative | b4.negative) === 0, "red works only with positives");
        assert3(
          a5.red && a5.red === b4.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a5) {
        if (this.prime)
          return this.prime.ireduce(a5)._forceRed(this);
        return a5.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg3(a5) {
        if (a5.isZero()) {
          return a5.clone();
        }
        return this.m.sub(a5)._forceRed(this);
      };
      Red.prototype.add = function add3(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.add(b4);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.iadd(b4);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.sub(b4);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.isub(b4);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a5, num) {
        this._verify1(a5);
        return this.imod(a5.ushln(num));
      };
      Red.prototype.imul = function imul(a5, b4) {
        this._verify2(a5, b4);
        return this.imod(a5.imul(b4));
      };
      Red.prototype.mul = function mul3(a5, b4) {
        this._verify2(a5, b4);
        return this.imod(a5.mul(b4));
      };
      Red.prototype.isqr = function isqr(a5) {
        return this.imul(a5, a5.clone());
      };
      Red.prototype.sqr = function sqr(a5) {
        return this.mul(a5, a5);
      };
      Red.prototype.sqrt = function sqrt(a5) {
        if (a5.isZero())
          return a5.clone();
        var mod3 = this.m.andln(3);
        assert3(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN4(1)).iushrn(2);
          return this.pow(a5, pow);
        }
        var q8 = this.m.subn(1);
        var s6 = 0;
        while (!q8.isZero() && q8.andln(1) === 0) {
          s6++;
          q8.iushrn(1);
        }
        assert3(!q8.isZero());
        var one = new BN4(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z6 = this.m.bitLength();
        z6 = new BN4(2 * z6 * z6).toRed(this);
        while (this.pow(z6, lpow).cmp(nOne) !== 0) {
          z6.redIAdd(nOne);
        }
        var c5 = this.pow(z6, q8);
        var r6 = this.pow(a5, q8.addn(1).iushrn(1));
        var t6 = this.pow(a5, q8);
        var m6 = s6;
        while (t6.cmp(one) !== 0) {
          var tmp = t6;
          for (var i6 = 0; tmp.cmp(one) !== 0; i6++) {
            tmp = tmp.redSqr();
          }
          assert3(i6 < m6);
          var b4 = this.pow(c5, new BN4(1).iushln(m6 - i6 - 1));
          r6 = r6.redMul(b4);
          c5 = b4.redSqr();
          t6 = t6.redMul(c5);
          m6 = i6;
        }
        return r6;
      };
      Red.prototype.invm = function invm(a5) {
        var inv = a5._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a5, num) {
        if (num.isZero())
          return new BN4(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a5.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN4(1).toRed(this);
        wnd[1] = a5;
        for (var i6 = 2; i6 < wnd.length; i6++) {
          wnd[i6] = this.mul(wnd[i6 - 1], a5);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i6 = num.length - 1; i6 >= 0; i6--) {
          var word = num.words[i6];
          for (var j8 = start - 1; j8 >= 0; j8--) {
            var bit = word >> j8 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i6 !== 0 || j8 !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r6 = num.umod(this.m);
        return r6 === num ? r6.clone() : r6;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN4.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m6) {
        Red.call(this, m6);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN4(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r6 = this.imod(num.mul(this.rinv));
        r6.red = null;
        return r6;
      };
      Mont.prototype.imul = function imul(a5, b4) {
        if (a5.isZero() || b4.isZero()) {
          a5.words[0] = 0;
          a5.length = 1;
          return a5;
        }
        var t6 = a5.imul(b4);
        var c5 = t6.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u7 = t6.isub(c5).iushrn(this.shift);
        var res = u7;
        if (u7.cmp(this.m) >= 0) {
          res = u7.isub(this.m);
        } else if (u7.cmpn(0) < 0) {
          res = u7.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul3(a5, b4) {
        if (a5.isZero() || b4.isZero())
          return new BN4(0)._forceRed(this);
        var t6 = a5.mul(b4);
        var c5 = t6.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u7 = t6.isub(c5).iushrn(this.shift);
        var res = u7;
        if (u7.cmp(this.m) >= 0) {
          res = u7.isub(this.m);
        } else if (u7.cmpn(0) < 0) {
          res = u7.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a5) {
        var res = this.imod(a5._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module2 === "undefined" || module2, exports2);
  }
});

// node_modules/@ethersproject/logger/lib.esm/_version.js
var version;
var init_version = __esm({
  "node_modules/@ethersproject/logger/lib.esm/_version.js"() {
    version = "logger/5.6.0";
  }
});

// node_modules/@ethersproject/logger/lib.esm/index.js
var lib_exports = {};
__export(lib_exports, {
  ErrorCode: () => ErrorCode,
  LogLevel: () => LogLevel,
  Logger: () => Logger
});
function _checkNormalize() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _permanentCensorErrors, _censorErrors, LogLevels, _logLevel, _globalLogger, _normalizeError, LogLevel, ErrorCode, HEX, Logger;
var init_lib = __esm({
  "node_modules/@ethersproject/logger/lib.esm/index.js"() {
    "use strict";
    init_version();
    _permanentCensorErrors = false;
    _censorErrors = false;
    LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
    _logLevel = LogLevels["default"];
    _globalLogger = null;
    _normalizeError = _checkNormalize();
    (function(LogLevel2) {
      LogLevel2["DEBUG"] = "DEBUG";
      LogLevel2["INFO"] = "INFO";
      LogLevel2["WARNING"] = "WARNING";
      LogLevel2["ERROR"] = "ERROR";
      LogLevel2["OFF"] = "OFF";
    })(LogLevel || (LogLevel = {}));
    (function(ErrorCode2) {
      ErrorCode2["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
      ErrorCode2["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
      ErrorCode2["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
      ErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
      ErrorCode2["SERVER_ERROR"] = "SERVER_ERROR";
      ErrorCode2["TIMEOUT"] = "TIMEOUT";
      ErrorCode2["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
      ErrorCode2["NUMERIC_FAULT"] = "NUMERIC_FAULT";
      ErrorCode2["MISSING_NEW"] = "MISSING_NEW";
      ErrorCode2["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
      ErrorCode2["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
      ErrorCode2["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
      ErrorCode2["CALL_EXCEPTION"] = "CALL_EXCEPTION";
      ErrorCode2["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
      ErrorCode2["NONCE_EXPIRED"] = "NONCE_EXPIRED";
      ErrorCode2["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
      ErrorCode2["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
      ErrorCode2["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
    })(ErrorCode || (ErrorCode = {}));
    HEX = "0123456789abcdef";
    Logger = class {
      constructor(version27) {
        Object.defineProperty(this, "version", {
          enumerable: true,
          value: version27,
          writable: false
        });
      }
      _log(logLevel, args) {
        const level = logLevel.toLowerCase();
        if (LogLevels[level] == null) {
          this.throwArgumentError("invalid log level name", "logLevel", logLevel);
        }
        if (_logLevel > LogLevels[level]) {
          return;
        }
        console.log.apply(console, args);
      }
      debug(...args) {
        this._log(Logger.levels.DEBUG, args);
      }
      info(...args) {
        this._log(Logger.levels.INFO, args);
      }
      warn(...args) {
        this._log(Logger.levels.WARNING, args);
      }
      makeError(message, code, params) {
        if (_censorErrors) {
          return this.makeError("censored error", code, {});
        }
        if (!code) {
          code = Logger.errors.UNKNOWN_ERROR;
        }
        if (!params) {
          params = {};
        }
        const messageDetails = [];
        Object.keys(params).forEach((key2) => {
          const value2 = params[key2];
          try {
            if (value2 instanceof Uint8Array) {
              let hex = "";
              for (let i6 = 0; i6 < value2.length; i6++) {
                hex += HEX[value2[i6] >> 4];
                hex += HEX[value2[i6] & 15];
              }
              messageDetails.push(key2 + "=Uint8Array(0x" + hex + ")");
            } else {
              messageDetails.push(key2 + "=" + JSON.stringify(value2));
            }
          } catch (error2) {
            messageDetails.push(key2 + "=" + JSON.stringify(params[key2].toString()));
          }
        });
        messageDetails.push(`code=${code}`);
        messageDetails.push(`version=${this.version}`);
        const reason = message;
        let url = "";
        switch (code) {
          case ErrorCode.NUMERIC_FAULT: {
            url = "NUMERIC_FAULT";
            const fault = message;
            switch (fault) {
              case "overflow":
              case "underflow":
              case "division-by-zero":
                url += "-" + fault;
                break;
              case "negative-power":
              case "negative-width":
                url += "-unsupported";
                break;
              case "unbound-bitwise-result":
                url += "-unbound-result";
                break;
            }
            break;
          }
          case ErrorCode.CALL_EXCEPTION:
          case ErrorCode.INSUFFICIENT_FUNDS:
          case ErrorCode.MISSING_NEW:
          case ErrorCode.NONCE_EXPIRED:
          case ErrorCode.REPLACEMENT_UNDERPRICED:
          case ErrorCode.TRANSACTION_REPLACED:
          case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
            url = code;
            break;
        }
        if (url) {
          message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
        }
        if (messageDetails.length) {
          message += " (" + messageDetails.join(", ") + ")";
        }
        const error = new Error(message);
        error.reason = reason;
        error.code = code;
        Object.keys(params).forEach(function(key2) {
          error[key2] = params[key2];
        });
        return error;
      }
      throwError(message, code, params) {
        throw this.makeError(message, code, params);
      }
      throwArgumentError(message, name2, value2) {
        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {
          argument: name2,
          value: value2
        });
      }
      assert(condition, message, code, params) {
        if (!!condition) {
          return;
        }
        this.throwError(message, code, params);
      }
      assertArgument(condition, message, name2, value2) {
        if (!!condition) {
          return;
        }
        this.throwArgumentError(message, name2, value2);
      }
      checkNormalize(message) {
        if (message == null) {
          message = "platform missing String.prototype.normalize";
        }
        if (_normalizeError) {
          this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "String.prototype.normalize",
            form: _normalizeError
          });
        }
      }
      checkSafeUint53(value2, message) {
        if (typeof value2 !== "number") {
          return;
        }
        if (message == null) {
          message = "value not safe";
        }
        if (value2 < 0 || value2 >= 9007199254740991) {
          this.throwError(message, Logger.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "out-of-safe-range",
            value: value2
          });
        }
        if (value2 % 1) {
          this.throwError(message, Logger.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "non-integer",
            value: value2
          });
        }
      }
      checkArgumentCount(count2, expectedCount, message) {
        if (message) {
          message = ": " + message;
        } else {
          message = "";
        }
        if (count2 < expectedCount) {
          this.throwError("missing argument" + message, Logger.errors.MISSING_ARGUMENT, {
            count: count2,
            expectedCount
          });
        }
        if (count2 > expectedCount) {
          this.throwError("too many arguments" + message, Logger.errors.UNEXPECTED_ARGUMENT, {
            count: count2,
            expectedCount
          });
        }
      }
      checkNew(target, kind) {
        if (target === Object || target == null) {
          this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
        }
      }
      checkAbstract(target, kind) {
        if (target === kind) {
          this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
        } else if (target === Object || target == null) {
          this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
        }
      }
      static globalLogger() {
        if (!_globalLogger) {
          _globalLogger = new Logger(version);
        }
        return _globalLogger;
      }
      static setCensorship(censorship, permanent) {
        if (!censorship && permanent) {
          this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "setCensorship"
          });
        }
        if (_permanentCensorErrors) {
          if (!censorship) {
            return;
          }
          this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "setCensorship"
          });
        }
        _censorErrors = !!censorship;
        _permanentCensorErrors = !!permanent;
      }
      static setLogLevel(logLevel) {
        const level = LogLevels[logLevel.toLowerCase()];
        if (level == null) {
          Logger.globalLogger().warn("invalid log level - " + logLevel);
          return;
        }
        _logLevel = level;
      }
      static from(version27) {
        return new Logger(version27);
      }
    };
    Logger.errors = ErrorCode;
    Logger.levels = LogLevel;
  }
});

// node_modules/@ethersproject/bytes/lib.esm/_version.js
var version2;
var init_version2 = __esm({
  "node_modules/@ethersproject/bytes/lib.esm/_version.js"() {
    version2 = "bytes/5.6.1";
  }
});

// node_modules/@ethersproject/bytes/lib.esm/index.js
var lib_exports2 = {};
__export(lib_exports2, {
  arrayify: () => arrayify,
  concat: () => concat,
  hexConcat: () => hexConcat,
  hexDataLength: () => hexDataLength,
  hexDataSlice: () => hexDataSlice,
  hexStripZeros: () => hexStripZeros,
  hexValue: () => hexValue,
  hexZeroPad: () => hexZeroPad,
  hexlify: () => hexlify,
  isBytes: () => isBytes,
  isBytesLike: () => isBytesLike,
  isHexString: () => isHexString,
  joinSignature: () => joinSignature,
  splitSignature: () => splitSignature,
  stripZeros: () => stripZeros,
  zeroPad: () => zeroPad
});
function isHexable(value2) {
  return !!value2.toHexString;
}
function addSlice(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isBytesLike(value2) {
  return isHexString(value2) && !(value2.length % 2) || isBytes(value2);
}
function isInteger(value2) {
  return typeof value2 === "number" && value2 == value2 && value2 % 1 === 0;
}
function isBytes(value2) {
  if (value2 == null) {
    return false;
  }
  if (value2.constructor === Uint8Array) {
    return true;
  }
  if (typeof value2 === "string") {
    return false;
  }
  if (!isInteger(value2.length) || value2.length < 0) {
    return false;
  }
  for (let i6 = 0; i6 < value2.length; i6++) {
    const v9 = value2[i6];
    if (!isInteger(v9) || v9 < 0 || v9 >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify(value2, options) {
  if (!options) {
    options = {};
  }
  if (typeof value2 === "number") {
    logger.checkSafeUint53(value2, "invalid arrayify value");
    const result = [];
    while (value2) {
      result.unshift(value2 & 255);
      value2 = parseInt(String(value2 / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value2 === "string" && value2.substring(0, 2) !== "0x") {
    value2 = "0x" + value2;
  }
  if (isHexable(value2)) {
    value2 = value2.toHexString();
  }
  if (isHexString(value2)) {
    let hex = value2.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger.throwArgumentError("hex data is odd-length", "value", value2);
      }
    }
    const result = [];
    for (let i6 = 0; i6 < hex.length; i6 += 2) {
      result.push(parseInt(hex.substring(i6, i6 + 2), 16));
    }
    return addSlice(new Uint8Array(result));
  }
  if (isBytes(value2)) {
    return addSlice(new Uint8Array(value2));
  }
  return logger.throwArgumentError("invalid arrayify value", "value", value2);
}
function concat(items) {
  const objects = items.map((item) => arrayify(item));
  const length = objects.reduce((accum, item) => accum + item.length, 0);
  const result = new Uint8Array(length);
  objects.reduce((offset, object) => {
    result.set(object, offset);
    return offset + object.length;
  }, 0);
  return addSlice(result);
}
function stripZeros(value2) {
  let result = arrayify(value2);
  if (result.length === 0) {
    return result;
  }
  let start = 0;
  while (start < result.length && result[start] === 0) {
    start++;
  }
  if (start) {
    result = result.slice(start);
  }
  return result;
}
function zeroPad(value2, length) {
  value2 = arrayify(value2);
  if (value2.length > length) {
    logger.throwArgumentError("value out of range", "value", arguments[0]);
  }
  const result = new Uint8Array(length);
  result.set(value2, length - value2.length);
  return addSlice(result);
}
function isHexString(value2, length) {
  if (typeof value2 !== "string" || !value2.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value2.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
function hexlify(value2, options) {
  if (!options) {
    options = {};
  }
  if (typeof value2 === "number") {
    logger.checkSafeUint53(value2, "invalid hexlify value");
    let hex = "";
    while (value2) {
      hex = HexCharacters[value2 & 15] + hex;
      value2 = Math.floor(value2 / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value2 === "bigint") {
    value2 = value2.toString(16);
    if (value2.length % 2) {
      return "0x0" + value2;
    }
    return "0x" + value2;
  }
  if (options.allowMissingPrefix && typeof value2 === "string" && value2.substring(0, 2) !== "0x") {
    value2 = "0x" + value2;
  }
  if (isHexable(value2)) {
    return value2.toHexString();
  }
  if (isHexString(value2)) {
    if (value2.length % 2) {
      if (options.hexPad === "left") {
        value2 = "0x0" + value2.substring(2);
      } else if (options.hexPad === "right") {
        value2 += "0";
      } else {
        logger.throwArgumentError("hex data is odd-length", "value", value2);
      }
    }
    return value2.toLowerCase();
  }
  if (isBytes(value2)) {
    let result = "0x";
    for (let i6 = 0; i6 < value2.length; i6++) {
      let v9 = value2[i6];
      result += HexCharacters[(v9 & 240) >> 4] + HexCharacters[v9 & 15];
    }
    return result;
  }
  return logger.throwArgumentError("invalid hexlify value", "value", value2);
}
function hexDataLength(data) {
  if (typeof data !== "string") {
    data = hexlify(data);
  } else if (!isHexString(data) || data.length % 2) {
    return null;
  }
  return (data.length - 2) / 2;
}
function hexDataSlice(data, offset, endOffset) {
  if (typeof data !== "string") {
    data = hexlify(data);
  } else if (!isHexString(data) || data.length % 2) {
    logger.throwArgumentError("invalid hexData", "value", data);
  }
  offset = 2 + 2 * offset;
  if (endOffset != null) {
    return "0x" + data.substring(offset, 2 + 2 * endOffset);
  }
  return "0x" + data.substring(offset);
}
function hexConcat(items) {
  let result = "0x";
  items.forEach((item) => {
    result += hexlify(item).substring(2);
  });
  return result;
}
function hexValue(value2) {
  const trimmed = hexStripZeros(hexlify(value2, { hexPad: "left" }));
  if (trimmed === "0x") {
    return "0x0";
  }
  return trimmed;
}
function hexStripZeros(value2) {
  if (typeof value2 !== "string") {
    value2 = hexlify(value2);
  }
  if (!isHexString(value2)) {
    logger.throwArgumentError("invalid hex string", "value", value2);
  }
  value2 = value2.substring(2);
  let offset = 0;
  while (offset < value2.length && value2[offset] === "0") {
    offset++;
  }
  return "0x" + value2.substring(offset);
}
function hexZeroPad(value2, length) {
  if (typeof value2 !== "string") {
    value2 = hexlify(value2);
  } else if (!isHexString(value2)) {
    logger.throwArgumentError("invalid hex string", "value", value2);
  }
  if (value2.length > 2 * length + 2) {
    logger.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value2.length < 2 * length + 2) {
    value2 = "0x0" + value2.substring(2);
  }
  return value2;
}
function splitSignature(signature2) {
  const result = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };
  if (isBytesLike(signature2)) {
    let bytes = arrayify(signature2);
    if (bytes.length === 64) {
      result.v = 27 + (bytes[32] >> 7);
      bytes[32] &= 127;
      result.r = hexlify(bytes.slice(0, 32));
      result.s = hexlify(bytes.slice(32, 64));
    } else if (bytes.length === 65) {
      result.r = hexlify(bytes.slice(0, 32));
      result.s = hexlify(bytes.slice(32, 64));
      result.v = bytes[64];
    } else {
      logger.throwArgumentError("invalid signature string", "signature", signature2);
    }
    if (result.v < 27) {
      if (result.v === 0 || result.v === 1) {
        result.v += 27;
      } else {
        logger.throwArgumentError("signature invalid v byte", "signature", signature2);
      }
    }
    result.recoveryParam = 1 - result.v % 2;
    if (result.recoveryParam) {
      bytes[32] |= 128;
    }
    result._vs = hexlify(bytes.slice(32, 64));
  } else {
    result.r = signature2.r;
    result.s = signature2.s;
    result.v = signature2.v;
    result.recoveryParam = signature2.recoveryParam;
    result._vs = signature2._vs;
    if (result._vs != null) {
      const vs2 = zeroPad(arrayify(result._vs), 32);
      result._vs = hexlify(vs2);
      const recoveryParam = vs2[0] >= 128 ? 1 : 0;
      if (result.recoveryParam == null) {
        result.recoveryParam = recoveryParam;
      } else if (result.recoveryParam !== recoveryParam) {
        logger.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature2);
      }
      vs2[0] &= 127;
      const s6 = hexlify(vs2);
      if (result.s == null) {
        result.s = s6;
      } else if (result.s !== s6) {
        logger.throwArgumentError("signature v mismatch _vs", "signature", signature2);
      }
    }
    if (result.recoveryParam == null) {
      if (result.v == null) {
        logger.throwArgumentError("signature missing v and recoveryParam", "signature", signature2);
      } else if (result.v === 0 || result.v === 1) {
        result.recoveryParam = result.v;
      } else {
        result.recoveryParam = 1 - result.v % 2;
      }
    } else {
      if (result.v == null) {
        result.v = 27 + result.recoveryParam;
      } else {
        const recId = result.v === 0 || result.v === 1 ? result.v : 1 - result.v % 2;
        if (result.recoveryParam !== recId) {
          logger.throwArgumentError("signature recoveryParam mismatch v", "signature", signature2);
        }
      }
    }
    if (result.r == null || !isHexString(result.r)) {
      logger.throwArgumentError("signature missing or invalid r", "signature", signature2);
    } else {
      result.r = hexZeroPad(result.r, 32);
    }
    if (result.s == null || !isHexString(result.s)) {
      logger.throwArgumentError("signature missing or invalid s", "signature", signature2);
    } else {
      result.s = hexZeroPad(result.s, 32);
    }
    const vs = arrayify(result.s);
    if (vs[0] >= 128) {
      logger.throwArgumentError("signature s out of range", "signature", signature2);
    }
    if (result.recoveryParam) {
      vs[0] |= 128;
    }
    const _vs = hexlify(vs);
    if (result._vs) {
      if (!isHexString(result._vs)) {
        logger.throwArgumentError("signature invalid _vs", "signature", signature2);
      }
      result._vs = hexZeroPad(result._vs, 32);
    }
    if (result._vs == null) {
      result._vs = _vs;
    } else if (result._vs !== _vs) {
      logger.throwArgumentError("signature _vs mismatch v and s", "signature", signature2);
    }
  }
  result.yParityAndS = result._vs;
  result.compact = result.r + result.yParityAndS.substring(2);
  return result;
}
function joinSignature(signature2) {
  signature2 = splitSignature(signature2);
  return hexlify(concat([
    signature2.r,
    signature2.s,
    signature2.recoveryParam ? "0x1c" : "0x1b"
  ]));
}
var logger, HexCharacters;
var init_lib2 = __esm({
  "node_modules/@ethersproject/bytes/lib.esm/index.js"() {
    "use strict";
    init_lib();
    init_version2();
    logger = new Logger(version2);
    HexCharacters = "0123456789abcdef";
  }
});

// node_modules/@ethersproject/bignumber/lib.esm/_version.js
var version3;
var init_version3 = __esm({
  "node_modules/@ethersproject/bignumber/lib.esm/_version.js"() {
    version3 = "bignumber/5.6.0";
  }
});

// node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
function isBigNumberish(value2) {
  return value2 != null && (BigNumber.isBigNumber(value2) || typeof value2 === "number" && value2 % 1 === 0 || typeof value2 === "string" && !!value2.match(/^-?[0-9]+$/) || isHexString(value2) || typeof value2 === "bigint" || isBytes(value2));
}
function toHex(value2) {
  if (typeof value2 !== "string") {
    return toHex(value2.toString(16));
  }
  if (value2[0] === "-") {
    value2 = value2.substring(1);
    if (value2[0] === "-") {
      logger2.throwArgumentError("invalid hex", "value", value2);
    }
    value2 = toHex(value2);
    if (value2 === "0x00") {
      return value2;
    }
    return "-" + value2;
  }
  if (value2.substring(0, 2) !== "0x") {
    value2 = "0x" + value2;
  }
  if (value2 === "0x") {
    return "0x00";
  }
  if (value2.length % 2) {
    value2 = "0x0" + value2.substring(2);
  }
  while (value2.length > 4 && value2.substring(0, 4) === "0x00") {
    value2 = "0x" + value2.substring(4);
  }
  return value2;
}
function toBigNumber(value2) {
  return BigNumber.from(toHex(value2));
}
function toBN(value2) {
  const hex = BigNumber.from(value2).toHexString();
  if (hex[0] === "-") {
    return new BN("-" + hex.substring(3), 16);
  }
  return new BN(hex.substring(2), 16);
}
function throwFault(fault, operation, value2) {
  const params = { fault, operation };
  if (value2 != null) {
    params.value = value2;
  }
  return logger2.throwError(fault, Logger.errors.NUMERIC_FAULT, params);
}
function _base36To16(value2) {
  return new BN(value2, 36).toString(16);
}
function _base16To36(value2) {
  return new BN(value2, 16).toString(36);
}
var import_bn, BN, logger2, _constructorGuard, MAX_SAFE, _warnedToStringRadix, BigNumber;
var init_bignumber = __esm({
  "node_modules/@ethersproject/bignumber/lib.esm/bignumber.js"() {
    "use strict";
    import_bn = __toESM(require_bn());
    init_lib2();
    init_lib();
    init_version3();
    BN = import_bn.default.BN;
    logger2 = new Logger(version3);
    _constructorGuard = {};
    MAX_SAFE = 9007199254740991;
    _warnedToStringRadix = false;
    BigNumber = class {
      constructor(constructorGuard, hex) {
        logger2.checkNew(new.target, BigNumber);
        if (constructorGuard !== _constructorGuard) {
          logger2.throwError("cannot call constructor directly; use BigNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new (BigNumber)"
          });
        }
        this._hex = hex;
        this._isBigNumber = true;
        Object.freeze(this);
      }
      fromTwos(value2) {
        return toBigNumber(toBN(this).fromTwos(value2));
      }
      toTwos(value2) {
        return toBigNumber(toBN(this).toTwos(value2));
      }
      abs() {
        if (this._hex[0] === "-") {
          return BigNumber.from(this._hex.substring(1));
        }
        return this;
      }
      add(other) {
        return toBigNumber(toBN(this).add(toBN(other)));
      }
      sub(other) {
        return toBigNumber(toBN(this).sub(toBN(other)));
      }
      div(other) {
        const o6 = BigNumber.from(other);
        if (o6.isZero()) {
          throwFault("division-by-zero", "div");
        }
        return toBigNumber(toBN(this).div(toBN(other)));
      }
      mul(other) {
        return toBigNumber(toBN(this).mul(toBN(other)));
      }
      mod(other) {
        const value2 = toBN(other);
        if (value2.isNeg()) {
          throwFault("division-by-zero", "mod");
        }
        return toBigNumber(toBN(this).umod(value2));
      }
      pow(other) {
        const value2 = toBN(other);
        if (value2.isNeg()) {
          throwFault("negative-power", "pow");
        }
        return toBigNumber(toBN(this).pow(value2));
      }
      and(other) {
        const value2 = toBN(other);
        if (this.isNegative() || value2.isNeg()) {
          throwFault("unbound-bitwise-result", "and");
        }
        return toBigNumber(toBN(this).and(value2));
      }
      or(other) {
        const value2 = toBN(other);
        if (this.isNegative() || value2.isNeg()) {
          throwFault("unbound-bitwise-result", "or");
        }
        return toBigNumber(toBN(this).or(value2));
      }
      xor(other) {
        const value2 = toBN(other);
        if (this.isNegative() || value2.isNeg()) {
          throwFault("unbound-bitwise-result", "xor");
        }
        return toBigNumber(toBN(this).xor(value2));
      }
      mask(value2) {
        if (this.isNegative() || value2 < 0) {
          throwFault("negative-width", "mask");
        }
        return toBigNumber(toBN(this).maskn(value2));
      }
      shl(value2) {
        if (this.isNegative() || value2 < 0) {
          throwFault("negative-width", "shl");
        }
        return toBigNumber(toBN(this).shln(value2));
      }
      shr(value2) {
        if (this.isNegative() || value2 < 0) {
          throwFault("negative-width", "shr");
        }
        return toBigNumber(toBN(this).shrn(value2));
      }
      eq(other) {
        return toBN(this).eq(toBN(other));
      }
      lt(other) {
        return toBN(this).lt(toBN(other));
      }
      lte(other) {
        return toBN(this).lte(toBN(other));
      }
      gt(other) {
        return toBN(this).gt(toBN(other));
      }
      gte(other) {
        return toBN(this).gte(toBN(other));
      }
      isNegative() {
        return this._hex[0] === "-";
      }
      isZero() {
        return toBN(this).isZero();
      }
      toNumber() {
        try {
          return toBN(this).toNumber();
        } catch (error) {
          throwFault("overflow", "toNumber", this.toString());
        }
        return null;
      }
      toBigInt() {
        try {
          return BigInt(this.toString());
        } catch (e6) {
        }
        return logger2.throwError("this platform does not support BigInt", Logger.errors.UNSUPPORTED_OPERATION, {
          value: this.toString()
        });
      }
      toString() {
        if (arguments.length > 0) {
          if (arguments[0] === 10) {
            if (!_warnedToStringRadix) {
              _warnedToStringRadix = true;
              logger2.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
            }
          } else if (arguments[0] === 16) {
            logger2.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger.errors.UNEXPECTED_ARGUMENT, {});
          } else {
            logger2.throwError("BigNumber.toString does not accept parameters", Logger.errors.UNEXPECTED_ARGUMENT, {});
          }
        }
        return toBN(this).toString(10);
      }
      toHexString() {
        return this._hex;
      }
      toJSON(key2) {
        return { type: "BigNumber", hex: this.toHexString() };
      }
      static from(value2) {
        if (value2 instanceof BigNumber) {
          return value2;
        }
        if (typeof value2 === "string") {
          if (value2.match(/^-?0x[0-9a-f]+$/i)) {
            return new BigNumber(_constructorGuard, toHex(value2));
          }
          if (value2.match(/^-?[0-9]+$/)) {
            return new BigNumber(_constructorGuard, toHex(new BN(value2)));
          }
          return logger2.throwArgumentError("invalid BigNumber string", "value", value2);
        }
        if (typeof value2 === "number") {
          if (value2 % 1) {
            throwFault("underflow", "BigNumber.from", value2);
          }
          if (value2 >= MAX_SAFE || value2 <= -MAX_SAFE) {
            throwFault("overflow", "BigNumber.from", value2);
          }
          return BigNumber.from(String(value2));
        }
        const anyValue = value2;
        if (typeof anyValue === "bigint") {
          return BigNumber.from(anyValue.toString());
        }
        if (isBytes(anyValue)) {
          return BigNumber.from(hexlify(anyValue));
        }
        if (anyValue) {
          if (anyValue.toHexString) {
            const hex = anyValue.toHexString();
            if (typeof hex === "string") {
              return BigNumber.from(hex);
            }
          } else {
            let hex = anyValue._hex;
            if (hex == null && anyValue.type === "BigNumber") {
              hex = anyValue.hex;
            }
            if (typeof hex === "string") {
              if (isHexString(hex) || hex[0] === "-" && isHexString(hex.substring(1))) {
                return BigNumber.from(hex);
              }
            }
          }
        }
        return logger2.throwArgumentError("invalid BigNumber value", "value", value2);
      }
      static isBigNumber(value2) {
        return !!(value2 && value2._isBigNumber);
      }
    };
  }
});

// node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js
function throwFault2(message, fault, operation, value2) {
  const params = { fault, operation };
  if (value2 !== void 0) {
    params.value = value2;
  }
  return logger3.throwError(message, Logger.errors.NUMERIC_FAULT, params);
}
function getMultiplier(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = BigNumber.from(decimals).toNumber();
    } catch (e6) {
    }
  }
  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros.substring(0, decimals);
  }
  return logger3.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed(value2, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  value2 = BigNumber.from(value2);
  const negative = value2.lt(Zero);
  if (negative) {
    value2 = value2.mul(NegativeOne);
  }
  let fraction = value2.mod(multiplier).toString();
  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  }
  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const whole = value2.div(multiplier).toString();
  if (multiplier.length === 1) {
    value2 = whole;
  } else {
    value2 = whole + "." + fraction;
  }
  if (negative) {
    value2 = "-" + value2;
  }
  return value2;
}
function parseFixed(value2, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  if (typeof value2 !== "string" || !value2.match(/^-?[0-9.]+$/)) {
    logger3.throwArgumentError("invalid decimal value", "value", value2);
  }
  const negative = value2.substring(0, 1) === "-";
  if (negative) {
    value2 = value2.substring(1);
  }
  if (value2 === ".") {
    logger3.throwArgumentError("missing value", "value", value2);
  }
  const comps = value2.split(".");
  if (comps.length > 2) {
    logger3.throwArgumentError("too many decimal points", "value", value2);
  }
  let whole = comps[0], fraction = comps[1];
  if (!whole) {
    whole = "0";
  }
  if (!fraction) {
    fraction = "0";
  }
  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  }
  if (fraction.length > multiplier.length - 1) {
    throwFault2("fractional component exceeds decimals", "underflow", "parseFixed");
  }
  if (fraction === "") {
    fraction = "0";
  }
  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }
  const wholeValue = BigNumber.from(whole);
  const fractionValue = BigNumber.from(fraction);
  let wei = wholeValue.mul(multiplier).add(fractionValue);
  if (negative) {
    wei = wei.mul(NegativeOne);
  }
  return wei;
}
var logger3, _constructorGuard2, Zero, NegativeOne, zeros, FixedFormat, FixedNumber, ONE, BUMP;
var init_fixednumber = __esm({
  "node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js"() {
    "use strict";
    init_lib2();
    init_lib();
    init_version3();
    init_bignumber();
    logger3 = new Logger(version3);
    _constructorGuard2 = {};
    Zero = BigNumber.from(0);
    NegativeOne = BigNumber.from(-1);
    zeros = "0";
    while (zeros.length < 256) {
      zeros += zeros;
    }
    FixedFormat = class {
      constructor(constructorGuard, signed, width, decimals) {
        if (constructorGuard !== _constructorGuard2) {
          logger3.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new FixedFormat"
          });
        }
        this.signed = signed;
        this.width = width;
        this.decimals = decimals;
        this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
        this._multiplier = getMultiplier(decimals);
        Object.freeze(this);
      }
      static from(value2) {
        if (value2 instanceof FixedFormat) {
          return value2;
        }
        if (typeof value2 === "number") {
          value2 = `fixed128x${value2}`;
        }
        let signed = true;
        let width = 128;
        let decimals = 18;
        if (typeof value2 === "string") {
          if (value2 === "fixed") {
          } else if (value2 === "ufixed") {
            signed = false;
          } else {
            const match = value2.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
            if (!match) {
              logger3.throwArgumentError("invalid fixed format", "format", value2);
            }
            signed = match[1] !== "u";
            width = parseInt(match[2]);
            decimals = parseInt(match[3]);
          }
        } else if (value2) {
          const check = (key2, type, defaultValue) => {
            if (value2[key2] == null) {
              return defaultValue;
            }
            if (typeof value2[key2] !== type) {
              logger3.throwArgumentError("invalid fixed format (" + key2 + " not " + type + ")", "format." + key2, value2[key2]);
            }
            return value2[key2];
          };
          signed = check("signed", "boolean", signed);
          width = check("width", "number", width);
          decimals = check("decimals", "number", decimals);
        }
        if (width % 8) {
          logger3.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
        }
        if (decimals > 80) {
          logger3.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
        }
        return new FixedFormat(_constructorGuard2, signed, width, decimals);
      }
    };
    FixedNumber = class {
      constructor(constructorGuard, hex, value2, format) {
        logger3.checkNew(new.target, FixedNumber);
        if (constructorGuard !== _constructorGuard2) {
          logger3.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new FixedFormat"
          });
        }
        this.format = format;
        this._hex = hex;
        this._value = value2;
        this._isFixedNumber = true;
        Object.freeze(this);
      }
      _checkFormat(other) {
        if (this.format.name !== other.format.name) {
          logger3.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
        }
      }
      addUnsafe(other) {
        this._checkFormat(other);
        const a5 = parseFixed(this._value, this.format.decimals);
        const b4 = parseFixed(other._value, other.format.decimals);
        return FixedNumber.fromValue(a5.add(b4), this.format.decimals, this.format);
      }
      subUnsafe(other) {
        this._checkFormat(other);
        const a5 = parseFixed(this._value, this.format.decimals);
        const b4 = parseFixed(other._value, other.format.decimals);
        return FixedNumber.fromValue(a5.sub(b4), this.format.decimals, this.format);
      }
      mulUnsafe(other) {
        this._checkFormat(other);
        const a5 = parseFixed(this._value, this.format.decimals);
        const b4 = parseFixed(other._value, other.format.decimals);
        return FixedNumber.fromValue(a5.mul(b4).div(this.format._multiplier), this.format.decimals, this.format);
      }
      divUnsafe(other) {
        this._checkFormat(other);
        const a5 = parseFixed(this._value, this.format.decimals);
        const b4 = parseFixed(other._value, other.format.decimals);
        return FixedNumber.fromValue(a5.mul(this.format._multiplier).div(b4), this.format.decimals, this.format);
      }
      floor() {
        const comps = this.toString().split(".");
        if (comps.length === 1) {
          comps.push("0");
        }
        let result = FixedNumber.from(comps[0], this.format);
        const hasFraction = !comps[1].match(/^(0*)$/);
        if (this.isNegative() && hasFraction) {
          result = result.subUnsafe(ONE.toFormat(result.format));
        }
        return result;
      }
      ceiling() {
        const comps = this.toString().split(".");
        if (comps.length === 1) {
          comps.push("0");
        }
        let result = FixedNumber.from(comps[0], this.format);
        const hasFraction = !comps[1].match(/^(0*)$/);
        if (!this.isNegative() && hasFraction) {
          result = result.addUnsafe(ONE.toFormat(result.format));
        }
        return result;
      }
      round(decimals) {
        if (decimals == null) {
          decimals = 0;
        }
        const comps = this.toString().split(".");
        if (comps.length === 1) {
          comps.push("0");
        }
        if (decimals < 0 || decimals > 80 || decimals % 1) {
          logger3.throwArgumentError("invalid decimal count", "decimals", decimals);
        }
        if (comps[1].length <= decimals) {
          return this;
        }
        const factor = FixedNumber.from("1" + zeros.substring(0, decimals), this.format);
        const bump = BUMP.toFormat(this.format);
        return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
      }
      isZero() {
        return this._value === "0.0" || this._value === "0";
      }
      isNegative() {
        return this._value[0] === "-";
      }
      toString() {
        return this._value;
      }
      toHexString(width) {
        if (width == null) {
          return this._hex;
        }
        if (width % 8) {
          logger3.throwArgumentError("invalid byte width", "width", width);
        }
        const hex = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
        return hexZeroPad(hex, width / 8);
      }
      toUnsafeFloat() {
        return parseFloat(this.toString());
      }
      toFormat(format) {
        return FixedNumber.fromString(this._value, format);
      }
      static fromValue(value2, decimals, format) {
        if (format == null && decimals != null && !isBigNumberish(decimals)) {
          format = decimals;
          decimals = null;
        }
        if (decimals == null) {
          decimals = 0;
        }
        if (format == null) {
          format = "fixed";
        }
        return FixedNumber.fromString(formatFixed(value2, decimals), FixedFormat.from(format));
      }
      static fromString(value2, format) {
        if (format == null) {
          format = "fixed";
        }
        const fixedFormat = FixedFormat.from(format);
        const numeric = parseFixed(value2, fixedFormat.decimals);
        if (!fixedFormat.signed && numeric.lt(Zero)) {
          throwFault2("unsigned value cannot be negative", "overflow", "value", value2);
        }
        let hex = null;
        if (fixedFormat.signed) {
          hex = numeric.toTwos(fixedFormat.width).toHexString();
        } else {
          hex = numeric.toHexString();
          hex = hexZeroPad(hex, fixedFormat.width / 8);
        }
        const decimal = formatFixed(numeric, fixedFormat.decimals);
        return new FixedNumber(_constructorGuard2, hex, decimal, fixedFormat);
      }
      static fromBytes(value2, format) {
        if (format == null) {
          format = "fixed";
        }
        const fixedFormat = FixedFormat.from(format);
        if (arrayify(value2).length > fixedFormat.width / 8) {
          throw new Error("overflow");
        }
        let numeric = BigNumber.from(value2);
        if (fixedFormat.signed) {
          numeric = numeric.fromTwos(fixedFormat.width);
        }
        const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
        const decimal = formatFixed(numeric, fixedFormat.decimals);
        return new FixedNumber(_constructorGuard2, hex, decimal, fixedFormat);
      }
      static from(value2, format) {
        if (typeof value2 === "string") {
          return FixedNumber.fromString(value2, format);
        }
        if (isBytes(value2)) {
          return FixedNumber.fromBytes(value2, format);
        }
        try {
          return FixedNumber.fromValue(value2, 0, format);
        } catch (error) {
          if (error.code !== Logger.errors.INVALID_ARGUMENT) {
            throw error;
          }
        }
        return logger3.throwArgumentError("invalid FixedNumber value", "value", value2);
      }
      static isFixedNumber(value2) {
        return !!(value2 && value2._isFixedNumber);
      }
    };
    ONE = FixedNumber.from(1);
    BUMP = FixedNumber.from("0.5");
  }
});

// node_modules/@ethersproject/bignumber/lib.esm/index.js
var init_lib3 = __esm({
  "node_modules/@ethersproject/bignumber/lib.esm/index.js"() {
    init_bignumber();
    init_fixednumber();
    init_bignumber();
  }
});

// node_modules/@ethersproject/properties/lib.esm/_version.js
var version4;
var init_version4 = __esm({
  "node_modules/@ethersproject/properties/lib.esm/_version.js"() {
    version4 = "properties/5.6.0";
  }
});

// node_modules/@ethersproject/properties/lib.esm/index.js
var lib_exports3 = {};
__export(lib_exports3, {
  Description: () => Description,
  checkProperties: () => checkProperties,
  deepCopy: () => deepCopy,
  defineReadOnly: () => defineReadOnly,
  getStatic: () => getStatic,
  resolveProperties: () => resolveProperties,
  shallowCopy: () => shallowCopy
});
function defineReadOnly(object, name2, value2) {
  Object.defineProperty(object, name2, {
    enumerable: true,
    value: value2,
    writable: false
  });
}
function getStatic(ctor, key2) {
  for (let i6 = 0; i6 < 32; i6++) {
    if (ctor[key2]) {
      return ctor[key2];
    }
    if (!ctor.prototype || typeof ctor.prototype !== "object") {
      break;
    }
    ctor = Object.getPrototypeOf(ctor.prototype).constructor;
  }
  return null;
}
function resolveProperties(object) {
  return __awaiter(this, void 0, void 0, function* () {
    const promises = Object.keys(object).map((key2) => {
      const value2 = object[key2];
      return Promise.resolve(value2).then((v9) => ({ key: key2, value: v9 }));
    });
    const results2 = yield Promise.all(promises);
    return results2.reduce((accum, result) => {
      accum[result.key] = result.value;
      return accum;
    }, {});
  });
}
function checkProperties(object, properties) {
  if (!object || typeof object !== "object") {
    logger4.throwArgumentError("invalid object", "object", object);
  }
  Object.keys(object).forEach((key2) => {
    if (!properties[key2]) {
      logger4.throwArgumentError("invalid object key - " + key2, "transaction:" + key2, object);
    }
  });
}
function shallowCopy(object) {
  const result = {};
  for (const key2 in object) {
    result[key2] = object[key2];
  }
  return result;
}
function _isFrozen(object) {
  if (object === void 0 || object === null || opaque[typeof object]) {
    return true;
  }
  if (Array.isArray(object) || typeof object === "object") {
    if (!Object.isFrozen(object)) {
      return false;
    }
    const keys = Object.keys(object);
    for (let i6 = 0; i6 < keys.length; i6++) {
      let value2 = null;
      try {
        value2 = object[keys[i6]];
      } catch (error) {
        continue;
      }
      if (!_isFrozen(value2)) {
        return false;
      }
    }
    return true;
  }
  return logger4.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}
function _deepCopy(object) {
  if (_isFrozen(object)) {
    return object;
  }
  if (Array.isArray(object)) {
    return Object.freeze(object.map((item) => deepCopy(item)));
  }
  if (typeof object === "object") {
    const result = {};
    for (const key2 in object) {
      const value2 = object[key2];
      if (value2 === void 0) {
        continue;
      }
      defineReadOnly(result, key2, deepCopy(value2));
    }
    return result;
  }
  return logger4.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}
function deepCopy(object) {
  return _deepCopy(object);
}
var __awaiter, logger4, opaque, Description;
var init_lib4 = __esm({
  "node_modules/@ethersproject/properties/lib.esm/index.js"() {
    "use strict";
    init_lib();
    init_version4();
    __awaiter = function(thisArg, _arguments, P5, generator) {
      function adopt(value2) {
        return value2 instanceof P5 ? value2 : new P5(function(resolve) {
          resolve(value2);
        });
      }
      return new (P5 || (P5 = Promise))(function(resolve, reject) {
        function fulfilled(value2) {
          try {
            step(generator.next(value2));
          } catch (e6) {
            reject(e6);
          }
        }
        function rejected(value2) {
          try {
            step(generator["throw"](value2));
          } catch (e6) {
            reject(e6);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger4 = new Logger(version4);
    opaque = { bigint: true, boolean: true, "function": true, number: true, string: true };
    Description = class {
      constructor(info) {
        for (const key2 in info) {
          this[key2] = deepCopy(info[key2]);
        }
      }
    };
  }
});

// node_modules/@ethersproject/abi/lib.esm/_version.js
var version5;
var init_version5 = __esm({
  "node_modules/@ethersproject/abi/lib.esm/_version.js"() {
    version5 = "abi/5.6.0";
  }
});

// node_modules/@ethersproject/abi/lib.esm/fragments.js
function checkModifier(type, name2) {
  if (type === "bytes" || type === "string") {
    if (ModifiersBytes[name2]) {
      return true;
    }
  } else if (type === "address") {
    if (name2 === "payable") {
      return true;
    }
  } else if (type.indexOf("[") >= 0 || type === "tuple") {
    if (ModifiersNest[name2]) {
      return true;
    }
  }
  if (ModifiersBytes[name2] || name2 === "payable") {
    logger5.throwArgumentError("invalid modifier", "name", name2);
  }
  return false;
}
function parseParamType(param, allowIndexed) {
  let originalParam = param;
  function throwError2(i6) {
    logger5.throwArgumentError(`unexpected character at position ${i6}`, "param", param);
  }
  param = param.replace(/\s/g, " ");
  function newNode(parent2) {
    let node2 = { type: "", name: "", parent: parent2, state: { allowType: true } };
    if (allowIndexed) {
      node2.indexed = false;
    }
    return node2;
  }
  let parent = { type: "", name: "", state: { allowType: true } };
  let node = parent;
  for (let i6 = 0; i6 < param.length; i6++) {
    let c5 = param[i6];
    switch (c5) {
      case "(":
        if (node.state.allowType && node.type === "") {
          node.type = "tuple";
        } else if (!node.state.allowParams) {
          throwError2(i6);
        }
        node.state.allowType = false;
        node.type = verifyType(node.type);
        node.components = [newNode(node)];
        node = node.components[0];
        break;
      case ")":
        delete node.state;
        if (node.name === "indexed") {
          if (!allowIndexed) {
            throwError2(i6);
          }
          node.indexed = true;
          node.name = "";
        }
        if (checkModifier(node.type, node.name)) {
          node.name = "";
        }
        node.type = verifyType(node.type);
        let child = node;
        node = node.parent;
        if (!node) {
          throwError2(i6);
        }
        delete child.parent;
        node.state.allowParams = false;
        node.state.allowName = true;
        node.state.allowArray = true;
        break;
      case ",":
        delete node.state;
        if (node.name === "indexed") {
          if (!allowIndexed) {
            throwError2(i6);
          }
          node.indexed = true;
          node.name = "";
        }
        if (checkModifier(node.type, node.name)) {
          node.name = "";
        }
        node.type = verifyType(node.type);
        let sibling = newNode(node.parent);
        node.parent.components.push(sibling);
        delete node.parent;
        node = sibling;
        break;
      case " ":
        if (node.state.allowType) {
          if (node.type !== "") {
            node.type = verifyType(node.type);
            delete node.state.allowType;
            node.state.allowName = true;
            node.state.allowParams = true;
          }
        }
        if (node.state.allowName) {
          if (node.name !== "") {
            if (node.name === "indexed") {
              if (!allowIndexed) {
                throwError2(i6);
              }
              if (node.indexed) {
                throwError2(i6);
              }
              node.indexed = true;
              node.name = "";
            } else if (checkModifier(node.type, node.name)) {
              node.name = "";
            } else {
              node.state.allowName = false;
            }
          }
        }
        break;
      case "[":
        if (!node.state.allowArray) {
          throwError2(i6);
        }
        node.type += c5;
        node.state.allowArray = false;
        node.state.allowName = false;
        node.state.readArray = true;
        break;
      case "]":
        if (!node.state.readArray) {
          throwError2(i6);
        }
        node.type += c5;
        node.state.readArray = false;
        node.state.allowArray = true;
        node.state.allowName = true;
        break;
      default:
        if (node.state.allowType) {
          node.type += c5;
          node.state.allowParams = true;
          node.state.allowArray = true;
        } else if (node.state.allowName) {
          node.name += c5;
          delete node.state.allowArray;
        } else if (node.state.readArray) {
          node.type += c5;
        } else {
          throwError2(i6);
        }
    }
  }
  if (node.parent) {
    logger5.throwArgumentError("unexpected eof", "param", param);
  }
  delete parent.state;
  if (node.name === "indexed") {
    if (!allowIndexed) {
      throwError2(originalParam.length - 7);
    }
    if (node.indexed) {
      throwError2(originalParam.length - 7);
    }
    node.indexed = true;
    node.name = "";
  } else if (checkModifier(node.type, node.name)) {
    node.name = "";
  }
  parent.type = verifyType(parent.type);
  return parent;
}
function populate(object, params) {
  for (let key2 in params) {
    defineReadOnly(object, key2, params[key2]);
  }
}
function parseParams(value2, allowIndex) {
  return splitNesting(value2).map((param) => ParamType.fromString(param, allowIndex));
}
function parseGas(value2, params) {
  params.gas = null;
  let comps = value2.split("@");
  if (comps.length !== 1) {
    if (comps.length > 2) {
      logger5.throwArgumentError("invalid human-readable ABI signature", "value", value2);
    }
    if (!comps[1].match(/^[0-9]+$/)) {
      logger5.throwArgumentError("invalid human-readable ABI signature gas", "value", value2);
    }
    params.gas = BigNumber.from(comps[1]);
    return comps[0];
  }
  return value2;
}
function parseModifiers(value2, params) {
  params.constant = false;
  params.payable = false;
  params.stateMutability = "nonpayable";
  value2.split(" ").forEach((modifier) => {
    switch (modifier.trim()) {
      case "constant":
        params.constant = true;
        break;
      case "payable":
        params.payable = true;
        params.stateMutability = "payable";
        break;
      case "nonpayable":
        params.payable = false;
        params.stateMutability = "nonpayable";
        break;
      case "pure":
        params.constant = true;
        params.stateMutability = "pure";
        break;
      case "view":
        params.constant = true;
        params.stateMutability = "view";
        break;
      case "external":
      case "public":
      case "":
        break;
      default:
        console.log("unknown modifier: " + modifier);
    }
  });
}
function verifyState(value2) {
  let result = {
    constant: false,
    payable: true,
    stateMutability: "payable"
  };
  if (value2.stateMutability != null) {
    result.stateMutability = value2.stateMutability;
    result.constant = result.stateMutability === "view" || result.stateMutability === "pure";
    if (value2.constant != null) {
      if (!!value2.constant !== result.constant) {
        logger5.throwArgumentError("cannot have constant function with mutability " + result.stateMutability, "value", value2);
      }
    }
    result.payable = result.stateMutability === "payable";
    if (value2.payable != null) {
      if (!!value2.payable !== result.payable) {
        logger5.throwArgumentError("cannot have payable function with mutability " + result.stateMutability, "value", value2);
      }
    }
  } else if (value2.payable != null) {
    result.payable = !!value2.payable;
    if (value2.constant == null && !result.payable && value2.type !== "constructor") {
      logger5.throwArgumentError("unable to determine stateMutability", "value", value2);
    }
    result.constant = !!value2.constant;
    if (result.constant) {
      result.stateMutability = "view";
    } else {
      result.stateMutability = result.payable ? "payable" : "nonpayable";
    }
    if (result.payable && result.constant) {
      logger5.throwArgumentError("cannot have constant payable function", "value", value2);
    }
  } else if (value2.constant != null) {
    result.constant = !!value2.constant;
    result.payable = !result.constant;
    result.stateMutability = result.constant ? "view" : "payable";
  } else if (value2.type !== "constructor") {
    logger5.throwArgumentError("unable to determine stateMutability", "value", value2);
  }
  return result;
}
function checkForbidden(fragment) {
  const sig = fragment.format();
  if (sig === "Error(string)" || sig === "Panic(uint256)") {
    logger5.throwArgumentError(`cannot specify user defined ${sig} error`, "fragment", fragment);
  }
  return fragment;
}
function verifyType(type) {
  if (type.match(/^uint($|[^1-9])/)) {
    type = "uint256" + type.substring(4);
  } else if (type.match(/^int($|[^1-9])/)) {
    type = "int256" + type.substring(3);
  }
  return type;
}
function verifyIdentifier(value2) {
  if (!value2 || !value2.match(regexIdentifier)) {
    logger5.throwArgumentError(`invalid identifier "${value2}"`, "value", value2);
  }
  return value2;
}
function splitNesting(value2) {
  value2 = value2.trim();
  let result = [];
  let accum = "";
  let depth = 0;
  for (let offset = 0; offset < value2.length; offset++) {
    let c5 = value2[offset];
    if (c5 === "," && depth === 0) {
      result.push(accum);
      accum = "";
    } else {
      accum += c5;
      if (c5 === "(") {
        depth++;
      } else if (c5 === ")") {
        depth--;
        if (depth === -1) {
          logger5.throwArgumentError("unbalanced parenthesis", "value", value2);
        }
      }
    }
  }
  if (accum) {
    result.push(accum);
  }
  return result;
}
var logger5, _constructorGuard3, ModifiersBytes, ModifiersNest, FormatTypes, paramTypeArray, ParamType, Fragment, EventFragment, ConstructorFragment, FunctionFragment, ErrorFragment, regexIdentifier, regexParen;
var init_fragments = __esm({
  "node_modules/@ethersproject/abi/lib.esm/fragments.js"() {
    "use strict";
    init_lib3();
    init_lib4();
    init_lib();
    init_version5();
    logger5 = new Logger(version5);
    _constructorGuard3 = {};
    ModifiersBytes = { calldata: true, memory: true, storage: true };
    ModifiersNest = { calldata: true, memory: true };
    FormatTypes = Object.freeze({
      sighash: "sighash",
      minimal: "minimal",
      full: "full",
      json: "json"
    });
    paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
    ParamType = class {
      constructor(constructorGuard, params) {
        if (constructorGuard !== _constructorGuard3) {
          logger5.throwError("use fromString", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new ParamType()"
          });
        }
        populate(this, params);
        let match = this.type.match(paramTypeArray);
        if (match) {
          populate(this, {
            arrayLength: parseInt(match[2] || "-1"),
            arrayChildren: ParamType.fromObject({
              type: match[1],
              components: this.components
            }),
            baseType: "array"
          });
        } else {
          populate(this, {
            arrayLength: null,
            arrayChildren: null,
            baseType: this.components != null ? "tuple" : this.type
          });
        }
        this._isParamType = true;
        Object.freeze(this);
      }
      format(format) {
        if (!format) {
          format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
          logger5.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
          let result2 = {
            type: this.baseType === "tuple" ? "tuple" : this.type,
            name: this.name || void 0
          };
          if (typeof this.indexed === "boolean") {
            result2.indexed = this.indexed;
          }
          if (this.components) {
            result2.components = this.components.map((comp) => JSON.parse(comp.format(format)));
          }
          return JSON.stringify(result2);
        }
        let result = "";
        if (this.baseType === "array") {
          result += this.arrayChildren.format(format);
          result += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]";
        } else {
          if (this.baseType === "tuple") {
            if (format !== FormatTypes.sighash) {
              result += this.type;
            }
            result += "(" + this.components.map((comp) => comp.format(format)).join(format === FormatTypes.full ? ", " : ",") + ")";
          } else {
            result += this.type;
          }
        }
        if (format !== FormatTypes.sighash) {
          if (this.indexed === true) {
            result += " indexed";
          }
          if (format === FormatTypes.full && this.name) {
            result += " " + this.name;
          }
        }
        return result;
      }
      static from(value2, allowIndexed) {
        if (typeof value2 === "string") {
          return ParamType.fromString(value2, allowIndexed);
        }
        return ParamType.fromObject(value2);
      }
      static fromObject(value2) {
        if (ParamType.isParamType(value2)) {
          return value2;
        }
        return new ParamType(_constructorGuard3, {
          name: value2.name || null,
          type: verifyType(value2.type),
          indexed: value2.indexed == null ? null : !!value2.indexed,
          components: value2.components ? value2.components.map(ParamType.fromObject) : null
        });
      }
      static fromString(value2, allowIndexed) {
        function ParamTypify(node) {
          return ParamType.fromObject({
            name: node.name,
            type: node.type,
            indexed: node.indexed,
            components: node.components
          });
        }
        return ParamTypify(parseParamType(value2, !!allowIndexed));
      }
      static isParamType(value2) {
        return !!(value2 != null && value2._isParamType);
      }
    };
    Fragment = class {
      constructor(constructorGuard, params) {
        if (constructorGuard !== _constructorGuard3) {
          logger5.throwError("use a static from method", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new Fragment()"
          });
        }
        populate(this, params);
        this._isFragment = true;
        Object.freeze(this);
      }
      static from(value2) {
        if (Fragment.isFragment(value2)) {
          return value2;
        }
        if (typeof value2 === "string") {
          return Fragment.fromString(value2);
        }
        return Fragment.fromObject(value2);
      }
      static fromObject(value2) {
        if (Fragment.isFragment(value2)) {
          return value2;
        }
        switch (value2.type) {
          case "function":
            return FunctionFragment.fromObject(value2);
          case "event":
            return EventFragment.fromObject(value2);
          case "constructor":
            return ConstructorFragment.fromObject(value2);
          case "error":
            return ErrorFragment.fromObject(value2);
          case "fallback":
          case "receive":
            return null;
        }
        return logger5.throwArgumentError("invalid fragment object", "value", value2);
      }
      static fromString(value2) {
        value2 = value2.replace(/\s/g, " ");
        value2 = value2.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ");
        value2 = value2.trim();
        if (value2.split(" ")[0] === "event") {
          return EventFragment.fromString(value2.substring(5).trim());
        } else if (value2.split(" ")[0] === "function") {
          return FunctionFragment.fromString(value2.substring(8).trim());
        } else if (value2.split("(")[0].trim() === "constructor") {
          return ConstructorFragment.fromString(value2.trim());
        } else if (value2.split(" ")[0] === "error") {
          return ErrorFragment.fromString(value2.substring(5).trim());
        }
        return logger5.throwArgumentError("unsupported fragment", "value", value2);
      }
      static isFragment(value2) {
        return !!(value2 && value2._isFragment);
      }
    };
    EventFragment = class extends Fragment {
      format(format) {
        if (!format) {
          format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
          logger5.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
          return JSON.stringify({
            type: "event",
            anonymous: this.anonymous,
            name: this.name,
            inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
          });
        }
        let result = "";
        if (format !== FormatTypes.sighash) {
          result += "event ";
        }
        result += this.name + "(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
        if (format !== FormatTypes.sighash) {
          if (this.anonymous) {
            result += "anonymous ";
          }
        }
        return result.trim();
      }
      static from(value2) {
        if (typeof value2 === "string") {
          return EventFragment.fromString(value2);
        }
        return EventFragment.fromObject(value2);
      }
      static fromObject(value2) {
        if (EventFragment.isEventFragment(value2)) {
          return value2;
        }
        if (value2.type !== "event") {
          logger5.throwArgumentError("invalid event object", "value", value2);
        }
        const params = {
          name: verifyIdentifier(value2.name),
          anonymous: value2.anonymous,
          inputs: value2.inputs ? value2.inputs.map(ParamType.fromObject) : [],
          type: "event"
        };
        return new EventFragment(_constructorGuard3, params);
      }
      static fromString(value2) {
        let match = value2.match(regexParen);
        if (!match) {
          logger5.throwArgumentError("invalid event string", "value", value2);
        }
        let anonymous = false;
        match[3].split(" ").forEach((modifier) => {
          switch (modifier.trim()) {
            case "anonymous":
              anonymous = true;
              break;
            case "":
              break;
            default:
              logger5.warn("unknown modifier: " + modifier);
          }
        });
        return EventFragment.fromObject({
          name: match[1].trim(),
          anonymous,
          inputs: parseParams(match[2], true),
          type: "event"
        });
      }
      static isEventFragment(value2) {
        return value2 && value2._isFragment && value2.type === "event";
      }
    };
    ConstructorFragment = class extends Fragment {
      format(format) {
        if (!format) {
          format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
          logger5.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
          return JSON.stringify({
            type: "constructor",
            stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
            payable: this.payable,
            gas: this.gas ? this.gas.toNumber() : void 0,
            inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
          });
        }
        if (format === FormatTypes.sighash) {
          logger5.throwError("cannot format a constructor for sighash", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "format(sighash)"
          });
        }
        let result = "constructor(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
        if (this.stateMutability && this.stateMutability !== "nonpayable") {
          result += this.stateMutability + " ";
        }
        return result.trim();
      }
      static from(value2) {
        if (typeof value2 === "string") {
          return ConstructorFragment.fromString(value2);
        }
        return ConstructorFragment.fromObject(value2);
      }
      static fromObject(value2) {
        if (ConstructorFragment.isConstructorFragment(value2)) {
          return value2;
        }
        if (value2.type !== "constructor") {
          logger5.throwArgumentError("invalid constructor object", "value", value2);
        }
        let state = verifyState(value2);
        if (state.constant) {
          logger5.throwArgumentError("constructor cannot be constant", "value", value2);
        }
        const params = {
          name: null,
          type: value2.type,
          inputs: value2.inputs ? value2.inputs.map(ParamType.fromObject) : [],
          payable: state.payable,
          stateMutability: state.stateMutability,
          gas: value2.gas ? BigNumber.from(value2.gas) : null
        };
        return new ConstructorFragment(_constructorGuard3, params);
      }
      static fromString(value2) {
        let params = { type: "constructor" };
        value2 = parseGas(value2, params);
        let parens = value2.match(regexParen);
        if (!parens || parens[1].trim() !== "constructor") {
          logger5.throwArgumentError("invalid constructor string", "value", value2);
        }
        params.inputs = parseParams(parens[2].trim(), false);
        parseModifiers(parens[3].trim(), params);
        return ConstructorFragment.fromObject(params);
      }
      static isConstructorFragment(value2) {
        return value2 && value2._isFragment && value2.type === "constructor";
      }
    };
    FunctionFragment = class extends ConstructorFragment {
      format(format) {
        if (!format) {
          format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
          logger5.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
          return JSON.stringify({
            type: "function",
            name: this.name,
            constant: this.constant,
            stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
            payable: this.payable,
            gas: this.gas ? this.gas.toNumber() : void 0,
            inputs: this.inputs.map((input) => JSON.parse(input.format(format))),
            outputs: this.outputs.map((output) => JSON.parse(output.format(format)))
          });
        }
        let result = "";
        if (format !== FormatTypes.sighash) {
          result += "function ";
        }
        result += this.name + "(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
        if (format !== FormatTypes.sighash) {
          if (this.stateMutability) {
            if (this.stateMutability !== "nonpayable") {
              result += this.stateMutability + " ";
            }
          } else if (this.constant) {
            result += "view ";
          }
          if (this.outputs && this.outputs.length) {
            result += "returns (" + this.outputs.map((output) => output.format(format)).join(", ") + ") ";
          }
          if (this.gas != null) {
            result += "@" + this.gas.toString() + " ";
          }
        }
        return result.trim();
      }
      static from(value2) {
        if (typeof value2 === "string") {
          return FunctionFragment.fromString(value2);
        }
        return FunctionFragment.fromObject(value2);
      }
      static fromObject(value2) {
        if (FunctionFragment.isFunctionFragment(value2)) {
          return value2;
        }
        if (value2.type !== "function") {
          logger5.throwArgumentError("invalid function object", "value", value2);
        }
        let state = verifyState(value2);
        const params = {
          type: value2.type,
          name: verifyIdentifier(value2.name),
          constant: state.constant,
          inputs: value2.inputs ? value2.inputs.map(ParamType.fromObject) : [],
          outputs: value2.outputs ? value2.outputs.map(ParamType.fromObject) : [],
          payable: state.payable,
          stateMutability: state.stateMutability,
          gas: value2.gas ? BigNumber.from(value2.gas) : null
        };
        return new FunctionFragment(_constructorGuard3, params);
      }
      static fromString(value2) {
        let params = { type: "function" };
        value2 = parseGas(value2, params);
        let comps = value2.split(" returns ");
        if (comps.length > 2) {
          logger5.throwArgumentError("invalid function string", "value", value2);
        }
        let parens = comps[0].match(regexParen);
        if (!parens) {
          logger5.throwArgumentError("invalid function signature", "value", value2);
        }
        params.name = parens[1].trim();
        if (params.name) {
          verifyIdentifier(params.name);
        }
        params.inputs = parseParams(parens[2], false);
        parseModifiers(parens[3].trim(), params);
        if (comps.length > 1) {
          let returns = comps[1].match(regexParen);
          if (returns[1].trim() != "" || returns[3].trim() != "") {
            logger5.throwArgumentError("unexpected tokens", "value", value2);
          }
          params.outputs = parseParams(returns[2], false);
        } else {
          params.outputs = [];
        }
        return FunctionFragment.fromObject(params);
      }
      static isFunctionFragment(value2) {
        return value2 && value2._isFragment && value2.type === "function";
      }
    };
    ErrorFragment = class extends Fragment {
      format(format) {
        if (!format) {
          format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
          logger5.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
          return JSON.stringify({
            type: "error",
            name: this.name,
            inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
          });
        }
        let result = "";
        if (format !== FormatTypes.sighash) {
          result += "error ";
        }
        result += this.name + "(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
        return result.trim();
      }
      static from(value2) {
        if (typeof value2 === "string") {
          return ErrorFragment.fromString(value2);
        }
        return ErrorFragment.fromObject(value2);
      }
      static fromObject(value2) {
        if (ErrorFragment.isErrorFragment(value2)) {
          return value2;
        }
        if (value2.type !== "error") {
          logger5.throwArgumentError("invalid error object", "value", value2);
        }
        const params = {
          type: value2.type,
          name: verifyIdentifier(value2.name),
          inputs: value2.inputs ? value2.inputs.map(ParamType.fromObject) : []
        };
        return checkForbidden(new ErrorFragment(_constructorGuard3, params));
      }
      static fromString(value2) {
        let params = { type: "error" };
        let parens = value2.match(regexParen);
        if (!parens) {
          logger5.throwArgumentError("invalid error signature", "value", value2);
        }
        params.name = parens[1].trim();
        if (params.name) {
          verifyIdentifier(params.name);
        }
        params.inputs = parseParams(parens[2], false);
        return checkForbidden(ErrorFragment.fromObject(params));
      }
      static isErrorFragment(value2) {
        return value2 && value2._isFragment && value2.type === "error";
      }
    };
    regexIdentifier = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
    regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
  }
});

// node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js
function checkResultErrors(result) {
  const errors = [];
  const checkErrors = function(path, object) {
    if (!Array.isArray(object)) {
      return;
    }
    for (let key2 in object) {
      const childPath = path.slice();
      childPath.push(key2);
      try {
        checkErrors(childPath, object[key2]);
      } catch (error) {
        errors.push({ path: childPath, error });
      }
    }
  };
  checkErrors([], result);
  return errors;
}
var logger6, Coder, Writer, Reader;
var init_abstract_coder = __esm({
  "node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js"() {
    "use strict";
    init_lib2();
    init_lib3();
    init_lib4();
    init_lib();
    init_version5();
    logger6 = new Logger(version5);
    Coder = class {
      constructor(name2, type, localName, dynamic) {
        this.name = name2;
        this.type = type;
        this.localName = localName;
        this.dynamic = dynamic;
      }
      _throwError(message, value2) {
        logger6.throwArgumentError(message, this.localName, value2);
      }
    };
    Writer = class {
      constructor(wordSize) {
        defineReadOnly(this, "wordSize", wordSize || 32);
        this._data = [];
        this._dataLength = 0;
        this._padding = new Uint8Array(wordSize);
      }
      get data() {
        return hexConcat(this._data);
      }
      get length() {
        return this._dataLength;
      }
      _writeData(data) {
        this._data.push(data);
        this._dataLength += data.length;
        return data.length;
      }
      appendWriter(writer) {
        return this._writeData(concat(writer._data));
      }
      writeBytes(value2) {
        let bytes = arrayify(value2);
        const paddingOffset = bytes.length % this.wordSize;
        if (paddingOffset) {
          bytes = concat([bytes, this._padding.slice(paddingOffset)]);
        }
        return this._writeData(bytes);
      }
      _getValue(value2) {
        let bytes = arrayify(BigNumber.from(value2));
        if (bytes.length > this.wordSize) {
          logger6.throwError("value out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
            length: this.wordSize,
            offset: bytes.length
          });
        }
        if (bytes.length % this.wordSize) {
          bytes = concat([this._padding.slice(bytes.length % this.wordSize), bytes]);
        }
        return bytes;
      }
      writeValue(value2) {
        return this._writeData(this._getValue(value2));
      }
      writeUpdatableValue() {
        const offset = this._data.length;
        this._data.push(this._padding);
        this._dataLength += this.wordSize;
        return (value2) => {
          this._data[offset] = this._getValue(value2);
        };
      }
    };
    Reader = class {
      constructor(data, wordSize, coerceFunc, allowLoose) {
        defineReadOnly(this, "_data", arrayify(data));
        defineReadOnly(this, "wordSize", wordSize || 32);
        defineReadOnly(this, "_coerceFunc", coerceFunc);
        defineReadOnly(this, "allowLoose", allowLoose);
        this._offset = 0;
      }
      get data() {
        return hexlify(this._data);
      }
      get consumed() {
        return this._offset;
      }
      static coerce(name2, value2) {
        let match = name2.match("^u?int([0-9]+)$");
        if (match && parseInt(match[1]) <= 48) {
          value2 = value2.toNumber();
        }
        return value2;
      }
      coerce(name2, value2) {
        if (this._coerceFunc) {
          return this._coerceFunc(name2, value2);
        }
        return Reader.coerce(name2, value2);
      }
      _peekBytes(offset, length, loose) {
        let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;
        if (this._offset + alignedLength > this._data.length) {
          if (this.allowLoose && loose && this._offset + length <= this._data.length) {
            alignedLength = length;
          } else {
            logger6.throwError("data out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
              length: this._data.length,
              offset: this._offset + alignedLength
            });
          }
        }
        return this._data.slice(this._offset, this._offset + alignedLength);
      }
      subReader(offset) {
        return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);
      }
      readBytes(length, loose) {
        let bytes = this._peekBytes(0, length, !!loose);
        this._offset += bytes.length;
        return bytes.slice(0, length);
      }
      readValue() {
        return BigNumber.from(this.readBytes(this.wordSize));
      }
    };
  }
});

// node_modules/js-sha3/src/sha3.js
var require_sha3 = __commonJS({
  "node_modules/js-sha3/src/sha3.js"(exports2, module2) {
    (function() {
      "use strict";
      var INPUT_ERROR = "input is invalid type";
      var FINALIZE_ERROR = "finalize already called";
      var WINDOW2 = typeof window === "object";
      var root2 = WINDOW2 ? window : {};
      if (root2.JS_SHA3_NO_WINDOW) {
        WINDOW2 = false;
      }
      var WEB_WORKER2 = !WINDOW2 && typeof self === "object";
      var NODE_JS2 = !root2.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS2) {
        root2 = global;
      } else if (WEB_WORKER2) {
        root2 = self;
      }
      var COMMON_JS2 = !root2.JS_SHA3_NO_COMMON_JS && typeof module2 === "object" && module2.exports;
      var AMD2 = typeof define === "function" && define.amd;
      var ARRAY_BUFFER2 = !root2.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS2 = "0123456789abcdef".split("");
      var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
      var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
      var KECCAK_PADDING = [1, 256, 65536, 16777216];
      var PADDING2 = [6, 1536, 393216, 100663296];
      var SHIFT2 = [0, 8, 16, 24];
      var RC = [
        1,
        0,
        32898,
        0,
        32906,
        2147483648,
        2147516416,
        2147483648,
        32907,
        0,
        2147483649,
        0,
        2147516545,
        2147483648,
        32777,
        2147483648,
        138,
        0,
        136,
        0,
        2147516425,
        0,
        2147483658,
        0,
        2147516555,
        0,
        139,
        2147483648,
        32905,
        2147483648,
        32771,
        2147483648,
        32770,
        2147483648,
        128,
        2147483648,
        32778,
        0,
        2147483658,
        2147483648,
        2147516545,
        2147483648,
        32896,
        2147483648,
        2147483649,
        0,
        2147516424,
        2147483648
      ];
      var BITS = [224, 256, 384, 512];
      var SHAKE_BITS = [128, 256];
      var OUTPUT_TYPES2 = ["hex", "buffer", "arrayBuffer", "array", "digest"];
      var CSHAKE_BYTEPAD = {
        "128": 168,
        "256": 136
      };
      if (root2.JS_SHA3_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      if (ARRAY_BUFFER2 && (root2.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var createOutputMethod2 = function(bits2, padding2, outputType) {
        return function(message) {
          return new Keccak(bits2, padding2, bits2).update(message)[outputType]();
        };
      };
      var createShakeOutputMethod = function(bits2, padding2, outputType) {
        return function(message, outputBits) {
          return new Keccak(bits2, padding2, outputBits).update(message)[outputType]();
        };
      };
      var createCshakeOutputMethod = function(bits2, padding2, outputType) {
        return function(message, outputBits, n4, s6) {
          return methods["cshake" + bits2].update(message, outputBits, n4, s6)[outputType]();
        };
      };
      var createKmacOutputMethod = function(bits2, padding2, outputType) {
        return function(key2, message, outputBits, s6) {
          return methods["kmac" + bits2].update(key2, message, outputBits, s6)[outputType]();
        };
      };
      var createOutputMethods = function(method2, createMethod3, bits2, padding2) {
        for (var i7 = 0; i7 < OUTPUT_TYPES2.length; ++i7) {
          var type = OUTPUT_TYPES2[i7];
          method2[type] = createMethod3(bits2, padding2, type);
        }
        return method2;
      };
      var createMethod2 = function(bits2, padding2) {
        var method2 = createOutputMethod2(bits2, padding2, "hex");
        method2.create = function() {
          return new Keccak(bits2, padding2, bits2);
        };
        method2.update = function(message) {
          return method2.create().update(message);
        };
        return createOutputMethods(method2, createOutputMethod2, bits2, padding2);
      };
      var createShakeMethod = function(bits2, padding2) {
        var method2 = createShakeOutputMethod(bits2, padding2, "hex");
        method2.create = function(outputBits) {
          return new Keccak(bits2, padding2, outputBits);
        };
        method2.update = function(message, outputBits) {
          return method2.create(outputBits).update(message);
        };
        return createOutputMethods(method2, createShakeOutputMethod, bits2, padding2);
      };
      var createCshakeMethod = function(bits2, padding2) {
        var w8 = CSHAKE_BYTEPAD[bits2];
        var method2 = createCshakeOutputMethod(bits2, padding2, "hex");
        method2.create = function(outputBits, n4, s6) {
          if (!n4 && !s6) {
            return methods["shake" + bits2].create(outputBits);
          } else {
            return new Keccak(bits2, padding2, outputBits).bytepad([n4, s6], w8);
          }
        };
        method2.update = function(message, outputBits, n4, s6) {
          return method2.create(outputBits, n4, s6).update(message);
        };
        return createOutputMethods(method2, createCshakeOutputMethod, bits2, padding2);
      };
      var createKmacMethod = function(bits2, padding2) {
        var w8 = CSHAKE_BYTEPAD[bits2];
        var method2 = createKmacOutputMethod(bits2, padding2, "hex");
        method2.create = function(key2, outputBits, s6) {
          return new Kmac(bits2, padding2, outputBits).bytepad(["KMAC", s6], w8).bytepad([key2], w8);
        };
        method2.update = function(key2, message, outputBits, s6) {
          return method2.create(key2, outputBits, s6).update(message);
        };
        return createOutputMethods(method2, createKmacOutputMethod, bits2, padding2);
      };
      var algorithms = [
        { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod: createMethod2 },
        { name: "sha3", padding: PADDING2, bits: BITS, createMethod: createMethod2 },
        { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
        { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
        { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
      ];
      var methods = {}, methodNames = [];
      for (var i6 = 0; i6 < algorithms.length; ++i6) {
        var algorithm2 = algorithms[i6];
        var bits = algorithm2.bits;
        for (var j8 = 0; j8 < bits.length; ++j8) {
          var methodName = algorithm2.name + "_" + bits[j8];
          methodNames.push(methodName);
          methods[methodName] = algorithm2.createMethod(bits[j8], algorithm2.padding);
          if (algorithm2.name !== "sha3") {
            var newMethodName = algorithm2.name + bits[j8];
            methodNames.push(newMethodName);
            methods[newMethodName] = methods[methodName];
          }
        }
      }
      function Keccak(bits2, padding2, outputBits) {
        this.blocks = [];
        this.s = [];
        this.padding = padding2;
        this.outputBits = outputBits;
        this.reset = true;
        this.finalized = false;
        this.block = 0;
        this.start = 0;
        this.blockCount = 1600 - (bits2 << 1) >> 5;
        this.byteCount = this.blockCount << 2;
        this.outputBlocks = outputBits >> 5;
        this.extraBytes = (outputBits & 31) >> 3;
        for (var i7 = 0; i7 < 50; ++i7) {
          this.s[i7] = 0;
        }
      }
      Keccak.prototype.update = function(message) {
        if (this.finalized) {
          throw new Error(FINALIZE_ERROR);
        }
        var notString, type = typeof message;
        if (type !== "string") {
          if (type === "object") {
            if (message === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER2 && message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            } else if (!Array.isArray(message)) {
              if (!ARRAY_BUFFER2 || !ArrayBuffer.isView(message)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var blocks2 = this.blocks, byteCount = this.byteCount, length = message.length, blockCount = this.blockCount, index = 0, s6 = this.s, i7, code;
        while (index < length) {
          if (this.reset) {
            this.reset = false;
            blocks2[0] = this.block;
            for (i7 = 1; i7 < blockCount + 1; ++i7) {
              blocks2[i7] = 0;
            }
          }
          if (notString) {
            for (i7 = this.start; index < length && i7 < byteCount; ++index) {
              blocks2[i7 >> 2] |= message[index] << SHIFT2[i7++ & 3];
            }
          } else {
            for (i7 = this.start; index < length && i7 < byteCount; ++index) {
              code = message.charCodeAt(index);
              if (code < 128) {
                blocks2[i7 >> 2] |= code << SHIFT2[i7++ & 3];
              } else if (code < 2048) {
                blocks2[i7 >> 2] |= (192 | code >> 6) << SHIFT2[i7++ & 3];
                blocks2[i7 >> 2] |= (128 | code & 63) << SHIFT2[i7++ & 3];
              } else if (code < 55296 || code >= 57344) {
                blocks2[i7 >> 2] |= (224 | code >> 12) << SHIFT2[i7++ & 3];
                blocks2[i7 >> 2] |= (128 | code >> 6 & 63) << SHIFT2[i7++ & 3];
                blocks2[i7 >> 2] |= (128 | code & 63) << SHIFT2[i7++ & 3];
              } else {
                code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                blocks2[i7 >> 2] |= (240 | code >> 18) << SHIFT2[i7++ & 3];
                blocks2[i7 >> 2] |= (128 | code >> 12 & 63) << SHIFT2[i7++ & 3];
                blocks2[i7 >> 2] |= (128 | code >> 6 & 63) << SHIFT2[i7++ & 3];
                blocks2[i7 >> 2] |= (128 | code & 63) << SHIFT2[i7++ & 3];
              }
            }
          }
          this.lastByteIndex = i7;
          if (i7 >= byteCount) {
            this.start = i7 - byteCount;
            this.block = blocks2[blockCount];
            for (i7 = 0; i7 < blockCount; ++i7) {
              s6[i7] ^= blocks2[i7];
            }
            f7(s6);
            this.reset = true;
          } else {
            this.start = i7;
          }
        }
        return this;
      };
      Keccak.prototype.encode = function(x6, right) {
        var o6 = x6 & 255, n4 = 1;
        var bytes = [o6];
        x6 = x6 >> 8;
        o6 = x6 & 255;
        while (o6 > 0) {
          bytes.unshift(o6);
          x6 = x6 >> 8;
          o6 = x6 & 255;
          ++n4;
        }
        if (right) {
          bytes.push(n4);
        } else {
          bytes.unshift(n4);
        }
        this.update(bytes);
        return bytes.length;
      };
      Keccak.prototype.encodeString = function(str) {
        var notString, type = typeof str;
        if (type !== "string") {
          if (type === "object") {
            if (str === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER2 && str.constructor === ArrayBuffer) {
              str = new Uint8Array(str);
            } else if (!Array.isArray(str)) {
              if (!ARRAY_BUFFER2 || !ArrayBuffer.isView(str)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var bytes = 0, length = str.length;
        if (notString) {
          bytes = length;
        } else {
          for (var i7 = 0; i7 < str.length; ++i7) {
            var code = str.charCodeAt(i7);
            if (code < 128) {
              bytes += 1;
            } else if (code < 2048) {
              bytes += 2;
            } else if (code < 55296 || code >= 57344) {
              bytes += 3;
            } else {
              code = 65536 + ((code & 1023) << 10 | str.charCodeAt(++i7) & 1023);
              bytes += 4;
            }
          }
        }
        bytes += this.encode(bytes * 8);
        this.update(str);
        return bytes;
      };
      Keccak.prototype.bytepad = function(strs, w8) {
        var bytes = this.encode(w8);
        for (var i7 = 0; i7 < strs.length; ++i7) {
          bytes += this.encodeString(strs[i7]);
        }
        var paddingBytes = w8 - bytes % w8;
        var zeros2 = [];
        zeros2.length = paddingBytes;
        this.update(zeros2);
        return this;
      };
      Keccak.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks2 = this.blocks, i7 = this.lastByteIndex, blockCount = this.blockCount, s6 = this.s;
        blocks2[i7 >> 2] |= this.padding[i7 & 3];
        if (this.lastByteIndex === this.byteCount) {
          blocks2[0] = blocks2[blockCount];
          for (i7 = 1; i7 < blockCount + 1; ++i7) {
            blocks2[i7] = 0;
          }
        }
        blocks2[blockCount - 1] |= 2147483648;
        for (i7 = 0; i7 < blockCount; ++i7) {
          s6[i7] ^= blocks2[i7];
        }
        f7(s6);
      };
      Keccak.prototype.toString = Keccak.prototype.hex = function() {
        this.finalize();
        var blockCount = this.blockCount, s6 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i7 = 0, j9 = 0;
        var hex = "", block;
        while (j9 < outputBlocks) {
          for (i7 = 0; i7 < blockCount && j9 < outputBlocks; ++i7, ++j9) {
            block = s6[i7];
            hex += HEX_CHARS2[block >> 4 & 15] + HEX_CHARS2[block & 15] + HEX_CHARS2[block >> 12 & 15] + HEX_CHARS2[block >> 8 & 15] + HEX_CHARS2[block >> 20 & 15] + HEX_CHARS2[block >> 16 & 15] + HEX_CHARS2[block >> 28 & 15] + HEX_CHARS2[block >> 24 & 15];
          }
          if (j9 % blockCount === 0) {
            f7(s6);
            i7 = 0;
          }
        }
        if (extraBytes) {
          block = s6[i7];
          hex += HEX_CHARS2[block >> 4 & 15] + HEX_CHARS2[block & 15];
          if (extraBytes > 1) {
            hex += HEX_CHARS2[block >> 12 & 15] + HEX_CHARS2[block >> 8 & 15];
          }
          if (extraBytes > 2) {
            hex += HEX_CHARS2[block >> 20 & 15] + HEX_CHARS2[block >> 16 & 15];
          }
        }
        return hex;
      };
      Keccak.prototype.arrayBuffer = function() {
        this.finalize();
        var blockCount = this.blockCount, s6 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i7 = 0, j9 = 0;
        var bytes = this.outputBits >> 3;
        var buffer2;
        if (extraBytes) {
          buffer2 = new ArrayBuffer(outputBlocks + 1 << 2);
        } else {
          buffer2 = new ArrayBuffer(bytes);
        }
        var array = new Uint32Array(buffer2);
        while (j9 < outputBlocks) {
          for (i7 = 0; i7 < blockCount && j9 < outputBlocks; ++i7, ++j9) {
            array[j9] = s6[i7];
          }
          if (j9 % blockCount === 0) {
            f7(s6);
          }
        }
        if (extraBytes) {
          array[i7] = s6[i7];
          buffer2 = buffer2.slice(0, bytes);
        }
        return buffer2;
      };
      Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
      Keccak.prototype.digest = Keccak.prototype.array = function() {
        this.finalize();
        var blockCount = this.blockCount, s6 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i7 = 0, j9 = 0;
        var array = [], offset, block;
        while (j9 < outputBlocks) {
          for (i7 = 0; i7 < blockCount && j9 < outputBlocks; ++i7, ++j9) {
            offset = j9 << 2;
            block = s6[i7];
            array[offset] = block & 255;
            array[offset + 1] = block >> 8 & 255;
            array[offset + 2] = block >> 16 & 255;
            array[offset + 3] = block >> 24 & 255;
          }
          if (j9 % blockCount === 0) {
            f7(s6);
          }
        }
        if (extraBytes) {
          offset = j9 << 2;
          block = s6[i7];
          array[offset] = block & 255;
          if (extraBytes > 1) {
            array[offset + 1] = block >> 8 & 255;
          }
          if (extraBytes > 2) {
            array[offset + 2] = block >> 16 & 255;
          }
        }
        return array;
      };
      function Kmac(bits2, padding2, outputBits) {
        Keccak.call(this, bits2, padding2, outputBits);
      }
      Kmac.prototype = new Keccak();
      Kmac.prototype.finalize = function() {
        this.encode(this.outputBits, true);
        return Keccak.prototype.finalize.call(this);
      };
      var f7 = function(s6) {
        var h6, l6, n4, c0, c1, c22, c32, c42, c5, c62, c7, c8, c9, b02, b1, b22, b32, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b222, b23, b24, b25, b26, b27, b28, b29, b30, b31, b322, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
        for (n4 = 0; n4 < 48; n4 += 2) {
          c0 = s6[0] ^ s6[10] ^ s6[20] ^ s6[30] ^ s6[40];
          c1 = s6[1] ^ s6[11] ^ s6[21] ^ s6[31] ^ s6[41];
          c22 = s6[2] ^ s6[12] ^ s6[22] ^ s6[32] ^ s6[42];
          c32 = s6[3] ^ s6[13] ^ s6[23] ^ s6[33] ^ s6[43];
          c42 = s6[4] ^ s6[14] ^ s6[24] ^ s6[34] ^ s6[44];
          c5 = s6[5] ^ s6[15] ^ s6[25] ^ s6[35] ^ s6[45];
          c62 = s6[6] ^ s6[16] ^ s6[26] ^ s6[36] ^ s6[46];
          c7 = s6[7] ^ s6[17] ^ s6[27] ^ s6[37] ^ s6[47];
          c8 = s6[8] ^ s6[18] ^ s6[28] ^ s6[38] ^ s6[48];
          c9 = s6[9] ^ s6[19] ^ s6[29] ^ s6[39] ^ s6[49];
          h6 = c8 ^ (c22 << 1 | c32 >>> 31);
          l6 = c9 ^ (c32 << 1 | c22 >>> 31);
          s6[0] ^= h6;
          s6[1] ^= l6;
          s6[10] ^= h6;
          s6[11] ^= l6;
          s6[20] ^= h6;
          s6[21] ^= l6;
          s6[30] ^= h6;
          s6[31] ^= l6;
          s6[40] ^= h6;
          s6[41] ^= l6;
          h6 = c0 ^ (c42 << 1 | c5 >>> 31);
          l6 = c1 ^ (c5 << 1 | c42 >>> 31);
          s6[2] ^= h6;
          s6[3] ^= l6;
          s6[12] ^= h6;
          s6[13] ^= l6;
          s6[22] ^= h6;
          s6[23] ^= l6;
          s6[32] ^= h6;
          s6[33] ^= l6;
          s6[42] ^= h6;
          s6[43] ^= l6;
          h6 = c22 ^ (c62 << 1 | c7 >>> 31);
          l6 = c32 ^ (c7 << 1 | c62 >>> 31);
          s6[4] ^= h6;
          s6[5] ^= l6;
          s6[14] ^= h6;
          s6[15] ^= l6;
          s6[24] ^= h6;
          s6[25] ^= l6;
          s6[34] ^= h6;
          s6[35] ^= l6;
          s6[44] ^= h6;
          s6[45] ^= l6;
          h6 = c42 ^ (c8 << 1 | c9 >>> 31);
          l6 = c5 ^ (c9 << 1 | c8 >>> 31);
          s6[6] ^= h6;
          s6[7] ^= l6;
          s6[16] ^= h6;
          s6[17] ^= l6;
          s6[26] ^= h6;
          s6[27] ^= l6;
          s6[36] ^= h6;
          s6[37] ^= l6;
          s6[46] ^= h6;
          s6[47] ^= l6;
          h6 = c62 ^ (c0 << 1 | c1 >>> 31);
          l6 = c7 ^ (c1 << 1 | c0 >>> 31);
          s6[8] ^= h6;
          s6[9] ^= l6;
          s6[18] ^= h6;
          s6[19] ^= l6;
          s6[28] ^= h6;
          s6[29] ^= l6;
          s6[38] ^= h6;
          s6[39] ^= l6;
          s6[48] ^= h6;
          s6[49] ^= l6;
          b02 = s6[0];
          b1 = s6[1];
          b322 = s6[11] << 4 | s6[10] >>> 28;
          b33 = s6[10] << 4 | s6[11] >>> 28;
          b14 = s6[20] << 3 | s6[21] >>> 29;
          b15 = s6[21] << 3 | s6[20] >>> 29;
          b46 = s6[31] << 9 | s6[30] >>> 23;
          b47 = s6[30] << 9 | s6[31] >>> 23;
          b28 = s6[40] << 18 | s6[41] >>> 14;
          b29 = s6[41] << 18 | s6[40] >>> 14;
          b20 = s6[2] << 1 | s6[3] >>> 31;
          b21 = s6[3] << 1 | s6[2] >>> 31;
          b22 = s6[13] << 12 | s6[12] >>> 20;
          b32 = s6[12] << 12 | s6[13] >>> 20;
          b34 = s6[22] << 10 | s6[23] >>> 22;
          b35 = s6[23] << 10 | s6[22] >>> 22;
          b16 = s6[33] << 13 | s6[32] >>> 19;
          b17 = s6[32] << 13 | s6[33] >>> 19;
          b48 = s6[42] << 2 | s6[43] >>> 30;
          b49 = s6[43] << 2 | s6[42] >>> 30;
          b40 = s6[5] << 30 | s6[4] >>> 2;
          b41 = s6[4] << 30 | s6[5] >>> 2;
          b222 = s6[14] << 6 | s6[15] >>> 26;
          b23 = s6[15] << 6 | s6[14] >>> 26;
          b4 = s6[25] << 11 | s6[24] >>> 21;
          b5 = s6[24] << 11 | s6[25] >>> 21;
          b36 = s6[34] << 15 | s6[35] >>> 17;
          b37 = s6[35] << 15 | s6[34] >>> 17;
          b18 = s6[45] << 29 | s6[44] >>> 3;
          b19 = s6[44] << 29 | s6[45] >>> 3;
          b10 = s6[6] << 28 | s6[7] >>> 4;
          b11 = s6[7] << 28 | s6[6] >>> 4;
          b42 = s6[17] << 23 | s6[16] >>> 9;
          b43 = s6[16] << 23 | s6[17] >>> 9;
          b24 = s6[26] << 25 | s6[27] >>> 7;
          b25 = s6[27] << 25 | s6[26] >>> 7;
          b6 = s6[36] << 21 | s6[37] >>> 11;
          b7 = s6[37] << 21 | s6[36] >>> 11;
          b38 = s6[47] << 24 | s6[46] >>> 8;
          b39 = s6[46] << 24 | s6[47] >>> 8;
          b30 = s6[8] << 27 | s6[9] >>> 5;
          b31 = s6[9] << 27 | s6[8] >>> 5;
          b12 = s6[18] << 20 | s6[19] >>> 12;
          b13 = s6[19] << 20 | s6[18] >>> 12;
          b44 = s6[29] << 7 | s6[28] >>> 25;
          b45 = s6[28] << 7 | s6[29] >>> 25;
          b26 = s6[38] << 8 | s6[39] >>> 24;
          b27 = s6[39] << 8 | s6[38] >>> 24;
          b8 = s6[48] << 14 | s6[49] >>> 18;
          b9 = s6[49] << 14 | s6[48] >>> 18;
          s6[0] = b02 ^ ~b22 & b4;
          s6[1] = b1 ^ ~b32 & b5;
          s6[10] = b10 ^ ~b12 & b14;
          s6[11] = b11 ^ ~b13 & b15;
          s6[20] = b20 ^ ~b222 & b24;
          s6[21] = b21 ^ ~b23 & b25;
          s6[30] = b30 ^ ~b322 & b34;
          s6[31] = b31 ^ ~b33 & b35;
          s6[40] = b40 ^ ~b42 & b44;
          s6[41] = b41 ^ ~b43 & b45;
          s6[2] = b22 ^ ~b4 & b6;
          s6[3] = b32 ^ ~b5 & b7;
          s6[12] = b12 ^ ~b14 & b16;
          s6[13] = b13 ^ ~b15 & b17;
          s6[22] = b222 ^ ~b24 & b26;
          s6[23] = b23 ^ ~b25 & b27;
          s6[32] = b322 ^ ~b34 & b36;
          s6[33] = b33 ^ ~b35 & b37;
          s6[42] = b42 ^ ~b44 & b46;
          s6[43] = b43 ^ ~b45 & b47;
          s6[4] = b4 ^ ~b6 & b8;
          s6[5] = b5 ^ ~b7 & b9;
          s6[14] = b14 ^ ~b16 & b18;
          s6[15] = b15 ^ ~b17 & b19;
          s6[24] = b24 ^ ~b26 & b28;
          s6[25] = b25 ^ ~b27 & b29;
          s6[34] = b34 ^ ~b36 & b38;
          s6[35] = b35 ^ ~b37 & b39;
          s6[44] = b44 ^ ~b46 & b48;
          s6[45] = b45 ^ ~b47 & b49;
          s6[6] = b6 ^ ~b8 & b02;
          s6[7] = b7 ^ ~b9 & b1;
          s6[16] = b16 ^ ~b18 & b10;
          s6[17] = b17 ^ ~b19 & b11;
          s6[26] = b26 ^ ~b28 & b20;
          s6[27] = b27 ^ ~b29 & b21;
          s6[36] = b36 ^ ~b38 & b30;
          s6[37] = b37 ^ ~b39 & b31;
          s6[46] = b46 ^ ~b48 & b40;
          s6[47] = b47 ^ ~b49 & b41;
          s6[8] = b8 ^ ~b02 & b22;
          s6[9] = b9 ^ ~b1 & b32;
          s6[18] = b18 ^ ~b10 & b12;
          s6[19] = b19 ^ ~b11 & b13;
          s6[28] = b28 ^ ~b20 & b222;
          s6[29] = b29 ^ ~b21 & b23;
          s6[38] = b38 ^ ~b30 & b322;
          s6[39] = b39 ^ ~b31 & b33;
          s6[48] = b48 ^ ~b40 & b42;
          s6[49] = b49 ^ ~b41 & b43;
          s6[0] ^= RC[n4];
          s6[1] ^= RC[n4 + 1];
        }
      };
      if (COMMON_JS2) {
        module2.exports = methods;
      } else {
        for (i6 = 0; i6 < methodNames.length; ++i6) {
          root2[methodNames[i6]] = methods[methodNames[i6]];
        }
        if (AMD2) {
          define(function() {
            return methods;
          });
        }
      }
    })();
  }
});

// node_modules/@ethersproject/keccak256/lib.esm/index.js
var lib_exports4 = {};
__export(lib_exports4, {
  keccak256: () => keccak256
});
function keccak256(data) {
  return "0x" + import_js_sha3.default.keccak_256(arrayify(data));
}
var import_js_sha3;
var init_lib5 = __esm({
  "node_modules/@ethersproject/keccak256/lib.esm/index.js"() {
    "use strict";
    import_js_sha3 = __toESM(require_sha3());
    init_lib2();
  }
});

// node_modules/@ethersproject/rlp/lib.esm/_version.js
var version6;
var init_version6 = __esm({
  "node_modules/@ethersproject/rlp/lib.esm/_version.js"() {
    version6 = "rlp/5.6.0";
  }
});

// node_modules/@ethersproject/rlp/lib.esm/index.js
var lib_exports5 = {};
__export(lib_exports5, {
  decode: () => decode,
  encode: () => encode
});
function arrayifyInteger(value2) {
  const result = [];
  while (value2) {
    result.unshift(value2 & 255);
    value2 >>= 8;
  }
  return result;
}
function unarrayifyInteger(data, offset, length) {
  let result = 0;
  for (let i6 = 0; i6 < length; i6++) {
    result = result * 256 + data[offset + i6];
  }
  return result;
}
function _encode(object) {
  if (Array.isArray(object)) {
    let payload = [];
    object.forEach(function(child) {
      payload = payload.concat(_encode(child));
    });
    if (payload.length <= 55) {
      payload.unshift(192 + payload.length);
      return payload;
    }
    const length2 = arrayifyInteger(payload.length);
    length2.unshift(247 + length2.length);
    return length2.concat(payload);
  }
  if (!isBytesLike(object)) {
    logger7.throwArgumentError("RLP object must be BytesLike", "object", object);
  }
  const data = Array.prototype.slice.call(arrayify(object));
  if (data.length === 1 && data[0] <= 127) {
    return data;
  } else if (data.length <= 55) {
    data.unshift(128 + data.length);
    return data;
  }
  const length = arrayifyInteger(data.length);
  length.unshift(183 + length.length);
  return length.concat(data);
}
function encode(object) {
  return hexlify(_encode(object));
}
function _decodeChildren(data, offset, childOffset, length) {
  const result = [];
  while (childOffset < offset + 1 + length) {
    const decoded = _decode(data, childOffset);
    result.push(decoded.result);
    childOffset += decoded.consumed;
    if (childOffset > offset + 1 + length) {
      logger7.throwError("child data too short", Logger.errors.BUFFER_OVERRUN, {});
    }
  }
  return { consumed: 1 + length, result };
}
function _decode(data, offset) {
  if (data.length === 0) {
    logger7.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
  }
  if (data[offset] >= 248) {
    const lengthLength = data[offset] - 247;
    if (offset + 1 + lengthLength > data.length) {
      logger7.throwError("data short segment too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const length = unarrayifyInteger(data, offset + 1, lengthLength);
    if (offset + 1 + lengthLength + length > data.length) {
      logger7.throwError("data long segment too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);
  } else if (data[offset] >= 192) {
    const length = data[offset] - 192;
    if (offset + 1 + length > data.length) {
      logger7.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren(data, offset, offset + 1, length);
  } else if (data[offset] >= 184) {
    const lengthLength = data[offset] - 183;
    if (offset + 1 + lengthLength > data.length) {
      logger7.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const length = unarrayifyInteger(data, offset + 1, lengthLength);
    if (offset + 1 + lengthLength + length > data.length) {
      logger7.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
    return { consumed: 1 + lengthLength + length, result };
  } else if (data[offset] >= 128) {
    const length = data[offset] - 128;
    if (offset + 1 + length > data.length) {
      logger7.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify(data.slice(offset + 1, offset + 1 + length));
    return { consumed: 1 + length, result };
  }
  return { consumed: 1, result: hexlify(data[offset]) };
}
function decode(data) {
  const bytes = arrayify(data);
  const decoded = _decode(bytes, 0);
  if (decoded.consumed !== bytes.length) {
    logger7.throwArgumentError("invalid rlp data", "data", data);
  }
  return decoded.result;
}
var logger7;
var init_lib6 = __esm({
  "node_modules/@ethersproject/rlp/lib.esm/index.js"() {
    "use strict";
    init_lib2();
    init_lib();
    init_version6();
    logger7 = new Logger(version6);
  }
});

// node_modules/@ethersproject/address/lib.esm/_version.js
var version7;
var init_version7 = __esm({
  "node_modules/@ethersproject/address/lib.esm/_version.js"() {
    version7 = "address/5.6.0";
  }
});

// node_modules/@ethersproject/address/lib.esm/index.js
var lib_exports6 = {};
__export(lib_exports6, {
  getAddress: () => getAddress,
  getContractAddress: () => getContractAddress,
  getCreate2Address: () => getCreate2Address,
  getIcapAddress: () => getIcapAddress,
  isAddress: () => isAddress
});
function getChecksumAddress(address) {
  if (!isHexString(address, 20)) {
    logger8.throwArgumentError("invalid address", "address", address);
  }
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i6 = 0; i6 < 40; i6++) {
    expanded[i6] = chars[i6].charCodeAt(0);
  }
  const hashed = arrayify(keccak256(expanded));
  for (let i6 = 0; i6 < 40; i6 += 2) {
    if (hashed[i6 >> 1] >> 4 >= 8) {
      chars[i6] = chars[i6].toUpperCase();
    }
    if ((hashed[i6 >> 1] & 15) >= 8) {
      chars[i6 + 1] = chars[i6 + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
function log10(x6) {
  if (Math.log10) {
    return Math.log10(x6);
  }
  return Math.log(x6) / Math.LN10;
}
function ibanChecksum(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c5) => {
    return ibanLookup[c5];
  }).join("");
  while (expanded.length >= safeDigits) {
    let block = expanded.substring(0, safeDigits);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum = String(98 - parseInt(expanded, 10) % 97);
  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }
  return checksum;
}
function getAddress(address) {
  let result = null;
  if (typeof address !== "string") {
    logger8.throwArgumentError("invalid address", "address", address);
  }
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (address.substring(0, 2) !== "0x") {
      address = "0x" + address;
    }
    result = getChecksumAddress(address);
    if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
      logger8.throwArgumentError("bad address checksum", "address", address);
    }
  } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    if (address.substring(2, 4) !== ibanChecksum(address)) {
      logger8.throwArgumentError("bad icap checksum", "address", address);
    }
    result = _base36To16(address.substring(4));
    while (result.length < 40) {
      result = "0" + result;
    }
    result = getChecksumAddress("0x" + result);
  } else {
    logger8.throwArgumentError("invalid address", "address", address);
  }
  return result;
}
function isAddress(address) {
  try {
    getAddress(address);
    return true;
  } catch (error) {
  }
  return false;
}
function getIcapAddress(address) {
  let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();
  while (base36.length < 30) {
    base36 = "0" + base36;
  }
  return "XE" + ibanChecksum("XE00" + base36) + base36;
}
function getContractAddress(transaction) {
  let from2 = null;
  try {
    from2 = getAddress(transaction.from);
  } catch (error) {
    logger8.throwArgumentError("missing from address", "transaction", transaction);
  }
  const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));
  return getAddress(hexDataSlice(keccak256(encode([from2, nonce])), 12));
}
function getCreate2Address(from2, salt, initCodeHash) {
  if (hexDataLength(salt) !== 32) {
    logger8.throwArgumentError("salt must be 32 bytes", "salt", salt);
  }
  if (hexDataLength(initCodeHash) !== 32) {
    logger8.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", initCodeHash);
  }
  return getAddress(hexDataSlice(keccak256(concat(["0xff", getAddress(from2), salt, initCodeHash])), 12));
}
var logger8, MAX_SAFE_INTEGER, ibanLookup, safeDigits;
var init_lib7 = __esm({
  "node_modules/@ethersproject/address/lib.esm/index.js"() {
    "use strict";
    init_lib2();
    init_lib3();
    init_lib5();
    init_lib6();
    init_lib();
    init_version7();
    logger8 = new Logger(version7);
    MAX_SAFE_INTEGER = 9007199254740991;
    ibanLookup = {};
    for (let i6 = 0; i6 < 10; i6++) {
      ibanLookup[String(i6)] = String(i6);
    }
    for (let i6 = 0; i6 < 26; i6++) {
      ibanLookup[String.fromCharCode(65 + i6)] = String(10 + i6);
    }
    safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
  }
});

// node_modules/@ethersproject/abi/lib.esm/coders/address.js
var AddressCoder;
var init_address = __esm({
  "node_modules/@ethersproject/abi/lib.esm/coders/address.js"() {
    "use strict";
    init_lib7();
    init_lib2();
    init_abstract_coder();
    AddressCoder = class extends Coder {
      constructor(localName) {
        super("address", "address", localName, false);
      }
      defaultValue() {
        return "0x0000000000000000000000000000000000000000";
      }
      encode(writer, value2) {
        try {
          value2 = getAddress(value2);
        } catch (error) {
          this._throwError(error.message, value2);
        }
        return writer.writeValue(value2);
      }
      decode(reader) {
        return getAddress(hexZeroPad(reader.readValue().toHexString(), 20));
      }
    };
  }
});

// node_modules/@ethersproject/abi/lib.esm/coders/anonymous.js
var AnonymousCoder;
var init_anonymous = __esm({
  "node_modules/@ethersproject/abi/lib.esm/coders/anonymous.js"() {
    "use strict";
    init_abstract_coder();
    AnonymousCoder = class extends Coder {
      constructor(coder) {
        super(coder.name, coder.type, void 0, coder.dynamic);
        this.coder = coder;
      }
      defaultValue() {
        return this.coder.defaultValue();
      }
      encode(writer, value2) {
        return this.coder.encode(writer, value2);
      }
      decode(reader) {
        return this.coder.decode(reader);
      }
    };
  }
});

// node_modules/@ethersproject/abi/lib.esm/coders/array.js
function pack(writer, coders, values) {
  let arrayValues = null;
  if (Array.isArray(values)) {
    arrayValues = values;
  } else if (values && typeof values === "object") {
    let unique = {};
    arrayValues = coders.map((coder) => {
      const name2 = coder.localName;
      if (!name2) {
        logger9.throwError("cannot encode object for signature with missing names", Logger.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder,
          value: values
        });
      }
      if (unique[name2]) {
        logger9.throwError("cannot encode object for signature with duplicate names", Logger.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder,
          value: values
        });
      }
      unique[name2] = true;
      return values[name2];
    });
  } else {
    logger9.throwArgumentError("invalid tuple value", "tuple", values);
  }
  if (coders.length !== arrayValues.length) {
    logger9.throwArgumentError("types/value length mismatch", "tuple", values);
  }
  let staticWriter = new Writer(writer.wordSize);
  let dynamicWriter = new Writer(writer.wordSize);
  let updateFuncs = [];
  coders.forEach((coder, index) => {
    let value2 = arrayValues[index];
    if (coder.dynamic) {
      let dynamicOffset = dynamicWriter.length;
      coder.encode(dynamicWriter, value2);
      let updateFunc = staticWriter.writeUpdatableValue();
      updateFuncs.push((baseOffset) => {
        updateFunc(baseOffset + dynamicOffset);
      });
    } else {
      coder.encode(staticWriter, value2);
    }
  });
  updateFuncs.forEach((func) => {
    func(staticWriter.length);
  });
  let length = writer.appendWriter(staticWriter);
  length += writer.appendWriter(dynamicWriter);
  return length;
}
function unpack(reader, coders) {
  let values = [];
  let baseReader = reader.subReader(0);
  coders.forEach((coder) => {
    let value2 = null;
    if (coder.dynamic) {
      let offset = reader.readValue();
      let offsetReader = baseReader.subReader(offset.toNumber());
      try {
        value2 = coder.decode(offsetReader);
      } catch (error) {
        if (error.code === Logger.errors.BUFFER_OVERRUN) {
          throw error;
        }
        value2 = error;
        value2.baseType = coder.name;
        value2.name = coder.localName;
        value2.type = coder.type;
      }
    } else {
      try {
        value2 = coder.decode(reader);
      } catch (error) {
        if (error.code === Logger.errors.BUFFER_OVERRUN) {
          throw error;
        }
        value2 = error;
        value2.baseType = coder.name;
        value2.name = coder.localName;
        value2.type = coder.type;
      }
    }
    if (value2 != void 0) {
      values.push(value2);
    }
  });
  const uniqueNames = coders.reduce((accum, coder) => {
    const name2 = coder.localName;
    if (name2) {
      if (!accum[name2]) {
        accum[name2] = 0;
      }
      accum[name2]++;
    }
    return accum;
  }, {});
  coders.forEach((coder, index) => {
    let name2 = coder.localName;
    if (!name2 || uniqueNames[name2] !== 1) {
      return;
    }
    if (name2 === "length") {
      name2 = "_length";
    }
    if (values[name2] != null) {
      return;
    }
    const value2 = values[index];
    if (value2 instanceof Error) {
      Object.defineProperty(values, name2, {
        enumerable: true,
        get: () => {
          throw value2;
        }
      });
    } else {
      values[name2] = value2;
    }
  });
  for (let i6 = 0; i6 < values.length; i6++) {
    const value2 = values[i6];
    if (value2 instanceof Error) {
      Object.defineProperty(values, i6, {
        enumerable: true,
        get: () => {
          throw value2;
        }
      });
    }
  }
  return Object.freeze(values);
}
var logger9, ArrayCoder;
var init_array = __esm({
  "node_modules/@ethersproject/abi/lib.esm/coders/array.js"() {
    "use strict";
    init_lib();
    init_version5();
    init_abstract_coder();
    init_anonymous();
    logger9 = new Logger(version5);
    ArrayCoder = class extends Coder {
      constructor(coder, length, localName) {
        const type = coder.type + "[" + (length >= 0 ? length : "") + "]";
        const dynamic = length === -1 || coder.dynamic;
        super("array", type, localName, dynamic);
        this.coder = coder;
        this.length = length;
      }
      defaultValue() {
        const defaultChild = this.coder.defaultValue();
        const result = [];
        for (let i6 = 0; i6 < this.length; i6++) {
          result.push(defaultChild);
        }
        return result;
      }
      encode(writer, value2) {
        if (!Array.isArray(value2)) {
          this._throwError("expected array value", value2);
        }
        let count2 = this.length;
        if (count2 === -1) {
          count2 = value2.length;
          writer.writeValue(value2.length);
        }
        logger9.checkArgumentCount(value2.length, count2, "coder array" + (this.localName ? " " + this.localName : ""));
        let coders = [];
        for (let i6 = 0; i6 < value2.length; i6++) {
          coders.push(this.coder);
        }
        return pack(writer, coders, value2);
      }
      decode(reader) {
        let count2 = this.length;
        if (count2 === -1) {
          count2 = reader.readValue().toNumber();
          if (count2 * 32 > reader._data.length) {
            logger9.throwError("insufficient data length", Logger.errors.BUFFER_OVERRUN, {
              length: reader._data.length,
              count: count2
            });
          }
        }
        let coders = [];
        for (let i6 = 0; i6 < count2; i6++) {
          coders.push(new AnonymousCoder(this.coder));
        }
        return reader.coerce(this.name, unpack(reader, coders));
      }
    };
  }
});

// node_modules/@ethersproject/abi/lib.esm/coders/boolean.js
var BooleanCoder;
var init_boolean = __esm({
  "node_modules/@ethersproject/abi/lib.esm/coders/boolean.js"() {
    "use strict";
    init_abstract_coder();
    BooleanCoder = class extends Coder {
      constructor(localName) {
        super("bool", "bool", localName, false);
      }
      defaultValue() {
        return false;
      }
      encode(writer, value2) {
        return writer.writeValue(value2 ? 1 : 0);
      }
      decode(reader) {
        return reader.coerce(this.type, !reader.readValue().isZero());
      }
    };
  }
});

// node_modules/@ethersproject/abi/lib.esm/coders/bytes.js
var DynamicBytesCoder, BytesCoder;
var init_bytes = __esm({
  "node_modules/@ethersproject/abi/lib.esm/coders/bytes.js"() {
    "use strict";
    init_lib2();
    init_abstract_coder();
    DynamicBytesCoder = class extends Coder {
      constructor(type, localName) {
        super(type, type, localName, true);
      }
      defaultValue() {
        return "0x";
      }
      encode(writer, value2) {
        value2 = arrayify(value2);
        let length = writer.writeValue(value2.length);
        length += writer.writeBytes(value2);
        return length;
      }
      decode(reader) {
        return reader.readBytes(reader.readValue().toNumber(), true);
      }
    };
    BytesCoder = class extends DynamicBytesCoder {
      constructor(localName) {
        super("bytes", localName);
      }
      decode(reader) {
        return reader.coerce(this.name, hexlify(super.decode(reader)));
      }
    };
  }
});

// node_modules/@ethersproject/abi/lib.esm/coders/fixed-bytes.js
var FixedBytesCoder;
var init_fixed_bytes = __esm({
  "node_modules/@ethersproject/abi/lib.esm/coders/fixed-bytes.js"() {
    "use strict";
    init_lib2();
    init_abstract_coder();
    FixedBytesCoder = class extends Coder {
      constructor(size, localName) {
        let name2 = "bytes" + String(size);
        super(name2, name2, localName, false);
        this.size = size;
      }
      defaultValue() {
        return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
      }
      encode(writer, value2) {
        let data = arrayify(value2);
        if (data.length !== this.size) {
          this._throwError("incorrect data length", value2);
        }
        return writer.writeBytes(data);
      }
      decode(reader) {
        return reader.coerce(this.name, hexlify(reader.readBytes(this.size)));
      }
    };
  }
});

// node_modules/@ethersproject/abi/lib.esm/coders/null.js
var NullCoder;
var init_null = __esm({
  "node_modules/@ethersproject/abi/lib.esm/coders/null.js"() {
    "use strict";
    init_abstract_coder();
    NullCoder = class extends Coder {
      constructor(localName) {
        super("null", "", localName, false);
      }
      defaultValue() {
        return null;
      }
      encode(writer, value2) {
        if (value2 != null) {
          this._throwError("not null", value2);
        }
        return writer.writeBytes([]);
      }
      decode(reader) {
        reader.readBytes(0);
        return reader.coerce(this.name, null);
      }
    };
  }
});

// node_modules/@ethersproject/constants/lib.esm/addresses.js
var AddressZero;
var init_addresses = __esm({
  "node_modules/@ethersproject/constants/lib.esm/addresses.js"() {
    AddressZero = "0x0000000000000000000000000000000000000000";
  }
});

// node_modules/@ethersproject/constants/lib.esm/bignumbers.js
var NegativeOne2, Zero2, One, Two, WeiPerEther, MaxUint256, MinInt256, MaxInt256;
var init_bignumbers = __esm({
  "node_modules/@ethersproject/constants/lib.esm/bignumbers.js"() {
    init_lib3();
    NegativeOne2 = BigNumber.from(-1);
    Zero2 = BigNumber.from(0);
    One = BigNumber.from(1);
    Two = BigNumber.from(2);
    WeiPerEther = BigNumber.from("1000000000000000000");
    MaxUint256 = BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    MinInt256 = BigNumber.from("-0x8000000000000000000000000000000000000000000000000000000000000000");
    MaxInt256 = BigNumber.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
  }
});

// node_modules/@ethersproject/constants/lib.esm/hashes.js
var HashZero;
var init_hashes = __esm({
  "node_modules/@ethersproject/constants/lib.esm/hashes.js"() {
    HashZero = "0x0000000000000000000000000000000000000000000000000000000000000000";
  }
});

// node_modules/@ethersproject/constants/lib.esm/strings.js
var EtherSymbol;
var init_strings = __esm({
  "node_modules/@ethersproject/constants/lib.esm/strings.js"() {
    EtherSymbol = "\u039E";
  }
});

// node_modules/@ethersproject/constants/lib.esm/index.js
var lib_exports7 = {};
__export(lib_exports7, {
  AddressZero: () => AddressZero,
  EtherSymbol: () => EtherSymbol,
  HashZero: () => HashZero,
  MaxInt256: () => MaxInt256,
  MaxUint256: () => MaxUint256,
  MinInt256: () => MinInt256,
  NegativeOne: () => NegativeOne2,
  One: () => One,
  Two: () => Two,
  WeiPerEther: () => WeiPerEther,
  Zero: () => Zero2
});
var init_lib8 = __esm({
  "node_modules/@ethersproject/constants/lib.esm/index.js"() {
    "use strict";
    init_addresses();
    init_bignumbers();
    init_hashes();
    init_strings();
  }
});

// node_modules/@ethersproject/abi/lib.esm/coders/number.js
var NumberCoder;
var init_number = __esm({
  "node_modules/@ethersproject/abi/lib.esm/coders/number.js"() {
    "use strict";
    init_lib3();
    init_lib8();
    init_abstract_coder();
    NumberCoder = class extends Coder {
      constructor(size, signed, localName) {
        const name2 = (signed ? "int" : "uint") + size * 8;
        super(name2, name2, localName, false);
        this.size = size;
        this.signed = signed;
      }
      defaultValue() {
        return 0;
      }
      encode(writer, value2) {
        let v9 = BigNumber.from(value2);
        let maxUintValue = MaxUint256.mask(writer.wordSize * 8);
        if (this.signed) {
          let bounds = maxUintValue.mask(this.size * 8 - 1);
          if (v9.gt(bounds) || v9.lt(bounds.add(One).mul(NegativeOne2))) {
            this._throwError("value out-of-bounds", value2);
          }
        } else if (v9.lt(Zero2) || v9.gt(maxUintValue.mask(this.size * 8))) {
          this._throwError("value out-of-bounds", value2);
        }
        v9 = v9.toTwos(this.size * 8).mask(this.size * 8);
        if (this.signed) {
          v9 = v9.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);
        }
        return writer.writeValue(v9);
      }
      decode(reader) {
        let value2 = reader.readValue().mask(this.size * 8);
        if (this.signed) {
          value2 = value2.fromTwos(this.size * 8);
        }
        return reader.coerce(this.name, value2);
      }
    };
  }
});

// node_modules/@ethersproject/strings/lib.esm/_version.js
var version8;
var init_version8 = __esm({
  "node_modules/@ethersproject/strings/lib.esm/_version.js"() {
    version8 = "strings/5.6.0";
  }
});

// node_modules/@ethersproject/strings/lib.esm/utf8.js
function errorFunc(reason, offset, bytes, output, badCodepoint) {
  return logger10.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
}
function ignoreFunc(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
    let i6 = 0;
    for (let o6 = offset + 1; o6 < bytes.length; o6++) {
      if (bytes[o6] >> 6 !== 2) {
        break;
      }
      i6++;
    }
    return i6;
  }
  if (reason === Utf8ErrorReason.OVERRUN) {
    return bytes.length - offset - 1;
  }
  return 0;
}
function replaceFunc(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason.OVERLONG) {
    output.push(badCodepoint);
    return 0;
  }
  output.push(65533);
  return ignoreFunc(reason, offset, bytes, output, badCodepoint);
}
function getUtf8CodePoints(bytes, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs.error;
  }
  bytes = arrayify(bytes);
  const result = [];
  let i6 = 0;
  while (i6 < bytes.length) {
    const c5 = bytes[i6++];
    if (c5 >> 7 === 0) {
      result.push(c5);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c5 & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c5 & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c5 & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c5 & 192) === 128) {
        i6 += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i6 - 1, bytes, result);
      } else {
        i6 += onError(Utf8ErrorReason.BAD_PREFIX, i6 - 1, bytes, result);
      }
      continue;
    }
    if (i6 - 1 + extraLength >= bytes.length) {
      i6 += onError(Utf8ErrorReason.OVERRUN, i6 - 1, bytes, result);
      continue;
    }
    let res = c5 & (1 << 8 - extraLength - 1) - 1;
    for (let j8 = 0; j8 < extraLength; j8++) {
      let nextChar = bytes[i6];
      if ((nextChar & 192) != 128) {
        i6 += onError(Utf8ErrorReason.MISSING_CONTINUE, i6, bytes, result);
        res = null;
        break;
      }
      ;
      res = res << 6 | nextChar & 63;
      i6++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i6 += onError(Utf8ErrorReason.OUT_OF_RANGE, i6 - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i6 += onError(Utf8ErrorReason.UTF16_SURROGATE, i6 - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i6 += onError(Utf8ErrorReason.OVERLONG, i6 - 1 - extraLength, bytes, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
function toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {
  if (form != UnicodeNormalizationForm.current) {
    logger10.checkNormalize();
    str = str.normalize(form);
  }
  let result = [];
  for (let i6 = 0; i6 < str.length; i6++) {
    const c5 = str.charCodeAt(i6);
    if (c5 < 128) {
      result.push(c5);
    } else if (c5 < 2048) {
      result.push(c5 >> 6 | 192);
      result.push(c5 & 63 | 128);
    } else if ((c5 & 64512) == 55296) {
      i6++;
      const c22 = str.charCodeAt(i6);
      if (i6 >= str.length || (c22 & 64512) !== 56320) {
        throw new Error("invalid utf-8 string");
      }
      const pair = 65536 + ((c5 & 1023) << 10) + (c22 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c5 >> 12 | 224);
      result.push(c5 >> 6 & 63 | 128);
      result.push(c5 & 63 | 128);
    }
  }
  return arrayify(result);
}
function escapeChar(value2) {
  const hex = "0000" + value2.toString(16);
  return "\\u" + hex.substring(hex.length - 4);
}
function _toEscapedUtf8String(bytes, onError) {
  return '"' + getUtf8CodePoints(bytes, onError).map((codePoint) => {
    if (codePoint < 256) {
      switch (codePoint) {
        case 8:
          return "\\b";
        case 9:
          return "\\t";
        case 10:
          return "\\n";
        case 13:
          return "\\r";
        case 34:
          return '\\"';
        case 92:
          return "\\\\";
      }
      if (codePoint >= 32 && codePoint < 127) {
        return String.fromCharCode(codePoint);
      }
    }
    if (codePoint <= 65535) {
      return escapeChar(codePoint);
    }
    codePoint -= 65536;
    return escapeChar((codePoint >> 10 & 1023) + 55296) + escapeChar((codePoint & 1023) + 56320);
  }).join("") + '"';
}
function _toUtf8String(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
}
function toUtf8String(bytes, onError) {
  return _toUtf8String(getUtf8CodePoints(bytes, onError));
}
function toUtf8CodePoints(str, form = UnicodeNormalizationForm.current) {
  return getUtf8CodePoints(toUtf8Bytes(str, form));
}
var logger10, UnicodeNormalizationForm, Utf8ErrorReason, Utf8ErrorFuncs;
var init_utf8 = __esm({
  "node_modules/@ethersproject/strings/lib.esm/utf8.js"() {
    "use strict";
    init_lib2();
    init_lib();
    init_version8();
    logger10 = new Logger(version8);
    (function(UnicodeNormalizationForm2) {
      UnicodeNormalizationForm2["current"] = "";
      UnicodeNormalizationForm2["NFC"] = "NFC";
      UnicodeNormalizationForm2["NFD"] = "NFD";
      UnicodeNormalizationForm2["NFKC"] = "NFKC";
      UnicodeNormalizationForm2["NFKD"] = "NFKD";
    })(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
    (function(Utf8ErrorReason2) {
      Utf8ErrorReason2["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
      Utf8ErrorReason2["BAD_PREFIX"] = "bad codepoint prefix";
      Utf8ErrorReason2["OVERRUN"] = "string overrun";
      Utf8ErrorReason2["MISSING_CONTINUE"] = "missing continuation byte";
      Utf8ErrorReason2["OUT_OF_RANGE"] = "out of UTF-8 range";
      Utf8ErrorReason2["UTF16_SURROGATE"] = "UTF-16 surrogate";
      Utf8ErrorReason2["OVERLONG"] = "overlong representation";
    })(Utf8ErrorReason || (Utf8ErrorReason = {}));
    Utf8ErrorFuncs = Object.freeze({
      error: errorFunc,
      ignore: ignoreFunc,
      replace: replaceFunc
    });
  }
});

// node_modules/@ethersproject/strings/lib.esm/bytes32.js
function formatBytes32String(text) {
  const bytes = toUtf8Bytes(text);
  if (bytes.length > 31) {
    throw new Error("bytes32 string must be less than 32 bytes");
  }
  return hexlify(concat([bytes, HashZero]).slice(0, 32));
}
function parseBytes32String(bytes) {
  const data = arrayify(bytes);
  if (data.length !== 32) {
    throw new Error("invalid bytes32 - not 32 bytes long");
  }
  if (data[31] !== 0) {
    throw new Error("invalid bytes32 string - no null terminator");
  }
  let length = 31;
  while (data[length - 1] === 0) {
    length--;
  }
  return toUtf8String(data.slice(0, length));
}
var init_bytes32 = __esm({
  "node_modules/@ethersproject/strings/lib.esm/bytes32.js"() {
    "use strict";
    init_lib8();
    init_lib2();
    init_utf8();
  }
});

// node_modules/@ethersproject/strings/lib.esm/idna.js
function bytes2(data) {
  if (data.length % 4 !== 0) {
    throw new Error("bad data");
  }
  let result = [];
  for (let i6 = 0; i6 < data.length; i6 += 4) {
    result.push(parseInt(data.substring(i6, i6 + 4), 16));
  }
  return result;
}
function createTable(data, func) {
  if (!func) {
    func = function(value2) {
      return [parseInt(value2, 16)];
    };
  }
  let lo = 0;
  let result = {};
  data.split(",").forEach((pair) => {
    let comps = pair.split(":");
    lo += parseInt(comps[0], 16);
    result[lo] = func(comps[1]);
  });
  return result;
}
function createRangeTable(data) {
  let hi2 = 0;
  return data.split(",").map((v9) => {
    let comps = v9.split("-");
    if (comps.length === 1) {
      comps[1] = "0";
    } else if (comps[1] === "") {
      comps[1] = "1";
    }
    let lo = hi2 + parseInt(comps[0], 16);
    hi2 = parseInt(comps[1], 16);
    return { l: lo, h: hi2 };
  });
}
function matchMap(value2, ranges) {
  let lo = 0;
  for (let i6 = 0; i6 < ranges.length; i6++) {
    let range2 = ranges[i6];
    lo += range2.l;
    if (value2 >= lo && value2 <= lo + range2.h && (value2 - lo) % (range2.d || 1) === 0) {
      if (range2.e && range2.e.indexOf(value2 - lo) !== -1) {
        continue;
      }
      return range2;
    }
  }
  return null;
}
function flatten(values) {
  return values.reduce((accum, value2) => {
    value2.forEach((value3) => {
      accum.push(value3);
    });
    return accum;
  }, []);
}
function _nameprepTableA1(codepoint) {
  return !!matchMap(codepoint, Table_A_1_ranges);
}
function _nameprepTableB2(codepoint) {
  let range2 = matchMap(codepoint, Table_B_2_ranges);
  if (range2) {
    return [codepoint + range2.s];
  }
  let codes = Table_B_2_lut_abs[codepoint];
  if (codes) {
    return codes;
  }
  let shift = Table_B_2_lut_rel[codepoint];
  if (shift) {
    return [codepoint + shift[0]];
  }
  let complex = Table_B_2_complex[codepoint];
  if (complex) {
    return complex;
  }
  return null;
}
function _nameprepTableC(codepoint) {
  return !!matchMap(codepoint, Table_C_ranges);
}
function nameprep(value2) {
  if (value2.match(/^[a-z0-9-]*$/i) && value2.length <= 59) {
    return value2.toLowerCase();
  }
  let codes = toUtf8CodePoints(value2);
  codes = flatten(codes.map((code) => {
    if (Table_B_1_flags.indexOf(code) >= 0) {
      return [];
    }
    if (code >= 65024 && code <= 65039) {
      return [];
    }
    let codesTableB2 = _nameprepTableB2(code);
    if (codesTableB2) {
      return codesTableB2;
    }
    return [code];
  }));
  codes = toUtf8CodePoints(_toUtf8String(codes), UnicodeNormalizationForm.NFKC);
  codes.forEach((code) => {
    if (_nameprepTableC(code)) {
      throw new Error("STRINGPREP_CONTAINS_PROHIBITED");
    }
  });
  codes.forEach((code) => {
    if (_nameprepTableA1(code)) {
      throw new Error("STRINGPREP_CONTAINS_UNASSIGNED");
    }
  });
  let name2 = _toUtf8String(codes);
  if (name2.substring(0, 1) === "-" || name2.substring(2, 4) === "--" || name2.substring(name2.length - 1) === "-") {
    throw new Error("invalid hyphen");
  }
  if (name2.length > 63) {
    throw new Error("too long");
  }
  return name2;
}
var Table_A_1_ranges, Table_B_1_flags, Table_B_2_ranges, Table_B_2_lut_abs, Table_B_2_lut_rel, Table_B_2_complex, Table_C_ranges;
var init_idna = __esm({
  "node_modules/@ethersproject/strings/lib.esm/idna.js"() {
    "use strict";
    init_utf8();
    Table_A_1_ranges = createRangeTable("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
    Table_B_1_flags = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((v9) => parseInt(v9, 16));
    Table_B_2_ranges = [
      { h: 25, s: 32, l: 65 },
      { h: 30, s: 32, e: [23], l: 127 },
      { h: 54, s: 1, e: [48], l: 64, d: 2 },
      { h: 14, s: 1, l: 57, d: 2 },
      { h: 44, s: 1, l: 17, d: 2 },
      { h: 10, s: 1, e: [2, 6, 8], l: 61, d: 2 },
      { h: 16, s: 1, l: 68, d: 2 },
      { h: 84, s: 1, e: [18, 24, 66], l: 19, d: 2 },
      { h: 26, s: 32, e: [17], l: 435 },
      { h: 22, s: 1, l: 71, d: 2 },
      { h: 15, s: 80, l: 40 },
      { h: 31, s: 32, l: 16 },
      { h: 32, s: 1, l: 80, d: 2 },
      { h: 52, s: 1, l: 42, d: 2 },
      { h: 12, s: 1, l: 55, d: 2 },
      { h: 40, s: 1, e: [38], l: 15, d: 2 },
      { h: 14, s: 1, l: 48, d: 2 },
      { h: 37, s: 48, l: 49 },
      { h: 148, s: 1, l: 6351, d: 2 },
      { h: 88, s: 1, l: 160, d: 2 },
      { h: 15, s: 16, l: 704 },
      { h: 25, s: 26, l: 854 },
      { h: 25, s: 32, l: 55915 },
      { h: 37, s: 40, l: 1247 },
      { h: 25, s: -119711, l: 53248 },
      { h: 25, s: -119763, l: 52 },
      { h: 25, s: -119815, l: 52 },
      { h: 25, s: -119867, e: [1, 4, 5, 7, 8, 11, 12, 17], l: 52 },
      { h: 25, s: -119919, l: 52 },
      { h: 24, s: -119971, e: [2, 7, 8, 17], l: 52 },
      { h: 24, s: -120023, e: [2, 7, 13, 15, 16, 17], l: 52 },
      { h: 25, s: -120075, l: 52 },
      { h: 25, s: -120127, l: 52 },
      { h: 25, s: -120179, l: 52 },
      { h: 25, s: -120231, l: 52 },
      { h: 25, s: -120283, l: 52 },
      { h: 25, s: -120335, l: 52 },
      { h: 24, s: -119543, e: [17], l: 56 },
      { h: 24, s: -119601, e: [17], l: 58 },
      { h: 24, s: -119659, e: [17], l: 58 },
      { h: 24, s: -119717, e: [17], l: 58 },
      { h: 24, s: -119775, e: [17], l: 58 }
    ];
    Table_B_2_lut_abs = createTable("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
    Table_B_2_lut_rel = createTable("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
    Table_B_2_complex = createTable("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes2);
    Table_C_ranges = createRangeTable("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");
  }
});

// node_modules/@ethersproject/strings/lib.esm/index.js
var lib_exports8 = {};
__export(lib_exports8, {
  UnicodeNormalizationForm: () => UnicodeNormalizationForm,
  Utf8ErrorFuncs: () => Utf8ErrorFuncs,
  Utf8ErrorReason: () => Utf8ErrorReason,
  _toEscapedUtf8String: () => _toEscapedUtf8String,
  formatBytes32String: () => formatBytes32String,
  nameprep: () => nameprep,
  parseBytes32String: () => parseBytes32String,
  toUtf8Bytes: () => toUtf8Bytes,
  toUtf8CodePoints: () => toUtf8CodePoints,
  toUtf8String: () => toUtf8String
});
var init_lib9 = __esm({
  "node_modules/@ethersproject/strings/lib.esm/index.js"() {
    "use strict";
    init_bytes32();
    init_idna();
    init_utf8();
  }
});

// node_modules/@ethersproject/abi/lib.esm/coders/string.js
var StringCoder;
var init_string = __esm({
  "node_modules/@ethersproject/abi/lib.esm/coders/string.js"() {
    "use strict";
    init_lib9();
    init_bytes();
    StringCoder = class extends DynamicBytesCoder {
      constructor(localName) {
        super("string", localName);
      }
      defaultValue() {
        return "";
      }
      encode(writer, value2) {
        return super.encode(writer, toUtf8Bytes(value2));
      }
      decode(reader) {
        return toUtf8String(super.decode(reader));
      }
    };
  }
});

// node_modules/@ethersproject/abi/lib.esm/coders/tuple.js
var TupleCoder;
var init_tuple = __esm({
  "node_modules/@ethersproject/abi/lib.esm/coders/tuple.js"() {
    "use strict";
    init_abstract_coder();
    init_array();
    TupleCoder = class extends Coder {
      constructor(coders, localName) {
        let dynamic = false;
        const types = [];
        coders.forEach((coder) => {
          if (coder.dynamic) {
            dynamic = true;
          }
          types.push(coder.type);
        });
        const type = "tuple(" + types.join(",") + ")";
        super("tuple", type, localName, dynamic);
        this.coders = coders;
      }
      defaultValue() {
        const values = [];
        this.coders.forEach((coder) => {
          values.push(coder.defaultValue());
        });
        const uniqueNames = this.coders.reduce((accum, coder) => {
          const name2 = coder.localName;
          if (name2) {
            if (!accum[name2]) {
              accum[name2] = 0;
            }
            accum[name2]++;
          }
          return accum;
        }, {});
        this.coders.forEach((coder, index) => {
          let name2 = coder.localName;
          if (!name2 || uniqueNames[name2] !== 1) {
            return;
          }
          if (name2 === "length") {
            name2 = "_length";
          }
          if (values[name2] != null) {
            return;
          }
          values[name2] = values[index];
        });
        return Object.freeze(values);
      }
      encode(writer, value2) {
        return pack(writer, this.coders, value2);
      }
      decode(reader) {
        return reader.coerce(this.name, unpack(reader, this.coders));
      }
    };
  }
});

// node_modules/@ethersproject/abi/lib.esm/abi-coder.js
var logger11, paramTypeBytes, paramTypeNumber, AbiCoder, defaultAbiCoder;
var init_abi_coder = __esm({
  "node_modules/@ethersproject/abi/lib.esm/abi-coder.js"() {
    "use strict";
    init_lib2();
    init_lib4();
    init_lib();
    init_version5();
    init_abstract_coder();
    init_address();
    init_array();
    init_boolean();
    init_bytes();
    init_fixed_bytes();
    init_null();
    init_number();
    init_string();
    init_tuple();
    init_fragments();
    logger11 = new Logger(version5);
    paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
    paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
    AbiCoder = class {
      constructor(coerceFunc) {
        logger11.checkNew(new.target, AbiCoder);
        defineReadOnly(this, "coerceFunc", coerceFunc || null);
      }
      _getCoder(param) {
        switch (param.baseType) {
          case "address":
            return new AddressCoder(param.name);
          case "bool":
            return new BooleanCoder(param.name);
          case "string":
            return new StringCoder(param.name);
          case "bytes":
            return new BytesCoder(param.name);
          case "array":
            return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);
          case "tuple":
            return new TupleCoder((param.components || []).map((component) => {
              return this._getCoder(component);
            }), param.name);
          case "":
            return new NullCoder(param.name);
        }
        let match = param.type.match(paramTypeNumber);
        if (match) {
          let size = parseInt(match[2] || "256");
          if (size === 0 || size > 256 || size % 8 !== 0) {
            logger11.throwArgumentError("invalid " + match[1] + " bit length", "param", param);
          }
          return new NumberCoder(size / 8, match[1] === "int", param.name);
        }
        match = param.type.match(paramTypeBytes);
        if (match) {
          let size = parseInt(match[1]);
          if (size === 0 || size > 32) {
            logger11.throwArgumentError("invalid bytes length", "param", param);
          }
          return new FixedBytesCoder(size, param.name);
        }
        return logger11.throwArgumentError("invalid type", "type", param.type);
      }
      _getWordSize() {
        return 32;
      }
      _getReader(data, allowLoose) {
        return new Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);
      }
      _getWriter() {
        return new Writer(this._getWordSize());
      }
      getDefaultValue(types) {
        const coders = types.map((type) => this._getCoder(ParamType.from(type)));
        const coder = new TupleCoder(coders, "_");
        return coder.defaultValue();
      }
      encode(types, values) {
        if (types.length !== values.length) {
          logger11.throwError("types/values length mismatch", Logger.errors.INVALID_ARGUMENT, {
            count: { types: types.length, values: values.length },
            value: { types, values }
          });
        }
        const coders = types.map((type) => this._getCoder(ParamType.from(type)));
        const coder = new TupleCoder(coders, "_");
        const writer = this._getWriter();
        coder.encode(writer, values);
        return writer.data;
      }
      decode(types, data, loose) {
        const coders = types.map((type) => this._getCoder(ParamType.from(type)));
        const coder = new TupleCoder(coders, "_");
        return coder.decode(this._getReader(arrayify(data), loose));
      }
    };
    defaultAbiCoder = new AbiCoder();
  }
});

// node_modules/@ethersproject/hash/lib.esm/id.js
function id(text) {
  return keccak256(toUtf8Bytes(text));
}
var init_id = __esm({
  "node_modules/@ethersproject/hash/lib.esm/id.js"() {
    init_lib5();
    init_lib9();
  }
});

// node_modules/@ethersproject/hash/lib.esm/_version.js
var version9;
var init_version9 = __esm({
  "node_modules/@ethersproject/hash/lib.esm/_version.js"() {
    version9 = "hash/5.6.0";
  }
});

// node_modules/@ethersproject/hash/lib.esm/namehash.js
function isValidName(name2) {
  try {
    const comps = name2.split(".");
    for (let i6 = 0; i6 < comps.length; i6++) {
      if (nameprep(comps[i6]).length === 0) {
        throw new Error("empty");
      }
    }
    return true;
  } catch (error) {
  }
  return false;
}
function namehash(name2) {
  if (typeof name2 !== "string") {
    logger12.throwArgumentError("invalid ENS name; not a string", "name", name2);
  }
  let current = name2;
  let result = Zeros;
  while (current.length) {
    const partition3 = current.match(Partition);
    if (partition3 == null || partition3[2] === "") {
      logger12.throwArgumentError("invalid ENS address; missing component", "name", name2);
    }
    const label = toUtf8Bytes(nameprep(partition3[3]));
    result = keccak256(concat([result, keccak256(label)]));
    current = partition3[2] || "";
  }
  return hexlify(result);
}
function dnsEncode(name2) {
  return hexlify(concat(name2.split(".").map((comp) => {
    const bytes = toUtf8Bytes("_" + nameprep(comp));
    bytes[0] = bytes.length - 1;
    return bytes;
  }))) + "00";
}
var logger12, Zeros, Partition;
var init_namehash = __esm({
  "node_modules/@ethersproject/hash/lib.esm/namehash.js"() {
    init_lib2();
    init_lib9();
    init_lib5();
    init_lib();
    init_version9();
    logger12 = new Logger(version9);
    Zeros = new Uint8Array(32);
    Zeros.fill(0);
    Partition = new RegExp("^((.*)\\.)?([^.]+)$");
  }
});

// node_modules/@ethersproject/hash/lib.esm/message.js
function hashMessage(message) {
  if (typeof message === "string") {
    message = toUtf8Bytes(message);
  }
  return keccak256(concat([
    toUtf8Bytes(messagePrefix),
    toUtf8Bytes(String(message.length)),
    message
  ]));
}
var messagePrefix;
var init_message = __esm({
  "node_modules/@ethersproject/hash/lib.esm/message.js"() {
    init_lib2();
    init_lib5();
    init_lib9();
    messagePrefix = "Ethereum Signed Message:\n";
  }
});

// node_modules/@ethersproject/hash/lib.esm/typed-data.js
function hexPadRight(value2) {
  const bytes = arrayify(value2);
  const padOffset = bytes.length % 32;
  if (padOffset) {
    return hexConcat([bytes, padding.slice(padOffset)]);
  }
  return hexlify(bytes);
}
function checkString(key2) {
  return function(value2) {
    if (typeof value2 !== "string") {
      logger13.throwArgumentError(`invalid domain value for ${JSON.stringify(key2)}`, `domain.${key2}`, value2);
    }
    return value2;
  };
}
function getBaseEncoder(type) {
  {
    const match = type.match(/^(u?)int(\d*)$/);
    if (match) {
      const signed = match[1] === "";
      const width = parseInt(match[2] || "256");
      if (width % 8 !== 0 || width > 256 || match[2] && match[2] !== String(width)) {
        logger13.throwArgumentError("invalid numeric width", "type", type);
      }
      const boundsUpper = MaxUint2562.mask(signed ? width - 1 : width);
      const boundsLower = signed ? boundsUpper.add(One2).mul(NegativeOne3) : Zero3;
      return function(value2) {
        const v9 = BigNumber.from(value2);
        if (v9.lt(boundsLower) || v9.gt(boundsUpper)) {
          logger13.throwArgumentError(`value out-of-bounds for ${type}`, "value", value2);
        }
        return hexZeroPad(v9.toTwos(256).toHexString(), 32);
      };
    }
  }
  {
    const match = type.match(/^bytes(\d+)$/);
    if (match) {
      const width = parseInt(match[1]);
      if (width === 0 || width > 32 || match[1] !== String(width)) {
        logger13.throwArgumentError("invalid bytes width", "type", type);
      }
      return function(value2) {
        const bytes = arrayify(value2);
        if (bytes.length !== width) {
          logger13.throwArgumentError(`invalid length for ${type}`, "value", value2);
        }
        return hexPadRight(value2);
      };
    }
  }
  switch (type) {
    case "address":
      return function(value2) {
        return hexZeroPad(getAddress(value2), 32);
      };
    case "bool":
      return function(value2) {
        return !value2 ? hexFalse : hexTrue;
      };
    case "bytes":
      return function(value2) {
        return keccak256(value2);
      };
    case "string":
      return function(value2) {
        return id(value2);
      };
  }
  return null;
}
function encodeType(name2, fields) {
  return `${name2}(${fields.map(({ name: name3, type }) => type + " " + name3).join(",")})`;
}
var __awaiter2, logger13, padding, NegativeOne3, Zero3, One2, MaxUint2562, hexTrue, hexFalse, domainFieldTypes, domainFieldNames, domainChecks, TypedDataEncoder;
var init_typed_data = __esm({
  "node_modules/@ethersproject/hash/lib.esm/typed-data.js"() {
    init_lib7();
    init_lib3();
    init_lib2();
    init_lib5();
    init_lib4();
    init_lib();
    init_version9();
    init_id();
    __awaiter2 = function(thisArg, _arguments, P5, generator) {
      function adopt(value2) {
        return value2 instanceof P5 ? value2 : new P5(function(resolve) {
          resolve(value2);
        });
      }
      return new (P5 || (P5 = Promise))(function(resolve, reject) {
        function fulfilled(value2) {
          try {
            step(generator.next(value2));
          } catch (e6) {
            reject(e6);
          }
        }
        function rejected(value2) {
          try {
            step(generator["throw"](value2));
          } catch (e6) {
            reject(e6);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger13 = new Logger(version9);
    padding = new Uint8Array(32);
    padding.fill(0);
    NegativeOne3 = BigNumber.from(-1);
    Zero3 = BigNumber.from(0);
    One2 = BigNumber.from(1);
    MaxUint2562 = BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    hexTrue = hexZeroPad(One2.toHexString(), 32);
    hexFalse = hexZeroPad(Zero3.toHexString(), 32);
    domainFieldTypes = {
      name: "string",
      version: "string",
      chainId: "uint256",
      verifyingContract: "address",
      salt: "bytes32"
    };
    domainFieldNames = [
      "name",
      "version",
      "chainId",
      "verifyingContract",
      "salt"
    ];
    domainChecks = {
      name: checkString("name"),
      version: checkString("version"),
      chainId: function(value2) {
        try {
          return BigNumber.from(value2).toString();
        } catch (error) {
        }
        return logger13.throwArgumentError(`invalid domain value for "chainId"`, "domain.chainId", value2);
      },
      verifyingContract: function(value2) {
        try {
          return getAddress(value2).toLowerCase();
        } catch (error) {
        }
        return logger13.throwArgumentError(`invalid domain value "verifyingContract"`, "domain.verifyingContract", value2);
      },
      salt: function(value2) {
        try {
          const bytes = arrayify(value2);
          if (bytes.length !== 32) {
            throw new Error("bad length");
          }
          return hexlify(bytes);
        } catch (error) {
        }
        return logger13.throwArgumentError(`invalid domain value "salt"`, "domain.salt", value2);
      }
    };
    TypedDataEncoder = class {
      constructor(types) {
        defineReadOnly(this, "types", Object.freeze(deepCopy(types)));
        defineReadOnly(this, "_encoderCache", {});
        defineReadOnly(this, "_types", {});
        const links = {};
        const parents = {};
        const subtypes = {};
        Object.keys(types).forEach((type) => {
          links[type] = {};
          parents[type] = [];
          subtypes[type] = {};
        });
        for (const name2 in types) {
          const uniqueNames = {};
          types[name2].forEach((field) => {
            if (uniqueNames[field.name]) {
              logger13.throwArgumentError(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name2)}`, "types", types);
            }
            uniqueNames[field.name] = true;
            const baseType = field.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
            if (baseType === name2) {
              logger13.throwArgumentError(`circular type reference to ${JSON.stringify(baseType)}`, "types", types);
            }
            const encoder = getBaseEncoder(baseType);
            if (encoder) {
              return;
            }
            if (!parents[baseType]) {
              logger13.throwArgumentError(`unknown type ${JSON.stringify(baseType)}`, "types", types);
            }
            parents[baseType].push(name2);
            links[name2][baseType] = true;
          });
        }
        const primaryTypes = Object.keys(parents).filter((n4) => parents[n4].length === 0);
        if (primaryTypes.length === 0) {
          logger13.throwArgumentError("missing primary type", "types", types);
        } else if (primaryTypes.length > 1) {
          logger13.throwArgumentError(`ambiguous primary types or unused types: ${primaryTypes.map((t6) => JSON.stringify(t6)).join(", ")}`, "types", types);
        }
        defineReadOnly(this, "primaryType", primaryTypes[0]);
        function checkCircular(type, found) {
          if (found[type]) {
            logger13.throwArgumentError(`circular type reference to ${JSON.stringify(type)}`, "types", types);
          }
          found[type] = true;
          Object.keys(links[type]).forEach((child) => {
            if (!parents[child]) {
              return;
            }
            checkCircular(child, found);
            Object.keys(found).forEach((subtype) => {
              subtypes[subtype][child] = true;
            });
          });
          delete found[type];
        }
        checkCircular(this.primaryType, {});
        for (const name2 in subtypes) {
          const st2 = Object.keys(subtypes[name2]);
          st2.sort();
          this._types[name2] = encodeType(name2, types[name2]) + st2.map((t6) => encodeType(t6, types[t6])).join("");
        }
      }
      getEncoder(type) {
        let encoder = this._encoderCache[type];
        if (!encoder) {
          encoder = this._encoderCache[type] = this._getEncoder(type);
        }
        return encoder;
      }
      _getEncoder(type) {
        {
          const encoder = getBaseEncoder(type);
          if (encoder) {
            return encoder;
          }
        }
        const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
        if (match) {
          const subtype = match[1];
          const subEncoder = this.getEncoder(subtype);
          const length = parseInt(match[3]);
          return (value2) => {
            if (length >= 0 && value2.length !== length) {
              logger13.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value2);
            }
            let result = value2.map(subEncoder);
            if (this._types[subtype]) {
              result = result.map(keccak256);
            }
            return keccak256(hexConcat(result));
          };
        }
        const fields = this.types[type];
        if (fields) {
          const encodedType = id(this._types[type]);
          return (value2) => {
            const values = fields.map(({ name: name2, type: type2 }) => {
              const result = this.getEncoder(type2)(value2[name2]);
              if (this._types[type2]) {
                return keccak256(result);
              }
              return result;
            });
            values.unshift(encodedType);
            return hexConcat(values);
          };
        }
        return logger13.throwArgumentError(`unknown type: ${type}`, "type", type);
      }
      encodeType(name2) {
        const result = this._types[name2];
        if (!result) {
          logger13.throwArgumentError(`unknown type: ${JSON.stringify(name2)}`, "name", name2);
        }
        return result;
      }
      encodeData(type, value2) {
        return this.getEncoder(type)(value2);
      }
      hashStruct(name2, value2) {
        return keccak256(this.encodeData(name2, value2));
      }
      encode(value2) {
        return this.encodeData(this.primaryType, value2);
      }
      hash(value2) {
        return this.hashStruct(this.primaryType, value2);
      }
      _visit(type, value2, callback) {
        {
          const encoder = getBaseEncoder(type);
          if (encoder) {
            return callback(type, value2);
          }
        }
        const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
        if (match) {
          const subtype = match[1];
          const length = parseInt(match[3]);
          if (length >= 0 && value2.length !== length) {
            logger13.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value2);
          }
          return value2.map((v9) => this._visit(subtype, v9, callback));
        }
        const fields = this.types[type];
        if (fields) {
          return fields.reduce((accum, { name: name2, type: type2 }) => {
            accum[name2] = this._visit(type2, value2[name2], callback);
            return accum;
          }, {});
        }
        return logger13.throwArgumentError(`unknown type: ${type}`, "type", type);
      }
      visit(value2, callback) {
        return this._visit(this.primaryType, value2, callback);
      }
      static from(types) {
        return new TypedDataEncoder(types);
      }
      static getPrimaryType(types) {
        return TypedDataEncoder.from(types).primaryType;
      }
      static hashStruct(name2, types, value2) {
        return TypedDataEncoder.from(types).hashStruct(name2, value2);
      }
      static hashDomain(domain2) {
        const domainFields = [];
        for (const name2 in domain2) {
          const type = domainFieldTypes[name2];
          if (!type) {
            logger13.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(name2)}`, "domain", domain2);
          }
          domainFields.push({ name: name2, type });
        }
        domainFields.sort((a5, b4) => {
          return domainFieldNames.indexOf(a5.name) - domainFieldNames.indexOf(b4.name);
        });
        return TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain2);
      }
      static encode(domain2, types, value2) {
        return hexConcat([
          "0x1901",
          TypedDataEncoder.hashDomain(domain2),
          TypedDataEncoder.from(types).hash(value2)
        ]);
      }
      static hash(domain2, types, value2) {
        return keccak256(TypedDataEncoder.encode(domain2, types, value2));
      }
      static resolveNames(domain2, types, value2, resolveName2) {
        return __awaiter2(this, void 0, void 0, function* () {
          domain2 = shallowCopy(domain2);
          const ensCache = {};
          if (domain2.verifyingContract && !isHexString(domain2.verifyingContract, 20)) {
            ensCache[domain2.verifyingContract] = "0x";
          }
          const encoder = TypedDataEncoder.from(types);
          encoder.visit(value2, (type, value3) => {
            if (type === "address" && !isHexString(value3, 20)) {
              ensCache[value3] = "0x";
            }
            return value3;
          });
          for (const name2 in ensCache) {
            ensCache[name2] = yield resolveName2(name2);
          }
          if (domain2.verifyingContract && ensCache[domain2.verifyingContract]) {
            domain2.verifyingContract = ensCache[domain2.verifyingContract];
          }
          value2 = encoder.visit(value2, (type, value3) => {
            if (type === "address" && ensCache[value3]) {
              return ensCache[value3];
            }
            return value3;
          });
          return { domain: domain2, value: value2 };
        });
      }
      static getPayload(domain2, types, value2) {
        TypedDataEncoder.hashDomain(domain2);
        const domainValues = {};
        const domainTypes = [];
        domainFieldNames.forEach((name2) => {
          const value3 = domain2[name2];
          if (value3 == null) {
            return;
          }
          domainValues[name2] = domainChecks[name2](value3);
          domainTypes.push({ name: name2, type: domainFieldTypes[name2] });
        });
        const encoder = TypedDataEncoder.from(types);
        const typesWithDomain = shallowCopy(types);
        if (typesWithDomain.EIP712Domain) {
          logger13.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", types);
        } else {
          typesWithDomain.EIP712Domain = domainTypes;
        }
        encoder.encode(value2);
        return {
          types: typesWithDomain,
          domain: domainValues,
          primaryType: encoder.primaryType,
          message: encoder.visit(value2, (type, value3) => {
            if (type.match(/^bytes(\d*)/)) {
              return hexlify(arrayify(value3));
            }
            if (type.match(/^u?int/)) {
              return BigNumber.from(value3).toString();
            }
            switch (type) {
              case "address":
                return value3.toLowerCase();
              case "bool":
                return !!value3;
              case "string":
                if (typeof value3 !== "string") {
                  logger13.throwArgumentError(`invalid string`, "value", value3);
                }
                return value3;
            }
            return logger13.throwArgumentError("unsupported type", "type", type);
          })
        };
      }
    };
  }
});

// node_modules/@ethersproject/hash/lib.esm/index.js
var lib_exports9 = {};
__export(lib_exports9, {
  _TypedDataEncoder: () => TypedDataEncoder,
  dnsEncode: () => dnsEncode,
  hashMessage: () => hashMessage,
  id: () => id,
  isValidName: () => isValidName,
  messagePrefix: () => messagePrefix,
  namehash: () => namehash
});
var init_lib10 = __esm({
  "node_modules/@ethersproject/hash/lib.esm/index.js"() {
    "use strict";
    init_id();
    init_namehash();
    init_message();
    init_typed_data();
  }
});

// node_modules/@ethersproject/abi/lib.esm/interface.js
function wrapAccessError(property, error) {
  const wrap = new Error(`deferred error during ABI decoding triggered accessing ${property}`);
  wrap.error = error;
  return wrap;
}
var logger14, LogDescription, TransactionDescription, ErrorDescription, Indexed, BuiltinErrors, Interface;
var init_interface = __esm({
  "node_modules/@ethersproject/abi/lib.esm/interface.js"() {
    "use strict";
    init_lib7();
    init_lib3();
    init_lib2();
    init_lib10();
    init_lib5();
    init_lib4();
    init_abi_coder();
    init_abstract_coder();
    init_fragments();
    init_lib();
    init_version5();
    logger14 = new Logger(version5);
    LogDescription = class extends Description {
    };
    TransactionDescription = class extends Description {
    };
    ErrorDescription = class extends Description {
    };
    Indexed = class extends Description {
      static isIndexed(value2) {
        return !!(value2 && value2._isIndexed);
      }
    };
    BuiltinErrors = {
      "0x08c379a0": { signature: "Error(string)", name: "Error", inputs: ["string"], reason: true },
      "0x4e487b71": { signature: "Panic(uint256)", name: "Panic", inputs: ["uint256"] }
    };
    Interface = class {
      constructor(fragments) {
        logger14.checkNew(new.target, Interface);
        let abi = [];
        if (typeof fragments === "string") {
          abi = JSON.parse(fragments);
        } else {
          abi = fragments;
        }
        defineReadOnly(this, "fragments", abi.map((fragment) => {
          return Fragment.from(fragment);
        }).filter((fragment) => fragment != null));
        defineReadOnly(this, "_abiCoder", getStatic(new.target, "getAbiCoder")());
        defineReadOnly(this, "functions", {});
        defineReadOnly(this, "errors", {});
        defineReadOnly(this, "events", {});
        defineReadOnly(this, "structs", {});
        this.fragments.forEach((fragment) => {
          let bucket = null;
          switch (fragment.type) {
            case "constructor":
              if (this.deploy) {
                logger14.warn("duplicate definition - constructor");
                return;
              }
              defineReadOnly(this, "deploy", fragment);
              return;
            case "function":
              bucket = this.functions;
              break;
            case "event":
              bucket = this.events;
              break;
            case "error":
              bucket = this.errors;
              break;
            default:
              return;
          }
          let signature2 = fragment.format();
          if (bucket[signature2]) {
            logger14.warn("duplicate definition - " + signature2);
            return;
          }
          bucket[signature2] = fragment;
        });
        if (!this.deploy) {
          defineReadOnly(this, "deploy", ConstructorFragment.from({
            payable: false,
            type: "constructor"
          }));
        }
        defineReadOnly(this, "_isInterface", true);
      }
      format(format) {
        if (!format) {
          format = FormatTypes.full;
        }
        if (format === FormatTypes.sighash) {
          logger14.throwArgumentError("interface does not support formatting sighash", "format", format);
        }
        const abi = this.fragments.map((fragment) => fragment.format(format));
        if (format === FormatTypes.json) {
          return JSON.stringify(abi.map((j8) => JSON.parse(j8)));
        }
        return abi;
      }
      static getAbiCoder() {
        return defaultAbiCoder;
      }
      static getAddress(address) {
        return getAddress(address);
      }
      static getSighash(fragment) {
        return hexDataSlice(id(fragment.format()), 0, 4);
      }
      static getEventTopic(eventFragment) {
        return id(eventFragment.format());
      }
      getFunction(nameOrSignatureOrSighash) {
        if (isHexString(nameOrSignatureOrSighash)) {
          for (const name2 in this.functions) {
            if (nameOrSignatureOrSighash === this.getSighash(name2)) {
              return this.functions[name2];
            }
          }
          logger14.throwArgumentError("no matching function", "sighash", nameOrSignatureOrSighash);
        }
        if (nameOrSignatureOrSighash.indexOf("(") === -1) {
          const name2 = nameOrSignatureOrSighash.trim();
          const matching = Object.keys(this.functions).filter((f7) => f7.split("(")[0] === name2);
          if (matching.length === 0) {
            logger14.throwArgumentError("no matching function", "name", name2);
          } else if (matching.length > 1) {
            logger14.throwArgumentError("multiple matching functions", "name", name2);
          }
          return this.functions[matching[0]];
        }
        const result = this.functions[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
        if (!result) {
          logger14.throwArgumentError("no matching function", "signature", nameOrSignatureOrSighash);
        }
        return result;
      }
      getEvent(nameOrSignatureOrTopic) {
        if (isHexString(nameOrSignatureOrTopic)) {
          const topichash = nameOrSignatureOrTopic.toLowerCase();
          for (const name2 in this.events) {
            if (topichash === this.getEventTopic(name2)) {
              return this.events[name2];
            }
          }
          logger14.throwArgumentError("no matching event", "topichash", topichash);
        }
        if (nameOrSignatureOrTopic.indexOf("(") === -1) {
          const name2 = nameOrSignatureOrTopic.trim();
          const matching = Object.keys(this.events).filter((f7) => f7.split("(")[0] === name2);
          if (matching.length === 0) {
            logger14.throwArgumentError("no matching event", "name", name2);
          } else if (matching.length > 1) {
            logger14.throwArgumentError("multiple matching events", "name", name2);
          }
          return this.events[matching[0]];
        }
        const result = this.events[EventFragment.fromString(nameOrSignatureOrTopic).format()];
        if (!result) {
          logger14.throwArgumentError("no matching event", "signature", nameOrSignatureOrTopic);
        }
        return result;
      }
      getError(nameOrSignatureOrSighash) {
        if (isHexString(nameOrSignatureOrSighash)) {
          const getSighash = getStatic(this.constructor, "getSighash");
          for (const name2 in this.errors) {
            const error = this.errors[name2];
            if (nameOrSignatureOrSighash === getSighash(error)) {
              return this.errors[name2];
            }
          }
          logger14.throwArgumentError("no matching error", "sighash", nameOrSignatureOrSighash);
        }
        if (nameOrSignatureOrSighash.indexOf("(") === -1) {
          const name2 = nameOrSignatureOrSighash.trim();
          const matching = Object.keys(this.errors).filter((f7) => f7.split("(")[0] === name2);
          if (matching.length === 0) {
            logger14.throwArgumentError("no matching error", "name", name2);
          } else if (matching.length > 1) {
            logger14.throwArgumentError("multiple matching errors", "name", name2);
          }
          return this.errors[matching[0]];
        }
        const result = this.errors[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
        if (!result) {
          logger14.throwArgumentError("no matching error", "signature", nameOrSignatureOrSighash);
        }
        return result;
      }
      getSighash(fragment) {
        if (typeof fragment === "string") {
          try {
            fragment = this.getFunction(fragment);
          } catch (error) {
            try {
              fragment = this.getError(fragment);
            } catch (_8) {
              throw error;
            }
          }
        }
        return getStatic(this.constructor, "getSighash")(fragment);
      }
      getEventTopic(eventFragment) {
        if (typeof eventFragment === "string") {
          eventFragment = this.getEvent(eventFragment);
        }
        return getStatic(this.constructor, "getEventTopic")(eventFragment);
      }
      _decodeParams(params, data) {
        return this._abiCoder.decode(params, data);
      }
      _encodeParams(params, values) {
        return this._abiCoder.encode(params, values);
      }
      encodeDeploy(values) {
        return this._encodeParams(this.deploy.inputs, values || []);
      }
      decodeErrorResult(fragment, data) {
        if (typeof fragment === "string") {
          fragment = this.getError(fragment);
        }
        const bytes = arrayify(data);
        if (hexlify(bytes.slice(0, 4)) !== this.getSighash(fragment)) {
          logger14.throwArgumentError(`data signature does not match error ${fragment.name}.`, "data", hexlify(bytes));
        }
        return this._decodeParams(fragment.inputs, bytes.slice(4));
      }
      encodeErrorResult(fragment, values) {
        if (typeof fragment === "string") {
          fragment = this.getError(fragment);
        }
        return hexlify(concat([
          this.getSighash(fragment),
          this._encodeParams(fragment.inputs, values || [])
        ]));
      }
      decodeFunctionData(functionFragment, data) {
        if (typeof functionFragment === "string") {
          functionFragment = this.getFunction(functionFragment);
        }
        const bytes = arrayify(data);
        if (hexlify(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {
          logger14.throwArgumentError(`data signature does not match function ${functionFragment.name}.`, "data", hexlify(bytes));
        }
        return this._decodeParams(functionFragment.inputs, bytes.slice(4));
      }
      encodeFunctionData(functionFragment, values) {
        if (typeof functionFragment === "string") {
          functionFragment = this.getFunction(functionFragment);
        }
        return hexlify(concat([
          this.getSighash(functionFragment),
          this._encodeParams(functionFragment.inputs, values || [])
        ]));
      }
      decodeFunctionResult(functionFragment, data) {
        if (typeof functionFragment === "string") {
          functionFragment = this.getFunction(functionFragment);
        }
        let bytes = arrayify(data);
        let reason = null;
        let errorArgs = null;
        let errorName = null;
        let errorSignature = null;
        switch (bytes.length % this._abiCoder._getWordSize()) {
          case 0:
            try {
              return this._abiCoder.decode(functionFragment.outputs, bytes);
            } catch (error) {
            }
            break;
          case 4: {
            const selector = hexlify(bytes.slice(0, 4));
            const builtin = BuiltinErrors[selector];
            if (builtin) {
              errorArgs = this._abiCoder.decode(builtin.inputs, bytes.slice(4));
              errorName = builtin.name;
              errorSignature = builtin.signature;
              if (builtin.reason) {
                reason = errorArgs[0];
              }
            } else {
              try {
                const error = this.getError(selector);
                errorArgs = this._abiCoder.decode(error.inputs, bytes.slice(4));
                errorName = error.name;
                errorSignature = error.format();
              } catch (error) {
              }
            }
            break;
          }
        }
        return logger14.throwError("call revert exception", Logger.errors.CALL_EXCEPTION, {
          method: functionFragment.format(),
          errorArgs,
          errorName,
          errorSignature,
          reason
        });
      }
      encodeFunctionResult(functionFragment, values) {
        if (typeof functionFragment === "string") {
          functionFragment = this.getFunction(functionFragment);
        }
        return hexlify(this._abiCoder.encode(functionFragment.outputs, values || []));
      }
      encodeFilterTopics(eventFragment, values) {
        if (typeof eventFragment === "string") {
          eventFragment = this.getEvent(eventFragment);
        }
        if (values.length > eventFragment.inputs.length) {
          logger14.throwError("too many arguments for " + eventFragment.format(), Logger.errors.UNEXPECTED_ARGUMENT, {
            argument: "values",
            value: values
          });
        }
        let topics = [];
        if (!eventFragment.anonymous) {
          topics.push(this.getEventTopic(eventFragment));
        }
        const encodeTopic = (param, value2) => {
          if (param.type === "string") {
            return id(value2);
          } else if (param.type === "bytes") {
            return keccak256(hexlify(value2));
          }
          if (param.type === "address") {
            this._abiCoder.encode(["address"], [value2]);
          }
          return hexZeroPad(hexlify(value2), 32);
        };
        values.forEach((value2, index) => {
          let param = eventFragment.inputs[index];
          if (!param.indexed) {
            if (value2 != null) {
              logger14.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + param.name, value2);
            }
            return;
          }
          if (value2 == null) {
            topics.push(null);
          } else if (param.baseType === "array" || param.baseType === "tuple") {
            logger14.throwArgumentError("filtering with tuples or arrays not supported", "contract." + param.name, value2);
          } else if (Array.isArray(value2)) {
            topics.push(value2.map((value3) => encodeTopic(param, value3)));
          } else {
            topics.push(encodeTopic(param, value2));
          }
        });
        while (topics.length && topics[topics.length - 1] === null) {
          topics.pop();
        }
        return topics;
      }
      encodeEventLog(eventFragment, values) {
        if (typeof eventFragment === "string") {
          eventFragment = this.getEvent(eventFragment);
        }
        const topics = [];
        const dataTypes = [];
        const dataValues = [];
        if (!eventFragment.anonymous) {
          topics.push(this.getEventTopic(eventFragment));
        }
        if (values.length !== eventFragment.inputs.length) {
          logger14.throwArgumentError("event arguments/values mismatch", "values", values);
        }
        eventFragment.inputs.forEach((param, index) => {
          const value2 = values[index];
          if (param.indexed) {
            if (param.type === "string") {
              topics.push(id(value2));
            } else if (param.type === "bytes") {
              topics.push(keccak256(value2));
            } else if (param.baseType === "tuple" || param.baseType === "array") {
              throw new Error("not implemented");
            } else {
              topics.push(this._abiCoder.encode([param.type], [value2]));
            }
          } else {
            dataTypes.push(param);
            dataValues.push(value2);
          }
        });
        return {
          data: this._abiCoder.encode(dataTypes, dataValues),
          topics
        };
      }
      decodeEventLog(eventFragment, data, topics) {
        if (typeof eventFragment === "string") {
          eventFragment = this.getEvent(eventFragment);
        }
        if (topics != null && !eventFragment.anonymous) {
          let topicHash = this.getEventTopic(eventFragment);
          if (!isHexString(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {
            logger14.throwError("fragment/topic mismatch", Logger.errors.INVALID_ARGUMENT, { argument: "topics[0]", expected: topicHash, value: topics[0] });
          }
          topics = topics.slice(1);
        }
        let indexed = [];
        let nonIndexed = [];
        let dynamic = [];
        eventFragment.inputs.forEach((param, index) => {
          if (param.indexed) {
            if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
              indexed.push(ParamType.fromObject({ type: "bytes32", name: param.name }));
              dynamic.push(true);
            } else {
              indexed.push(param);
              dynamic.push(false);
            }
          } else {
            nonIndexed.push(param);
            dynamic.push(false);
          }
        });
        let resultIndexed = topics != null ? this._abiCoder.decode(indexed, concat(topics)) : null;
        let resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);
        let result = [];
        let nonIndexedIndex = 0, indexedIndex = 0;
        eventFragment.inputs.forEach((param, index) => {
          if (param.indexed) {
            if (resultIndexed == null) {
              result[index] = new Indexed({ _isIndexed: true, hash: null });
            } else if (dynamic[index]) {
              result[index] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });
            } else {
              try {
                result[index] = resultIndexed[indexedIndex++];
              } catch (error) {
                result[index] = error;
              }
            }
          } else {
            try {
              result[index] = resultNonIndexed[nonIndexedIndex++];
            } catch (error) {
              result[index] = error;
            }
          }
          if (param.name && result[param.name] == null) {
            const value2 = result[index];
            if (value2 instanceof Error) {
              Object.defineProperty(result, param.name, {
                enumerable: true,
                get: () => {
                  throw wrapAccessError(`property ${JSON.stringify(param.name)}`, value2);
                }
              });
            } else {
              result[param.name] = value2;
            }
          }
        });
        for (let i6 = 0; i6 < result.length; i6++) {
          const value2 = result[i6];
          if (value2 instanceof Error) {
            Object.defineProperty(result, i6, {
              enumerable: true,
              get: () => {
                throw wrapAccessError(`index ${i6}`, value2);
              }
            });
          }
        }
        return Object.freeze(result);
      }
      parseTransaction(tx) {
        let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());
        if (!fragment) {
          return null;
        }
        return new TransactionDescription({
          args: this._abiCoder.decode(fragment.inputs, "0x" + tx.data.substring(10)),
          functionFragment: fragment,
          name: fragment.name,
          signature: fragment.format(),
          sighash: this.getSighash(fragment),
          value: BigNumber.from(tx.value || "0")
        });
      }
      parseLog(log) {
        let fragment = this.getEvent(log.topics[0]);
        if (!fragment || fragment.anonymous) {
          return null;
        }
        return new LogDescription({
          eventFragment: fragment,
          name: fragment.name,
          signature: fragment.format(),
          topic: this.getEventTopic(fragment),
          args: this.decodeEventLog(fragment, log.data, log.topics)
        });
      }
      parseError(data) {
        const hexData = hexlify(data);
        let fragment = this.getError(hexData.substring(0, 10).toLowerCase());
        if (!fragment) {
          return null;
        }
        return new ErrorDescription({
          args: this._abiCoder.decode(fragment.inputs, "0x" + hexData.substring(10)),
          errorFragment: fragment,
          name: fragment.name,
          signature: fragment.format(),
          sighash: this.getSighash(fragment)
        });
      }
      static isInterface(value2) {
        return !!(value2 && value2._isInterface);
      }
    };
  }
});

// node_modules/@ethersproject/abi/lib.esm/index.js
var lib_exports10 = {};
__export(lib_exports10, {
  AbiCoder: () => AbiCoder,
  ConstructorFragment: () => ConstructorFragment,
  ErrorFragment: () => ErrorFragment,
  EventFragment: () => EventFragment,
  FormatTypes: () => FormatTypes,
  Fragment: () => Fragment,
  FunctionFragment: () => FunctionFragment,
  Indexed: () => Indexed,
  Interface: () => Interface,
  LogDescription: () => LogDescription,
  ParamType: () => ParamType,
  TransactionDescription: () => TransactionDescription,
  checkResultErrors: () => checkResultErrors,
  defaultAbiCoder: () => defaultAbiCoder
});
var init_lib11 = __esm({
  "node_modules/@ethersproject/abi/lib.esm/index.js"() {
    "use strict";
    init_fragments();
    init_abi_coder();
    init_interface();
  }
});

// node_modules/@ethersproject/abstract-provider/lib.esm/_version.js
var version10;
var init_version10 = __esm({
  "node_modules/@ethersproject/abstract-provider/lib.esm/_version.js"() {
    version10 = "abstract-provider/5.6.0";
  }
});

// node_modules/@ethersproject/abstract-provider/lib.esm/index.js
var __awaiter3, logger15, ForkEvent, Provider;
var init_lib12 = __esm({
  "node_modules/@ethersproject/abstract-provider/lib.esm/index.js"() {
    "use strict";
    init_lib3();
    init_lib2();
    init_lib4();
    init_lib();
    init_version10();
    __awaiter3 = function(thisArg, _arguments, P5, generator) {
      function adopt(value2) {
        return value2 instanceof P5 ? value2 : new P5(function(resolve) {
          resolve(value2);
        });
      }
      return new (P5 || (P5 = Promise))(function(resolve, reject) {
        function fulfilled(value2) {
          try {
            step(generator.next(value2));
          } catch (e6) {
            reject(e6);
          }
        }
        function rejected(value2) {
          try {
            step(generator["throw"](value2));
          } catch (e6) {
            reject(e6);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger15 = new Logger(version10);
    ForkEvent = class extends Description {
      static isForkEvent(value2) {
        return !!(value2 && value2._isForkEvent);
      }
    };
    Provider = class {
      constructor() {
        logger15.checkAbstract(new.target, Provider);
        defineReadOnly(this, "_isProvider", true);
      }
      getFeeData() {
        return __awaiter3(this, void 0, void 0, function* () {
          const { block, gasPrice } = yield resolveProperties({
            block: this.getBlock("latest"),
            gasPrice: this.getGasPrice().catch((error) => {
              return null;
            })
          });
          let maxFeePerGas = null, maxPriorityFeePerGas = null;
          if (block && block.baseFeePerGas) {
            maxPriorityFeePerGas = BigNumber.from("1500000000");
            maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);
          }
          return { maxFeePerGas, maxPriorityFeePerGas, gasPrice };
        });
      }
      addListener(eventName, listener) {
        return this.on(eventName, listener);
      }
      removeListener(eventName, listener) {
        return this.off(eventName, listener);
      }
      static isProvider(value2) {
        return !!(value2 && value2._isProvider);
      }
    };
  }
});

// node_modules/@ethersproject/abstract-signer/lib.esm/_version.js
var version11;
var init_version11 = __esm({
  "node_modules/@ethersproject/abstract-signer/lib.esm/_version.js"() {
    version11 = "abstract-signer/5.6.0";
  }
});

// node_modules/@ethersproject/abstract-signer/lib.esm/index.js
var __awaiter4, logger16, allowedTransactionKeys, forwardErrors, Signer, VoidSigner;
var init_lib13 = __esm({
  "node_modules/@ethersproject/abstract-signer/lib.esm/index.js"() {
    "use strict";
    init_lib4();
    init_lib();
    init_version11();
    __awaiter4 = function(thisArg, _arguments, P5, generator) {
      function adopt(value2) {
        return value2 instanceof P5 ? value2 : new P5(function(resolve) {
          resolve(value2);
        });
      }
      return new (P5 || (P5 = Promise))(function(resolve, reject) {
        function fulfilled(value2) {
          try {
            step(generator.next(value2));
          } catch (e6) {
            reject(e6);
          }
        }
        function rejected(value2) {
          try {
            step(generator["throw"](value2));
          } catch (e6) {
            reject(e6);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger16 = new Logger(version11);
    allowedTransactionKeys = [
      "accessList",
      "ccipReadEnabled",
      "chainId",
      "customData",
      "data",
      "from",
      "gasLimit",
      "gasPrice",
      "maxFeePerGas",
      "maxPriorityFeePerGas",
      "nonce",
      "to",
      "type",
      "value"
    ];
    forwardErrors = [
      Logger.errors.INSUFFICIENT_FUNDS,
      Logger.errors.NONCE_EXPIRED,
      Logger.errors.REPLACEMENT_UNDERPRICED
    ];
    Signer = class {
      constructor() {
        logger16.checkAbstract(new.target, Signer);
        defineReadOnly(this, "_isSigner", true);
      }
      getBalance(blockTag) {
        return __awaiter4(this, void 0, void 0, function* () {
          this._checkProvider("getBalance");
          return yield this.provider.getBalance(this.getAddress(), blockTag);
        });
      }
      getTransactionCount(blockTag) {
        return __awaiter4(this, void 0, void 0, function* () {
          this._checkProvider("getTransactionCount");
          return yield this.provider.getTransactionCount(this.getAddress(), blockTag);
        });
      }
      estimateGas(transaction) {
        return __awaiter4(this, void 0, void 0, function* () {
          this._checkProvider("estimateGas");
          const tx = yield resolveProperties(this.checkTransaction(transaction));
          return yield this.provider.estimateGas(tx);
        });
      }
      call(transaction, blockTag) {
        return __awaiter4(this, void 0, void 0, function* () {
          this._checkProvider("call");
          const tx = yield resolveProperties(this.checkTransaction(transaction));
          return yield this.provider.call(tx, blockTag);
        });
      }
      sendTransaction(transaction) {
        return __awaiter4(this, void 0, void 0, function* () {
          this._checkProvider("sendTransaction");
          const tx = yield this.populateTransaction(transaction);
          const signedTx = yield this.signTransaction(tx);
          return yield this.provider.sendTransaction(signedTx);
        });
      }
      getChainId() {
        return __awaiter4(this, void 0, void 0, function* () {
          this._checkProvider("getChainId");
          const network = yield this.provider.getNetwork();
          return network.chainId;
        });
      }
      getGasPrice() {
        return __awaiter4(this, void 0, void 0, function* () {
          this._checkProvider("getGasPrice");
          return yield this.provider.getGasPrice();
        });
      }
      getFeeData() {
        return __awaiter4(this, void 0, void 0, function* () {
          this._checkProvider("getFeeData");
          return yield this.provider.getFeeData();
        });
      }
      resolveName(name2) {
        return __awaiter4(this, void 0, void 0, function* () {
          this._checkProvider("resolveName");
          return yield this.provider.resolveName(name2);
        });
      }
      checkTransaction(transaction) {
        for (const key2 in transaction) {
          if (allowedTransactionKeys.indexOf(key2) === -1) {
            logger16.throwArgumentError("invalid transaction key: " + key2, "transaction", transaction);
          }
        }
        const tx = shallowCopy(transaction);
        if (tx.from == null) {
          tx.from = this.getAddress();
        } else {
          tx.from = Promise.all([
            Promise.resolve(tx.from),
            this.getAddress()
          ]).then((result) => {
            if (result[0].toLowerCase() !== result[1].toLowerCase()) {
              logger16.throwArgumentError("from address mismatch", "transaction", transaction);
            }
            return result[0];
          });
        }
        return tx;
      }
      populateTransaction(transaction) {
        return __awaiter4(this, void 0, void 0, function* () {
          const tx = yield resolveProperties(this.checkTransaction(transaction));
          if (tx.to != null) {
            tx.to = Promise.resolve(tx.to).then((to2) => __awaiter4(this, void 0, void 0, function* () {
              if (to2 == null) {
                return null;
              }
              const address = yield this.resolveName(to2);
              if (address == null) {
                logger16.throwArgumentError("provided ENS name resolves to null", "tx.to", to2);
              }
              return address;
            }));
            tx.to.catch((error) => {
            });
          }
          const hasEip1559 = tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null;
          if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {
            logger16.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", transaction);
          } else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {
            logger16.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", transaction);
          }
          if ((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)) {
            tx.type = 2;
          } else if (tx.type === 0 || tx.type === 1) {
            if (tx.gasPrice == null) {
              tx.gasPrice = this.getGasPrice();
            }
          } else {
            const feeData = yield this.getFeeData();
            if (tx.type == null) {
              if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
                tx.type = 2;
                if (tx.gasPrice != null) {
                  const gasPrice = tx.gasPrice;
                  delete tx.gasPrice;
                  tx.maxFeePerGas = gasPrice;
                  tx.maxPriorityFeePerGas = gasPrice;
                } else {
                  if (tx.maxFeePerGas == null) {
                    tx.maxFeePerGas = feeData.maxFeePerGas;
                  }
                  if (tx.maxPriorityFeePerGas == null) {
                    tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
                  }
                }
              } else if (feeData.gasPrice != null) {
                if (hasEip1559) {
                  logger16.throwError("network does not support EIP-1559", Logger.errors.UNSUPPORTED_OPERATION, {
                    operation: "populateTransaction"
                  });
                }
                if (tx.gasPrice == null) {
                  tx.gasPrice = feeData.gasPrice;
                }
                tx.type = 0;
              } else {
                logger16.throwError("failed to get consistent fee data", Logger.errors.UNSUPPORTED_OPERATION, {
                  operation: "signer.getFeeData"
                });
              }
            } else if (tx.type === 2) {
              if (tx.maxFeePerGas == null) {
                tx.maxFeePerGas = feeData.maxFeePerGas;
              }
              if (tx.maxPriorityFeePerGas == null) {
                tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
              }
            }
          }
          if (tx.nonce == null) {
            tx.nonce = this.getTransactionCount("pending");
          }
          if (tx.gasLimit == null) {
            tx.gasLimit = this.estimateGas(tx).catch((error) => {
              if (forwardErrors.indexOf(error.code) >= 0) {
                throw error;
              }
              return logger16.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
                error,
                tx
              });
            });
          }
          if (tx.chainId == null) {
            tx.chainId = this.getChainId();
          } else {
            tx.chainId = Promise.all([
              Promise.resolve(tx.chainId),
              this.getChainId()
            ]).then((results2) => {
              if (results2[1] !== 0 && results2[0] !== results2[1]) {
                logger16.throwArgumentError("chainId address mismatch", "transaction", transaction);
              }
              return results2[0];
            });
          }
          return yield resolveProperties(tx);
        });
      }
      _checkProvider(operation) {
        if (!this.provider) {
          logger16.throwError("missing provider", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: operation || "_checkProvider"
          });
        }
      }
      static isSigner(value2) {
        return !!(value2 && value2._isSigner);
      }
    };
    VoidSigner = class extends Signer {
      constructor(address, provider) {
        logger16.checkNew(new.target, VoidSigner);
        super();
        defineReadOnly(this, "address", address);
        defineReadOnly(this, "provider", provider || null);
      }
      getAddress() {
        return Promise.resolve(this.address);
      }
      _fail(message, operation) {
        return Promise.resolve().then(() => {
          logger16.throwError(message, Logger.errors.UNSUPPORTED_OPERATION, { operation });
        });
      }
      signMessage(message) {
        return this._fail("VoidSigner cannot sign messages", "signMessage");
      }
      signTransaction(transaction) {
        return this._fail("VoidSigner cannot sign transactions", "signTransaction");
      }
      _signTypedData(domain2, types, value2) {
        return this._fail("VoidSigner cannot sign typed data", "signTypedData");
      }
      connect(provider) {
        return new VoidSigner(this.address, provider);
      }
    };
  }
});

// node_modules/minimalistic-assert/index.js
var require_minimalistic_assert = __commonJS({
  "node_modules/minimalistic-assert/index.js"(exports2, module2) {
    module2.exports = assert3;
    function assert3(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    assert3.equal = function assertEqual2(l6, r6, msg) {
      if (l6 != r6)
        throw new Error(msg || "Assertion failed: " + l6 + " != " + r6);
    };
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/hash.js/lib/hash/utils.js
var require_utils = __commonJS({
  "node_modules/hash.js/lib/hash/utils.js"(exports2) {
    "use strict";
    var assert3 = require_minimalistic_assert();
    var inherits = require_inherits_browser();
    exports2.inherits = inherits;
    function isSurrogatePair(msg, i6) {
      if ((msg.charCodeAt(i6) & 64512) !== 55296) {
        return false;
      }
      if (i6 < 0 || i6 + 1 >= msg.length) {
        return false;
      }
      return (msg.charCodeAt(i6 + 1) & 64512) === 56320;
    }
    function toArray2(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg === "string") {
        if (!enc) {
          var p7 = 0;
          for (var i6 = 0; i6 < msg.length; i6++) {
            var c5 = msg.charCodeAt(i6);
            if (c5 < 128) {
              res[p7++] = c5;
            } else if (c5 < 2048) {
              res[p7++] = c5 >> 6 | 192;
              res[p7++] = c5 & 63 | 128;
            } else if (isSurrogatePair(msg, i6)) {
              c5 = 65536 + ((c5 & 1023) << 10) + (msg.charCodeAt(++i6) & 1023);
              res[p7++] = c5 >> 18 | 240;
              res[p7++] = c5 >> 12 & 63 | 128;
              res[p7++] = c5 >> 6 & 63 | 128;
              res[p7++] = c5 & 63 | 128;
            } else {
              res[p7++] = c5 >> 12 | 224;
              res[p7++] = c5 >> 6 & 63 | 128;
              res[p7++] = c5 & 63 | 128;
            }
          }
        } else if (enc === "hex") {
          msg = msg.replace(/[^a-z0-9]+/ig, "");
          if (msg.length % 2 !== 0)
            msg = "0" + msg;
          for (i6 = 0; i6 < msg.length; i6 += 2)
            res.push(parseInt(msg[i6] + msg[i6 + 1], 16));
        }
      } else {
        for (i6 = 0; i6 < msg.length; i6++)
          res[i6] = msg[i6] | 0;
      }
      return res;
    }
    exports2.toArray = toArray2;
    function toHex2(msg) {
      var res = "";
      for (var i6 = 0; i6 < msg.length; i6++)
        res += zero2(msg[i6].toString(16));
      return res;
    }
    exports2.toHex = toHex2;
    function htonl(w8) {
      var res = w8 >>> 24 | w8 >>> 8 & 65280 | w8 << 8 & 16711680 | (w8 & 255) << 24;
      return res >>> 0;
    }
    exports2.htonl = htonl;
    function toHex32(msg, endian) {
      var res = "";
      for (var i6 = 0; i6 < msg.length; i6++) {
        var w8 = msg[i6];
        if (endian === "little")
          w8 = htonl(w8);
        res += zero8(w8.toString(16));
      }
      return res;
    }
    exports2.toHex32 = toHex32;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    exports2.zero2 = zero2;
    function zero8(word) {
      if (word.length === 7)
        return "0" + word;
      else if (word.length === 6)
        return "00" + word;
      else if (word.length === 5)
        return "000" + word;
      else if (word.length === 4)
        return "0000" + word;
      else if (word.length === 3)
        return "00000" + word;
      else if (word.length === 2)
        return "000000" + word;
      else if (word.length === 1)
        return "0000000" + word;
      else
        return word;
    }
    exports2.zero8 = zero8;
    function join32(msg, start, end, endian) {
      var len = end - start;
      assert3(len % 4 === 0);
      var res = new Array(len / 4);
      for (var i6 = 0, k8 = start; i6 < res.length; i6++, k8 += 4) {
        var w8;
        if (endian === "big")
          w8 = msg[k8] << 24 | msg[k8 + 1] << 16 | msg[k8 + 2] << 8 | msg[k8 + 3];
        else
          w8 = msg[k8 + 3] << 24 | msg[k8 + 2] << 16 | msg[k8 + 1] << 8 | msg[k8];
        res[i6] = w8 >>> 0;
      }
      return res;
    }
    exports2.join32 = join32;
    function split32(msg, endian) {
      var res = new Array(msg.length * 4);
      for (var i6 = 0, k8 = 0; i6 < msg.length; i6++, k8 += 4) {
        var m6 = msg[i6];
        if (endian === "big") {
          res[k8] = m6 >>> 24;
          res[k8 + 1] = m6 >>> 16 & 255;
          res[k8 + 2] = m6 >>> 8 & 255;
          res[k8 + 3] = m6 & 255;
        } else {
          res[k8 + 3] = m6 >>> 24;
          res[k8 + 2] = m6 >>> 16 & 255;
          res[k8 + 1] = m6 >>> 8 & 255;
          res[k8] = m6 & 255;
        }
      }
      return res;
    }
    exports2.split32 = split32;
    function rotr32(w8, b4) {
      return w8 >>> b4 | w8 << 32 - b4;
    }
    exports2.rotr32 = rotr32;
    function rotl32(w8, b4) {
      return w8 << b4 | w8 >>> 32 - b4;
    }
    exports2.rotl32 = rotl32;
    function sum32(a5, b4) {
      return a5 + b4 >>> 0;
    }
    exports2.sum32 = sum32;
    function sum32_3(a5, b4, c5) {
      return a5 + b4 + c5 >>> 0;
    }
    exports2.sum32_3 = sum32_3;
    function sum32_4(a5, b4, c5, d6) {
      return a5 + b4 + c5 + d6 >>> 0;
    }
    exports2.sum32_4 = sum32_4;
    function sum32_5(a5, b4, c5, d6, e6) {
      return a5 + b4 + c5 + d6 + e6 >>> 0;
    }
    exports2.sum32_5 = sum32_5;
    function sum64(buf, pos, ah, al) {
      var bh = buf[pos];
      var bl = buf[pos + 1];
      var lo = al + bl >>> 0;
      var hi2 = (lo < al ? 1 : 0) + ah + bh;
      buf[pos] = hi2 >>> 0;
      buf[pos + 1] = lo;
    }
    exports2.sum64 = sum64;
    function sum64_hi(ah, al, bh, bl) {
      var lo = al + bl >>> 0;
      var hi2 = (lo < al ? 1 : 0) + ah + bh;
      return hi2 >>> 0;
    }
    exports2.sum64_hi = sum64_hi;
    function sum64_lo(ah, al, bh, bl) {
      var lo = al + bl;
      return lo >>> 0;
    }
    exports2.sum64_lo = sum64_lo;
    function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
      var carry = 0;
      var lo = al;
      lo = lo + bl >>> 0;
      carry += lo < al ? 1 : 0;
      lo = lo + cl >>> 0;
      carry += lo < cl ? 1 : 0;
      lo = lo + dl >>> 0;
      carry += lo < dl ? 1 : 0;
      var hi2 = ah + bh + ch + dh + carry;
      return hi2 >>> 0;
    }
    exports2.sum64_4_hi = sum64_4_hi;
    function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
      var lo = al + bl + cl + dl;
      return lo >>> 0;
    }
    exports2.sum64_4_lo = sum64_4_lo;
    function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var carry = 0;
      var lo = al;
      lo = lo + bl >>> 0;
      carry += lo < al ? 1 : 0;
      lo = lo + cl >>> 0;
      carry += lo < cl ? 1 : 0;
      lo = lo + dl >>> 0;
      carry += lo < dl ? 1 : 0;
      lo = lo + el >>> 0;
      carry += lo < el ? 1 : 0;
      var hi2 = ah + bh + ch + dh + eh + carry;
      return hi2 >>> 0;
    }
    exports2.sum64_5_hi = sum64_5_hi;
    function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var lo = al + bl + cl + dl + el;
      return lo >>> 0;
    }
    exports2.sum64_5_lo = sum64_5_lo;
    function rotr64_hi(ah, al, num) {
      var r6 = al << 32 - num | ah >>> num;
      return r6 >>> 0;
    }
    exports2.rotr64_hi = rotr64_hi;
    function rotr64_lo(ah, al, num) {
      var r6 = ah << 32 - num | al >>> num;
      return r6 >>> 0;
    }
    exports2.rotr64_lo = rotr64_lo;
    function shr64_hi(ah, al, num) {
      return ah >>> num;
    }
    exports2.shr64_hi = shr64_hi;
    function shr64_lo(ah, al, num) {
      var r6 = ah << 32 - num | al >>> num;
      return r6 >>> 0;
    }
    exports2.shr64_lo = shr64_lo;
  }
});

// node_modules/hash.js/lib/hash/common.js
var require_common = __commonJS({
  "node_modules/hash.js/lib/hash/common.js"(exports2) {
    "use strict";
    var utils = require_utils();
    var assert3 = require_minimalistic_assert();
    function BlockHash() {
      this.pending = null;
      this.pendingTotal = 0;
      this.blockSize = this.constructor.blockSize;
      this.outSize = this.constructor.outSize;
      this.hmacStrength = this.constructor.hmacStrength;
      this.padLength = this.constructor.padLength / 8;
      this.endian = "big";
      this._delta8 = this.blockSize / 8;
      this._delta32 = this.blockSize / 32;
    }
    exports2.BlockHash = BlockHash;
    BlockHash.prototype.update = function update2(msg, enc) {
      msg = utils.toArray(msg, enc);
      if (!this.pending)
        this.pending = msg;
      else
        this.pending = this.pending.concat(msg);
      this.pendingTotal += msg.length;
      if (this.pending.length >= this._delta8) {
        msg = this.pending;
        var r6 = msg.length % this._delta8;
        this.pending = msg.slice(msg.length - r6, msg.length);
        if (this.pending.length === 0)
          this.pending = null;
        msg = utils.join32(msg, 0, msg.length - r6, this.endian);
        for (var i6 = 0; i6 < msg.length; i6 += this._delta32)
          this._update(msg, i6, i6 + this._delta32);
      }
      return this;
    };
    BlockHash.prototype.digest = function digest(enc) {
      this.update(this._pad());
      assert3(this.pending === null);
      return this._digest(enc);
    };
    BlockHash.prototype._pad = function pad() {
      var len = this.pendingTotal;
      var bytes = this._delta8;
      var k8 = bytes - (len + this.padLength) % bytes;
      var res = new Array(k8 + this.padLength);
      res[0] = 128;
      for (var i6 = 1; i6 < k8; i6++)
        res[i6] = 0;
      len <<= 3;
      if (this.endian === "big") {
        for (var t6 = 8; t6 < this.padLength; t6++)
          res[i6++] = 0;
        res[i6++] = 0;
        res[i6++] = 0;
        res[i6++] = 0;
        res[i6++] = 0;
        res[i6++] = len >>> 24 & 255;
        res[i6++] = len >>> 16 & 255;
        res[i6++] = len >>> 8 & 255;
        res[i6++] = len & 255;
      } else {
        res[i6++] = len & 255;
        res[i6++] = len >>> 8 & 255;
        res[i6++] = len >>> 16 & 255;
        res[i6++] = len >>> 24 & 255;
        res[i6++] = 0;
        res[i6++] = 0;
        res[i6++] = 0;
        res[i6++] = 0;
        for (t6 = 8; t6 < this.padLength; t6++)
          res[i6++] = 0;
      }
      return res;
    };
  }
});

// node_modules/hash.js/lib/hash/sha/common.js
var require_common2 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/common.js"(exports2) {
    "use strict";
    var utils = require_utils();
    var rotr32 = utils.rotr32;
    function ft_1(s6, x6, y5, z6) {
      if (s6 === 0)
        return ch32(x6, y5, z6);
      if (s6 === 1 || s6 === 3)
        return p32(x6, y5, z6);
      if (s6 === 2)
        return maj32(x6, y5, z6);
    }
    exports2.ft_1 = ft_1;
    function ch32(x6, y5, z6) {
      return x6 & y5 ^ ~x6 & z6;
    }
    exports2.ch32 = ch32;
    function maj32(x6, y5, z6) {
      return x6 & y5 ^ x6 & z6 ^ y5 & z6;
    }
    exports2.maj32 = maj32;
    function p32(x6, y5, z6) {
      return x6 ^ y5 ^ z6;
    }
    exports2.p32 = p32;
    function s0_256(x6) {
      return rotr32(x6, 2) ^ rotr32(x6, 13) ^ rotr32(x6, 22);
    }
    exports2.s0_256 = s0_256;
    function s1_256(x6) {
      return rotr32(x6, 6) ^ rotr32(x6, 11) ^ rotr32(x6, 25);
    }
    exports2.s1_256 = s1_256;
    function g0_256(x6) {
      return rotr32(x6, 7) ^ rotr32(x6, 18) ^ x6 >>> 3;
    }
    exports2.g0_256 = g0_256;
    function g1_256(x6) {
      return rotr32(x6, 17) ^ rotr32(x6, 19) ^ x6 >>> 10;
    }
    exports2.g1_256 = g1_256;
  }
});

// node_modules/hash.js/lib/hash/sha/1.js
var require__ = __commonJS({
  "node_modules/hash.js/lib/hash/sha/1.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var common = require_common();
    var shaCommon = require_common2();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_5 = utils.sum32_5;
    var ft_1 = shaCommon.ft_1;
    var BlockHash = common.BlockHash;
    var sha1_K = [
      1518500249,
      1859775393,
      2400959708,
      3395469782
    ];
    function SHA1() {
      if (!(this instanceof SHA1))
        return new SHA1();
      BlockHash.call(this);
      this.h = [
        1732584193,
        4023233417,
        2562383102,
        271733878,
        3285377520
      ];
      this.W = new Array(80);
    }
    utils.inherits(SHA1, BlockHash);
    module2.exports = SHA1;
    SHA1.blockSize = 512;
    SHA1.outSize = 160;
    SHA1.hmacStrength = 80;
    SHA1.padLength = 64;
    SHA1.prototype._update = function _update(msg, start) {
      var W4 = this.W;
      for (var i6 = 0; i6 < 16; i6++)
        W4[i6] = msg[start + i6];
      for (; i6 < W4.length; i6++)
        W4[i6] = rotl32(W4[i6 - 3] ^ W4[i6 - 8] ^ W4[i6 - 14] ^ W4[i6 - 16], 1);
      var a5 = this.h[0];
      var b4 = this.h[1];
      var c5 = this.h[2];
      var d6 = this.h[3];
      var e6 = this.h[4];
      for (i6 = 0; i6 < W4.length; i6++) {
        var s6 = ~~(i6 / 20);
        var t6 = sum32_5(rotl32(a5, 5), ft_1(s6, b4, c5, d6), e6, W4[i6], sha1_K[s6]);
        e6 = d6;
        d6 = c5;
        c5 = rotl32(b4, 30);
        b4 = a5;
        a5 = t6;
      }
      this.h[0] = sum32(this.h[0], a5);
      this.h[1] = sum32(this.h[1], b4);
      this.h[2] = sum32(this.h[2], c5);
      this.h[3] = sum32(this.h[3], d6);
      this.h[4] = sum32(this.h[4], e6);
    };
    SHA1.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/256.js
var require__2 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/256.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var common = require_common();
    var shaCommon = require_common2();
    var assert3 = require_minimalistic_assert();
    var sum32 = utils.sum32;
    var sum32_4 = utils.sum32_4;
    var sum32_5 = utils.sum32_5;
    var ch32 = shaCommon.ch32;
    var maj32 = shaCommon.maj32;
    var s0_256 = shaCommon.s0_256;
    var s1_256 = shaCommon.s1_256;
    var g0_256 = shaCommon.g0_256;
    var g1_256 = shaCommon.g1_256;
    var BlockHash = common.BlockHash;
    var sha256_K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    function SHA256() {
      if (!(this instanceof SHA256))
        return new SHA256();
      BlockHash.call(this);
      this.h = [
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ];
      this.k = sha256_K;
      this.W = new Array(64);
    }
    utils.inherits(SHA256, BlockHash);
    module2.exports = SHA256;
    SHA256.blockSize = 512;
    SHA256.outSize = 256;
    SHA256.hmacStrength = 192;
    SHA256.padLength = 64;
    SHA256.prototype._update = function _update(msg, start) {
      var W4 = this.W;
      for (var i6 = 0; i6 < 16; i6++)
        W4[i6] = msg[start + i6];
      for (; i6 < W4.length; i6++)
        W4[i6] = sum32_4(g1_256(W4[i6 - 2]), W4[i6 - 7], g0_256(W4[i6 - 15]), W4[i6 - 16]);
      var a5 = this.h[0];
      var b4 = this.h[1];
      var c5 = this.h[2];
      var d6 = this.h[3];
      var e6 = this.h[4];
      var f7 = this.h[5];
      var g7 = this.h[6];
      var h6 = this.h[7];
      assert3(this.k.length === W4.length);
      for (i6 = 0; i6 < W4.length; i6++) {
        var T1 = sum32_5(h6, s1_256(e6), ch32(e6, f7, g7), this.k[i6], W4[i6]);
        var T22 = sum32(s0_256(a5), maj32(a5, b4, c5));
        h6 = g7;
        g7 = f7;
        f7 = e6;
        e6 = sum32(d6, T1);
        d6 = c5;
        c5 = b4;
        b4 = a5;
        a5 = sum32(T1, T22);
      }
      this.h[0] = sum32(this.h[0], a5);
      this.h[1] = sum32(this.h[1], b4);
      this.h[2] = sum32(this.h[2], c5);
      this.h[3] = sum32(this.h[3], d6);
      this.h[4] = sum32(this.h[4], e6);
      this.h[5] = sum32(this.h[5], f7);
      this.h[6] = sum32(this.h[6], g7);
      this.h[7] = sum32(this.h[7], h6);
    };
    SHA256.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/224.js
var require__3 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/224.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var SHA256 = require__2();
    function SHA224() {
      if (!(this instanceof SHA224))
        return new SHA224();
      SHA256.call(this);
      this.h = [
        3238371032,
        914150663,
        812702999,
        4144912697,
        4290775857,
        1750603025,
        1694076839,
        3204075428
      ];
    }
    utils.inherits(SHA224, SHA256);
    module2.exports = SHA224;
    SHA224.blockSize = 512;
    SHA224.outSize = 224;
    SHA224.hmacStrength = 192;
    SHA224.padLength = 64;
    SHA224.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 7), "big");
      else
        return utils.split32(this.h.slice(0, 7), "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/512.js
var require__4 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/512.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var common = require_common();
    var assert3 = require_minimalistic_assert();
    var rotr64_hi = utils.rotr64_hi;
    var rotr64_lo = utils.rotr64_lo;
    var shr64_hi = utils.shr64_hi;
    var shr64_lo = utils.shr64_lo;
    var sum64 = utils.sum64;
    var sum64_hi = utils.sum64_hi;
    var sum64_lo = utils.sum64_lo;
    var sum64_4_hi = utils.sum64_4_hi;
    var sum64_4_lo = utils.sum64_4_lo;
    var sum64_5_hi = utils.sum64_5_hi;
    var sum64_5_lo = utils.sum64_5_lo;
    var BlockHash = common.BlockHash;
    var sha512_K = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function SHA512() {
      if (!(this instanceof SHA512))
        return new SHA512();
      BlockHash.call(this);
      this.h = [
        1779033703,
        4089235720,
        3144134277,
        2227873595,
        1013904242,
        4271175723,
        2773480762,
        1595750129,
        1359893119,
        2917565137,
        2600822924,
        725511199,
        528734635,
        4215389547,
        1541459225,
        327033209
      ];
      this.k = sha512_K;
      this.W = new Array(160);
    }
    utils.inherits(SHA512, BlockHash);
    module2.exports = SHA512;
    SHA512.blockSize = 1024;
    SHA512.outSize = 512;
    SHA512.hmacStrength = 192;
    SHA512.padLength = 128;
    SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
      var W4 = this.W;
      for (var i6 = 0; i6 < 32; i6++)
        W4[i6] = msg[start + i6];
      for (; i6 < W4.length; i6 += 2) {
        var c0_hi = g1_512_hi(W4[i6 - 4], W4[i6 - 3]);
        var c0_lo = g1_512_lo(W4[i6 - 4], W4[i6 - 3]);
        var c1_hi = W4[i6 - 14];
        var c1_lo = W4[i6 - 13];
        var c2_hi = g0_512_hi(W4[i6 - 30], W4[i6 - 29]);
        var c2_lo = g0_512_lo(W4[i6 - 30], W4[i6 - 29]);
        var c3_hi = W4[i6 - 32];
        var c3_lo = W4[i6 - 31];
        W4[i6] = sum64_4_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
        W4[i6 + 1] = sum64_4_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
      }
    };
    SHA512.prototype._update = function _update(msg, start) {
      this._prepareBlock(msg, start);
      var W4 = this.W;
      var ah = this.h[0];
      var al = this.h[1];
      var bh = this.h[2];
      var bl = this.h[3];
      var ch = this.h[4];
      var cl = this.h[5];
      var dh = this.h[6];
      var dl = this.h[7];
      var eh = this.h[8];
      var el = this.h[9];
      var fh = this.h[10];
      var fl = this.h[11];
      var gh = this.h[12];
      var gl = this.h[13];
      var hh = this.h[14];
      var hl = this.h[15];
      assert3(this.k.length === W4.length);
      for (var i6 = 0; i6 < W4.length; i6 += 2) {
        var c0_hi = hh;
        var c0_lo = hl;
        var c1_hi = s1_512_hi(eh, el);
        var c1_lo = s1_512_lo(eh, el);
        var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
        var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
        var c3_hi = this.k[i6];
        var c3_lo = this.k[i6 + 1];
        var c4_hi = W4[i6];
        var c4_lo = W4[i6 + 1];
        var T1_hi = sum64_5_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        var T1_lo = sum64_5_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        c0_hi = s0_512_hi(ah, al);
        c0_lo = s0_512_lo(ah, al);
        c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
        c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
        var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
        var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        eh = sum64_hi(dh, dl, T1_hi, T1_lo);
        el = sum64_lo(dl, dl, T1_hi, T1_lo);
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
        al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
      }
      sum64(this.h, 0, ah, al);
      sum64(this.h, 2, bh, bl);
      sum64(this.h, 4, ch, cl);
      sum64(this.h, 6, dh, dl);
      sum64(this.h, 8, eh, el);
      sum64(this.h, 10, fh, fl);
      sum64(this.h, 12, gh, gl);
      sum64(this.h, 14, hh, hl);
    };
    SHA512.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
    function ch64_hi(xh, xl, yh, yl, zh) {
      var r6 = xh & yh ^ ~xh & zh;
      if (r6 < 0)
        r6 += 4294967296;
      return r6;
    }
    function ch64_lo(xh, xl, yh, yl, zh, zl) {
      var r6 = xl & yl ^ ~xl & zl;
      if (r6 < 0)
        r6 += 4294967296;
      return r6;
    }
    function maj64_hi(xh, xl, yh, yl, zh) {
      var r6 = xh & yh ^ xh & zh ^ yh & zh;
      if (r6 < 0)
        r6 += 4294967296;
      return r6;
    }
    function maj64_lo(xh, xl, yh, yl, zh, zl) {
      var r6 = xl & yl ^ xl & zl ^ yl & zl;
      if (r6 < 0)
        r6 += 4294967296;
      return r6;
    }
    function s0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 28);
      var c1_hi = rotr64_hi(xl, xh, 2);
      var c2_hi = rotr64_hi(xl, xh, 7);
      var r6 = c0_hi ^ c1_hi ^ c2_hi;
      if (r6 < 0)
        r6 += 4294967296;
      return r6;
    }
    function s0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 28);
      var c1_lo = rotr64_lo(xl, xh, 2);
      var c2_lo = rotr64_lo(xl, xh, 7);
      var r6 = c0_lo ^ c1_lo ^ c2_lo;
      if (r6 < 0)
        r6 += 4294967296;
      return r6;
    }
    function s1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 14);
      var c1_hi = rotr64_hi(xh, xl, 18);
      var c2_hi = rotr64_hi(xl, xh, 9);
      var r6 = c0_hi ^ c1_hi ^ c2_hi;
      if (r6 < 0)
        r6 += 4294967296;
      return r6;
    }
    function s1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 14);
      var c1_lo = rotr64_lo(xh, xl, 18);
      var c2_lo = rotr64_lo(xl, xh, 9);
      var r6 = c0_lo ^ c1_lo ^ c2_lo;
      if (r6 < 0)
        r6 += 4294967296;
      return r6;
    }
    function g0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 1);
      var c1_hi = rotr64_hi(xh, xl, 8);
      var c2_hi = shr64_hi(xh, xl, 7);
      var r6 = c0_hi ^ c1_hi ^ c2_hi;
      if (r6 < 0)
        r6 += 4294967296;
      return r6;
    }
    function g0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 1);
      var c1_lo = rotr64_lo(xh, xl, 8);
      var c2_lo = shr64_lo(xh, xl, 7);
      var r6 = c0_lo ^ c1_lo ^ c2_lo;
      if (r6 < 0)
        r6 += 4294967296;
      return r6;
    }
    function g1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 19);
      var c1_hi = rotr64_hi(xl, xh, 29);
      var c2_hi = shr64_hi(xh, xl, 6);
      var r6 = c0_hi ^ c1_hi ^ c2_hi;
      if (r6 < 0)
        r6 += 4294967296;
      return r6;
    }
    function g1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 19);
      var c1_lo = rotr64_lo(xl, xh, 29);
      var c2_lo = shr64_lo(xh, xl, 6);
      var r6 = c0_lo ^ c1_lo ^ c2_lo;
      if (r6 < 0)
        r6 += 4294967296;
      return r6;
    }
  }
});

// node_modules/hash.js/lib/hash/sha/384.js
var require__5 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/384.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var SHA512 = require__4();
    function SHA384() {
      if (!(this instanceof SHA384))
        return new SHA384();
      SHA512.call(this);
      this.h = [
        3418070365,
        3238371032,
        1654270250,
        914150663,
        2438529370,
        812702999,
        355462360,
        4144912697,
        1731405415,
        4290775857,
        2394180231,
        1750603025,
        3675008525,
        1694076839,
        1203062813,
        3204075428
      ];
    }
    utils.inherits(SHA384, SHA512);
    module2.exports = SHA384;
    SHA384.blockSize = 1024;
    SHA384.outSize = 384;
    SHA384.hmacStrength = 192;
    SHA384.padLength = 128;
    SHA384.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 12), "big");
      else
        return utils.split32(this.h.slice(0, 12), "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha.js
var require_sha = __commonJS({
  "node_modules/hash.js/lib/hash/sha.js"(exports2) {
    "use strict";
    exports2.sha1 = require__();
    exports2.sha224 = require__3();
    exports2.sha256 = require__2();
    exports2.sha384 = require__5();
    exports2.sha512 = require__4();
  }
});

// node_modules/hash.js/lib/hash/ripemd.js
var require_ripemd = __commonJS({
  "node_modules/hash.js/lib/hash/ripemd.js"(exports2) {
    "use strict";
    var utils = require_utils();
    var common = require_common();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_3 = utils.sum32_3;
    var sum32_4 = utils.sum32_4;
    var BlockHash = common.BlockHash;
    function RIPEMD160() {
      if (!(this instanceof RIPEMD160))
        return new RIPEMD160();
      BlockHash.call(this);
      this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      this.endian = "little";
    }
    utils.inherits(RIPEMD160, BlockHash);
    exports2.ripemd160 = RIPEMD160;
    RIPEMD160.blockSize = 512;
    RIPEMD160.outSize = 160;
    RIPEMD160.hmacStrength = 192;
    RIPEMD160.padLength = 64;
    RIPEMD160.prototype._update = function update2(msg, start) {
      var A8 = this.h[0];
      var B4 = this.h[1];
      var C5 = this.h[2];
      var D5 = this.h[3];
      var E5 = this.h[4];
      var Ah = A8;
      var Bh = B4;
      var Ch = C5;
      var Dh = D5;
      var Eh = E5;
      for (var j8 = 0; j8 < 80; j8++) {
        var T8 = sum32(
          rotl32(
            sum32_4(A8, f7(j8, B4, C5, D5), msg[r6[j8] + start], K5(j8)),
            s6[j8]
          ),
          E5
        );
        A8 = E5;
        E5 = D5;
        D5 = rotl32(C5, 10);
        C5 = B4;
        B4 = T8;
        T8 = sum32(
          rotl32(
            sum32_4(Ah, f7(79 - j8, Bh, Ch, Dh), msg[rh[j8] + start], Kh(j8)),
            sh[j8]
          ),
          Eh
        );
        Ah = Eh;
        Eh = Dh;
        Dh = rotl32(Ch, 10);
        Ch = Bh;
        Bh = T8;
      }
      T8 = sum32_3(this.h[1], C5, Dh);
      this.h[1] = sum32_3(this.h[2], D5, Eh);
      this.h[2] = sum32_3(this.h[3], E5, Ah);
      this.h[3] = sum32_3(this.h[4], A8, Bh);
      this.h[4] = sum32_3(this.h[0], B4, Ch);
      this.h[0] = T8;
    };
    RIPEMD160.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "little");
      else
        return utils.split32(this.h, "little");
    };
    function f7(j8, x6, y5, z6) {
      if (j8 <= 15)
        return x6 ^ y5 ^ z6;
      else if (j8 <= 31)
        return x6 & y5 | ~x6 & z6;
      else if (j8 <= 47)
        return (x6 | ~y5) ^ z6;
      else if (j8 <= 63)
        return x6 & z6 | y5 & ~z6;
      else
        return x6 ^ (y5 | ~z6);
    }
    function K5(j8) {
      if (j8 <= 15)
        return 0;
      else if (j8 <= 31)
        return 1518500249;
      else if (j8 <= 47)
        return 1859775393;
      else if (j8 <= 63)
        return 2400959708;
      else
        return 2840853838;
    }
    function Kh(j8) {
      if (j8 <= 15)
        return 1352829926;
      else if (j8 <= 31)
        return 1548603684;
      else if (j8 <= 47)
        return 1836072691;
      else if (j8 <= 63)
        return 2053994217;
      else
        return 0;
    }
    var r6 = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      7,
      4,
      13,
      1,
      10,
      6,
      15,
      3,
      12,
      0,
      9,
      5,
      2,
      14,
      11,
      8,
      3,
      10,
      14,
      4,
      9,
      15,
      8,
      1,
      2,
      7,
      0,
      6,
      13,
      11,
      5,
      12,
      1,
      9,
      11,
      10,
      0,
      8,
      12,
      4,
      13,
      3,
      7,
      15,
      14,
      5,
      6,
      2,
      4,
      0,
      5,
      9,
      7,
      12,
      2,
      10,
      14,
      1,
      3,
      8,
      11,
      6,
      15,
      13
    ];
    var rh = [
      5,
      14,
      7,
      0,
      9,
      2,
      11,
      4,
      13,
      6,
      15,
      8,
      1,
      10,
      3,
      12,
      6,
      11,
      3,
      7,
      0,
      13,
      5,
      10,
      14,
      15,
      8,
      12,
      4,
      9,
      1,
      2,
      15,
      5,
      1,
      3,
      7,
      14,
      6,
      9,
      11,
      8,
      12,
      2,
      10,
      0,
      4,
      13,
      8,
      6,
      4,
      1,
      3,
      11,
      15,
      0,
      5,
      12,
      2,
      13,
      9,
      7,
      10,
      14,
      12,
      15,
      10,
      4,
      1,
      5,
      8,
      7,
      6,
      2,
      13,
      14,
      0,
      3,
      9,
      11
    ];
    var s6 = [
      11,
      14,
      15,
      12,
      5,
      8,
      7,
      9,
      11,
      13,
      14,
      15,
      6,
      7,
      9,
      8,
      7,
      6,
      8,
      13,
      11,
      9,
      7,
      15,
      7,
      12,
      15,
      9,
      11,
      7,
      13,
      12,
      11,
      13,
      6,
      7,
      14,
      9,
      13,
      15,
      14,
      8,
      13,
      6,
      5,
      12,
      7,
      5,
      11,
      12,
      14,
      15,
      14,
      15,
      9,
      8,
      9,
      14,
      5,
      6,
      8,
      6,
      5,
      12,
      9,
      15,
      5,
      11,
      6,
      8,
      13,
      12,
      5,
      12,
      13,
      14,
      11,
      8,
      5,
      6
    ];
    var sh = [
      8,
      9,
      9,
      11,
      13,
      15,
      15,
      5,
      7,
      7,
      8,
      11,
      14,
      14,
      12,
      6,
      9,
      13,
      15,
      7,
      12,
      8,
      9,
      11,
      7,
      7,
      12,
      7,
      6,
      15,
      13,
      11,
      9,
      7,
      15,
      11,
      8,
      6,
      6,
      14,
      12,
      13,
      5,
      14,
      13,
      13,
      7,
      5,
      15,
      5,
      8,
      11,
      14,
      14,
      6,
      14,
      6,
      9,
      12,
      9,
      12,
      5,
      15,
      8,
      8,
      5,
      12,
      9,
      12,
      5,
      14,
      6,
      8,
      13,
      6,
      5,
      15,
      13,
      11,
      11
    ];
  }
});

// node_modules/hash.js/lib/hash/hmac.js
var require_hmac = __commonJS({
  "node_modules/hash.js/lib/hash/hmac.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var assert3 = require_minimalistic_assert();
    function Hmac(hash3, key2, enc) {
      if (!(this instanceof Hmac))
        return new Hmac(hash3, key2, enc);
      this.Hash = hash3;
      this.blockSize = hash3.blockSize / 8;
      this.outSize = hash3.outSize / 8;
      this.inner = null;
      this.outer = null;
      this._init(utils.toArray(key2, enc));
    }
    module2.exports = Hmac;
    Hmac.prototype._init = function init2(key2) {
      if (key2.length > this.blockSize)
        key2 = new this.Hash().update(key2).digest();
      assert3(key2.length <= this.blockSize);
      for (var i6 = key2.length; i6 < this.blockSize; i6++)
        key2.push(0);
      for (i6 = 0; i6 < key2.length; i6++)
        key2[i6] ^= 54;
      this.inner = new this.Hash().update(key2);
      for (i6 = 0; i6 < key2.length; i6++)
        key2[i6] ^= 106;
      this.outer = new this.Hash().update(key2);
    };
    Hmac.prototype.update = function update2(msg, enc) {
      this.inner.update(msg, enc);
      return this;
    };
    Hmac.prototype.digest = function digest(enc) {
      this.outer.update(this.inner.digest());
      return this.outer.digest(enc);
    };
  }
});

// node_modules/hash.js/lib/hash.js
var require_hash = __commonJS({
  "node_modules/hash.js/lib/hash.js"(exports2) {
    var hash3 = exports2;
    hash3.utils = require_utils();
    hash3.common = require_common();
    hash3.sha = require_sha();
    hash3.ripemd = require_ripemd();
    hash3.hmac = require_hmac();
    hash3.sha1 = hash3.sha.sha1;
    hash3.sha256 = hash3.sha.sha256;
    hash3.sha224 = hash3.sha.sha224;
    hash3.sha384 = hash3.sha.sha384;
    hash3.sha512 = hash3.sha.sha512;
    hash3.ripemd160 = hash3.ripemd.ripemd160;
  }
});

// node_modules/@ethersproject/signing-key/lib.esm/elliptic.js
function createCommonjsModule(fn2, basedir, module2) {
  return module2 = {
    path: basedir,
    exports: {},
    require: function(path, base2) {
      return commonjsRequire(path, base2 === void 0 || base2 === null ? module2.path : base2);
    }
  }, fn2(module2, module2.exports), module2.exports;
}
function commonjsRequire() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
function assert(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
function BaseCurve(type, conf) {
  this.type = type;
  this.p = new import_bn2.default(conf.p, 16);
  this.red = conf.prime ? import_bn2.default.red(conf.prime) : import_bn2.default.mont(this.p);
  this.zero = new import_bn2.default(0).toRed(this.red);
  this.one = new import_bn2.default(1).toRed(this.red);
  this.two = new import_bn2.default(2).toRed(this.red);
  this.n = conf.n && new import_bn2.default(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);
  this._bitLength = this.n ? this.n.bitLength() : 0;
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
function ShortCurve(conf) {
  base.call(this, "short", conf);
  this.a = new import_bn2.default(conf.a, 16).toRed(this.red);
  this.b = new import_bn2.default(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();
  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
function Point(curve, x6, y5, isRed) {
  base.BasePoint.call(this, curve, "affine");
  if (x6 === null && y5 === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new import_bn2.default(x6, 16);
    this.y = new import_bn2.default(y5, 16);
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
function JPoint(curve, x6, y5, z6) {
  base.BasePoint.call(this, curve, "jacobian");
  if (x6 === null && y5 === null && z6 === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new import_bn2.default(0);
  } else {
    this.x = new import_bn2.default(x6, 16);
    this.y = new import_bn2.default(y5, 16);
    this.z = new import_bn2.default(z6, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);
  this.zOne = this.z === this.curve.one;
}
function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;
  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;
  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;
  var entropy = utils_1.toArray(options.entropy, options.entropyEnc || "hex");
  var nonce = utils_1.toArray(options.nonce, options.nonceEnc || "hex");
  var pers = utils_1.toArray(options.pers, options.persEnc || "hex");
  minimalisticAssert(
    entropy.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  );
  this._init(entropy, nonce, pers);
}
function KeyPair(ec2, options) {
  this.ec = ec2;
  this.priv = null;
  this.pub = null;
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
function Signature(options, enc) {
  if (options instanceof Signature)
    return options;
  if (this._importDER(options, enc))
    return;
  assert$4(options.r && options.s, "Signature without r or s");
  this.r = new import_bn2.default(options.r, 16);
  this.s = new import_bn2.default(options.s, 16);
  if (options.recoveryParam === void 0)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
function Position() {
  this.place = 0;
}
function getLength(buf, p7) {
  var initial = buf[p7.place++];
  if (!(initial & 128)) {
    return initial;
  }
  var octetLen = initial & 15;
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }
  var val = 0;
  for (var i6 = 0, off = p7.place; i6 < octetLen; i6++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }
  if (val <= 127) {
    return false;
  }
  p7.place = off;
  return val;
}
function rmPadding(buf) {
  var i6 = 0;
  var len = buf.length - 1;
  while (!buf[i6] && !(buf[i6 + 1] & 128) && i6 < len) {
    i6++;
  }
  if (i6 === 0) {
    return buf;
  }
  return buf.slice(i6);
}
function constructLength(arr, len) {
  if (len < 128) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 128);
  while (--octets) {
    arr.push(len >>> (octets << 3) & 255);
  }
  arr.push(len);
}
function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);
  if (typeof options === "string") {
    assert$5(
      Object.prototype.hasOwnProperty.call(curves_1, options),
      "Unknown curve " + options
    );
    options = curves_1[options];
  }
  if (options instanceof curves_1.PresetCurve)
    options = { curve: options };
  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);
  this.hash = options.hash || options.curve.hash;
}
var import_bn2, import_hash2, minimalisticAssert, utils_1, utils_1$1, getNAF, getJSF, assert$1, base, inherits_browser, assert$2, short_1, curve_1, curves_1, hmacDrbg, assert$3, key, assert$4, signature, rand, assert$5, ec, elliptic_1, EC$1;
var init_elliptic = __esm({
  "node_modules/@ethersproject/signing-key/lib.esm/elliptic.js"() {
    import_bn2 = __toESM(require_bn());
    import_hash2 = __toESM(require_hash());
    minimalisticAssert = assert;
    assert.equal = function assertEqual(l6, r6, msg) {
      if (l6 != r6)
        throw new Error(msg || "Assertion failed: " + l6 + " != " + r6);
    };
    utils_1 = createCommonjsModule(function(module2, exports2) {
      "use strict";
      var utils = exports2;
      function toArray2(msg, enc) {
        if (Array.isArray(msg))
          return msg.slice();
        if (!msg)
          return [];
        var res = [];
        if (typeof msg !== "string") {
          for (var i6 = 0; i6 < msg.length; i6++)
            res[i6] = msg[i6] | 0;
          return res;
        }
        if (enc === "hex") {
          msg = msg.replace(/[^a-z0-9]+/ig, "");
          if (msg.length % 2 !== 0)
            msg = "0" + msg;
          for (var i6 = 0; i6 < msg.length; i6 += 2)
            res.push(parseInt(msg[i6] + msg[i6 + 1], 16));
        } else {
          for (var i6 = 0; i6 < msg.length; i6++) {
            var c5 = msg.charCodeAt(i6);
            var hi2 = c5 >> 8;
            var lo = c5 & 255;
            if (hi2)
              res.push(hi2, lo);
            else
              res.push(lo);
          }
        }
        return res;
      }
      utils.toArray = toArray2;
      function zero2(word) {
        if (word.length === 1)
          return "0" + word;
        else
          return word;
      }
      utils.zero2 = zero2;
      function toHex2(msg) {
        var res = "";
        for (var i6 = 0; i6 < msg.length; i6++)
          res += zero2(msg[i6].toString(16));
        return res;
      }
      utils.toHex = toHex2;
      utils.encode = function encode4(arr, enc) {
        if (enc === "hex")
          return toHex2(arr);
        else
          return arr;
      };
    });
    utils_1$1 = createCommonjsModule(function(module2, exports2) {
      "use strict";
      var utils = exports2;
      utils.assert = minimalisticAssert;
      utils.toArray = utils_1.toArray;
      utils.zero2 = utils_1.zero2;
      utils.toHex = utils_1.toHex;
      utils.encode = utils_1.encode;
      function getNAF2(num, w8, bits) {
        var naf = new Array(Math.max(num.bitLength(), bits) + 1);
        naf.fill(0);
        var ws2 = 1 << w8 + 1;
        var k8 = num.clone();
        for (var i6 = 0; i6 < naf.length; i6++) {
          var z6;
          var mod2 = k8.andln(ws2 - 1);
          if (k8.isOdd()) {
            if (mod2 > (ws2 >> 1) - 1)
              z6 = (ws2 >> 1) - mod2;
            else
              z6 = mod2;
            k8.isubn(z6);
          } else {
            z6 = 0;
          }
          naf[i6] = z6;
          k8.iushrn(1);
        }
        return naf;
      }
      utils.getNAF = getNAF2;
      function getJSF2(k1, k22) {
        var jsf = [
          [],
          []
        ];
        k1 = k1.clone();
        k22 = k22.clone();
        var d1 = 0;
        var d22 = 0;
        var m8;
        while (k1.cmpn(-d1) > 0 || k22.cmpn(-d22) > 0) {
          var m14 = k1.andln(3) + d1 & 3;
          var m24 = k22.andln(3) + d22 & 3;
          if (m14 === 3)
            m14 = -1;
          if (m24 === 3)
            m24 = -1;
          var u1;
          if ((m14 & 1) === 0) {
            u1 = 0;
          } else {
            m8 = k1.andln(7) + d1 & 7;
            if ((m8 === 3 || m8 === 5) && m24 === 2)
              u1 = -m14;
            else
              u1 = m14;
          }
          jsf[0].push(u1);
          var u22;
          if ((m24 & 1) === 0) {
            u22 = 0;
          } else {
            m8 = k22.andln(7) + d22 & 7;
            if ((m8 === 3 || m8 === 5) && m14 === 2)
              u22 = -m24;
            else
              u22 = m24;
          }
          jsf[1].push(u22);
          if (2 * d1 === u1 + 1)
            d1 = 1 - d1;
          if (2 * d22 === u22 + 1)
            d22 = 1 - d22;
          k1.iushrn(1);
          k22.iushrn(1);
        }
        return jsf;
      }
      utils.getJSF = getJSF2;
      function cachedProperty(obj, name2, computer) {
        var key2 = "_" + name2;
        obj.prototype[name2] = function cachedProperty2() {
          return this[key2] !== void 0 ? this[key2] : this[key2] = computer.call(this);
        };
      }
      utils.cachedProperty = cachedProperty;
      function parseBytes(bytes) {
        return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
      }
      utils.parseBytes = parseBytes;
      function intFromLE(bytes) {
        return new import_bn2.default(bytes, "hex", "le");
      }
      utils.intFromLE = intFromLE;
    });
    getNAF = utils_1$1.getNAF;
    getJSF = utils_1$1.getJSF;
    assert$1 = utils_1$1.assert;
    base = BaseCurve;
    BaseCurve.prototype.point = function point() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype.validate = function validate() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p7, k8) {
      assert$1(p7.precomputed);
      var doubles = p7._getDoubles();
      var naf = getNAF(k8, 1, this._bitLength);
      var I5 = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
      I5 /= 3;
      var repr = [];
      var j8;
      var nafW;
      for (j8 = 0; j8 < naf.length; j8 += doubles.step) {
        nafW = 0;
        for (var l6 = j8 + doubles.step - 1; l6 >= j8; l6--)
          nafW = (nafW << 1) + naf[l6];
        repr.push(nafW);
      }
      var a5 = this.jpoint(null, null, null);
      var b4 = this.jpoint(null, null, null);
      for (var i6 = I5; i6 > 0; i6--) {
        for (j8 = 0; j8 < repr.length; j8++) {
          nafW = repr[j8];
          if (nafW === i6)
            b4 = b4.mixedAdd(doubles.points[j8]);
          else if (nafW === -i6)
            b4 = b4.mixedAdd(doubles.points[j8].neg());
        }
        a5 = a5.add(b4);
      }
      return a5.toP();
    };
    BaseCurve.prototype._wnafMul = function _wnafMul(p7, k8) {
      var w8 = 4;
      var nafPoints = p7._getNAFPoints(w8);
      w8 = nafPoints.wnd;
      var wnd = nafPoints.points;
      var naf = getNAF(k8, w8, this._bitLength);
      var acc = this.jpoint(null, null, null);
      for (var i6 = naf.length - 1; i6 >= 0; i6--) {
        for (var l6 = 0; i6 >= 0 && naf[i6] === 0; i6--)
          l6++;
        if (i6 >= 0)
          l6++;
        acc = acc.dblp(l6);
        if (i6 < 0)
          break;
        var z6 = naf[i6];
        assert$1(z6 !== 0);
        if (p7.type === "affine") {
          if (z6 > 0)
            acc = acc.mixedAdd(wnd[z6 - 1 >> 1]);
          else
            acc = acc.mixedAdd(wnd[-z6 - 1 >> 1].neg());
        } else {
          if (z6 > 0)
            acc = acc.add(wnd[z6 - 1 >> 1]);
          else
            acc = acc.add(wnd[-z6 - 1 >> 1].neg());
        }
      }
      return p7.type === "affine" ? acc.toP() : acc;
    };
    BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
      var wndWidth = this._wnafT1;
      var wnd = this._wnafT2;
      var naf = this._wnafT3;
      var max2 = 0;
      var i6;
      var j8;
      var p7;
      for (i6 = 0; i6 < len; i6++) {
        p7 = points[i6];
        var nafPoints = p7._getNAFPoints(defW);
        wndWidth[i6] = nafPoints.wnd;
        wnd[i6] = nafPoints.points;
      }
      for (i6 = len - 1; i6 >= 1; i6 -= 2) {
        var a5 = i6 - 1;
        var b4 = i6;
        if (wndWidth[a5] !== 1 || wndWidth[b4] !== 1) {
          naf[a5] = getNAF(coeffs[a5], wndWidth[a5], this._bitLength);
          naf[b4] = getNAF(coeffs[b4], wndWidth[b4], this._bitLength);
          max2 = Math.max(naf[a5].length, max2);
          max2 = Math.max(naf[b4].length, max2);
          continue;
        }
        var comb = [
          points[a5],
          null,
          null,
          points[b4]
        ];
        if (points[a5].y.cmp(points[b4].y) === 0) {
          comb[1] = points[a5].add(points[b4]);
          comb[2] = points[a5].toJ().mixedAdd(points[b4].neg());
        } else if (points[a5].y.cmp(points[b4].y.redNeg()) === 0) {
          comb[1] = points[a5].toJ().mixedAdd(points[b4]);
          comb[2] = points[a5].add(points[b4].neg());
        } else {
          comb[1] = points[a5].toJ().mixedAdd(points[b4]);
          comb[2] = points[a5].toJ().mixedAdd(points[b4].neg());
        }
        var index = [
          -3,
          -1,
          -5,
          -7,
          0,
          7,
          5,
          1,
          3
        ];
        var jsf = getJSF(coeffs[a5], coeffs[b4]);
        max2 = Math.max(jsf[0].length, max2);
        naf[a5] = new Array(max2);
        naf[b4] = new Array(max2);
        for (j8 = 0; j8 < max2; j8++) {
          var ja2 = jsf[0][j8] | 0;
          var jb = jsf[1][j8] | 0;
          naf[a5][j8] = index[(ja2 + 1) * 3 + (jb + 1)];
          naf[b4][j8] = 0;
          wnd[a5] = comb;
        }
      }
      var acc = this.jpoint(null, null, null);
      var tmp = this._wnafT4;
      for (i6 = max2; i6 >= 0; i6--) {
        var k8 = 0;
        while (i6 >= 0) {
          var zero = true;
          for (j8 = 0; j8 < len; j8++) {
            tmp[j8] = naf[j8][i6] | 0;
            if (tmp[j8] !== 0)
              zero = false;
          }
          if (!zero)
            break;
          k8++;
          i6--;
        }
        if (i6 >= 0)
          k8++;
        acc = acc.dblp(k8);
        if (i6 < 0)
          break;
        for (j8 = 0; j8 < len; j8++) {
          var z6 = tmp[j8];
          p7;
          if (z6 === 0)
            continue;
          else if (z6 > 0)
            p7 = wnd[j8][z6 - 1 >> 1];
          else if (z6 < 0)
            p7 = wnd[j8][-z6 - 1 >> 1].neg();
          if (p7.type === "affine")
            acc = acc.mixedAdd(p7);
          else
            acc = acc.add(p7);
        }
      }
      for (i6 = 0; i6 < len; i6++)
        wnd[i6] = null;
      if (jacobianResult)
        return acc;
      else
        return acc.toP();
    };
    BaseCurve.BasePoint = BasePoint;
    BasePoint.prototype.eq = function eq() {
      throw new Error("Not implemented");
    };
    BasePoint.prototype.validate = function validate2() {
      return this.curve.validate(this);
    };
    BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      bytes = utils_1$1.toArray(bytes, enc);
      var len = this.p.byteLength();
      if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
        if (bytes[0] === 6)
          assert$1(bytes[bytes.length - 1] % 2 === 0);
        else if (bytes[0] === 7)
          assert$1(bytes[bytes.length - 1] % 2 === 1);
        var res = this.point(
          bytes.slice(1, 1 + len),
          bytes.slice(1 + len, 1 + 2 * len)
        );
        return res;
      } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
        return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
      }
      throw new Error("Unknown point format");
    };
    BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
      return this.encode(enc, true);
    };
    BasePoint.prototype._encode = function _encode2(compact) {
      var len = this.curve.p.byteLength();
      var x6 = this.getX().toArray("be", len);
      if (compact)
        return [this.getY().isEven() ? 2 : 3].concat(x6);
      return [4].concat(x6, this.getY().toArray("be", len));
    };
    BasePoint.prototype.encode = function encode2(enc, compact) {
      return utils_1$1.encode(this._encode(compact), enc);
    };
    BasePoint.prototype.precompute = function precompute(power) {
      if (this.precomputed)
        return this;
      var precomputed = {
        doubles: null,
        naf: null,
        beta: null
      };
      precomputed.naf = this._getNAFPoints(8);
      precomputed.doubles = this._getDoubles(4, power);
      precomputed.beta = this._getBeta();
      this.precomputed = precomputed;
      return this;
    };
    BasePoint.prototype._hasDoubles = function _hasDoubles(k8) {
      if (!this.precomputed)
        return false;
      var doubles = this.precomputed.doubles;
      if (!doubles)
        return false;
      return doubles.points.length >= Math.ceil((k8.bitLength() + 1) / doubles.step);
    };
    BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      var doubles = [this];
      var acc = this;
      for (var i6 = 0; i6 < power; i6 += step) {
        for (var j8 = 0; j8 < step; j8++)
          acc = acc.dbl();
        doubles.push(acc);
      }
      return {
        step,
        points: doubles
      };
    };
    BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      var res = [this];
      var max2 = (1 << wnd) - 1;
      var dbl3 = max2 === 1 ? null : this.dbl();
      for (var i6 = 1; i6 < max2; i6++)
        res[i6] = res[i6 - 1].add(dbl3);
      return {
        wnd,
        points: res
      };
    };
    BasePoint.prototype._getBeta = function _getBeta() {
      return null;
    };
    BasePoint.prototype.dblp = function dblp(k8) {
      var r6 = this;
      for (var i6 = 0; i6 < k8; i6++)
        r6 = r6.dbl();
      return r6;
    };
    inherits_browser = createCommonjsModule(function(module2) {
      if (typeof Object.create === "function") {
        module2.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          }
        };
      } else {
        module2.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          }
        };
      }
    });
    assert$2 = utils_1$1.assert;
    inherits_browser(ShortCurve, base);
    short_1 = ShortCurve;
    ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
      if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
        return;
      var beta;
      var lambda;
      if (conf.beta) {
        beta = new import_bn2.default(conf.beta, 16).toRed(this.red);
      } else {
        var betas = this._getEndoRoots(this.p);
        beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
        beta = beta.toRed(this.red);
      }
      if (conf.lambda) {
        lambda = new import_bn2.default(conf.lambda, 16);
      } else {
        var lambdas = this._getEndoRoots(this.n);
        if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
          lambda = lambdas[0];
        } else {
          lambda = lambdas[1];
          assert$2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
        }
      }
      var basis;
      if (conf.basis) {
        basis = conf.basis.map(function(vec) {
          return {
            a: new import_bn2.default(vec.a, 16),
            b: new import_bn2.default(vec.b, 16)
          };
        });
      } else {
        basis = this._getEndoBasis(lambda);
      }
      return {
        beta,
        lambda,
        basis
      };
    };
    ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
      var red = num === this.p ? this.red : import_bn2.default.mont(num);
      var tinv = new import_bn2.default(2).toRed(red).redInvm();
      var ntinv = tinv.redNeg();
      var s6 = new import_bn2.default(3).toRed(red).redNeg().redSqrt().redMul(tinv);
      var l1 = ntinv.redAdd(s6).fromRed();
      var l22 = ntinv.redSub(s6).fromRed();
      return [l1, l22];
    };
    ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
      var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
      var u7 = lambda;
      var v9 = this.n.clone();
      var x1 = new import_bn2.default(1);
      var y1 = new import_bn2.default(0);
      var x22 = new import_bn2.default(0);
      var y22 = new import_bn2.default(1);
      var a02;
      var b02;
      var a1;
      var b1;
      var a22;
      var b22;
      var prevR;
      var i6 = 0;
      var r6;
      var x6;
      while (u7.cmpn(0) !== 0) {
        var q8 = v9.div(u7);
        r6 = v9.sub(q8.mul(u7));
        x6 = x22.sub(q8.mul(x1));
        var y5 = y22.sub(q8.mul(y1));
        if (!a1 && r6.cmp(aprxSqrt) < 0) {
          a02 = prevR.neg();
          b02 = x1;
          a1 = r6.neg();
          b1 = x6;
        } else if (a1 && ++i6 === 2) {
          break;
        }
        prevR = r6;
        v9 = u7;
        u7 = r6;
        x22 = x1;
        x1 = x6;
        y22 = y1;
        y1 = y5;
      }
      a22 = r6.neg();
      b22 = x6;
      var len1 = a1.sqr().add(b1.sqr());
      var len2 = a22.sqr().add(b22.sqr());
      if (len2.cmp(len1) >= 0) {
        a22 = a02;
        b22 = b02;
      }
      if (a1.negative) {
        a1 = a1.neg();
        b1 = b1.neg();
      }
      if (a22.negative) {
        a22 = a22.neg();
        b22 = b22.neg();
      }
      return [
        { a: a1, b: b1 },
        { a: a22, b: b22 }
      ];
    };
    ShortCurve.prototype._endoSplit = function _endoSplit(k8) {
      var basis = this.endo.basis;
      var v1 = basis[0];
      var v22 = basis[1];
      var c1 = v22.b.mul(k8).divRound(this.n);
      var c22 = v1.b.neg().mul(k8).divRound(this.n);
      var p1 = c1.mul(v1.a);
      var p22 = c22.mul(v22.a);
      var q1 = c1.mul(v1.b);
      var q22 = c22.mul(v22.b);
      var k1 = k8.sub(p1).sub(p22);
      var k22 = q1.add(q22).neg();
      return { k1, k2: k22 };
    };
    ShortCurve.prototype.pointFromX = function pointFromX(x6, odd) {
      x6 = new import_bn2.default(x6, 16);
      if (!x6.red)
        x6 = x6.toRed(this.red);
      var y22 = x6.redSqr().redMul(x6).redIAdd(x6.redMul(this.a)).redIAdd(this.b);
      var y5 = y22.redSqrt();
      if (y5.redSqr().redSub(y22).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y5.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y5 = y5.redNeg();
      return this.point(x6, y5);
    };
    ShortCurve.prototype.validate = function validate3(point3) {
      if (point3.inf)
        return true;
      var x6 = point3.x;
      var y5 = point3.y;
      var ax = this.a.redMul(x6);
      var rhs = x6.redSqr().redMul(x6).redIAdd(ax).redIAdd(this.b);
      return y5.redSqr().redISub(rhs).cmpn(0) === 0;
    };
    ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i6 = 0; i6 < points.length; i6++) {
        var split = this._endoSplit(coeffs[i6]);
        var p7 = points[i6];
        var beta = p7._getBeta();
        if (split.k1.negative) {
          split.k1.ineg();
          p7 = p7.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }
        npoints[i6 * 2] = p7;
        npoints[i6 * 2 + 1] = beta;
        ncoeffs[i6 * 2] = split.k1;
        ncoeffs[i6 * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i6 * 2, jacobianResult);
      for (var j8 = 0; j8 < i6 * 2; j8++) {
        npoints[j8] = null;
        ncoeffs[j8] = null;
      }
      return res;
    };
    inherits_browser(Point, base.BasePoint);
    ShortCurve.prototype.point = function point2(x6, y5, isRed) {
      return new Point(this, x6, y5, isRed);
    };
    ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
      return Point.fromJSON(this, obj, red);
    };
    Point.prototype._getBeta = function _getBeta2() {
      if (!this.curve.endo)
        return;
      var pre = this.precomputed;
      if (pre && pre.beta)
        return pre.beta;
      var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (pre) {
        var curve = this.curve;
        var endoMul = function(p7) {
          return curve.point(p7.x.redMul(curve.endo.beta), p7.y);
        };
        pre.beta = beta;
        beta.precomputed = {
          beta: null,
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(endoMul)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(endoMul)
          }
        };
      }
      return beta;
    };
    Point.prototype.toJSON = function toJSON() {
      if (!this.precomputed)
        return [this.x, this.y];
      return [this.x, this.y, this.precomputed && {
        doubles: this.precomputed.doubles && {
          step: this.precomputed.doubles.step,
          points: this.precomputed.doubles.points.slice(1)
        },
        naf: this.precomputed.naf && {
          wnd: this.precomputed.naf.wnd,
          points: this.precomputed.naf.points.slice(1)
        }
      }];
    };
    Point.fromJSON = function fromJSON(curve, obj, red) {
      if (typeof obj === "string")
        obj = JSON.parse(obj);
      var res = curve.point(obj[0], obj[1], red);
      if (!obj[2])
        return res;
      function obj2point(obj2) {
        return curve.point(obj2[0], obj2[1], red);
      }
      var pre = obj[2];
      res.precomputed = {
        beta: null,
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: [res].concat(pre.doubles.points.map(obj2point))
        },
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: [res].concat(pre.naf.points.map(obj2point))
        }
      };
      return res;
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.inf;
    };
    Point.prototype.add = function add(p7) {
      if (this.inf)
        return p7;
      if (p7.inf)
        return this;
      if (this.eq(p7))
        return this.dbl();
      if (this.neg().eq(p7))
        return this.curve.point(null, null);
      if (this.x.cmp(p7.x) === 0)
        return this.curve.point(null, null);
      var c5 = this.y.redSub(p7.y);
      if (c5.cmpn(0) !== 0)
        c5 = c5.redMul(this.x.redSub(p7.x).redInvm());
      var nx = c5.redSqr().redISub(this.x).redISub(p7.x);
      var ny = c5.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.dbl = function dbl() {
      if (this.inf)
        return this;
      var ys1 = this.y.redAdd(this.y);
      if (ys1.cmpn(0) === 0)
        return this.curve.point(null, null);
      var a5 = this.curve.a;
      var x22 = this.x.redSqr();
      var dyinv = ys1.redInvm();
      var c5 = x22.redAdd(x22).redIAdd(x22).redIAdd(a5).redMul(dyinv);
      var nx = c5.redSqr().redISub(this.x.redAdd(this.x));
      var ny = c5.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.getX = function getX() {
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      return this.y.fromRed();
    };
    Point.prototype.mul = function mul(k8) {
      k8 = new import_bn2.default(k8, 16);
      if (this.isInfinity())
        return this;
      else if (this._hasDoubles(k8))
        return this.curve._fixedNafMul(this, k8);
      else if (this.curve.endo)
        return this.curve._endoWnafMulAdd([this], [k8]);
      else
        return this.curve._wnafMul(this, k8);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p22, k22) {
      var points = [this, p22];
      var coeffs = [k1, k22];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p22, k22) {
      var points = [this, p22];
      var coeffs = [k1, k22];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs, true);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
    };
    Point.prototype.eq = function eq2(p7) {
      return this === p7 || this.inf === p7.inf && (this.inf || this.x.cmp(p7.x) === 0 && this.y.cmp(p7.y) === 0);
    };
    Point.prototype.neg = function neg(_precompute) {
      if (this.inf)
        return this;
      var res = this.curve.point(this.x, this.y.redNeg());
      if (_precompute && this.precomputed) {
        var pre = this.precomputed;
        var negate = function(p7) {
          return p7.neg();
        };
        res.precomputed = {
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(negate)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(negate)
          }
        };
      }
      return res;
    };
    Point.prototype.toJ = function toJ() {
      if (this.inf)
        return this.curve.jpoint(null, null, null);
      var res = this.curve.jpoint(this.x, this.y, this.curve.one);
      return res;
    };
    inherits_browser(JPoint, base.BasePoint);
    ShortCurve.prototype.jpoint = function jpoint(x6, y5, z6) {
      return new JPoint(this, x6, y5, z6);
    };
    JPoint.prototype.toP = function toP() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var zinv = this.z.redInvm();
      var zinv2 = zinv.redSqr();
      var ax = this.x.redMul(zinv2);
      var ay = this.y.redMul(zinv2).redMul(zinv);
      return this.curve.point(ax, ay);
    };
    JPoint.prototype.neg = function neg2() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };
    JPoint.prototype.add = function add2(p7) {
      if (this.isInfinity())
        return p7;
      if (p7.isInfinity())
        return this;
      var pz2 = p7.z.redSqr();
      var z22 = this.z.redSqr();
      var u1 = this.x.redMul(pz2);
      var u22 = p7.x.redMul(z22);
      var s1 = this.y.redMul(pz2.redMul(p7.z));
      var s22 = p7.y.redMul(z22.redMul(this.z));
      var h6 = u1.redSub(u22);
      var r6 = s1.redSub(s22);
      if (h6.cmpn(0) === 0) {
        if (r6.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h22 = h6.redSqr();
      var h32 = h22.redMul(h6);
      var v9 = u1.redMul(h22);
      var nx = r6.redSqr().redIAdd(h32).redISub(v9).redISub(v9);
      var ny = r6.redMul(v9.redISub(nx)).redISub(s1.redMul(h32));
      var nz = this.z.redMul(p7.z).redMul(h6);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mixedAdd = function mixedAdd(p7) {
      if (this.isInfinity())
        return p7.toJ();
      if (p7.isInfinity())
        return this;
      var z22 = this.z.redSqr();
      var u1 = this.x;
      var u22 = p7.x.redMul(z22);
      var s1 = this.y;
      var s22 = p7.y.redMul(z22).redMul(this.z);
      var h6 = u1.redSub(u22);
      var r6 = s1.redSub(s22);
      if (h6.cmpn(0) === 0) {
        if (r6.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h22 = h6.redSqr();
      var h32 = h22.redMul(h6);
      var v9 = u1.redMul(h22);
      var nx = r6.redSqr().redIAdd(h32).redISub(v9).redISub(v9);
      var ny = r6.redMul(v9.redISub(nx)).redISub(s1.redMul(h32));
      var nz = this.z.redMul(h6);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.dblp = function dblp2(pow) {
      if (pow === 0)
        return this;
      if (this.isInfinity())
        return this;
      if (!pow)
        return this.dbl();
      var i6;
      if (this.curve.zeroA || this.curve.threeA) {
        var r6 = this;
        for (i6 = 0; i6 < pow; i6++)
          r6 = r6.dbl();
        return r6;
      }
      var a5 = this.curve.a;
      var tinv = this.curve.tinv;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jyd = jy.redAdd(jy);
      for (i6 = 0; i6 < pow; i6++) {
        var jx2 = jx.redSqr();
        var jyd2 = jyd.redSqr();
        var jyd4 = jyd2.redSqr();
        var c5 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a5.redMul(jz4));
        var t12 = jx.redMul(jyd2);
        var nx = c5.redSqr().redISub(t12.redAdd(t12));
        var t22 = t12.redISub(nx);
        var dny = c5.redMul(t22);
        dny = dny.redIAdd(dny).redISub(jyd4);
        var nz = jyd.redMul(jz);
        if (i6 + 1 < pow)
          jz4 = jz4.redMul(jyd4);
        jx = nx;
        jz = nz;
        jyd = dny;
      }
      return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
    };
    JPoint.prototype.dbl = function dbl2() {
      if (this.isInfinity())
        return this;
      if (this.curve.zeroA)
        return this._zeroDbl();
      else if (this.curve.threeA)
        return this._threeDbl();
      else
        return this._dbl();
    };
    JPoint.prototype._zeroDbl = function _zeroDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s6 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s6 = s6.redIAdd(s6);
        var m6 = xx.redAdd(xx).redIAdd(xx);
        var t6 = m6.redSqr().redISub(s6).redISub(s6);
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        nx = t6;
        ny = m6.redMul(s6.redISub(t6)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var a5 = this.x.redSqr();
        var b4 = this.y.redSqr();
        var c5 = b4.redSqr();
        var d6 = this.x.redAdd(b4).redSqr().redISub(a5).redISub(c5);
        d6 = d6.redIAdd(d6);
        var e6 = a5.redAdd(a5).redIAdd(a5);
        var f7 = e6.redSqr();
        var c8 = c5.redIAdd(c5);
        c8 = c8.redIAdd(c8);
        c8 = c8.redIAdd(c8);
        nx = f7.redISub(d6).redISub(d6);
        ny = e6.redMul(d6.redISub(nx)).redISub(c8);
        nz = this.y.redMul(this.z);
        nz = nz.redIAdd(nz);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._threeDbl = function _threeDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s6 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s6 = s6.redIAdd(s6);
        var m6 = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
        var t6 = m6.redSqr().redISub(s6).redISub(s6);
        nx = t6;
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        ny = m6.redMul(s6.redISub(t6)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var delta = this.z.redSqr();
        var gamma = this.y.redSqr();
        var beta = this.x.redMul(gamma);
        var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
        alpha = alpha.redAdd(alpha).redIAdd(alpha);
        var beta4 = beta.redIAdd(beta);
        beta4 = beta4.redIAdd(beta4);
        var beta8 = beta4.redAdd(beta4);
        nx = alpha.redSqr().redISub(beta8);
        nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
        var ggamma8 = gamma.redSqr();
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._dbl = function _dbl() {
      var a5 = this.curve.a;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jx2 = jx.redSqr();
      var jy2 = jy.redSqr();
      var c5 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a5.redMul(jz4));
      var jxd4 = jx.redAdd(jx);
      jxd4 = jxd4.redIAdd(jxd4);
      var t12 = jxd4.redMul(jy2);
      var nx = c5.redSqr().redISub(t12.redAdd(t12));
      var t22 = t12.redISub(nx);
      var jyd8 = jy2.redSqr();
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      var ny = c5.redMul(t22).redISub(jyd8);
      var nz = jy.redAdd(jy).redMul(jz);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.trpl = function trpl() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var zz = this.z.redSqr();
      var yyyy = yy.redSqr();
      var m6 = xx.redAdd(xx).redIAdd(xx);
      var mm = m6.redSqr();
      var e6 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      e6 = e6.redIAdd(e6);
      e6 = e6.redAdd(e6).redIAdd(e6);
      e6 = e6.redISub(mm);
      var ee3 = e6.redSqr();
      var t6 = yyyy.redIAdd(yyyy);
      t6 = t6.redIAdd(t6);
      t6 = t6.redIAdd(t6);
      t6 = t6.redIAdd(t6);
      var u7 = m6.redIAdd(e6).redSqr().redISub(mm).redISub(ee3).redISub(t6);
      var yyu4 = yy.redMul(u7);
      yyu4 = yyu4.redIAdd(yyu4);
      yyu4 = yyu4.redIAdd(yyu4);
      var nx = this.x.redMul(ee3).redISub(yyu4);
      nx = nx.redIAdd(nx);
      nx = nx.redIAdd(nx);
      var ny = this.y.redMul(u7.redMul(t6.redISub(u7)).redISub(e6.redMul(ee3)));
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      var nz = this.z.redAdd(e6).redSqr().redISub(zz).redISub(ee3);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mul = function mul2(k8, kbase) {
      k8 = new import_bn2.default(k8, kbase);
      return this.curve._wnafMul(this, k8);
    };
    JPoint.prototype.eq = function eq3(p7) {
      if (p7.type === "affine")
        return this.eq(p7.toJ());
      if (this === p7)
        return true;
      var z22 = this.z.redSqr();
      var pz2 = p7.z.redSqr();
      if (this.x.redMul(pz2).redISub(p7.x.redMul(z22)).cmpn(0) !== 0)
        return false;
      var z32 = z22.redMul(this.z);
      var pz3 = pz2.redMul(p7.z);
      return this.y.redMul(pz3).redISub(p7.y.redMul(z32)).cmpn(0) === 0;
    };
    JPoint.prototype.eqXToP = function eqXToP(x6) {
      var zs2 = this.z.redSqr();
      var rx = x6.toRed(this.curve.red).redMul(zs2);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x6.clone();
      var t6 = this.curve.redN.redMul(zs2);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t6);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    JPoint.prototype.inspect = function inspect2() {
      if (this.isInfinity())
        return "<EC JPoint Infinity>";
      return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    };
    JPoint.prototype.isInfinity = function isInfinity2() {
      return this.z.cmpn(0) === 0;
    };
    curve_1 = createCommonjsModule(function(module2, exports2) {
      "use strict";
      var curve = exports2;
      curve.base = base;
      curve.short = short_1;
      curve.mont = null;
      curve.edwards = null;
    });
    curves_1 = createCommonjsModule(function(module2, exports2) {
      "use strict";
      var curves = exports2;
      var assert3 = utils_1$1.assert;
      function PresetCurve(options) {
        if (options.type === "short")
          this.curve = new curve_1.short(options);
        else if (options.type === "edwards")
          this.curve = new curve_1.edwards(options);
        else
          this.curve = new curve_1.mont(options);
        this.g = this.curve.g;
        this.n = this.curve.n;
        this.hash = options.hash;
        assert3(this.g.validate(), "Invalid curve");
        assert3(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
      }
      curves.PresetCurve = PresetCurve;
      function defineCurve(name2, options) {
        Object.defineProperty(curves, name2, {
          configurable: true,
          enumerable: true,
          get: function() {
            var curve = new PresetCurve(options);
            Object.defineProperty(curves, name2, {
              configurable: true,
              enumerable: true,
              value: curve
            });
            return curve;
          }
        });
      }
      defineCurve("p192", {
        type: "short",
        prime: "p192",
        p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
        a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
        b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
        n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
        hash: import_hash2.default.sha256,
        gRed: false,
        g: [
          "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
          "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
        ]
      });
      defineCurve("p224", {
        type: "short",
        prime: "p224",
        p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
        a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
        b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
        n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
        hash: import_hash2.default.sha256,
        gRed: false,
        g: [
          "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
          "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
        ]
      });
      defineCurve("p256", {
        type: "short",
        prime: null,
        p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
        a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
        b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
        n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
        hash: import_hash2.default.sha256,
        gRed: false,
        g: [
          "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
          "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
        ]
      });
      defineCurve("p384", {
        type: "short",
        prime: null,
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
        a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
        b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
        n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
        hash: import_hash2.default.sha384,
        gRed: false,
        g: [
          "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
          "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
        ]
      });
      defineCurve("p521", {
        type: "short",
        prime: null,
        p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
        a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
        b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
        n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
        hash: import_hash2.default.sha512,
        gRed: false,
        g: [
          "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
          "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
        ]
      });
      defineCurve("curve25519", {
        type: "mont",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "76d06",
        b: "1",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: import_hash2.default.sha256,
        gRed: false,
        g: [
          "9"
        ]
      });
      defineCurve("ed25519", {
        type: "edwards",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "-1",
        c: "1",
        d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: import_hash2.default.sha256,
        gRed: false,
        g: [
          "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
          "6666666666666666666666666666666666666666666666666666666666666658"
        ]
      });
      var pre;
      try {
        pre = null.crash();
      } catch (e6) {
        pre = void 0;
      }
      defineCurve("secp256k1", {
        type: "short",
        prime: "k256",
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
        a: "0",
        b: "7",
        n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
        h: "1",
        hash: import_hash2.default.sha256,
        beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
        lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
        basis: [
          {
            a: "3086d221a7d46bcde86c90e49284eb15",
            b: "-e4437ed6010e88286f547fa90abfe4c3"
          },
          {
            a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
            b: "3086d221a7d46bcde86c90e49284eb15"
          }
        ],
        gRed: false,
        g: [
          "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
          "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
          pre
        ]
      });
    });
    hmacDrbg = HmacDRBG;
    HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
      var seed = entropy.concat(nonce).concat(pers);
      this.K = new Array(this.outLen / 8);
      this.V = new Array(this.outLen / 8);
      for (var i6 = 0; i6 < this.V.length; i6++) {
        this.K[i6] = 0;
        this.V[i6] = 1;
      }
      this._update(seed);
      this._reseed = 1;
      this.reseedInterval = 281474976710656;
    };
    HmacDRBG.prototype._hmac = function hmac() {
      return new import_hash2.default.hmac(this.hash, this.K);
    };
    HmacDRBG.prototype._update = function update(seed) {
      var kmac = this._hmac().update(this.V).update([0]);
      if (seed)
        kmac = kmac.update(seed);
      this.K = kmac.digest();
      this.V = this._hmac().update(this.V).digest();
      if (!seed)
        return;
      this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
      this.V = this._hmac().update(this.V).digest();
    };
    HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add3, addEnc) {
      if (typeof entropyEnc !== "string") {
        addEnc = add3;
        add3 = entropyEnc;
        entropyEnc = null;
      }
      entropy = utils_1.toArray(entropy, entropyEnc);
      add3 = utils_1.toArray(add3, addEnc);
      minimalisticAssert(
        entropy.length >= this.minEntropy / 8,
        "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
      );
      this._update(entropy.concat(add3 || []));
      this._reseed = 1;
    };
    HmacDRBG.prototype.generate = function generate(len, enc, add3, addEnc) {
      if (this._reseed > this.reseedInterval)
        throw new Error("Reseed is required");
      if (typeof enc !== "string") {
        addEnc = add3;
        add3 = enc;
        enc = null;
      }
      if (add3) {
        add3 = utils_1.toArray(add3, addEnc || "hex");
        this._update(add3);
      }
      var temp = [];
      while (temp.length < len) {
        this.V = this._hmac().update(this.V).digest();
        temp = temp.concat(this.V);
      }
      var res = temp.slice(0, len);
      this._update(add3);
      this._reseed++;
      return utils_1.encode(res, enc);
    };
    assert$3 = utils_1$1.assert;
    key = KeyPair;
    KeyPair.fromPublic = function fromPublic(ec2, pub, enc) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(ec2, {
        pub,
        pubEnc: enc
      });
    };
    KeyPair.fromPrivate = function fromPrivate(ec2, priv, enc) {
      if (priv instanceof KeyPair)
        return priv;
      return new KeyPair(ec2, {
        priv,
        privEnc: enc
      });
    };
    KeyPair.prototype.validate = function validate4() {
      var pub = this.getPublic();
      if (pub.isInfinity())
        return { result: false, reason: "Invalid public key" };
      if (!pub.validate())
        return { result: false, reason: "Public key is not a point" };
      if (!pub.mul(this.ec.curve.n).isInfinity())
        return { result: false, reason: "Public key * N != O" };
      return { result: true, reason: null };
    };
    KeyPair.prototype.getPublic = function getPublic(compact, enc) {
      if (typeof compact === "string") {
        enc = compact;
        compact = null;
      }
      if (!this.pub)
        this.pub = this.ec.g.mul(this.priv);
      if (!enc)
        return this.pub;
      return this.pub.encode(enc, compact);
    };
    KeyPair.prototype.getPrivate = function getPrivate(enc) {
      if (enc === "hex")
        return this.priv.toString(16, 2);
      else
        return this.priv;
    };
    KeyPair.prototype._importPrivate = function _importPrivate(key2, enc) {
      this.priv = new import_bn2.default(key2, enc || 16);
      this.priv = this.priv.umod(this.ec.curve.n);
    };
    KeyPair.prototype._importPublic = function _importPublic(key2, enc) {
      if (key2.x || key2.y) {
        if (this.ec.curve.type === "mont") {
          assert$3(key2.x, "Need x coordinate");
        } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
          assert$3(key2.x && key2.y, "Need both x and y coordinate");
        }
        this.pub = this.ec.curve.point(key2.x, key2.y);
        return;
      }
      this.pub = this.ec.curve.decodePoint(key2, enc);
    };
    KeyPair.prototype.derive = function derive(pub) {
      if (!pub.validate()) {
        assert$3(pub.validate(), "public point not validated");
      }
      return pub.mul(this.priv).getX();
    };
    KeyPair.prototype.sign = function sign(msg, enc, options) {
      return this.ec.sign(msg, this, enc, options);
    };
    KeyPair.prototype.verify = function verify(msg, signature2) {
      return this.ec.verify(msg, signature2, this);
    };
    KeyPair.prototype.inspect = function inspect3() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
    assert$4 = utils_1$1.assert;
    signature = Signature;
    Signature.prototype._importDER = function _importDER(data, enc) {
      data = utils_1$1.toArray(data, enc);
      var p7 = new Position();
      if (data[p7.place++] !== 48) {
        return false;
      }
      var len = getLength(data, p7);
      if (len === false) {
        return false;
      }
      if (len + p7.place !== data.length) {
        return false;
      }
      if (data[p7.place++] !== 2) {
        return false;
      }
      var rlen = getLength(data, p7);
      if (rlen === false) {
        return false;
      }
      var r6 = data.slice(p7.place, rlen + p7.place);
      p7.place += rlen;
      if (data[p7.place++] !== 2) {
        return false;
      }
      var slen = getLength(data, p7);
      if (slen === false) {
        return false;
      }
      if (data.length !== slen + p7.place) {
        return false;
      }
      var s6 = data.slice(p7.place, slen + p7.place);
      if (r6[0] === 0) {
        if (r6[1] & 128) {
          r6 = r6.slice(1);
        } else {
          return false;
        }
      }
      if (s6[0] === 0) {
        if (s6[1] & 128) {
          s6 = s6.slice(1);
        } else {
          return false;
        }
      }
      this.r = new import_bn2.default(r6);
      this.s = new import_bn2.default(s6);
      this.recoveryParam = null;
      return true;
    };
    Signature.prototype.toDER = function toDER(enc) {
      var r6 = this.r.toArray();
      var s6 = this.s.toArray();
      if (r6[0] & 128)
        r6 = [0].concat(r6);
      if (s6[0] & 128)
        s6 = [0].concat(s6);
      r6 = rmPadding(r6);
      s6 = rmPadding(s6);
      while (!s6[0] && !(s6[1] & 128)) {
        s6 = s6.slice(1);
      }
      var arr = [2];
      constructLength(arr, r6.length);
      arr = arr.concat(r6);
      arr.push(2);
      constructLength(arr, s6.length);
      var backHalf = arr.concat(s6);
      var res = [48];
      constructLength(res, backHalf.length);
      res = res.concat(backHalf);
      return utils_1$1.encode(res, enc);
    };
    rand = function() {
      throw new Error("unsupported");
    };
    assert$5 = utils_1$1.assert;
    ec = EC;
    EC.prototype.keyPair = function keyPair(options) {
      return new key(this, options);
    };
    EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
      return key.fromPrivate(this, priv, enc);
    };
    EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
      return key.fromPublic(this, pub, enc);
    };
    EC.prototype.genKeyPair = function genKeyPair(options) {
      if (!options)
        options = {};
      var drbg = new hmacDrbg({
        hash: this.hash,
        pers: options.pers,
        persEnc: options.persEnc || "utf8",
        entropy: options.entropy || rand(this.hash.hmacStrength),
        entropyEnc: options.entropy && options.entropyEnc || "utf8",
        nonce: this.n.toArray()
      });
      var bytes = this.n.byteLength();
      var ns2 = this.n.sub(new import_bn2.default(2));
      for (; ; ) {
        var priv = new import_bn2.default(drbg.generate(bytes));
        if (priv.cmp(ns2) > 0)
          continue;
        priv.iaddn(1);
        return this.keyFromPrivate(priv);
      }
    };
    EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
      var delta = msg.byteLength() * 8 - this.n.bitLength();
      if (delta > 0)
        msg = msg.ushrn(delta);
      if (!truncOnly && msg.cmp(this.n) >= 0)
        return msg.sub(this.n);
      else
        return msg;
    };
    EC.prototype.sign = function sign2(msg, key2, enc, options) {
      if (typeof enc === "object") {
        options = enc;
        enc = null;
      }
      if (!options)
        options = {};
      key2 = this.keyFromPrivate(key2, enc);
      msg = this._truncateToN(new import_bn2.default(msg, 16));
      var bytes = this.n.byteLength();
      var bkey = key2.getPrivate().toArray("be", bytes);
      var nonce = msg.toArray("be", bytes);
      var drbg = new hmacDrbg({
        hash: this.hash,
        entropy: bkey,
        nonce,
        pers: options.pers,
        persEnc: options.persEnc || "utf8"
      });
      var ns1 = this.n.sub(new import_bn2.default(1));
      for (var iter = 0; ; iter++) {
        var k8 = options.k ? options.k(iter) : new import_bn2.default(drbg.generate(this.n.byteLength()));
        k8 = this._truncateToN(k8, true);
        if (k8.cmpn(1) <= 0 || k8.cmp(ns1) >= 0)
          continue;
        var kp2 = this.g.mul(k8);
        if (kp2.isInfinity())
          continue;
        var kpX = kp2.getX();
        var r6 = kpX.umod(this.n);
        if (r6.cmpn(0) === 0)
          continue;
        var s6 = k8.invm(this.n).mul(r6.mul(key2.getPrivate()).iadd(msg));
        s6 = s6.umod(this.n);
        if (s6.cmpn(0) === 0)
          continue;
        var recoveryParam = (kp2.getY().isOdd() ? 1 : 0) | (kpX.cmp(r6) !== 0 ? 2 : 0);
        if (options.canonical && s6.cmp(this.nh) > 0) {
          s6 = this.n.sub(s6);
          recoveryParam ^= 1;
        }
        return new signature({ r: r6, s: s6, recoveryParam });
      }
    };
    EC.prototype.verify = function verify2(msg, signature$1, key2, enc) {
      msg = this._truncateToN(new import_bn2.default(msg, 16));
      key2 = this.keyFromPublic(key2, enc);
      signature$1 = new signature(signature$1, "hex");
      var r6 = signature$1.r;
      var s6 = signature$1.s;
      if (r6.cmpn(1) < 0 || r6.cmp(this.n) >= 0)
        return false;
      if (s6.cmpn(1) < 0 || s6.cmp(this.n) >= 0)
        return false;
      var sinv = s6.invm(this.n);
      var u1 = sinv.mul(msg).umod(this.n);
      var u22 = sinv.mul(r6).umod(this.n);
      var p7;
      if (!this.curve._maxwellTrick) {
        p7 = this.g.mulAdd(u1, key2.getPublic(), u22);
        if (p7.isInfinity())
          return false;
        return p7.getX().umod(this.n).cmp(r6) === 0;
      }
      p7 = this.g.jmulAdd(u1, key2.getPublic(), u22);
      if (p7.isInfinity())
        return false;
      return p7.eqXToP(r6);
    };
    EC.prototype.recoverPubKey = function(msg, signature$1, j8, enc) {
      assert$5((3 & j8) === j8, "The recovery param is more than two bits");
      signature$1 = new signature(signature$1, enc);
      var n4 = this.n;
      var e6 = new import_bn2.default(msg);
      var r6 = signature$1.r;
      var s6 = signature$1.s;
      var isYOdd = j8 & 1;
      var isSecondKey = j8 >> 1;
      if (r6.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
        throw new Error("Unable to find sencond key candinate");
      if (isSecondKey)
        r6 = this.curve.pointFromX(r6.add(this.curve.n), isYOdd);
      else
        r6 = this.curve.pointFromX(r6, isYOdd);
      var rInv = signature$1.r.invm(n4);
      var s1 = n4.sub(e6).mul(rInv).umod(n4);
      var s22 = s6.mul(rInv).umod(n4);
      return this.g.mulAdd(s1, r6, s22);
    };
    EC.prototype.getKeyRecoveryParam = function(e6, signature$1, Q3, enc) {
      signature$1 = new signature(signature$1, enc);
      if (signature$1.recoveryParam !== null)
        return signature$1.recoveryParam;
      for (var i6 = 0; i6 < 4; i6++) {
        var Qprime;
        try {
          Qprime = this.recoverPubKey(e6, signature$1, i6);
        } catch (e7) {
          continue;
        }
        if (Qprime.eq(Q3))
          return i6;
      }
      throw new Error("Unable to find valid recovery factor");
    };
    elliptic_1 = createCommonjsModule(function(module2, exports2) {
      "use strict";
      var elliptic = exports2;
      elliptic.version = { version: "6.5.4" }.version;
      elliptic.utils = utils_1$1;
      elliptic.rand = function() {
        throw new Error("unsupported");
      };
      elliptic.curve = curve_1;
      elliptic.curves = curves_1;
      elliptic.ec = ec;
      elliptic.eddsa = null;
    });
    EC$1 = elliptic_1.ec;
  }
});

// node_modules/@ethersproject/signing-key/lib.esm/_version.js
var version12;
var init_version12 = __esm({
  "node_modules/@ethersproject/signing-key/lib.esm/_version.js"() {
    version12 = "signing-key/5.6.0";
  }
});

// node_modules/@ethersproject/signing-key/lib.esm/index.js
var lib_exports11 = {};
__export(lib_exports11, {
  SigningKey: () => SigningKey,
  computePublicKey: () => computePublicKey,
  recoverPublicKey: () => recoverPublicKey
});
function getCurve() {
  if (!_curve) {
    _curve = new EC$1("secp256k1");
  }
  return _curve;
}
function recoverPublicKey(digest, signature2) {
  const sig = splitSignature(signature2);
  const rs = { r: arrayify(sig.r), s: arrayify(sig.s) };
  return "0x" + getCurve().recoverPubKey(arrayify(digest), rs, sig.recoveryParam).encode("hex", false);
}
function computePublicKey(key2, compressed) {
  const bytes = arrayify(key2);
  if (bytes.length === 32) {
    const signingKey = new SigningKey(bytes);
    if (compressed) {
      return "0x" + getCurve().keyFromPrivate(bytes).getPublic(true, "hex");
    }
    return signingKey.publicKey;
  } else if (bytes.length === 33) {
    if (compressed) {
      return hexlify(bytes);
    }
    return "0x" + getCurve().keyFromPublic(bytes).getPublic(false, "hex");
  } else if (bytes.length === 65) {
    if (!compressed) {
      return hexlify(bytes);
    }
    return "0x" + getCurve().keyFromPublic(bytes).getPublic(true, "hex");
  }
  return logger17.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}
var logger17, _curve, SigningKey;
var init_lib14 = __esm({
  "node_modules/@ethersproject/signing-key/lib.esm/index.js"() {
    "use strict";
    init_elliptic();
    init_lib2();
    init_lib4();
    init_lib();
    init_version12();
    logger17 = new Logger(version12);
    _curve = null;
    SigningKey = class {
      constructor(privateKey) {
        defineReadOnly(this, "curve", "secp256k1");
        defineReadOnly(this, "privateKey", hexlify(privateKey));
        const keyPair2 = getCurve().keyFromPrivate(arrayify(this.privateKey));
        defineReadOnly(this, "publicKey", "0x" + keyPair2.getPublic(false, "hex"));
        defineReadOnly(this, "compressedPublicKey", "0x" + keyPair2.getPublic(true, "hex"));
        defineReadOnly(this, "_isSigningKey", true);
      }
      _addPoint(other) {
        const p0 = getCurve().keyFromPublic(arrayify(this.publicKey));
        const p1 = getCurve().keyFromPublic(arrayify(other));
        return "0x" + p0.pub.add(p1.pub).encodeCompressed("hex");
      }
      signDigest(digest) {
        const keyPair2 = getCurve().keyFromPrivate(arrayify(this.privateKey));
        const digestBytes = arrayify(digest);
        if (digestBytes.length !== 32) {
          logger17.throwArgumentError("bad digest length", "digest", digest);
        }
        const signature2 = keyPair2.sign(digestBytes, { canonical: true });
        return splitSignature({
          recoveryParam: signature2.recoveryParam,
          r: hexZeroPad("0x" + signature2.r.toString(16), 32),
          s: hexZeroPad("0x" + signature2.s.toString(16), 32)
        });
      }
      computeSharedSecret(otherKey) {
        const keyPair2 = getCurve().keyFromPrivate(arrayify(this.privateKey));
        const otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));
        return hexZeroPad("0x" + keyPair2.derive(otherKeyPair.getPublic()).toString(16), 32);
      }
      static isSigningKey(value2) {
        return !!(value2 && value2._isSigningKey);
      }
    };
  }
});

// node_modules/@ethersproject/transactions/lib.esm/_version.js
var version13;
var init_version13 = __esm({
  "node_modules/@ethersproject/transactions/lib.esm/_version.js"() {
    version13 = "transactions/5.6.0";
  }
});

// node_modules/@ethersproject/transactions/lib.esm/index.js
var lib_exports12 = {};
__export(lib_exports12, {
  TransactionTypes: () => TransactionTypes,
  accessListify: () => accessListify,
  computeAddress: () => computeAddress,
  parse: () => parse,
  recoverAddress: () => recoverAddress,
  serialize: () => serialize
});
function handleAddress(value2) {
  if (value2 === "0x") {
    return null;
  }
  return getAddress(value2);
}
function handleNumber(value2) {
  if (value2 === "0x") {
    return Zero2;
  }
  return BigNumber.from(value2);
}
function computeAddress(key2) {
  const publicKey = computePublicKey(key2);
  return getAddress(hexDataSlice(keccak256(hexDataSlice(publicKey, 1)), 12));
}
function recoverAddress(digest, signature2) {
  return computeAddress(recoverPublicKey(arrayify(digest), signature2));
}
function formatNumber(value2, name2) {
  const result = stripZeros(BigNumber.from(value2).toHexString());
  if (result.length > 32) {
    logger18.throwArgumentError("invalid length for " + name2, "transaction:" + name2, value2);
  }
  return result;
}
function accessSetify(addr, storageKeys) {
  return {
    address: getAddress(addr),
    storageKeys: (storageKeys || []).map((storageKey, index) => {
      if (hexDataLength(storageKey) !== 32) {
        logger18.throwArgumentError("invalid access list storageKey", `accessList[${addr}:${index}]`, storageKey);
      }
      return storageKey.toLowerCase();
    })
  };
}
function accessListify(value2) {
  if (Array.isArray(value2)) {
    return value2.map((set, index) => {
      if (Array.isArray(set)) {
        if (set.length > 2) {
          logger18.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${index}]`, set);
        }
        return accessSetify(set[0], set[1]);
      }
      return accessSetify(set.address, set.storageKeys);
    });
  }
  const result = Object.keys(value2).map((addr) => {
    const storageKeys = value2[addr].reduce((accum, storageKey) => {
      accum[storageKey] = true;
      return accum;
    }, {});
    return accessSetify(addr, Object.keys(storageKeys).sort());
  });
  result.sort((a5, b4) => a5.address.localeCompare(b4.address));
  return result;
}
function formatAccessList(value2) {
  return accessListify(value2).map((set) => [set.address, set.storageKeys]);
}
function _serializeEip1559(transaction, signature2) {
  if (transaction.gasPrice != null) {
    const gasPrice = BigNumber.from(transaction.gasPrice);
    const maxFeePerGas = BigNumber.from(transaction.maxFeePerGas || 0);
    if (!gasPrice.eq(maxFeePerGas)) {
      logger18.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
        gasPrice,
        maxFeePerGas
      });
    }
  }
  const fields = [
    formatNumber(transaction.chainId || 0, "chainId"),
    formatNumber(transaction.nonce || 0, "nonce"),
    formatNumber(transaction.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(transaction.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(transaction.gasLimit || 0, "gasLimit"),
    transaction.to != null ? getAddress(transaction.to) : "0x",
    formatNumber(transaction.value || 0, "value"),
    transaction.data || "0x",
    formatAccessList(transaction.accessList || [])
  ];
  if (signature2) {
    const sig = splitSignature(signature2);
    fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
    fields.push(stripZeros(sig.r));
    fields.push(stripZeros(sig.s));
  }
  return hexConcat(["0x02", encode(fields)]);
}
function _serializeEip2930(transaction, signature2) {
  const fields = [
    formatNumber(transaction.chainId || 0, "chainId"),
    formatNumber(transaction.nonce || 0, "nonce"),
    formatNumber(transaction.gasPrice || 0, "gasPrice"),
    formatNumber(transaction.gasLimit || 0, "gasLimit"),
    transaction.to != null ? getAddress(transaction.to) : "0x",
    formatNumber(transaction.value || 0, "value"),
    transaction.data || "0x",
    formatAccessList(transaction.accessList || [])
  ];
  if (signature2) {
    const sig = splitSignature(signature2);
    fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
    fields.push(stripZeros(sig.r));
    fields.push(stripZeros(sig.s));
  }
  return hexConcat(["0x01", encode(fields)]);
}
function _serialize(transaction, signature2) {
  checkProperties(transaction, allowedTransactionKeys2);
  const raw = [];
  transactionFields.forEach(function(fieldInfo) {
    let value2 = transaction[fieldInfo.name] || [];
    const options = {};
    if (fieldInfo.numeric) {
      options.hexPad = "left";
    }
    value2 = arrayify(hexlify(value2, options));
    if (fieldInfo.length && value2.length !== fieldInfo.length && value2.length > 0) {
      logger18.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value2);
    }
    if (fieldInfo.maxLength) {
      value2 = stripZeros(value2);
      if (value2.length > fieldInfo.maxLength) {
        logger18.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value2);
      }
    }
    raw.push(hexlify(value2));
  });
  let chainId = 0;
  if (transaction.chainId != null) {
    chainId = transaction.chainId;
    if (typeof chainId !== "number") {
      logger18.throwArgumentError("invalid transaction.chainId", "transaction", transaction);
    }
  } else if (signature2 && !isBytesLike(signature2) && signature2.v > 28) {
    chainId = Math.floor((signature2.v - 35) / 2);
  }
  if (chainId !== 0) {
    raw.push(hexlify(chainId));
    raw.push("0x");
    raw.push("0x");
  }
  if (!signature2) {
    return encode(raw);
  }
  const sig = splitSignature(signature2);
  let v9 = 27 + sig.recoveryParam;
  if (chainId !== 0) {
    raw.pop();
    raw.pop();
    raw.pop();
    v9 += chainId * 2 + 8;
    if (sig.v > 28 && sig.v !== v9) {
      logger18.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature2);
    }
  } else if (sig.v !== v9) {
    logger18.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature2);
  }
  raw.push(hexlify(v9));
  raw.push(stripZeros(arrayify(sig.r)));
  raw.push(stripZeros(arrayify(sig.s)));
  return encode(raw);
}
function serialize(transaction, signature2) {
  if (transaction.type == null || transaction.type === 0) {
    if (transaction.accessList != null) {
      logger18.throwArgumentError("untyped transactions do not support accessList; include type: 1", "transaction", transaction);
    }
    return _serialize(transaction, signature2);
  }
  switch (transaction.type) {
    case 1:
      return _serializeEip2930(transaction, signature2);
    case 2:
      return _serializeEip1559(transaction, signature2);
    default:
      break;
  }
  return logger18.throwError(`unsupported transaction type: ${transaction.type}`, Logger.errors.UNSUPPORTED_OPERATION, {
    operation: "serializeTransaction",
    transactionType: transaction.type
  });
}
function _parseEipSignature(tx, fields, serialize3) {
  try {
    const recid = handleNumber(fields[0]).toNumber();
    if (recid !== 0 && recid !== 1) {
      throw new Error("bad recid");
    }
    tx.v = recid;
  } catch (error) {
    logger18.throwArgumentError("invalid v for transaction type: 1", "v", fields[0]);
  }
  tx.r = hexZeroPad(fields[1], 32);
  tx.s = hexZeroPad(fields[2], 32);
  try {
    const digest = keccak256(serialize3(tx));
    tx.from = recoverAddress(digest, { r: tx.r, s: tx.s, recoveryParam: tx.v });
  } catch (error) {
    console.log(error);
  }
}
function _parseEip1559(payload) {
  const transaction = decode(payload.slice(1));
  if (transaction.length !== 9 && transaction.length !== 12) {
    logger18.throwArgumentError("invalid component count for transaction type: 2", "payload", hexlify(payload));
  }
  const maxPriorityFeePerGas = handleNumber(transaction[2]);
  const maxFeePerGas = handleNumber(transaction[3]);
  const tx = {
    type: 2,
    chainId: handleNumber(transaction[0]).toNumber(),
    nonce: handleNumber(transaction[1]).toNumber(),
    maxPriorityFeePerGas,
    maxFeePerGas,
    gasPrice: null,
    gasLimit: handleNumber(transaction[4]),
    to: handleAddress(transaction[5]),
    value: handleNumber(transaction[6]),
    data: transaction[7],
    accessList: accessListify(transaction[8])
  };
  if (transaction.length === 9) {
    return tx;
  }
  tx.hash = keccak256(payload);
  _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);
  return tx;
}
function _parseEip2930(payload) {
  const transaction = decode(payload.slice(1));
  if (transaction.length !== 8 && transaction.length !== 11) {
    logger18.throwArgumentError("invalid component count for transaction type: 1", "payload", hexlify(payload));
  }
  const tx = {
    type: 1,
    chainId: handleNumber(transaction[0]).toNumber(),
    nonce: handleNumber(transaction[1]).toNumber(),
    gasPrice: handleNumber(transaction[2]),
    gasLimit: handleNumber(transaction[3]),
    to: handleAddress(transaction[4]),
    value: handleNumber(transaction[5]),
    data: transaction[6],
    accessList: accessListify(transaction[7])
  };
  if (transaction.length === 8) {
    return tx;
  }
  tx.hash = keccak256(payload);
  _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);
  return tx;
}
function _parse(rawTransaction) {
  const transaction = decode(rawTransaction);
  if (transaction.length !== 9 && transaction.length !== 6) {
    logger18.throwArgumentError("invalid raw transaction", "rawTransaction", rawTransaction);
  }
  const tx = {
    nonce: handleNumber(transaction[0]).toNumber(),
    gasPrice: handleNumber(transaction[1]),
    gasLimit: handleNumber(transaction[2]),
    to: handleAddress(transaction[3]),
    value: handleNumber(transaction[4]),
    data: transaction[5],
    chainId: 0
  };
  if (transaction.length === 6) {
    return tx;
  }
  try {
    tx.v = BigNumber.from(transaction[6]).toNumber();
  } catch (error) {
    console.log(error);
    return tx;
  }
  tx.r = hexZeroPad(transaction[7], 32);
  tx.s = hexZeroPad(transaction[8], 32);
  if (BigNumber.from(tx.r).isZero() && BigNumber.from(tx.s).isZero()) {
    tx.chainId = tx.v;
    tx.v = 0;
  } else {
    tx.chainId = Math.floor((tx.v - 35) / 2);
    if (tx.chainId < 0) {
      tx.chainId = 0;
    }
    let recoveryParam = tx.v - 27;
    const raw = transaction.slice(0, 6);
    if (tx.chainId !== 0) {
      raw.push(hexlify(tx.chainId));
      raw.push("0x");
      raw.push("0x");
      recoveryParam -= tx.chainId * 2 + 8;
    }
    const digest = keccak256(encode(raw));
    try {
      tx.from = recoverAddress(digest, { r: hexlify(tx.r), s: hexlify(tx.s), recoveryParam });
    } catch (error) {
      console.log(error);
    }
    tx.hash = keccak256(rawTransaction);
  }
  tx.type = null;
  return tx;
}
function parse(rawTransaction) {
  const payload = arrayify(rawTransaction);
  if (payload[0] > 127) {
    return _parse(payload);
  }
  switch (payload[0]) {
    case 1:
      return _parseEip2930(payload);
    case 2:
      return _parseEip1559(payload);
    default:
      break;
  }
  return logger18.throwError(`unsupported transaction type: ${payload[0]}`, Logger.errors.UNSUPPORTED_OPERATION, {
    operation: "parseTransaction",
    transactionType: payload[0]
  });
}
var logger18, TransactionTypes, transactionFields, allowedTransactionKeys2;
var init_lib15 = __esm({
  "node_modules/@ethersproject/transactions/lib.esm/index.js"() {
    "use strict";
    init_lib7();
    init_lib3();
    init_lib2();
    init_lib8();
    init_lib5();
    init_lib4();
    init_lib6();
    init_lib14();
    init_lib();
    init_version13();
    logger18 = new Logger(version13);
    (function(TransactionTypes2) {
      TransactionTypes2[TransactionTypes2["legacy"] = 0] = "legacy";
      TransactionTypes2[TransactionTypes2["eip2930"] = 1] = "eip2930";
      TransactionTypes2[TransactionTypes2["eip1559"] = 2] = "eip1559";
    })(TransactionTypes || (TransactionTypes = {}));
    transactionFields = [
      { name: "nonce", maxLength: 32, numeric: true },
      { name: "gasPrice", maxLength: 32, numeric: true },
      { name: "gasLimit", maxLength: 32, numeric: true },
      { name: "to", length: 20 },
      { name: "value", maxLength: 32, numeric: true },
      { name: "data" }
    ];
    allowedTransactionKeys2 = {
      chainId: true,
      data: true,
      gasLimit: true,
      gasPrice: true,
      nonce: true,
      to: true,
      type: true,
      value: true
    };
  }
});

// node_modules/@ethersproject/basex/lib.esm/index.js
var lib_exports13 = {};
__export(lib_exports13, {
  Base32: () => Base32,
  Base58: () => Base58,
  BaseX: () => BaseX
});
var BaseX, Base32, Base58;
var init_lib16 = __esm({
  "node_modules/@ethersproject/basex/lib.esm/index.js"() {
    init_lib2();
    init_lib4();
    BaseX = class {
      constructor(alphabet) {
        defineReadOnly(this, "alphabet", alphabet);
        defineReadOnly(this, "base", alphabet.length);
        defineReadOnly(this, "_alphabetMap", {});
        defineReadOnly(this, "_leader", alphabet.charAt(0));
        for (let i6 = 0; i6 < alphabet.length; i6++) {
          this._alphabetMap[alphabet.charAt(i6)] = i6;
        }
      }
      encode(value2) {
        let source = arrayify(value2);
        if (source.length === 0) {
          return "";
        }
        let digits = [0];
        for (let i6 = 0; i6 < source.length; ++i6) {
          let carry = source[i6];
          for (let j8 = 0; j8 < digits.length; ++j8) {
            carry += digits[j8] << 8;
            digits[j8] = carry % this.base;
            carry = carry / this.base | 0;
          }
          while (carry > 0) {
            digits.push(carry % this.base);
            carry = carry / this.base | 0;
          }
        }
        let string = "";
        for (let k8 = 0; source[k8] === 0 && k8 < source.length - 1; ++k8) {
          string += this._leader;
        }
        for (let q8 = digits.length - 1; q8 >= 0; --q8) {
          string += this.alphabet[digits[q8]];
        }
        return string;
      }
      decode(value2) {
        if (typeof value2 !== "string") {
          throw new TypeError("Expected String");
        }
        let bytes = [];
        if (value2.length === 0) {
          return new Uint8Array(bytes);
        }
        bytes.push(0);
        for (let i6 = 0; i6 < value2.length; i6++) {
          let byte = this._alphabetMap[value2[i6]];
          if (byte === void 0) {
            throw new Error("Non-base" + this.base + " character");
          }
          let carry = byte;
          for (let j8 = 0; j8 < bytes.length; ++j8) {
            carry += bytes[j8] * this.base;
            bytes[j8] = carry & 255;
            carry >>= 8;
          }
          while (carry > 0) {
            bytes.push(carry & 255);
            carry >>= 8;
          }
        }
        for (let k8 = 0; value2[k8] === this._leader && k8 < value2.length - 1; ++k8) {
          bytes.push(0);
        }
        return arrayify(new Uint8Array(bytes.reverse()));
      }
    };
    Base32 = new BaseX("abcdefghijklmnopqrstuvwxyz234567");
    Base58 = new BaseX("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
  }
});

// node_modules/@ethersproject/sha2/lib.esm/types.js
var SupportedAlgorithm;
var init_types = __esm({
  "node_modules/@ethersproject/sha2/lib.esm/types.js"() {
    (function(SupportedAlgorithm2) {
      SupportedAlgorithm2["sha256"] = "sha256";
      SupportedAlgorithm2["sha512"] = "sha512";
    })(SupportedAlgorithm || (SupportedAlgorithm = {}));
  }
});

// node_modules/@ethersproject/sha2/lib.esm/_version.js
var version15;
var init_version14 = __esm({
  "node_modules/@ethersproject/sha2/lib.esm/_version.js"() {
    version15 = "sha2/5.6.0";
  }
});

// node_modules/@ethersproject/sha2/lib.esm/sha2.js
function ripemd160(data) {
  return "0x" + import_hash3.default.ripemd160().update(arrayify(data)).digest("hex");
}
function sha256(data) {
  return "0x" + import_hash3.default.sha256().update(arrayify(data)).digest("hex");
}
function sha512(data) {
  return "0x" + import_hash3.default.sha512().update(arrayify(data)).digest("hex");
}
function computeHmac(algorithm2, key2, data) {
  if (!SupportedAlgorithm[algorithm2]) {
    logger20.throwError("unsupported algorithm " + algorithm2, Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "hmac",
      algorithm: algorithm2
    });
  }
  return "0x" + import_hash3.default.hmac(import_hash3.default[algorithm2], arrayify(key2)).update(arrayify(data)).digest("hex");
}
var import_hash3, logger20;
var init_sha2 = __esm({
  "node_modules/@ethersproject/sha2/lib.esm/sha2.js"() {
    "use strict";
    import_hash3 = __toESM(require_hash());
    init_lib2();
    init_types();
    init_lib();
    init_version14();
    logger20 = new Logger(version15);
  }
});

// node_modules/@ethersproject/sha2/lib.esm/index.js
var lib_exports14 = {};
__export(lib_exports14, {
  SupportedAlgorithm: () => SupportedAlgorithm,
  computeHmac: () => computeHmac,
  ripemd160: () => ripemd160,
  sha256: () => sha256,
  sha512: () => sha512
});
var init_lib17 = __esm({
  "node_modules/@ethersproject/sha2/lib.esm/index.js"() {
    init_sha2();
    init_types();
  }
});

// node_modules/@ethersproject/pbkdf2/lib.esm/pbkdf2.js
function pbkdf2(password, salt, iterations, keylen, hashAlgorithm) {
  password = arrayify(password);
  salt = arrayify(salt);
  let hLen;
  let l6 = 1;
  const DK = new Uint8Array(keylen);
  const block1 = new Uint8Array(salt.length + 4);
  block1.set(salt);
  let r6;
  let T8;
  for (let i6 = 1; i6 <= l6; i6++) {
    block1[salt.length] = i6 >> 24 & 255;
    block1[salt.length + 1] = i6 >> 16 & 255;
    block1[salt.length + 2] = i6 >> 8 & 255;
    block1[salt.length + 3] = i6 & 255;
    let U3 = arrayify(computeHmac(hashAlgorithm, password, block1));
    if (!hLen) {
      hLen = U3.length;
      T8 = new Uint8Array(hLen);
      l6 = Math.ceil(keylen / hLen);
      r6 = keylen - (l6 - 1) * hLen;
    }
    T8.set(U3);
    for (let j8 = 1; j8 < iterations; j8++) {
      U3 = arrayify(computeHmac(hashAlgorithm, password, U3));
      for (let k8 = 0; k8 < hLen; k8++)
        T8[k8] ^= U3[k8];
    }
    const destPos = (i6 - 1) * hLen;
    const len = i6 === l6 ? r6 : hLen;
    DK.set(arrayify(T8).slice(0, len), destPos);
  }
  return hexlify(DK);
}
var init_pbkdf2 = __esm({
  "node_modules/@ethersproject/pbkdf2/lib.esm/pbkdf2.js"() {
    "use strict";
    init_lib2();
    init_lib17();
  }
});

// node_modules/@ethersproject/pbkdf2/lib.esm/index.js
var init_lib18 = __esm({
  "node_modules/@ethersproject/pbkdf2/lib.esm/index.js"() {
    init_pbkdf2();
  }
});

// node_modules/@ethersproject/wordlists/lib.esm/_version.js
var version16;
var init_version15 = __esm({
  "node_modules/@ethersproject/wordlists/lib.esm/_version.js"() {
    version16 = "wordlists/5.6.0";
  }
});

// node_modules/@ethersproject/wordlists/lib.esm/wordlist.js
var exportWordlist, logger21, Wordlist;
var init_wordlist = __esm({
  "node_modules/@ethersproject/wordlists/lib.esm/wordlist.js"() {
    "use strict";
    init_lib10();
    init_lib4();
    init_lib();
    init_version15();
    exportWordlist = false;
    logger21 = new Logger(version16);
    Wordlist = class {
      constructor(locale) {
        logger21.checkAbstract(new.target, Wordlist);
        defineReadOnly(this, "locale", locale);
      }
      split(mnemonic) {
        return mnemonic.toLowerCase().split(/ +/g);
      }
      join(words2) {
        return words2.join(" ");
      }
      static check(wordlist2) {
        const words2 = [];
        for (let i6 = 0; i6 < 2048; i6++) {
          const word = wordlist2.getWord(i6);
          if (i6 !== wordlist2.getWordIndex(word)) {
            return "0x";
          }
          words2.push(word);
        }
        return id(words2.join("\n") + "\n");
      }
      static register(lang, name2) {
        if (!name2) {
          name2 = lang.locale;
        }
        if (exportWordlist) {
          try {
            const anyGlobal2 = window;
            if (anyGlobal2._ethers && anyGlobal2._ethers.wordlists) {
              if (!anyGlobal2._ethers.wordlists[name2]) {
                defineReadOnly(anyGlobal2._ethers.wordlists, name2, lang);
              }
            }
          } catch (error) {
          }
        }
      }
    };
  }
});

// node_modules/@ethersproject/wordlists/lib.esm/lang-en.js
function loadWords(lang) {
  if (wordlist != null) {
    return;
  }
  wordlist = words.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ");
  if (Wordlist.check(lang) !== "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60") {
    wordlist = null;
    throw new Error("BIP39 Wordlist for en (English) FAILED");
  }
}
var words, wordlist, LangEn, langEn;
var init_lang_en = __esm({
  "node_modules/@ethersproject/wordlists/lib.esm/lang-en.js"() {
    "use strict";
    init_wordlist();
    words = "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo";
    wordlist = null;
    LangEn = class extends Wordlist {
      constructor() {
        super("en");
      }
      getWord(index) {
        loadWords(this);
        return wordlist[index];
      }
      getWordIndex(word) {
        loadWords(this);
        return wordlist.indexOf(word);
      }
    };
    langEn = new LangEn();
    Wordlist.register(langEn);
  }
});

// node_modules/@ethersproject/wordlists/lib.esm/wordlists.js
var wordlists;
var init_wordlists = __esm({
  "node_modules/@ethersproject/wordlists/lib.esm/wordlists.js"() {
    "use strict";
    init_lang_en();
    wordlists = {
      en: langEn
    };
  }
});

// node_modules/@ethersproject/wordlists/lib.esm/index.js
var init_lib19 = __esm({
  "node_modules/@ethersproject/wordlists/lib.esm/index.js"() {
    "use strict";
    init_wordlist();
    init_wordlists();
  }
});

// node_modules/@ethersproject/hdnode/lib.esm/_version.js
var version17;
var init_version16 = __esm({
  "node_modules/@ethersproject/hdnode/lib.esm/_version.js"() {
    version17 = "hdnode/5.6.0";
  }
});

// node_modules/@ethersproject/hdnode/lib.esm/index.js
var lib_exports15 = {};
__export(lib_exports15, {
  HDNode: () => HDNode,
  defaultPath: () => defaultPath,
  entropyToMnemonic: () => entropyToMnemonic,
  getAccountPath: () => getAccountPath,
  isValidMnemonic: () => isValidMnemonic,
  mnemonicToEntropy: () => mnemonicToEntropy,
  mnemonicToSeed: () => mnemonicToSeed
});
function getUpperMask(bits) {
  return (1 << bits) - 1 << 8 - bits;
}
function getLowerMask(bits) {
  return (1 << bits) - 1;
}
function bytes32(value2) {
  return hexZeroPad(hexlify(value2), 32);
}
function base58check(data) {
  return Base58.encode(concat([data, hexDataSlice(sha256(sha256(data)), 0, 4)]));
}
function getWordlist(wordlist2) {
  if (wordlist2 == null) {
    return wordlists["en"];
  }
  if (typeof wordlist2 === "string") {
    const words2 = wordlists[wordlist2];
    if (words2 == null) {
      logger22.throwArgumentError("unknown locale", "wordlist", wordlist2);
    }
    return words2;
  }
  return wordlist2;
}
function mnemonicToSeed(mnemonic, password) {
  if (!password) {
    password = "";
  }
  const salt = toUtf8Bytes("mnemonic" + password, UnicodeNormalizationForm.NFKD);
  return pbkdf2(toUtf8Bytes(mnemonic, UnicodeNormalizationForm.NFKD), salt, 2048, 64, "sha512");
}
function mnemonicToEntropy(mnemonic, wordlist2) {
  wordlist2 = getWordlist(wordlist2);
  logger22.checkNormalize();
  const words2 = wordlist2.split(mnemonic);
  if (words2.length % 3 !== 0) {
    throw new Error("invalid mnemonic");
  }
  const entropy = arrayify(new Uint8Array(Math.ceil(11 * words2.length / 8)));
  let offset = 0;
  for (let i6 = 0; i6 < words2.length; i6++) {
    let index = wordlist2.getWordIndex(words2[i6].normalize("NFKD"));
    if (index === -1) {
      throw new Error("invalid mnemonic");
    }
    for (let bit = 0; bit < 11; bit++) {
      if (index & 1 << 10 - bit) {
        entropy[offset >> 3] |= 1 << 7 - offset % 8;
      }
      offset++;
    }
  }
  const entropyBits = 32 * words2.length / 3;
  const checksumBits = words2.length / 3;
  const checksumMask = getUpperMask(checksumBits);
  const checksum = arrayify(sha256(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
  if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {
    throw new Error("invalid checksum");
  }
  return hexlify(entropy.slice(0, entropyBits / 8));
}
function entropyToMnemonic(entropy, wordlist2) {
  wordlist2 = getWordlist(wordlist2);
  entropy = arrayify(entropy);
  if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {
    throw new Error("invalid entropy");
  }
  const indices = [0];
  let remainingBits = 11;
  for (let i6 = 0; i6 < entropy.length; i6++) {
    if (remainingBits > 8) {
      indices[indices.length - 1] <<= 8;
      indices[indices.length - 1] |= entropy[i6];
      remainingBits -= 8;
    } else {
      indices[indices.length - 1] <<= remainingBits;
      indices[indices.length - 1] |= entropy[i6] >> 8 - remainingBits;
      indices.push(entropy[i6] & getLowerMask(8 - remainingBits));
      remainingBits += 3;
    }
  }
  const checksumBits = entropy.length / 4;
  const checksum = arrayify(sha256(entropy))[0] & getUpperMask(checksumBits);
  indices[indices.length - 1] <<= checksumBits;
  indices[indices.length - 1] |= checksum >> 8 - checksumBits;
  return wordlist2.join(indices.map((index) => wordlist2.getWord(index)));
}
function isValidMnemonic(mnemonic, wordlist2) {
  try {
    mnemonicToEntropy(mnemonic, wordlist2);
    return true;
  } catch (error) {
  }
  return false;
}
function getAccountPath(index) {
  if (typeof index !== "number" || index < 0 || index >= HardenedBit || index % 1) {
    logger22.throwArgumentError("invalid account index", "index", index);
  }
  return `m/44'/60'/${index}'/0/0`;
}
var logger22, N, MasterSecret, HardenedBit, _constructorGuard4, defaultPath, HDNode;
var init_lib20 = __esm({
  "node_modules/@ethersproject/hdnode/lib.esm/index.js"() {
    "use strict";
    init_lib16();
    init_lib2();
    init_lib3();
    init_lib9();
    init_lib18();
    init_lib4();
    init_lib14();
    init_lib17();
    init_lib15();
    init_lib19();
    init_lib();
    init_version16();
    logger22 = new Logger(version17);
    N = BigNumber.from("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
    MasterSecret = toUtf8Bytes("Bitcoin seed");
    HardenedBit = 2147483648;
    _constructorGuard4 = {};
    defaultPath = "m/44'/60'/0'/0/0";
    HDNode = class {
      constructor(constructorGuard, privateKey, publicKey, parentFingerprint, chainCode, index, depth, mnemonicOrPath) {
        logger22.checkNew(new.target, HDNode);
        if (constructorGuard !== _constructorGuard4) {
          throw new Error("HDNode constructor cannot be called directly");
        }
        if (privateKey) {
          const signingKey = new SigningKey(privateKey);
          defineReadOnly(this, "privateKey", signingKey.privateKey);
          defineReadOnly(this, "publicKey", signingKey.compressedPublicKey);
        } else {
          defineReadOnly(this, "privateKey", null);
          defineReadOnly(this, "publicKey", hexlify(publicKey));
        }
        defineReadOnly(this, "parentFingerprint", parentFingerprint);
        defineReadOnly(this, "fingerprint", hexDataSlice(ripemd160(sha256(this.publicKey)), 0, 4));
        defineReadOnly(this, "address", computeAddress(this.publicKey));
        defineReadOnly(this, "chainCode", chainCode);
        defineReadOnly(this, "index", index);
        defineReadOnly(this, "depth", depth);
        if (mnemonicOrPath == null) {
          defineReadOnly(this, "mnemonic", null);
          defineReadOnly(this, "path", null);
        } else if (typeof mnemonicOrPath === "string") {
          defineReadOnly(this, "mnemonic", null);
          defineReadOnly(this, "path", mnemonicOrPath);
        } else {
          defineReadOnly(this, "mnemonic", mnemonicOrPath);
          defineReadOnly(this, "path", mnemonicOrPath.path);
        }
      }
      get extendedKey() {
        if (this.depth >= 256) {
          throw new Error("Depth too large!");
        }
        return base58check(concat([
          this.privateKey != null ? "0x0488ADE4" : "0x0488B21E",
          hexlify(this.depth),
          this.parentFingerprint,
          hexZeroPad(hexlify(this.index), 4),
          this.chainCode,
          this.privateKey != null ? concat(["0x00", this.privateKey]) : this.publicKey
        ]));
      }
      neuter() {
        return new HDNode(_constructorGuard4, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);
      }
      _derive(index) {
        if (index > 4294967295) {
          throw new Error("invalid index - " + String(index));
        }
        let path = this.path;
        if (path) {
          path += "/" + (index & ~HardenedBit);
        }
        const data = new Uint8Array(37);
        if (index & HardenedBit) {
          if (!this.privateKey) {
            throw new Error("cannot derive child of neutered node");
          }
          data.set(arrayify(this.privateKey), 1);
          if (path) {
            path += "'";
          }
        } else {
          data.set(arrayify(this.publicKey));
        }
        for (let i6 = 24; i6 >= 0; i6 -= 8) {
          data[33 + (i6 >> 3)] = index >> 24 - i6 & 255;
        }
        const I5 = arrayify(computeHmac(SupportedAlgorithm.sha512, this.chainCode, data));
        const IL = I5.slice(0, 32);
        const IR = I5.slice(32);
        let ki2 = null;
        let Ki2 = null;
        if (this.privateKey) {
          ki2 = bytes32(BigNumber.from(IL).add(this.privateKey).mod(N));
        } else {
          const ek = new SigningKey(hexlify(IL));
          Ki2 = ek._addPoint(this.publicKey);
        }
        let mnemonicOrPath = path;
        const srcMnemonic = this.mnemonic;
        if (srcMnemonic) {
          mnemonicOrPath = Object.freeze({
            phrase: srcMnemonic.phrase,
            path,
            locale: srcMnemonic.locale || "en"
          });
        }
        return new HDNode(_constructorGuard4, ki2, Ki2, this.fingerprint, bytes32(IR), index, this.depth + 1, mnemonicOrPath);
      }
      derivePath(path) {
        const components = path.split("/");
        if (components.length === 0 || components[0] === "m" && this.depth !== 0) {
          throw new Error("invalid path - " + path);
        }
        if (components[0] === "m") {
          components.shift();
        }
        let result = this;
        for (let i6 = 0; i6 < components.length; i6++) {
          const component = components[i6];
          if (component.match(/^[0-9]+'$/)) {
            const index = parseInt(component.substring(0, component.length - 1));
            if (index >= HardenedBit) {
              throw new Error("invalid path index - " + component);
            }
            result = result._derive(HardenedBit + index);
          } else if (component.match(/^[0-9]+$/)) {
            const index = parseInt(component);
            if (index >= HardenedBit) {
              throw new Error("invalid path index - " + component);
            }
            result = result._derive(index);
          } else {
            throw new Error("invalid path component - " + component);
          }
        }
        return result;
      }
      static _fromSeed(seed, mnemonic) {
        const seedArray = arrayify(seed);
        if (seedArray.length < 16 || seedArray.length > 64) {
          throw new Error("invalid seed");
        }
        const I5 = arrayify(computeHmac(SupportedAlgorithm.sha512, MasterSecret, seedArray));
        return new HDNode(_constructorGuard4, bytes32(I5.slice(0, 32)), null, "0x00000000", bytes32(I5.slice(32)), 0, 0, mnemonic);
      }
      static fromMnemonic(mnemonic, password, wordlist2) {
        wordlist2 = getWordlist(wordlist2);
        mnemonic = entropyToMnemonic(mnemonicToEntropy(mnemonic, wordlist2), wordlist2);
        return HDNode._fromSeed(mnemonicToSeed(mnemonic, password), {
          phrase: mnemonic,
          path: "m",
          locale: wordlist2.locale
        });
      }
      static fromSeed(seed) {
        return HDNode._fromSeed(seed, null);
      }
      static fromExtendedKey(extendedKey) {
        const bytes = Base58.decode(extendedKey);
        if (bytes.length !== 82 || base58check(bytes.slice(0, 78)) !== extendedKey) {
          logger22.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
        }
        const depth = bytes[4];
        const parentFingerprint = hexlify(bytes.slice(5, 9));
        const index = parseInt(hexlify(bytes.slice(9, 13)).substring(2), 16);
        const chainCode = hexlify(bytes.slice(13, 45));
        const key2 = bytes.slice(45, 78);
        switch (hexlify(bytes.slice(0, 4))) {
          case "0x0488b21e":
          case "0x043587cf":
            return new HDNode(_constructorGuard4, null, hexlify(key2), parentFingerprint, chainCode, index, depth, null);
          case "0x0488ade4":
          case "0x04358394 ":
            if (key2[0] !== 0) {
              break;
            }
            return new HDNode(_constructorGuard4, hexlify(key2.slice(1)), null, parentFingerprint, chainCode, index, depth, null);
        }
        return logger22.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
      }
    };
  }
});

// node_modules/@ethersproject/random/lib.esm/_version.js
var version18;
var init_version17 = __esm({
  "node_modules/@ethersproject/random/lib.esm/_version.js"() {
    version18 = "random/5.6.0";
  }
});

// node_modules/@ethersproject/random/lib.esm/random.js
function getGlobal() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw new Error("unable to locate global object");
}
function randomBytes(length) {
  if (length <= 0 || length > 1024 || length % 1 || length != length) {
    logger23.throwArgumentError("invalid length", "length", length);
  }
  const result = new Uint8Array(length);
  crypto2.getRandomValues(result);
  return arrayify(result);
}
var logger23, anyGlobal, crypto2;
var init_random = __esm({
  "node_modules/@ethersproject/random/lib.esm/random.js"() {
    "use strict";
    init_lib2();
    init_lib();
    init_version17();
    logger23 = new Logger(version18);
    anyGlobal = getGlobal();
    crypto2 = anyGlobal.crypto || anyGlobal.msCrypto;
    if (!crypto2 || !crypto2.getRandomValues) {
      logger23.warn("WARNING: Missing strong random number source");
      crypto2 = {
        getRandomValues: function(buffer2) {
          return logger23.throwError("no secure random source avaialble", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "crypto.getRandomValues"
          });
        }
      };
    }
  }
});

// node_modules/@ethersproject/random/lib.esm/shuffle.js
function shuffled(array) {
  array = array.slice();
  for (let i6 = array.length - 1; i6 > 0; i6--) {
    const j8 = Math.floor(Math.random() * (i6 + 1));
    const tmp = array[i6];
    array[i6] = array[j8];
    array[j8] = tmp;
  }
  return array;
}
var init_shuffle = __esm({
  "node_modules/@ethersproject/random/lib.esm/shuffle.js"() {
    "use strict";
  }
});

// node_modules/@ethersproject/random/lib.esm/index.js
var lib_exports16 = {};
__export(lib_exports16, {
  randomBytes: () => randomBytes,
  shuffled: () => shuffled
});
var init_lib21 = __esm({
  "node_modules/@ethersproject/random/lib.esm/index.js"() {
    "use strict";
    init_random();
    init_shuffle();
  }
});

// node_modules/@ethersproject/json-wallets/node_modules/aes-js/index.js
var require_aes_js = __commonJS({
  "node_modules/@ethersproject/json-wallets/node_modules/aes-js/index.js"(exports2, module2) {
    "use strict";
    (function(root2) {
      function checkInt(value2) {
        return parseInt(value2) === value2;
      }
      function checkInts(arrayish) {
        if (!checkInt(arrayish.length)) {
          return false;
        }
        for (var i6 = 0; i6 < arrayish.length; i6++) {
          if (!checkInt(arrayish[i6]) || arrayish[i6] < 0 || arrayish[i6] > 255) {
            return false;
          }
        }
        return true;
      }
      function coerceArray(arg, copy) {
        if (arg.buffer && ArrayBuffer.isView(arg) && arg.name === "Uint8Array") {
          if (copy) {
            if (arg.slice) {
              arg = arg.slice();
            } else {
              arg = Array.prototype.slice.call(arg);
            }
          }
          return arg;
        }
        if (Array.isArray(arg)) {
          if (!checkInts(arg)) {
            throw new Error("Array contains invalid value: " + arg);
          }
          return new Uint8Array(arg);
        }
        if (checkInt(arg.length) && checkInts(arg)) {
          return new Uint8Array(arg);
        }
        throw new Error("unsupported array-like object");
      }
      function createArray(length) {
        return new Uint8Array(length);
      }
      function copyArray(sourceArray, targetArray, targetStart, sourceStart, sourceEnd) {
        if (sourceStart != null || sourceEnd != null) {
          if (sourceArray.slice) {
            sourceArray = sourceArray.slice(sourceStart, sourceEnd);
          } else {
            sourceArray = Array.prototype.slice.call(sourceArray, sourceStart, sourceEnd);
          }
        }
        targetArray.set(sourceArray, targetStart);
      }
      var convertUtf8 = function() {
        function toBytes(text) {
          var result = [], i6 = 0;
          text = encodeURI(text);
          while (i6 < text.length) {
            var c5 = text.charCodeAt(i6++);
            if (c5 === 37) {
              result.push(parseInt(text.substr(i6, 2), 16));
              i6 += 2;
            } else {
              result.push(c5);
            }
          }
          return coerceArray(result);
        }
        function fromBytes(bytes) {
          var result = [], i6 = 0;
          while (i6 < bytes.length) {
            var c5 = bytes[i6];
            if (c5 < 128) {
              result.push(String.fromCharCode(c5));
              i6++;
            } else if (c5 > 191 && c5 < 224) {
              result.push(String.fromCharCode((c5 & 31) << 6 | bytes[i6 + 1] & 63));
              i6 += 2;
            } else {
              result.push(String.fromCharCode((c5 & 15) << 12 | (bytes[i6 + 1] & 63) << 6 | bytes[i6 + 2] & 63));
              i6 += 3;
            }
          }
          return result.join("");
        }
        return {
          toBytes,
          fromBytes
        };
      }();
      var convertHex = function() {
        function toBytes(text) {
          var result = [];
          for (var i6 = 0; i6 < text.length; i6 += 2) {
            result.push(parseInt(text.substr(i6, 2), 16));
          }
          return result;
        }
        var Hex = "0123456789abcdef";
        function fromBytes(bytes) {
          var result = [];
          for (var i6 = 0; i6 < bytes.length; i6++) {
            var v9 = bytes[i6];
            result.push(Hex[(v9 & 240) >> 4] + Hex[v9 & 15]);
          }
          return result.join("");
        }
        return {
          toBytes,
          fromBytes
        };
      }();
      var numberOfRounds = { 16: 10, 24: 12, 32: 14 };
      var rcon = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145];
      var S5 = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22];
      var Si2 = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125];
      var T1 = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986];
      var T22 = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766];
      var T32 = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126];
      var T42 = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436];
      var T52 = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890];
      var T62 = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935];
      var T72 = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600];
      var T8 = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480];
      var U1 = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795];
      var U22 = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855];
      var U3 = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150];
      var U4 = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];
      function convertToInt32(bytes) {
        var result = [];
        for (var i6 = 0; i6 < bytes.length; i6 += 4) {
          result.push(
            bytes[i6] << 24 | bytes[i6 + 1] << 16 | bytes[i6 + 2] << 8 | bytes[i6 + 3]
          );
        }
        return result;
      }
      var AES = function(key2) {
        if (!(this instanceof AES)) {
          throw Error("AES must be instanitated with `new`");
        }
        Object.defineProperty(this, "key", {
          value: coerceArray(key2, true)
        });
        this._prepare();
      };
      AES.prototype._prepare = function() {
        var rounds = numberOfRounds[this.key.length];
        if (rounds == null) {
          throw new Error("invalid key size (must be 16, 24 or 32 bytes)");
        }
        this._Ke = [];
        this._Kd = [];
        for (var i6 = 0; i6 <= rounds; i6++) {
          this._Ke.push([0, 0, 0, 0]);
          this._Kd.push([0, 0, 0, 0]);
        }
        var roundKeyCount = (rounds + 1) * 4;
        var KC = this.key.length / 4;
        var tk = convertToInt32(this.key);
        var index;
        for (var i6 = 0; i6 < KC; i6++) {
          index = i6 >> 2;
          this._Ke[index][i6 % 4] = tk[i6];
          this._Kd[rounds - index][i6 % 4] = tk[i6];
        }
        var rconpointer = 0;
        var t6 = KC, tt2;
        while (t6 < roundKeyCount) {
          tt2 = tk[KC - 1];
          tk[0] ^= S5[tt2 >> 16 & 255] << 24 ^ S5[tt2 >> 8 & 255] << 16 ^ S5[tt2 & 255] << 8 ^ S5[tt2 >> 24 & 255] ^ rcon[rconpointer] << 24;
          rconpointer += 1;
          if (KC != 8) {
            for (var i6 = 1; i6 < KC; i6++) {
              tk[i6] ^= tk[i6 - 1];
            }
          } else {
            for (var i6 = 1; i6 < KC / 2; i6++) {
              tk[i6] ^= tk[i6 - 1];
            }
            tt2 = tk[KC / 2 - 1];
            tk[KC / 2] ^= S5[tt2 & 255] ^ S5[tt2 >> 8 & 255] << 8 ^ S5[tt2 >> 16 & 255] << 16 ^ S5[tt2 >> 24 & 255] << 24;
            for (var i6 = KC / 2 + 1; i6 < KC; i6++) {
              tk[i6] ^= tk[i6 - 1];
            }
          }
          var i6 = 0, r6, c5;
          while (i6 < KC && t6 < roundKeyCount) {
            r6 = t6 >> 2;
            c5 = t6 % 4;
            this._Ke[r6][c5] = tk[i6];
            this._Kd[rounds - r6][c5] = tk[i6++];
            t6++;
          }
        }
        for (var r6 = 1; r6 < rounds; r6++) {
          for (var c5 = 0; c5 < 4; c5++) {
            tt2 = this._Kd[r6][c5];
            this._Kd[r6][c5] = U1[tt2 >> 24 & 255] ^ U22[tt2 >> 16 & 255] ^ U3[tt2 >> 8 & 255] ^ U4[tt2 & 255];
          }
        }
      };
      AES.prototype.encrypt = function(plaintext) {
        if (plaintext.length != 16) {
          throw new Error("invalid plaintext size (must be 16 bytes)");
        }
        var rounds = this._Ke.length - 1;
        var a5 = [0, 0, 0, 0];
        var t6 = convertToInt32(plaintext);
        for (var i6 = 0; i6 < 4; i6++) {
          t6[i6] ^= this._Ke[0][i6];
        }
        for (var r6 = 1; r6 < rounds; r6++) {
          for (var i6 = 0; i6 < 4; i6++) {
            a5[i6] = T1[t6[i6] >> 24 & 255] ^ T22[t6[(i6 + 1) % 4] >> 16 & 255] ^ T32[t6[(i6 + 2) % 4] >> 8 & 255] ^ T42[t6[(i6 + 3) % 4] & 255] ^ this._Ke[r6][i6];
          }
          t6 = a5.slice();
        }
        var result = createArray(16), tt2;
        for (var i6 = 0; i6 < 4; i6++) {
          tt2 = this._Ke[rounds][i6];
          result[4 * i6] = (S5[t6[i6] >> 24 & 255] ^ tt2 >> 24) & 255;
          result[4 * i6 + 1] = (S5[t6[(i6 + 1) % 4] >> 16 & 255] ^ tt2 >> 16) & 255;
          result[4 * i6 + 2] = (S5[t6[(i6 + 2) % 4] >> 8 & 255] ^ tt2 >> 8) & 255;
          result[4 * i6 + 3] = (S5[t6[(i6 + 3) % 4] & 255] ^ tt2) & 255;
        }
        return result;
      };
      AES.prototype.decrypt = function(ciphertext) {
        if (ciphertext.length != 16) {
          throw new Error("invalid ciphertext size (must be 16 bytes)");
        }
        var rounds = this._Kd.length - 1;
        var a5 = [0, 0, 0, 0];
        var t6 = convertToInt32(ciphertext);
        for (var i6 = 0; i6 < 4; i6++) {
          t6[i6] ^= this._Kd[0][i6];
        }
        for (var r6 = 1; r6 < rounds; r6++) {
          for (var i6 = 0; i6 < 4; i6++) {
            a5[i6] = T52[t6[i6] >> 24 & 255] ^ T62[t6[(i6 + 3) % 4] >> 16 & 255] ^ T72[t6[(i6 + 2) % 4] >> 8 & 255] ^ T8[t6[(i6 + 1) % 4] & 255] ^ this._Kd[r6][i6];
          }
          t6 = a5.slice();
        }
        var result = createArray(16), tt2;
        for (var i6 = 0; i6 < 4; i6++) {
          tt2 = this._Kd[rounds][i6];
          result[4 * i6] = (Si2[t6[i6] >> 24 & 255] ^ tt2 >> 24) & 255;
          result[4 * i6 + 1] = (Si2[t6[(i6 + 3) % 4] >> 16 & 255] ^ tt2 >> 16) & 255;
          result[4 * i6 + 2] = (Si2[t6[(i6 + 2) % 4] >> 8 & 255] ^ tt2 >> 8) & 255;
          result[4 * i6 + 3] = (Si2[t6[(i6 + 1) % 4] & 255] ^ tt2) & 255;
        }
        return result;
      };
      var ModeOfOperationECB = function(key2) {
        if (!(this instanceof ModeOfOperationECB)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Electronic Code Block";
        this.name = "ecb";
        this._aes = new AES(key2);
      };
      ModeOfOperationECB.prototype.encrypt = function(plaintext) {
        plaintext = coerceArray(plaintext);
        if (plaintext.length % 16 !== 0) {
          throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
        }
        var ciphertext = createArray(plaintext.length);
        var block = createArray(16);
        for (var i6 = 0; i6 < plaintext.length; i6 += 16) {
          copyArray(plaintext, block, 0, i6, i6 + 16);
          block = this._aes.encrypt(block);
          copyArray(block, ciphertext, i6);
        }
        return ciphertext;
      };
      ModeOfOperationECB.prototype.decrypt = function(ciphertext) {
        ciphertext = coerceArray(ciphertext);
        if (ciphertext.length % 16 !== 0) {
          throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
        }
        var plaintext = createArray(ciphertext.length);
        var block = createArray(16);
        for (var i6 = 0; i6 < ciphertext.length; i6 += 16) {
          copyArray(ciphertext, block, 0, i6, i6 + 16);
          block = this._aes.decrypt(block);
          copyArray(block, plaintext, i6);
        }
        return plaintext;
      };
      var ModeOfOperationCBC = function(key2, iv) {
        if (!(this instanceof ModeOfOperationCBC)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Cipher Block Chaining";
        this.name = "cbc";
        if (!iv) {
          iv = createArray(16);
        } else if (iv.length != 16) {
          throw new Error("invalid initialation vector size (must be 16 bytes)");
        }
        this._lastCipherblock = coerceArray(iv, true);
        this._aes = new AES(key2);
      };
      ModeOfOperationCBC.prototype.encrypt = function(plaintext) {
        plaintext = coerceArray(plaintext);
        if (plaintext.length % 16 !== 0) {
          throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
        }
        var ciphertext = createArray(plaintext.length);
        var block = createArray(16);
        for (var i6 = 0; i6 < plaintext.length; i6 += 16) {
          copyArray(plaintext, block, 0, i6, i6 + 16);
          for (var j8 = 0; j8 < 16; j8++) {
            block[j8] ^= this._lastCipherblock[j8];
          }
          this._lastCipherblock = this._aes.encrypt(block);
          copyArray(this._lastCipherblock, ciphertext, i6);
        }
        return ciphertext;
      };
      ModeOfOperationCBC.prototype.decrypt = function(ciphertext) {
        ciphertext = coerceArray(ciphertext);
        if (ciphertext.length % 16 !== 0) {
          throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
        }
        var plaintext = createArray(ciphertext.length);
        var block = createArray(16);
        for (var i6 = 0; i6 < ciphertext.length; i6 += 16) {
          copyArray(ciphertext, block, 0, i6, i6 + 16);
          block = this._aes.decrypt(block);
          for (var j8 = 0; j8 < 16; j8++) {
            plaintext[i6 + j8] = block[j8] ^ this._lastCipherblock[j8];
          }
          copyArray(ciphertext, this._lastCipherblock, 0, i6, i6 + 16);
        }
        return plaintext;
      };
      var ModeOfOperationCFB = function(key2, iv, segmentSize) {
        if (!(this instanceof ModeOfOperationCFB)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Cipher Feedback";
        this.name = "cfb";
        if (!iv) {
          iv = createArray(16);
        } else if (iv.length != 16) {
          throw new Error("invalid initialation vector size (must be 16 size)");
        }
        if (!segmentSize) {
          segmentSize = 1;
        }
        this.segmentSize = segmentSize;
        this._shiftRegister = coerceArray(iv, true);
        this._aes = new AES(key2);
      };
      ModeOfOperationCFB.prototype.encrypt = function(plaintext) {
        if (plaintext.length % this.segmentSize != 0) {
          throw new Error("invalid plaintext size (must be segmentSize bytes)");
        }
        var encrypted = coerceArray(plaintext, true);
        var xorSegment;
        for (var i6 = 0; i6 < encrypted.length; i6 += this.segmentSize) {
          xorSegment = this._aes.encrypt(this._shiftRegister);
          for (var j8 = 0; j8 < this.segmentSize; j8++) {
            encrypted[i6 + j8] ^= xorSegment[j8];
          }
          copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
          copyArray(encrypted, this._shiftRegister, 16 - this.segmentSize, i6, i6 + this.segmentSize);
        }
        return encrypted;
      };
      ModeOfOperationCFB.prototype.decrypt = function(ciphertext) {
        if (ciphertext.length % this.segmentSize != 0) {
          throw new Error("invalid ciphertext size (must be segmentSize bytes)");
        }
        var plaintext = coerceArray(ciphertext, true);
        var xorSegment;
        for (var i6 = 0; i6 < plaintext.length; i6 += this.segmentSize) {
          xorSegment = this._aes.encrypt(this._shiftRegister);
          for (var j8 = 0; j8 < this.segmentSize; j8++) {
            plaintext[i6 + j8] ^= xorSegment[j8];
          }
          copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
          copyArray(ciphertext, this._shiftRegister, 16 - this.segmentSize, i6, i6 + this.segmentSize);
        }
        return plaintext;
      };
      var ModeOfOperationOFB = function(key2, iv) {
        if (!(this instanceof ModeOfOperationOFB)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Output Feedback";
        this.name = "ofb";
        if (!iv) {
          iv = createArray(16);
        } else if (iv.length != 16) {
          throw new Error("invalid initialation vector size (must be 16 bytes)");
        }
        this._lastPrecipher = coerceArray(iv, true);
        this._lastPrecipherIndex = 16;
        this._aes = new AES(key2);
      };
      ModeOfOperationOFB.prototype.encrypt = function(plaintext) {
        var encrypted = coerceArray(plaintext, true);
        for (var i6 = 0; i6 < encrypted.length; i6++) {
          if (this._lastPrecipherIndex === 16) {
            this._lastPrecipher = this._aes.encrypt(this._lastPrecipher);
            this._lastPrecipherIndex = 0;
          }
          encrypted[i6] ^= this._lastPrecipher[this._lastPrecipherIndex++];
        }
        return encrypted;
      };
      ModeOfOperationOFB.prototype.decrypt = ModeOfOperationOFB.prototype.encrypt;
      var Counter = function(initialValue) {
        if (!(this instanceof Counter)) {
          throw Error("Counter must be instanitated with `new`");
        }
        if (initialValue !== 0 && !initialValue) {
          initialValue = 1;
        }
        if (typeof initialValue === "number") {
          this._counter = createArray(16);
          this.setValue(initialValue);
        } else {
          this.setBytes(initialValue);
        }
      };
      Counter.prototype.setValue = function(value2) {
        if (typeof value2 !== "number" || parseInt(value2) != value2) {
          throw new Error("invalid counter value (must be an integer)");
        }
        for (var index = 15; index >= 0; --index) {
          this._counter[index] = value2 % 256;
          value2 = value2 >> 8;
        }
      };
      Counter.prototype.setBytes = function(bytes) {
        bytes = coerceArray(bytes, true);
        if (bytes.length != 16) {
          throw new Error("invalid counter bytes size (must be 16 bytes)");
        }
        this._counter = bytes;
      };
      Counter.prototype.increment = function() {
        for (var i6 = 15; i6 >= 0; i6--) {
          if (this._counter[i6] === 255) {
            this._counter[i6] = 0;
          } else {
            this._counter[i6]++;
            break;
          }
        }
      };
      var ModeOfOperationCTR = function(key2, counter) {
        if (!(this instanceof ModeOfOperationCTR)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Counter";
        this.name = "ctr";
        if (!(counter instanceof Counter)) {
          counter = new Counter(counter);
        }
        this._counter = counter;
        this._remainingCounter = null;
        this._remainingCounterIndex = 16;
        this._aes = new AES(key2);
      };
      ModeOfOperationCTR.prototype.encrypt = function(plaintext) {
        var encrypted = coerceArray(plaintext, true);
        for (var i6 = 0; i6 < encrypted.length; i6++) {
          if (this._remainingCounterIndex === 16) {
            this._remainingCounter = this._aes.encrypt(this._counter._counter);
            this._remainingCounterIndex = 0;
            this._counter.increment();
          }
          encrypted[i6] ^= this._remainingCounter[this._remainingCounterIndex++];
        }
        return encrypted;
      };
      ModeOfOperationCTR.prototype.decrypt = ModeOfOperationCTR.prototype.encrypt;
      function pkcs7pad(data) {
        data = coerceArray(data, true);
        var padder = 16 - data.length % 16;
        var result = createArray(data.length + padder);
        copyArray(data, result);
        for (var i6 = data.length; i6 < result.length; i6++) {
          result[i6] = padder;
        }
        return result;
      }
      function pkcs7strip(data) {
        data = coerceArray(data, true);
        if (data.length < 16) {
          throw new Error("PKCS#7 invalid length");
        }
        var padder = data[data.length - 1];
        if (padder > 16) {
          throw new Error("PKCS#7 padding byte out of range");
        }
        var length = data.length - padder;
        for (var i6 = 0; i6 < padder; i6++) {
          if (data[length + i6] !== padder) {
            throw new Error("PKCS#7 invalid padding byte");
          }
        }
        var result = createArray(length);
        copyArray(data, result, 0, 0, length);
        return result;
      }
      var aesjs = {
        AES,
        Counter,
        ModeOfOperation: {
          ecb: ModeOfOperationECB,
          cbc: ModeOfOperationCBC,
          cfb: ModeOfOperationCFB,
          ofb: ModeOfOperationOFB,
          ctr: ModeOfOperationCTR
        },
        utils: {
          hex: convertHex,
          utf8: convertUtf8
        },
        padding: {
          pkcs7: {
            pad: pkcs7pad,
            strip: pkcs7strip
          }
        },
        _arrayTest: {
          coerceArray,
          createArray,
          copyArray
        }
      };
      if (typeof exports2 !== "undefined") {
        module2.exports = aesjs;
      } else if (typeof define === "function" && define.amd) {
        define(aesjs);
      } else {
        if (root2.aesjs) {
          aesjs._aesjs = root2.aesjs;
        }
        root2.aesjs = aesjs;
      }
    })(exports2);
  }
});

// node_modules/@ethersproject/json-wallets/lib.esm/_version.js
var version19;
var init_version18 = __esm({
  "node_modules/@ethersproject/json-wallets/lib.esm/_version.js"() {
    version19 = "json-wallets/5.6.0";
  }
});

// node_modules/@ethersproject/json-wallets/lib.esm/utils.js
function looseArrayify(hexString) {
  if (typeof hexString === "string" && hexString.substring(0, 2) !== "0x") {
    hexString = "0x" + hexString;
  }
  return arrayify(hexString);
}
function zpad(value2, length) {
  value2 = String(value2);
  while (value2.length < length) {
    value2 = "0" + value2;
  }
  return value2;
}
function getPassword(password) {
  if (typeof password === "string") {
    return toUtf8Bytes(password, UnicodeNormalizationForm.NFKC);
  }
  return arrayify(password);
}
function searchPath(object, path) {
  let currentChild = object;
  const comps = path.toLowerCase().split("/");
  for (let i6 = 0; i6 < comps.length; i6++) {
    let matchingChild = null;
    for (const key2 in currentChild) {
      if (key2.toLowerCase() === comps[i6]) {
        matchingChild = currentChild[key2];
        break;
      }
    }
    if (matchingChild === null) {
      return null;
    }
    currentChild = matchingChild;
  }
  return currentChild;
}
function uuidV4(randomBytes3) {
  const bytes = arrayify(randomBytes3);
  bytes[6] = bytes[6] & 15 | 64;
  bytes[8] = bytes[8] & 63 | 128;
  const value2 = hexlify(bytes);
  return [
    value2.substring(2, 10),
    value2.substring(10, 14),
    value2.substring(14, 18),
    value2.substring(18, 22),
    value2.substring(22, 34)
  ].join("-");
}
var init_utils = __esm({
  "node_modules/@ethersproject/json-wallets/lib.esm/utils.js"() {
    "use strict";
    init_lib2();
    init_lib9();
  }
});

// node_modules/@ethersproject/json-wallets/lib.esm/crowdsale.js
function decrypt(json, password) {
  const data = JSON.parse(json);
  password = getPassword(password);
  const ethaddr = getAddress(searchPath(data, "ethaddr"));
  const encseed = looseArrayify(searchPath(data, "encseed"));
  if (!encseed || encseed.length % 16 !== 0) {
    logger24.throwArgumentError("invalid encseed", "json", json);
  }
  const key2 = arrayify(pbkdf2(password, password, 2e3, 32, "sha256")).slice(0, 16);
  const iv = encseed.slice(0, 16);
  const encryptedSeed = encseed.slice(16);
  const aesCbc = new import_aes_js.default.ModeOfOperation.cbc(key2, iv);
  const seed = import_aes_js.default.padding.pkcs7.strip(arrayify(aesCbc.decrypt(encryptedSeed)));
  let seedHex = "";
  for (let i6 = 0; i6 < seed.length; i6++) {
    seedHex += String.fromCharCode(seed[i6]);
  }
  const seedHexBytes = toUtf8Bytes(seedHex);
  const privateKey = keccak256(seedHexBytes);
  return new CrowdsaleAccount({
    _isCrowdsaleAccount: true,
    address: ethaddr,
    privateKey
  });
}
var import_aes_js, logger24, CrowdsaleAccount;
var init_crowdsale = __esm({
  "node_modules/@ethersproject/json-wallets/lib.esm/crowdsale.js"() {
    "use strict";
    import_aes_js = __toESM(require_aes_js());
    init_lib7();
    init_lib2();
    init_lib5();
    init_lib18();
    init_lib9();
    init_lib4();
    init_lib();
    init_version18();
    init_utils();
    logger24 = new Logger(version19);
    CrowdsaleAccount = class extends Description {
      isCrowdsaleAccount(value2) {
        return !!(value2 && value2._isCrowdsaleAccount);
      }
    };
  }
});

// node_modules/@ethersproject/json-wallets/lib.esm/inspect.js
function isCrowdsaleWallet(json) {
  let data = null;
  try {
    data = JSON.parse(json);
  } catch (error) {
    return false;
  }
  return data.encseed && data.ethaddr;
}
function isKeystoreWallet(json) {
  let data = null;
  try {
    data = JSON.parse(json);
  } catch (error) {
    return false;
  }
  if (!data.version || parseInt(data.version) !== data.version || parseInt(data.version) !== 3) {
    return false;
  }
  return true;
}
function getJsonWalletAddress(json) {
  if (isCrowdsaleWallet(json)) {
    try {
      return getAddress(JSON.parse(json).ethaddr);
    } catch (error) {
      return null;
    }
  }
  if (isKeystoreWallet(json)) {
    try {
      return getAddress(JSON.parse(json).address);
    } catch (error) {
      return null;
    }
  }
  return null;
}
var init_inspect = __esm({
  "node_modules/@ethersproject/json-wallets/lib.esm/inspect.js"() {
    "use strict";
    init_lib7();
  }
});

// node_modules/scrypt-js/scrypt.js
var require_scrypt = __commonJS({
  "node_modules/scrypt-js/scrypt.js"(exports2, module2) {
    "use strict";
    (function(root2) {
      const MAX_VALUE = 2147483647;
      function SHA256(m6) {
        const K5 = new Uint32Array([
          1116352408,
          1899447441,
          3049323471,
          3921009573,
          961987163,
          1508970993,
          2453635748,
          2870763221,
          3624381080,
          310598401,
          607225278,
          1426881987,
          1925078388,
          2162078206,
          2614888103,
          3248222580,
          3835390401,
          4022224774,
          264347078,
          604807628,
          770255983,
          1249150122,
          1555081692,
          1996064986,
          2554220882,
          2821834349,
          2952996808,
          3210313671,
          3336571891,
          3584528711,
          113926993,
          338241895,
          666307205,
          773529912,
          1294757372,
          1396182291,
          1695183700,
          1986661051,
          2177026350,
          2456956037,
          2730485921,
          2820302411,
          3259730800,
          3345764771,
          3516065817,
          3600352804,
          4094571909,
          275423344,
          430227734,
          506948616,
          659060556,
          883997877,
          958139571,
          1322822218,
          1537002063,
          1747873779,
          1955562222,
          2024104815,
          2227730452,
          2361852424,
          2428436474,
          2756734187,
          3204031479,
          3329325298
        ]);
        let h0 = 1779033703, h1 = 3144134277, h22 = 1013904242, h32 = 2773480762;
        let h42 = 1359893119, h52 = 2600822924, h6 = 528734635, h7 = 1541459225;
        const w8 = new Uint32Array(64);
        function blocks2(p8) {
          let off = 0, len = p8.length;
          while (len >= 64) {
            let a5 = h0, b4 = h1, c5 = h22, d6 = h32, e6 = h42, f7 = h52, g7 = h6, h8 = h7, u7, i7, j8, t12, t22;
            for (i7 = 0; i7 < 16; i7++) {
              j8 = off + i7 * 4;
              w8[i7] = (p8[j8] & 255) << 24 | (p8[j8 + 1] & 255) << 16 | (p8[j8 + 2] & 255) << 8 | p8[j8 + 3] & 255;
            }
            for (i7 = 16; i7 < 64; i7++) {
              u7 = w8[i7 - 2];
              t12 = (u7 >>> 17 | u7 << 32 - 17) ^ (u7 >>> 19 | u7 << 32 - 19) ^ u7 >>> 10;
              u7 = w8[i7 - 15];
              t22 = (u7 >>> 7 | u7 << 32 - 7) ^ (u7 >>> 18 | u7 << 32 - 18) ^ u7 >>> 3;
              w8[i7] = (t12 + w8[i7 - 7] | 0) + (t22 + w8[i7 - 16] | 0) | 0;
            }
            for (i7 = 0; i7 < 64; i7++) {
              t12 = (((e6 >>> 6 | e6 << 32 - 6) ^ (e6 >>> 11 | e6 << 32 - 11) ^ (e6 >>> 25 | e6 << 32 - 25)) + (e6 & f7 ^ ~e6 & g7) | 0) + (h8 + (K5[i7] + w8[i7] | 0) | 0) | 0;
              t22 = ((a5 >>> 2 | a5 << 32 - 2) ^ (a5 >>> 13 | a5 << 32 - 13) ^ (a5 >>> 22 | a5 << 32 - 22)) + (a5 & b4 ^ a5 & c5 ^ b4 & c5) | 0;
              h8 = g7;
              g7 = f7;
              f7 = e6;
              e6 = d6 + t12 | 0;
              d6 = c5;
              c5 = b4;
              b4 = a5;
              a5 = t12 + t22 | 0;
            }
            h0 = h0 + a5 | 0;
            h1 = h1 + b4 | 0;
            h22 = h22 + c5 | 0;
            h32 = h32 + d6 | 0;
            h42 = h42 + e6 | 0;
            h52 = h52 + f7 | 0;
            h6 = h6 + g7 | 0;
            h7 = h7 + h8 | 0;
            off += 64;
            len -= 64;
          }
        }
        blocks2(m6);
        let i6, bytesLeft = m6.length % 64, bitLenHi = m6.length / 536870912 | 0, bitLenLo = m6.length << 3, numZeros = bytesLeft < 56 ? 56 : 120, p7 = m6.slice(m6.length - bytesLeft, m6.length);
        p7.push(128);
        for (i6 = bytesLeft + 1; i6 < numZeros; i6++) {
          p7.push(0);
        }
        p7.push(bitLenHi >>> 24 & 255);
        p7.push(bitLenHi >>> 16 & 255);
        p7.push(bitLenHi >>> 8 & 255);
        p7.push(bitLenHi >>> 0 & 255);
        p7.push(bitLenLo >>> 24 & 255);
        p7.push(bitLenLo >>> 16 & 255);
        p7.push(bitLenLo >>> 8 & 255);
        p7.push(bitLenLo >>> 0 & 255);
        blocks2(p7);
        return [
          h0 >>> 24 & 255,
          h0 >>> 16 & 255,
          h0 >>> 8 & 255,
          h0 >>> 0 & 255,
          h1 >>> 24 & 255,
          h1 >>> 16 & 255,
          h1 >>> 8 & 255,
          h1 >>> 0 & 255,
          h22 >>> 24 & 255,
          h22 >>> 16 & 255,
          h22 >>> 8 & 255,
          h22 >>> 0 & 255,
          h32 >>> 24 & 255,
          h32 >>> 16 & 255,
          h32 >>> 8 & 255,
          h32 >>> 0 & 255,
          h42 >>> 24 & 255,
          h42 >>> 16 & 255,
          h42 >>> 8 & 255,
          h42 >>> 0 & 255,
          h52 >>> 24 & 255,
          h52 >>> 16 & 255,
          h52 >>> 8 & 255,
          h52 >>> 0 & 255,
          h6 >>> 24 & 255,
          h6 >>> 16 & 255,
          h6 >>> 8 & 255,
          h6 >>> 0 & 255,
          h7 >>> 24 & 255,
          h7 >>> 16 & 255,
          h7 >>> 8 & 255,
          h7 >>> 0 & 255
        ];
      }
      function PBKDF2_HMAC_SHA256_OneIter(password, salt, dkLen) {
        password = password.length <= 64 ? password : SHA256(password);
        const innerLen = 64 + salt.length + 4;
        const inner = new Array(innerLen);
        const outerKey = new Array(64);
        let i6;
        let dk = [];
        for (i6 = 0; i6 < 64; i6++) {
          inner[i6] = 54;
        }
        for (i6 = 0; i6 < password.length; i6++) {
          inner[i6] ^= password[i6];
        }
        for (i6 = 0; i6 < salt.length; i6++) {
          inner[64 + i6] = salt[i6];
        }
        for (i6 = innerLen - 4; i6 < innerLen; i6++) {
          inner[i6] = 0;
        }
        for (i6 = 0; i6 < 64; i6++)
          outerKey[i6] = 92;
        for (i6 = 0; i6 < password.length; i6++)
          outerKey[i6] ^= password[i6];
        function incrementCounter() {
          for (let i7 = innerLen - 1; i7 >= innerLen - 4; i7--) {
            inner[i7]++;
            if (inner[i7] <= 255)
              return;
            inner[i7] = 0;
          }
        }
        while (dkLen >= 32) {
          incrementCounter();
          dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))));
          dkLen -= 32;
        }
        if (dkLen > 0) {
          incrementCounter();
          dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))).slice(0, dkLen));
        }
        return dk;
      }
      function blockmix_salsa8(BY, Yi2, r6, x6, _X) {
        let i6;
        arraycopy(BY, (2 * r6 - 1) * 16, _X, 0, 16);
        for (i6 = 0; i6 < 2 * r6; i6++) {
          blockxor(BY, i6 * 16, _X, 16);
          salsa20_8(_X, x6);
          arraycopy(_X, 0, BY, Yi2 + i6 * 16, 16);
        }
        for (i6 = 0; i6 < r6; i6++) {
          arraycopy(BY, Yi2 + i6 * 2 * 16, BY, i6 * 16, 16);
        }
        for (i6 = 0; i6 < r6; i6++) {
          arraycopy(BY, Yi2 + (i6 * 2 + 1) * 16, BY, (i6 + r6) * 16, 16);
        }
      }
      function R4(a5, b4) {
        return a5 << b4 | a5 >>> 32 - b4;
      }
      function salsa20_8(B4, x6) {
        arraycopy(B4, 0, x6, 0, 16);
        for (let i6 = 8; i6 > 0; i6 -= 2) {
          x6[4] ^= R4(x6[0] + x6[12], 7);
          x6[8] ^= R4(x6[4] + x6[0], 9);
          x6[12] ^= R4(x6[8] + x6[4], 13);
          x6[0] ^= R4(x6[12] + x6[8], 18);
          x6[9] ^= R4(x6[5] + x6[1], 7);
          x6[13] ^= R4(x6[9] + x6[5], 9);
          x6[1] ^= R4(x6[13] + x6[9], 13);
          x6[5] ^= R4(x6[1] + x6[13], 18);
          x6[14] ^= R4(x6[10] + x6[6], 7);
          x6[2] ^= R4(x6[14] + x6[10], 9);
          x6[6] ^= R4(x6[2] + x6[14], 13);
          x6[10] ^= R4(x6[6] + x6[2], 18);
          x6[3] ^= R4(x6[15] + x6[11], 7);
          x6[7] ^= R4(x6[3] + x6[15], 9);
          x6[11] ^= R4(x6[7] + x6[3], 13);
          x6[15] ^= R4(x6[11] + x6[7], 18);
          x6[1] ^= R4(x6[0] + x6[3], 7);
          x6[2] ^= R4(x6[1] + x6[0], 9);
          x6[3] ^= R4(x6[2] + x6[1], 13);
          x6[0] ^= R4(x6[3] + x6[2], 18);
          x6[6] ^= R4(x6[5] + x6[4], 7);
          x6[7] ^= R4(x6[6] + x6[5], 9);
          x6[4] ^= R4(x6[7] + x6[6], 13);
          x6[5] ^= R4(x6[4] + x6[7], 18);
          x6[11] ^= R4(x6[10] + x6[9], 7);
          x6[8] ^= R4(x6[11] + x6[10], 9);
          x6[9] ^= R4(x6[8] + x6[11], 13);
          x6[10] ^= R4(x6[9] + x6[8], 18);
          x6[12] ^= R4(x6[15] + x6[14], 7);
          x6[13] ^= R4(x6[12] + x6[15], 9);
          x6[14] ^= R4(x6[13] + x6[12], 13);
          x6[15] ^= R4(x6[14] + x6[13], 18);
        }
        for (let i6 = 0; i6 < 16; ++i6) {
          B4[i6] += x6[i6];
        }
      }
      function blockxor(S5, Si2, D5, len) {
        for (let i6 = 0; i6 < len; i6++) {
          D5[i6] ^= S5[Si2 + i6];
        }
      }
      function arraycopy(src, srcPos, dest, destPos, length) {
        while (length--) {
          dest[destPos++] = src[srcPos++];
        }
      }
      function checkBufferish(o6) {
        if (!o6 || typeof o6.length !== "number") {
          return false;
        }
        for (let i6 = 0; i6 < o6.length; i6++) {
          const v9 = o6[i6];
          if (typeof v9 !== "number" || v9 % 1 || v9 < 0 || v9 >= 256) {
            return false;
          }
        }
        return true;
      }
      function ensureInteger(value2, name2) {
        if (typeof value2 !== "number" || value2 % 1) {
          throw new Error("invalid " + name2);
        }
        return value2;
      }
      function _scrypt(password, salt, N7, r6, p7, dkLen, callback) {
        N7 = ensureInteger(N7, "N");
        r6 = ensureInteger(r6, "r");
        p7 = ensureInteger(p7, "p");
        dkLen = ensureInteger(dkLen, "dkLen");
        if (N7 === 0 || (N7 & N7 - 1) !== 0) {
          throw new Error("N must be power of 2");
        }
        if (N7 > MAX_VALUE / 128 / r6) {
          throw new Error("N too large");
        }
        if (r6 > MAX_VALUE / 128 / p7) {
          throw new Error("r too large");
        }
        if (!checkBufferish(password)) {
          throw new Error("password must be an array or buffer");
        }
        password = Array.prototype.slice.call(password);
        if (!checkBufferish(salt)) {
          throw new Error("salt must be an array or buffer");
        }
        salt = Array.prototype.slice.call(salt);
        let b4 = PBKDF2_HMAC_SHA256_OneIter(password, salt, p7 * 128 * r6);
        const B4 = new Uint32Array(p7 * 32 * r6);
        for (let i6 = 0; i6 < B4.length; i6++) {
          const j8 = i6 * 4;
          B4[i6] = (b4[j8 + 3] & 255) << 24 | (b4[j8 + 2] & 255) << 16 | (b4[j8 + 1] & 255) << 8 | (b4[j8 + 0] & 255) << 0;
        }
        const XY = new Uint32Array(64 * r6);
        const V3 = new Uint32Array(32 * r6 * N7);
        const Yi2 = 32 * r6;
        const x6 = new Uint32Array(16);
        const _X = new Uint32Array(16);
        const totalOps = p7 * N7 * 2;
        let currentOp = 0;
        let lastPercent10 = null;
        let stop = false;
        let state = 0;
        let i02 = 0, i1;
        let Bi2;
        const limit = callback ? parseInt(1e3 / r6) : 4294967295;
        const nextTick = typeof setImmediate !== "undefined" ? setImmediate : setTimeout;
        const incrementalSMix = function() {
          if (stop) {
            return callback(new Error("cancelled"), currentOp / totalOps);
          }
          let steps;
          switch (state) {
            case 0:
              Bi2 = i02 * 32 * r6;
              arraycopy(B4, Bi2, XY, 0, Yi2);
              state = 1;
              i1 = 0;
            case 1:
              steps = N7 - i1;
              if (steps > limit) {
                steps = limit;
              }
              for (let i6 = 0; i6 < steps; i6++) {
                arraycopy(XY, 0, V3, (i1 + i6) * Yi2, Yi2);
                blockmix_salsa8(XY, Yi2, r6, x6, _X);
              }
              i1 += steps;
              currentOp += steps;
              if (callback) {
                const percent10 = parseInt(1e3 * currentOp / totalOps);
                if (percent10 !== lastPercent10) {
                  stop = callback(null, currentOp / totalOps);
                  if (stop) {
                    break;
                  }
                  lastPercent10 = percent10;
                }
              }
              if (i1 < N7) {
                break;
              }
              i1 = 0;
              state = 2;
            case 2:
              steps = N7 - i1;
              if (steps > limit) {
                steps = limit;
              }
              for (let i6 = 0; i6 < steps; i6++) {
                const offset = (2 * r6 - 1) * 16;
                const j8 = XY[offset] & N7 - 1;
                blockxor(V3, j8 * Yi2, XY, Yi2);
                blockmix_salsa8(XY, Yi2, r6, x6, _X);
              }
              i1 += steps;
              currentOp += steps;
              if (callback) {
                const percent10 = parseInt(1e3 * currentOp / totalOps);
                if (percent10 !== lastPercent10) {
                  stop = callback(null, currentOp / totalOps);
                  if (stop) {
                    break;
                  }
                  lastPercent10 = percent10;
                }
              }
              if (i1 < N7) {
                break;
              }
              arraycopy(XY, 0, B4, Bi2, Yi2);
              i02++;
              if (i02 < p7) {
                state = 0;
                break;
              }
              b4 = [];
              for (let i6 = 0; i6 < B4.length; i6++) {
                b4.push(B4[i6] >> 0 & 255);
                b4.push(B4[i6] >> 8 & 255);
                b4.push(B4[i6] >> 16 & 255);
                b4.push(B4[i6] >> 24 & 255);
              }
              const derivedKey = PBKDF2_HMAC_SHA256_OneIter(password, b4, dkLen);
              if (callback) {
                callback(null, 1, derivedKey);
              }
              return derivedKey;
          }
          if (callback) {
            nextTick(incrementalSMix);
          }
        };
        if (!callback) {
          while (true) {
            const derivedKey = incrementalSMix();
            if (derivedKey != void 0) {
              return derivedKey;
            }
          }
        }
        incrementalSMix();
      }
      const lib = {
        scrypt: function(password, salt, N7, r6, p7, dkLen, progressCallback) {
          return new Promise(function(resolve, reject) {
            let lastProgress = 0;
            if (progressCallback) {
              progressCallback(0);
            }
            _scrypt(password, salt, N7, r6, p7, dkLen, function(error, progress, key2) {
              if (error) {
                reject(error);
              } else if (key2) {
                if (progressCallback && lastProgress !== 1) {
                  progressCallback(1);
                }
                resolve(new Uint8Array(key2));
              } else if (progressCallback && progress !== lastProgress) {
                lastProgress = progress;
                return progressCallback(progress);
              }
            });
          });
        },
        syncScrypt: function(password, salt, N7, r6, p7, dkLen) {
          return new Uint8Array(_scrypt(password, salt, N7, r6, p7, dkLen));
        }
      };
      if (typeof exports2 !== "undefined") {
        module2.exports = lib;
      } else if (typeof define === "function" && define.amd) {
        define(lib);
      } else if (root2) {
        if (root2.scrypt) {
          root2._scrypt = root2.scrypt;
        }
        root2.scrypt = lib;
      }
    })(exports2);
  }
});

// node_modules/@ethersproject/json-wallets/lib.esm/keystore.js
function hasMnemonic(value2) {
  return value2 != null && value2.mnemonic && value2.mnemonic.phrase;
}
function _decrypt(data, key2, ciphertext) {
  const cipher = searchPath(data, "crypto/cipher");
  if (cipher === "aes-128-ctr") {
    const iv = looseArrayify(searchPath(data, "crypto/cipherparams/iv"));
    const counter = new import_aes_js2.default.Counter(iv);
    const aesCtr = new import_aes_js2.default.ModeOfOperation.ctr(key2, counter);
    return arrayify(aesCtr.decrypt(ciphertext));
  }
  return null;
}
function _getAccount(data, key2) {
  const ciphertext = looseArrayify(searchPath(data, "crypto/ciphertext"));
  const computedMAC = hexlify(keccak256(concat([key2.slice(16, 32), ciphertext]))).substring(2);
  if (computedMAC !== searchPath(data, "crypto/mac").toLowerCase()) {
    throw new Error("invalid password");
  }
  const privateKey = _decrypt(data, key2.slice(0, 16), ciphertext);
  if (!privateKey) {
    logger25.throwError("unsupported cipher", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "decrypt"
    });
  }
  const mnemonicKey = key2.slice(32, 64);
  const address = computeAddress(privateKey);
  if (data.address) {
    let check = data.address.toLowerCase();
    if (check.substring(0, 2) !== "0x") {
      check = "0x" + check;
    }
    if (getAddress(check) !== address) {
      throw new Error("address mismatch");
    }
  }
  const account = {
    _isKeystoreAccount: true,
    address,
    privateKey: hexlify(privateKey)
  };
  if (searchPath(data, "x-ethers/version") === "0.1") {
    const mnemonicCiphertext = looseArrayify(searchPath(data, "x-ethers/mnemonicCiphertext"));
    const mnemonicIv = looseArrayify(searchPath(data, "x-ethers/mnemonicCounter"));
    const mnemonicCounter = new import_aes_js2.default.Counter(mnemonicIv);
    const mnemonicAesCtr = new import_aes_js2.default.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
    const path = searchPath(data, "x-ethers/path") || defaultPath;
    const locale = searchPath(data, "x-ethers/locale") || "en";
    const entropy = arrayify(mnemonicAesCtr.decrypt(mnemonicCiphertext));
    try {
      const mnemonic = entropyToMnemonic(entropy, locale);
      const node = HDNode.fromMnemonic(mnemonic, null, locale).derivePath(path);
      if (node.privateKey != account.privateKey) {
        throw new Error("mnemonic mismatch");
      }
      account.mnemonic = node.mnemonic;
    } catch (error) {
      if (error.code !== Logger.errors.INVALID_ARGUMENT || error.argument !== "wordlist") {
        throw error;
      }
    }
  }
  return new KeystoreAccount(account);
}
function pbkdf2Sync(passwordBytes, salt, count2, dkLen, prfFunc) {
  return arrayify(pbkdf2(passwordBytes, salt, count2, dkLen, prfFunc));
}
function pbkdf22(passwordBytes, salt, count2, dkLen, prfFunc) {
  return Promise.resolve(pbkdf2Sync(passwordBytes, salt, count2, dkLen, prfFunc));
}
function _computeKdfKey(data, password, pbkdf2Func, scryptFunc, progressCallback) {
  const passwordBytes = getPassword(password);
  const kdf = searchPath(data, "crypto/kdf");
  if (kdf && typeof kdf === "string") {
    const throwError2 = function(name2, value2) {
      return logger25.throwArgumentError("invalid key-derivation function parameters", name2, value2);
    };
    if (kdf.toLowerCase() === "scrypt") {
      const salt = looseArrayify(searchPath(data, "crypto/kdfparams/salt"));
      const N7 = parseInt(searchPath(data, "crypto/kdfparams/n"));
      const r6 = parseInt(searchPath(data, "crypto/kdfparams/r"));
      const p7 = parseInt(searchPath(data, "crypto/kdfparams/p"));
      if (!N7 || !r6 || !p7) {
        throwError2("kdf", kdf);
      }
      if ((N7 & N7 - 1) !== 0) {
        throwError2("N", N7);
      }
      const dkLen = parseInt(searchPath(data, "crypto/kdfparams/dklen"));
      if (dkLen !== 32) {
        throwError2("dklen", dkLen);
      }
      return scryptFunc(passwordBytes, salt, N7, r6, p7, 64, progressCallback);
    } else if (kdf.toLowerCase() === "pbkdf2") {
      const salt = looseArrayify(searchPath(data, "crypto/kdfparams/salt"));
      let prfFunc = null;
      const prf = searchPath(data, "crypto/kdfparams/prf");
      if (prf === "hmac-sha256") {
        prfFunc = "sha256";
      } else if (prf === "hmac-sha512") {
        prfFunc = "sha512";
      } else {
        throwError2("prf", prf);
      }
      const count2 = parseInt(searchPath(data, "crypto/kdfparams/c"));
      const dkLen = parseInt(searchPath(data, "crypto/kdfparams/dklen"));
      if (dkLen !== 32) {
        throwError2("dklen", dkLen);
      }
      return pbkdf2Func(passwordBytes, salt, count2, dkLen, prfFunc);
    }
  }
  return logger25.throwArgumentError("unsupported key-derivation function", "kdf", kdf);
}
function decryptSync(json, password) {
  const data = JSON.parse(json);
  const key2 = _computeKdfKey(data, password, pbkdf2Sync, import_scrypt_js.default.syncScrypt);
  return _getAccount(data, key2);
}
function decrypt2(json, password, progressCallback) {
  return __awaiter6(this, void 0, void 0, function* () {
    const data = JSON.parse(json);
    const key2 = yield _computeKdfKey(data, password, pbkdf22, import_scrypt_js.default.scrypt, progressCallback);
    return _getAccount(data, key2);
  });
}
function encrypt(account, password, options, progressCallback) {
  try {
    if (getAddress(account.address) !== computeAddress(account.privateKey)) {
      throw new Error("address/privateKey mismatch");
    }
    if (hasMnemonic(account)) {
      const mnemonic = account.mnemonic;
      const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path || defaultPath);
      if (node.privateKey != account.privateKey) {
        throw new Error("mnemonic mismatch");
      }
    }
  } catch (e6) {
    return Promise.reject(e6);
  }
  if (typeof options === "function" && !progressCallback) {
    progressCallback = options;
    options = {};
  }
  if (!options) {
    options = {};
  }
  const privateKey = arrayify(account.privateKey);
  const passwordBytes = getPassword(password);
  let entropy = null;
  let path = null;
  let locale = null;
  if (hasMnemonic(account)) {
    const srcMnemonic = account.mnemonic;
    entropy = arrayify(mnemonicToEntropy(srcMnemonic.phrase, srcMnemonic.locale || "en"));
    path = srcMnemonic.path || defaultPath;
    locale = srcMnemonic.locale || "en";
  }
  let client = options.client;
  if (!client) {
    client = "ethers.js";
  }
  let salt = null;
  if (options.salt) {
    salt = arrayify(options.salt);
  } else {
    salt = randomBytes(32);
    ;
  }
  let iv = null;
  if (options.iv) {
    iv = arrayify(options.iv);
    if (iv.length !== 16) {
      throw new Error("invalid iv");
    }
  } else {
    iv = randomBytes(16);
  }
  let uuidRandom = null;
  if (options.uuid) {
    uuidRandom = arrayify(options.uuid);
    if (uuidRandom.length !== 16) {
      throw new Error("invalid uuid");
    }
  } else {
    uuidRandom = randomBytes(16);
  }
  let N7 = 1 << 17, r6 = 8, p7 = 1;
  if (options.scrypt) {
    if (options.scrypt.N) {
      N7 = options.scrypt.N;
    }
    if (options.scrypt.r) {
      r6 = options.scrypt.r;
    }
    if (options.scrypt.p) {
      p7 = options.scrypt.p;
    }
  }
  return import_scrypt_js.default.scrypt(passwordBytes, salt, N7, r6, p7, 64, progressCallback).then((key2) => {
    key2 = arrayify(key2);
    const derivedKey = key2.slice(0, 16);
    const macPrefix = key2.slice(16, 32);
    const mnemonicKey = key2.slice(32, 64);
    const counter = new import_aes_js2.default.Counter(iv);
    const aesCtr = new import_aes_js2.default.ModeOfOperation.ctr(derivedKey, counter);
    const ciphertext = arrayify(aesCtr.encrypt(privateKey));
    const mac = keccak256(concat([macPrefix, ciphertext]));
    const data = {
      address: account.address.substring(2).toLowerCase(),
      id: uuidV4(uuidRandom),
      version: 3,
      Crypto: {
        cipher: "aes-128-ctr",
        cipherparams: {
          iv: hexlify(iv).substring(2)
        },
        ciphertext: hexlify(ciphertext).substring(2),
        kdf: "scrypt",
        kdfparams: {
          salt: hexlify(salt).substring(2),
          n: N7,
          dklen: 32,
          p: p7,
          r: r6
        },
        mac: mac.substring(2)
      }
    };
    if (entropy) {
      const mnemonicIv = randomBytes(16);
      const mnemonicCounter = new import_aes_js2.default.Counter(mnemonicIv);
      const mnemonicAesCtr = new import_aes_js2.default.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
      const mnemonicCiphertext = arrayify(mnemonicAesCtr.encrypt(entropy));
      const now2 = new Date();
      const timestamp2 = now2.getUTCFullYear() + "-" + zpad(now2.getUTCMonth() + 1, 2) + "-" + zpad(now2.getUTCDate(), 2) + "T" + zpad(now2.getUTCHours(), 2) + "-" + zpad(now2.getUTCMinutes(), 2) + "-" + zpad(now2.getUTCSeconds(), 2) + ".0Z";
      data["x-ethers"] = {
        client,
        gethFilename: "UTC--" + timestamp2 + "--" + data.address,
        mnemonicCounter: hexlify(mnemonicIv).substring(2),
        mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),
        path,
        locale,
        version: "0.1"
      };
    }
    return JSON.stringify(data);
  });
}
var import_aes_js2, import_scrypt_js, __awaiter6, logger25, KeystoreAccount;
var init_keystore = __esm({
  "node_modules/@ethersproject/json-wallets/lib.esm/keystore.js"() {
    "use strict";
    import_aes_js2 = __toESM(require_aes_js());
    import_scrypt_js = __toESM(require_scrypt());
    init_lib7();
    init_lib2();
    init_lib20();
    init_lib5();
    init_lib18();
    init_lib21();
    init_lib4();
    init_lib15();
    init_utils();
    init_lib();
    init_version18();
    __awaiter6 = function(thisArg, _arguments, P5, generator) {
      function adopt(value2) {
        return value2 instanceof P5 ? value2 : new P5(function(resolve) {
          resolve(value2);
        });
      }
      return new (P5 || (P5 = Promise))(function(resolve, reject) {
        function fulfilled(value2) {
          try {
            step(generator.next(value2));
          } catch (e6) {
            reject(e6);
          }
        }
        function rejected(value2) {
          try {
            step(generator["throw"](value2));
          } catch (e6) {
            reject(e6);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger25 = new Logger(version19);
    KeystoreAccount = class extends Description {
      isKeystoreAccount(value2) {
        return !!(value2 && value2._isKeystoreAccount);
      }
    };
  }
});

// node_modules/@ethersproject/json-wallets/lib.esm/index.js
var lib_exports17 = {};
__export(lib_exports17, {
  decryptCrowdsale: () => decrypt,
  decryptJsonWallet: () => decryptJsonWallet,
  decryptJsonWalletSync: () => decryptJsonWalletSync,
  decryptKeystore: () => decrypt2,
  decryptKeystoreSync: () => decryptSync,
  encryptKeystore: () => encrypt,
  getJsonWalletAddress: () => getJsonWalletAddress,
  isCrowdsaleWallet: () => isCrowdsaleWallet,
  isKeystoreWallet: () => isKeystoreWallet
});
function decryptJsonWallet(json, password, progressCallback) {
  if (isCrowdsaleWallet(json)) {
    if (progressCallback) {
      progressCallback(0);
    }
    const account = decrypt(json, password);
    if (progressCallback) {
      progressCallback(1);
    }
    return Promise.resolve(account);
  }
  if (isKeystoreWallet(json)) {
    return decrypt2(json, password, progressCallback);
  }
  return Promise.reject(new Error("invalid JSON wallet"));
}
function decryptJsonWalletSync(json, password) {
  if (isCrowdsaleWallet(json)) {
    return decrypt(json, password);
  }
  if (isKeystoreWallet(json)) {
    return decryptSync(json, password);
  }
  throw new Error("invalid JSON wallet");
}
var init_lib22 = __esm({
  "node_modules/@ethersproject/json-wallets/lib.esm/index.js"() {
    "use strict";
    init_crowdsale();
    init_inspect();
    init_keystore();
  }
});

// node_modules/@ethersproject/wallet/lib.esm/_version.js
var version20;
var init_version19 = __esm({
  "node_modules/@ethersproject/wallet/lib.esm/_version.js"() {
    version20 = "wallet/5.6.0";
  }
});

// node_modules/@ethersproject/wallet/lib.esm/index.js
var lib_exports18 = {};
__export(lib_exports18, {
  Wallet: () => Wallet,
  verifyMessage: () => verifyMessage,
  verifyTypedData: () => verifyTypedData
});
function isAccount(value2) {
  return value2 != null && isHexString(value2.privateKey, 32) && value2.address != null;
}
function hasMnemonic2(value2) {
  const mnemonic = value2.mnemonic;
  return mnemonic && mnemonic.phrase;
}
function verifyMessage(message, signature2) {
  return recoverAddress(hashMessage(message), signature2);
}
function verifyTypedData(domain2, types, value2, signature2) {
  return recoverAddress(TypedDataEncoder.hash(domain2, types, value2), signature2);
}
var __awaiter7, logger26, Wallet;
var init_lib23 = __esm({
  "node_modules/@ethersproject/wallet/lib.esm/index.js"() {
    "use strict";
    init_lib7();
    init_lib12();
    init_lib13();
    init_lib2();
    init_lib10();
    init_lib20();
    init_lib5();
    init_lib4();
    init_lib21();
    init_lib14();
    init_lib22();
    init_lib15();
    init_lib();
    init_version19();
    __awaiter7 = function(thisArg, _arguments, P5, generator) {
      function adopt(value2) {
        return value2 instanceof P5 ? value2 : new P5(function(resolve) {
          resolve(value2);
        });
      }
      return new (P5 || (P5 = Promise))(function(resolve, reject) {
        function fulfilled(value2) {
          try {
            step(generator.next(value2));
          } catch (e6) {
            reject(e6);
          }
        }
        function rejected(value2) {
          try {
            step(generator["throw"](value2));
          } catch (e6) {
            reject(e6);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger26 = new Logger(version20);
    Wallet = class extends Signer {
      constructor(privateKey, provider) {
        logger26.checkNew(new.target, Wallet);
        super();
        if (isAccount(privateKey)) {
          const signingKey = new SigningKey(privateKey.privateKey);
          defineReadOnly(this, "_signingKey", () => signingKey);
          defineReadOnly(this, "address", computeAddress(this.publicKey));
          if (this.address !== getAddress(privateKey.address)) {
            logger26.throwArgumentError("privateKey/address mismatch", "privateKey", "[REDACTED]");
          }
          if (hasMnemonic2(privateKey)) {
            const srcMnemonic = privateKey.mnemonic;
            defineReadOnly(this, "_mnemonic", () => ({
              phrase: srcMnemonic.phrase,
              path: srcMnemonic.path || defaultPath,
              locale: srcMnemonic.locale || "en"
            }));
            const mnemonic = this.mnemonic;
            const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path);
            if (computeAddress(node.privateKey) !== this.address) {
              logger26.throwArgumentError("mnemonic/address mismatch", "privateKey", "[REDACTED]");
            }
          } else {
            defineReadOnly(this, "_mnemonic", () => null);
          }
        } else {
          if (SigningKey.isSigningKey(privateKey)) {
            if (privateKey.curve !== "secp256k1") {
              logger26.throwArgumentError("unsupported curve; must be secp256k1", "privateKey", "[REDACTED]");
            }
            defineReadOnly(this, "_signingKey", () => privateKey);
          } else {
            if (typeof privateKey === "string") {
              if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {
                privateKey = "0x" + privateKey;
              }
            }
            const signingKey = new SigningKey(privateKey);
            defineReadOnly(this, "_signingKey", () => signingKey);
          }
          defineReadOnly(this, "_mnemonic", () => null);
          defineReadOnly(this, "address", computeAddress(this.publicKey));
        }
        if (provider && !Provider.isProvider(provider)) {
          logger26.throwArgumentError("invalid provider", "provider", provider);
        }
        defineReadOnly(this, "provider", provider || null);
      }
      get mnemonic() {
        return this._mnemonic();
      }
      get privateKey() {
        return this._signingKey().privateKey;
      }
      get publicKey() {
        return this._signingKey().publicKey;
      }
      getAddress() {
        return Promise.resolve(this.address);
      }
      connect(provider) {
        return new Wallet(this, provider);
      }
      signTransaction(transaction) {
        return resolveProperties(transaction).then((tx) => {
          if (tx.from != null) {
            if (getAddress(tx.from) !== this.address) {
              logger26.throwArgumentError("transaction from address mismatch", "transaction.from", transaction.from);
            }
            delete tx.from;
          }
          const signature2 = this._signingKey().signDigest(keccak256(serialize(tx)));
          return serialize(tx, signature2);
        });
      }
      signMessage(message) {
        return __awaiter7(this, void 0, void 0, function* () {
          return joinSignature(this._signingKey().signDigest(hashMessage(message)));
        });
      }
      _signTypedData(domain2, types, value2) {
        return __awaiter7(this, void 0, void 0, function* () {
          const populated = yield TypedDataEncoder.resolveNames(domain2, types, value2, (name2) => {
            if (this.provider == null) {
              logger26.throwError("cannot resolve ENS names without a provider", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "resolveName",
                value: name2
              });
            }
            return this.provider.resolveName(name2);
          });
          return joinSignature(this._signingKey().signDigest(TypedDataEncoder.hash(populated.domain, types, populated.value)));
        });
      }
      encrypt(password, options, progressCallback) {
        if (typeof options === "function" && !progressCallback) {
          progressCallback = options;
          options = {};
        }
        if (progressCallback && typeof progressCallback !== "function") {
          throw new Error("invalid callback");
        }
        if (!options) {
          options = {};
        }
        return encrypt(this, password, options, progressCallback);
      }
      static createRandom(options) {
        let entropy = randomBytes(16);
        if (!options) {
          options = {};
        }
        if (options.extraEntropy) {
          entropy = arrayify(hexDataSlice(keccak256(concat([entropy, options.extraEntropy])), 0, 16));
        }
        const mnemonic = entropyToMnemonic(entropy, options.locale);
        return Wallet.fromMnemonic(mnemonic, options.path, options.locale);
      }
      static fromEncryptedJson(json, password, progressCallback) {
        return decryptJsonWallet(json, password, progressCallback).then((account) => {
          return new Wallet(account);
        });
      }
      static fromEncryptedJsonSync(json, password) {
        return new Wallet(decryptJsonWalletSync(json, password));
      }
      static fromMnemonic(mnemonic, path, wordlist2) {
        if (!path) {
          path = defaultPath;
        }
        return new Wallet(HDNode.fromMnemonic(mnemonic, null, wordlist2).derivePath(path));
      }
    };
  }
});

// node_modules/@ethersproject/base64/lib.esm/base64.js
function decode2(textData) {
  textData = atob(textData);
  const data = [];
  for (let i6 = 0; i6 < textData.length; i6++) {
    data.push(textData.charCodeAt(i6));
  }
  return arrayify(data);
}
function encode3(data) {
  data = arrayify(data);
  let textData = "";
  for (let i6 = 0; i6 < data.length; i6++) {
    textData += String.fromCharCode(data[i6]);
  }
  return btoa(textData);
}
var init_base64 = __esm({
  "node_modules/@ethersproject/base64/lib.esm/base64.js"() {
    "use strict";
    init_lib2();
  }
});

// node_modules/@ethersproject/base64/lib.esm/index.js
var lib_exports19 = {};
__export(lib_exports19, {
  decode: () => decode2,
  encode: () => encode3
});
var init_lib24 = __esm({
  "node_modules/@ethersproject/base64/lib.esm/index.js"() {
    "use strict";
    init_base64();
  }
});

// node_modules/@ethersproject/web/lib.esm/_version.js
var version22;
var init_version20 = __esm({
  "node_modules/@ethersproject/web/lib.esm/_version.js"() {
    version22 = "web/5.6.0";
  }
});

// node_modules/@ethersproject/web/lib.esm/geturl.js
function getUrl(href, options) {
  return __awaiter8(this, void 0, void 0, function* () {
    if (options == null) {
      options = {};
    }
    const request = {
      method: options.method || "GET",
      headers: options.headers || {},
      body: options.body || void 0
    };
    if (options.skipFetchSetup !== true) {
      request.mode = "cors";
      request.cache = "no-cache";
      request.credentials = "same-origin";
      request.redirect = "follow";
      request.referrer = "client";
    }
    ;
    const response = yield fetch(href, request);
    const body = yield response.arrayBuffer();
    const headers = {};
    if (response.headers.forEach) {
      response.headers.forEach((value2, key2) => {
        headers[key2.toLowerCase()] = value2;
      });
    } else {
      response.headers.keys().forEach((key2) => {
        headers[key2.toLowerCase()] = response.headers.get(key2);
      });
    }
    return {
      headers,
      statusCode: response.status,
      statusMessage: response.statusText,
      body: arrayify(new Uint8Array(body))
    };
  });
}
var __awaiter8;
var init_geturl = __esm({
  "node_modules/@ethersproject/web/lib.esm/geturl.js"() {
    "use strict";
    init_lib2();
    __awaiter8 = function(thisArg, _arguments, P5, generator) {
      function adopt(value2) {
        return value2 instanceof P5 ? value2 : new P5(function(resolve) {
          resolve(value2);
        });
      }
      return new (P5 || (P5 = Promise))(function(resolve, reject) {
        function fulfilled(value2) {
          try {
            step(generator.next(value2));
          } catch (e6) {
            reject(e6);
          }
        }
        function rejected(value2) {
          try {
            step(generator["throw"](value2));
          } catch (e6) {
            reject(e6);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
  }
});

// node_modules/@ethersproject/web/lib.esm/index.js
var lib_exports20 = {};
__export(lib_exports20, {
  _fetchData: () => _fetchData,
  fetchJson: () => fetchJson,
  poll: () => poll
});
function staller(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
function bodyify(value2, type) {
  if (value2 == null) {
    return null;
  }
  if (typeof value2 === "string") {
    return value2;
  }
  if (isBytesLike(value2)) {
    if (type && (type.split("/")[0] === "text" || type.split(";")[0].trim() === "application/json")) {
      try {
        return toUtf8String(value2);
      } catch (error) {
      }
      ;
    }
    return hexlify(value2);
  }
  return value2;
}
function _fetchData(connection, body, processFunc) {
  const attemptLimit = typeof connection === "object" && connection.throttleLimit != null ? connection.throttleLimit : 12;
  logger28.assertArgument(attemptLimit > 0 && attemptLimit % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", attemptLimit);
  const throttleCallback = typeof connection === "object" ? connection.throttleCallback : null;
  const throttleSlotInterval = typeof connection === "object" && typeof connection.throttleSlotInterval === "number" ? connection.throttleSlotInterval : 100;
  logger28.assertArgument(throttleSlotInterval > 0 && throttleSlotInterval % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", throttleSlotInterval);
  const errorPassThrough = typeof connection === "object" ? !!connection.errorPassThrough : false;
  const headers = {};
  let url = null;
  const options = {
    method: "GET"
  };
  let allow304 = false;
  let timeout2 = 2 * 60 * 1e3;
  if (typeof connection === "string") {
    url = connection;
  } else if (typeof connection === "object") {
    if (connection == null || connection.url == null) {
      logger28.throwArgumentError("missing URL", "connection.url", connection);
    }
    url = connection.url;
    if (typeof connection.timeout === "number" && connection.timeout > 0) {
      timeout2 = connection.timeout;
    }
    if (connection.headers) {
      for (const key2 in connection.headers) {
        headers[key2.toLowerCase()] = { key: key2, value: String(connection.headers[key2]) };
        if (["if-none-match", "if-modified-since"].indexOf(key2.toLowerCase()) >= 0) {
          allow304 = true;
        }
      }
    }
    options.allowGzip = !!connection.allowGzip;
    if (connection.user != null && connection.password != null) {
      if (url.substring(0, 6) !== "https:" && connection.allowInsecureAuthentication !== true) {
        logger28.throwError("basic authentication requires a secure https url", Logger.errors.INVALID_ARGUMENT, { argument: "url", url, user: connection.user, password: "[REDACTED]" });
      }
      const authorization = connection.user + ":" + connection.password;
      headers["authorization"] = {
        key: "Authorization",
        value: "Basic " + encode3(toUtf8Bytes(authorization))
      };
    }
    if (connection.skipFetchSetup != null) {
      options.skipFetchSetup = !!connection.skipFetchSetup;
    }
  }
  const reData = new RegExp("^data:([a-z0-9-]+/[a-z0-9-]+);base64,(.*)$", "i");
  const dataMatch = url ? url.match(reData) : null;
  if (dataMatch) {
    try {
      const response = {
        statusCode: 200,
        statusMessage: "OK",
        headers: { "content-type": dataMatch[1] },
        body: decode2(dataMatch[2])
      };
      let result = response.body;
      if (processFunc) {
        result = processFunc(response.body, response);
      }
      return Promise.resolve(result);
    } catch (error) {
      logger28.throwError("processing response error", Logger.errors.SERVER_ERROR, {
        body: bodyify(dataMatch[1], dataMatch[2]),
        error,
        requestBody: null,
        requestMethod: "GET",
        url
      });
    }
  }
  if (body) {
    options.method = "POST";
    options.body = body;
    if (headers["content-type"] == null) {
      headers["content-type"] = { key: "Content-Type", value: "application/octet-stream" };
    }
    if (headers["content-length"] == null) {
      headers["content-length"] = { key: "Content-Length", value: String(body.length) };
    }
  }
  const flatHeaders = {};
  Object.keys(headers).forEach((key2) => {
    const header = headers[key2];
    flatHeaders[header.key] = header.value;
  });
  options.headers = flatHeaders;
  const runningTimeout = function() {
    let timer3 = null;
    const promise = new Promise(function(resolve, reject) {
      if (timeout2) {
        timer3 = setTimeout(() => {
          if (timer3 == null) {
            return;
          }
          timer3 = null;
          reject(logger28.makeError("timeout", Logger.errors.TIMEOUT, {
            requestBody: bodyify(options.body, flatHeaders["content-type"]),
            requestMethod: options.method,
            timeout: timeout2,
            url
          }));
        }, timeout2);
      }
    });
    const cancel = function() {
      if (timer3 == null) {
        return;
      }
      clearTimeout(timer3);
      timer3 = null;
    };
    return { promise, cancel };
  }();
  const runningFetch = function() {
    return __awaiter9(this, void 0, void 0, function* () {
      for (let attempt = 0; attempt < attemptLimit; attempt++) {
        let response = null;
        try {
          response = yield getUrl(url, options);
          if (attempt < attemptLimit) {
            if (response.statusCode === 301 || response.statusCode === 302) {
              const location2 = response.headers.location || "";
              if (options.method === "GET" && location2.match(/^https:/)) {
                url = response.headers.location;
                continue;
              }
            } else if (response.statusCode === 429) {
              let tryAgain = true;
              if (throttleCallback) {
                tryAgain = yield throttleCallback(attempt, url);
              }
              if (tryAgain) {
                let stall3 = 0;
                const retryAfter = response.headers["retry-after"];
                if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
                  stall3 = parseInt(retryAfter) * 1e3;
                } else {
                  stall3 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                }
                yield staller(stall3);
                continue;
              }
            }
          }
        } catch (error) {
          response = error.response;
          if (response == null) {
            runningTimeout.cancel();
            logger28.throwError("missing response", Logger.errors.SERVER_ERROR, {
              requestBody: bodyify(options.body, flatHeaders["content-type"]),
              requestMethod: options.method,
              serverError: error,
              url
            });
          }
        }
        let body2 = response.body;
        if (allow304 && response.statusCode === 304) {
          body2 = null;
        } else if (!errorPassThrough && (response.statusCode < 200 || response.statusCode >= 300)) {
          runningTimeout.cancel();
          logger28.throwError("bad response", Logger.errors.SERVER_ERROR, {
            status: response.statusCode,
            headers: response.headers,
            body: bodyify(body2, response.headers ? response.headers["content-type"] : null),
            requestBody: bodyify(options.body, flatHeaders["content-type"]),
            requestMethod: options.method,
            url
          });
        }
        if (processFunc) {
          try {
            const result = yield processFunc(body2, response);
            runningTimeout.cancel();
            return result;
          } catch (error) {
            if (error.throttleRetry && attempt < attemptLimit) {
              let tryAgain = true;
              if (throttleCallback) {
                tryAgain = yield throttleCallback(attempt, url);
              }
              if (tryAgain) {
                const timeout3 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                yield staller(timeout3);
                continue;
              }
            }
            runningTimeout.cancel();
            logger28.throwError("processing response error", Logger.errors.SERVER_ERROR, {
              body: bodyify(body2, response.headers ? response.headers["content-type"] : null),
              error,
              requestBody: bodyify(options.body, flatHeaders["content-type"]),
              requestMethod: options.method,
              url
            });
          }
        }
        runningTimeout.cancel();
        return body2;
      }
      return logger28.throwError("failed response", Logger.errors.SERVER_ERROR, {
        requestBody: bodyify(options.body, flatHeaders["content-type"]),
        requestMethod: options.method,
        url
      });
    });
  }();
  return Promise.race([runningTimeout.promise, runningFetch]);
}
function fetchJson(connection, json, processFunc) {
  let processJsonFunc = (value2, response) => {
    let result = null;
    if (value2 != null) {
      try {
        result = JSON.parse(toUtf8String(value2));
      } catch (error) {
        logger28.throwError("invalid JSON", Logger.errors.SERVER_ERROR, {
          body: value2,
          error
        });
      }
    }
    if (processFunc) {
      result = processFunc(result, response);
    }
    return result;
  };
  let body = null;
  if (json != null) {
    body = toUtf8Bytes(json);
    const updated = typeof connection === "string" ? { url: connection } : shallowCopy(connection);
    if (updated.headers) {
      const hasContentType = Object.keys(updated.headers).filter((k8) => k8.toLowerCase() === "content-type").length !== 0;
      if (!hasContentType) {
        updated.headers = shallowCopy(updated.headers);
        updated.headers["content-type"] = "application/json";
      }
    } else {
      updated.headers = { "content-type": "application/json" };
    }
    connection = updated;
  }
  return _fetchData(connection, body, processJsonFunc);
}
function poll(func, options) {
  if (!options) {
    options = {};
  }
  options = shallowCopy(options);
  if (options.floor == null) {
    options.floor = 0;
  }
  if (options.ceiling == null) {
    options.ceiling = 1e4;
  }
  if (options.interval == null) {
    options.interval = 250;
  }
  return new Promise(function(resolve, reject) {
    let timer3 = null;
    let done = false;
    const cancel = () => {
      if (done) {
        return false;
      }
      done = true;
      if (timer3) {
        clearTimeout(timer3);
      }
      return true;
    };
    if (options.timeout) {
      timer3 = setTimeout(() => {
        if (cancel()) {
          reject(new Error("timeout"));
        }
      }, options.timeout);
    }
    const retryLimit = options.retryLimit;
    let attempt = 0;
    function check() {
      return func().then(function(result) {
        if (result !== void 0) {
          if (cancel()) {
            resolve(result);
          }
        } else if (options.oncePoll) {
          options.oncePoll.once("poll", check);
        } else if (options.onceBlock) {
          options.onceBlock.once("block", check);
        } else if (!done) {
          attempt++;
          if (attempt > retryLimit) {
            if (cancel()) {
              reject(new Error("retry limit reached"));
            }
            return;
          }
          let timeout2 = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));
          if (timeout2 < options.floor) {
            timeout2 = options.floor;
          }
          if (timeout2 > options.ceiling) {
            timeout2 = options.ceiling;
          }
          setTimeout(check, timeout2);
        }
        return null;
      }, function(error) {
        if (cancel()) {
          reject(error);
        }
      });
    }
    check();
  });
}
var __awaiter9, logger28;
var init_lib25 = __esm({
  "node_modules/@ethersproject/web/lib.esm/index.js"() {
    "use strict";
    init_lib24();
    init_lib2();
    init_lib4();
    init_lib9();
    init_lib();
    init_version20();
    init_geturl();
    __awaiter9 = function(thisArg, _arguments, P5, generator) {
      function adopt(value2) {
        return value2 instanceof P5 ? value2 : new P5(function(resolve) {
          resolve(value2);
        });
      }
      return new (P5 || (P5 = Promise))(function(resolve, reject) {
        function fulfilled(value2) {
          try {
            step(generator.next(value2));
          } catch (e6) {
            reject(e6);
          }
        }
        function rejected(value2) {
          try {
            step(generator["throw"](value2));
          } catch (e6) {
            reject(e6);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger28 = new Logger(version22);
  }
});

// node_modules/bech32/index.js
var require_bech32 = __commonJS({
  "node_modules/bech32/index.js"(exports2, module2) {
    "use strict";
    var ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
    var ALPHABET_MAP = {};
    for (z6 = 0; z6 < ALPHABET.length; z6++) {
      x6 = ALPHABET.charAt(z6);
      if (ALPHABET_MAP[x6] !== void 0)
        throw new TypeError(x6 + " is ambiguous");
      ALPHABET_MAP[x6] = z6;
    }
    var x6;
    var z6;
    function polymodStep(pre) {
      var b4 = pre >> 25;
      return (pre & 33554431) << 5 ^ -(b4 >> 0 & 1) & 996825010 ^ -(b4 >> 1 & 1) & 642813549 ^ -(b4 >> 2 & 1) & 513874426 ^ -(b4 >> 3 & 1) & 1027748829 ^ -(b4 >> 4 & 1) & 705979059;
    }
    function prefixChk(prefix2) {
      var chk = 1;
      for (var i6 = 0; i6 < prefix2.length; ++i6) {
        var c5 = prefix2.charCodeAt(i6);
        if (c5 < 33 || c5 > 126)
          return "Invalid prefix (" + prefix2 + ")";
        chk = polymodStep(chk) ^ c5 >> 5;
      }
      chk = polymodStep(chk);
      for (i6 = 0; i6 < prefix2.length; ++i6) {
        var v9 = prefix2.charCodeAt(i6);
        chk = polymodStep(chk) ^ v9 & 31;
      }
      return chk;
    }
    function encode4(prefix2, words2, LIMIT) {
      LIMIT = LIMIT || 90;
      if (prefix2.length + 7 + words2.length > LIMIT)
        throw new TypeError("Exceeds length limit");
      prefix2 = prefix2.toLowerCase();
      var chk = prefixChk(prefix2);
      if (typeof chk === "string")
        throw new Error(chk);
      var result = prefix2 + "1";
      for (var i6 = 0; i6 < words2.length; ++i6) {
        var x7 = words2[i6];
        if (x7 >> 5 !== 0)
          throw new Error("Non 5-bit word");
        chk = polymodStep(chk) ^ x7;
        result += ALPHABET.charAt(x7);
      }
      for (i6 = 0; i6 < 6; ++i6) {
        chk = polymodStep(chk);
      }
      chk ^= 1;
      for (i6 = 0; i6 < 6; ++i6) {
        var v9 = chk >> (5 - i6) * 5 & 31;
        result += ALPHABET.charAt(v9);
      }
      return result;
    }
    function __decode(str, LIMIT) {
      LIMIT = LIMIT || 90;
      if (str.length < 8)
        return str + " too short";
      if (str.length > LIMIT)
        return "Exceeds length limit";
      var lowered = str.toLowerCase();
      var uppered = str.toUpperCase();
      if (str !== lowered && str !== uppered)
        return "Mixed-case string " + str;
      str = lowered;
      var split = str.lastIndexOf("1");
      if (split === -1)
        return "No separator character for " + str;
      if (split === 0)
        return "Missing prefix for " + str;
      var prefix2 = str.slice(0, split);
      var wordChars = str.slice(split + 1);
      if (wordChars.length < 6)
        return "Data too short";
      var chk = prefixChk(prefix2);
      if (typeof chk === "string")
        return chk;
      var words2 = [];
      for (var i6 = 0; i6 < wordChars.length; ++i6) {
        var c5 = wordChars.charAt(i6);
        var v9 = ALPHABET_MAP[c5];
        if (v9 === void 0)
          return "Unknown character " + c5;
        chk = polymodStep(chk) ^ v9;
        if (i6 + 6 >= wordChars.length)
          continue;
        words2.push(v9);
      }
      if (chk !== 1)
        return "Invalid checksum for " + str;
      return { prefix: prefix2, words: words2 };
    }
    function decodeUnsafe() {
      var res = __decode.apply(null, arguments);
      if (typeof res === "object")
        return res;
    }
    function decode3(str) {
      var res = __decode.apply(null, arguments);
      if (typeof res === "object")
        return res;
      throw new Error(res);
    }
    function convert(data, inBits, outBits, pad) {
      var value2 = 0;
      var bits = 0;
      var maxV = (1 << outBits) - 1;
      var result = [];
      for (var i6 = 0; i6 < data.length; ++i6) {
        value2 = value2 << inBits | data[i6];
        bits += inBits;
        while (bits >= outBits) {
          bits -= outBits;
          result.push(value2 >> bits & maxV);
        }
      }
      if (pad) {
        if (bits > 0) {
          result.push(value2 << outBits - bits & maxV);
        }
      } else {
        if (bits >= inBits)
          return "Excess padding";
        if (value2 << outBits - bits & maxV)
          return "Non-zero padding";
      }
      return result;
    }
    function toWordsUnsafe(bytes) {
      var res = convert(bytes, 8, 5, true);
      if (Array.isArray(res))
        return res;
    }
    function toWords(bytes) {
      var res = convert(bytes, 8, 5, true);
      if (Array.isArray(res))
        return res;
      throw new Error(res);
    }
    function fromWordsUnsafe(words2) {
      var res = convert(words2, 5, 8, false);
      if (Array.isArray(res))
        return res;
    }
    function fromWords(words2) {
      var res = convert(words2, 5, 8, false);
      if (Array.isArray(res))
        return res;
      throw new Error(res);
    }
    module2.exports = {
      decodeUnsafe,
      decode: decode3,
      encode: encode4,
      toWordsUnsafe,
      toWords,
      fromWordsUnsafe,
      fromWords
    };
  }
});

// node_modules/@ethersproject/solidity/lib.esm/_version.js
var version24;
var init_version21 = __esm({
  "node_modules/@ethersproject/solidity/lib.esm/_version.js"() {
    version24 = "solidity/5.6.0";
  }
});

// node_modules/@ethersproject/solidity/lib.esm/index.js
var lib_exports22 = {};
__export(lib_exports22, {
  keccak256: () => keccak2562,
  pack: () => pack2,
  sha256: () => sha2562
});
function _pack(type, value2, isArray2) {
  switch (type) {
    case "address":
      if (isArray2) {
        return zeroPad(value2, 32);
      }
      return arrayify(value2);
    case "string":
      return toUtf8Bytes(value2);
    case "bytes":
      return arrayify(value2);
    case "bool":
      value2 = value2 ? "0x01" : "0x00";
      if (isArray2) {
        return zeroPad(value2, 32);
      }
      return arrayify(value2);
  }
  let match = type.match(regexNumber);
  if (match) {
    let size = parseInt(match[2] || "256");
    if (match[2] && String(size) !== match[2] || size % 8 !== 0 || size === 0 || size > 256) {
      logger44.throwArgumentError("invalid number type", "type", type);
    }
    if (isArray2) {
      size = 256;
    }
    value2 = BigNumber.from(value2).toTwos(size);
    return zeroPad(value2, size / 8);
  }
  match = type.match(regexBytes);
  if (match) {
    const size = parseInt(match[1]);
    if (String(size) !== match[1] || size === 0 || size > 32) {
      logger44.throwArgumentError("invalid bytes type", "type", type);
    }
    if (arrayify(value2).byteLength !== size) {
      logger44.throwArgumentError(`invalid value for ${type}`, "value", value2);
    }
    if (isArray2) {
      return arrayify((value2 + Zeros2).substring(0, 66));
    }
    return value2;
  }
  match = type.match(regexArray);
  if (match && Array.isArray(value2)) {
    const baseType = match[1];
    const count2 = parseInt(match[2] || String(value2.length));
    if (count2 != value2.length) {
      logger44.throwArgumentError(`invalid array length for ${type}`, "value", value2);
    }
    const result = [];
    value2.forEach(function(value3) {
      result.push(_pack(baseType, value3, true));
    });
    return concat(result);
  }
  return logger44.throwArgumentError("invalid type", "type", type);
}
function pack2(types, values) {
  if (types.length != values.length) {
    logger44.throwArgumentError("wrong number of values; expected ${ types.length }", "values", values);
  }
  const tight = [];
  types.forEach(function(type, index) {
    tight.push(_pack(type, values[index]));
  });
  return hexlify(concat(tight));
}
function keccak2562(types, values) {
  return keccak256(pack2(types, values));
}
function sha2562(types, values) {
  return sha256(pack2(types, values));
}
var regexBytes, regexNumber, regexArray, Zeros2, logger44;
var init_lib26 = __esm({
  "node_modules/@ethersproject/solidity/lib.esm/index.js"() {
    "use strict";
    init_lib3();
    init_lib2();
    init_lib5();
    init_lib17();
    init_lib9();
    init_lib();
    init_version21();
    regexBytes = new RegExp("^bytes([0-9]+)$");
    regexNumber = new RegExp("^(u?int)([0-9]*)$");
    regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$");
    Zeros2 = "0000000000000000000000000000000000000000000000000000000000000000";
    logger44 = new Logger(version24);
  }
});

// node_modules/@ethersproject/units/lib.esm/_version.js
var version25;
var init_version22 = __esm({
  "node_modules/@ethersproject/units/lib.esm/_version.js"() {
    version25 = "units/5.6.0";
  }
});

// node_modules/@ethersproject/units/lib.esm/index.js
var lib_exports23 = {};
__export(lib_exports23, {
  commify: () => commify,
  formatEther: () => formatEther,
  formatUnits: () => formatUnits,
  parseEther: () => parseEther,
  parseUnits: () => parseUnits
});
function commify(value2) {
  const comps = String(value2).split(".");
  if (comps.length > 2 || !comps[0].match(/^-?[0-9]*$/) || comps[1] && !comps[1].match(/^[0-9]*$/) || value2 === "." || value2 === "-.") {
    logger45.throwArgumentError("invalid value", "value", value2);
  }
  let whole = comps[0];
  let negative = "";
  if (whole.substring(0, 1) === "-") {
    negative = "-";
    whole = whole.substring(1);
  }
  while (whole.substring(0, 1) === "0") {
    whole = whole.substring(1);
  }
  if (whole === "") {
    whole = "0";
  }
  let suffix = "";
  if (comps.length === 2) {
    suffix = "." + (comps[1] || "0");
  }
  while (suffix.length > 2 && suffix[suffix.length - 1] === "0") {
    suffix = suffix.substring(0, suffix.length - 1);
  }
  const formatted = [];
  while (whole.length) {
    if (whole.length <= 3) {
      formatted.unshift(whole);
      break;
    } else {
      const index = whole.length - 3;
      formatted.unshift(whole.substring(index));
      whole = whole.substring(0, index);
    }
  }
  return negative + formatted.join(",") + suffix;
}
function formatUnits(value2, unitName) {
  if (typeof unitName === "string") {
    const index = names.indexOf(unitName);
    if (index !== -1) {
      unitName = 3 * index;
    }
  }
  return formatFixed(value2, unitName != null ? unitName : 18);
}
function parseUnits(value2, unitName) {
  if (typeof value2 !== "string") {
    logger45.throwArgumentError("value must be a string", "value", value2);
  }
  if (typeof unitName === "string") {
    const index = names.indexOf(unitName);
    if (index !== -1) {
      unitName = 3 * index;
    }
  }
  return parseFixed(value2, unitName != null ? unitName : 18);
}
function formatEther(wei) {
  return formatUnits(wei, 18);
}
function parseEther(ether) {
  return parseUnits(ether, 18);
}
var logger45, names;
var init_lib27 = __esm({
  "node_modules/@ethersproject/units/lib.esm/index.js"() {
    "use strict";
    init_lib3();
    init_lib();
    init_version22();
    logger45 = new Logger(version25);
    names = [
      "wei",
      "kwei",
      "mwei",
      "gwei",
      "szabo",
      "finney",
      "ether"
    ];
  }
});

// node_modules/eventemitter2/lib/eventemitter2.js
var require_eventemitter2 = __commonJS({
  "node_modules/eventemitter2/lib/eventemitter2.js"(exports2, module2) {
    !function(undefined2) {
      var hasOwnProperty = Object.hasOwnProperty;
      var isArray2 = Array.isArray ? Array.isArray : function _isArray(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      };
      var defaultMaxListeners = 10;
      var nextTickSupported = typeof process == "object" && typeof process.nextTick == "function";
      var symbolsSupported = typeof Symbol === "function";
      var reflectSupported = typeof Reflect === "object";
      var setImmediateSupported = typeof setImmediate === "function";
      var _setImmediate = setImmediateSupported ? setImmediate : setTimeout;
      var ownKeys = symbolsSupported ? reflectSupported && typeof Reflect.ownKeys === "function" ? Reflect.ownKeys : function(obj) {
        var arr = Object.getOwnPropertyNames(obj);
        arr.push.apply(arr, Object.getOwnPropertySymbols(obj));
        return arr;
      } : Object.keys;
      function init2() {
        this._events = {};
        if (this._conf) {
          configure.call(this, this._conf);
        }
      }
      function configure(conf) {
        if (conf) {
          this._conf = conf;
          conf.delimiter && (this.delimiter = conf.delimiter);
          if (conf.maxListeners !== undefined2) {
            this._maxListeners = conf.maxListeners;
          }
          conf.wildcard && (this.wildcard = conf.wildcard);
          conf.newListener && (this._newListener = conf.newListener);
          conf.removeListener && (this._removeListener = conf.removeListener);
          conf.verboseMemoryLeak && (this.verboseMemoryLeak = conf.verboseMemoryLeak);
          conf.ignoreErrors && (this.ignoreErrors = conf.ignoreErrors);
          if (this.wildcard) {
            this.listenerTree = {};
          }
        }
      }
      function logPossibleMemoryLeak(count2, eventName) {
        var errorMsg = "(node) warning: possible EventEmitter memory leak detected. " + count2 + " listeners added. Use emitter.setMaxListeners() to increase limit.";
        if (this.verboseMemoryLeak) {
          errorMsg += " Event name: " + eventName + ".";
        }
        if (typeof process !== "undefined" && process.emitWarning) {
          var e6 = new Error(errorMsg);
          e6.name = "MaxListenersExceededWarning";
          e6.emitter = this;
          e6.count = count2;
          process.emitWarning(e6);
        } else {
          console.error(errorMsg);
          if (console.trace) {
            console.trace();
          }
        }
      }
      var toArray2 = function(a5, b4, c5) {
        var n4 = arguments.length;
        switch (n4) {
          case 0:
            return [];
          case 1:
            return [a5];
          case 2:
            return [a5, b4];
          case 3:
            return [a5, b4, c5];
          default:
            var arr = new Array(n4);
            while (n4--) {
              arr[n4] = arguments[n4];
            }
            return arr;
        }
      };
      function toObject(keys, values) {
        var obj = {};
        var key2;
        var len = keys.length;
        var valuesCount = values ? value.length : 0;
        for (var i6 = 0; i6 < len; i6++) {
          key2 = keys[i6];
          obj[key2] = i6 < valuesCount ? values[i6] : undefined2;
        }
        return obj;
      }
      function TargetObserver(emitter, target, options) {
        this._emitter = emitter;
        this._target = target;
        this._listeners = {};
        this._listenersCount = 0;
        var on2, off;
        if (options.on || options.off) {
          on2 = options.on;
          off = options.off;
        }
        if (target.addEventListener) {
          on2 = target.addEventListener;
          off = target.removeEventListener;
        } else if (target.addListener) {
          on2 = target.addListener;
          off = target.removeListener;
        } else if (target.on) {
          on2 = target.on;
          off = target.off;
        }
        if (!on2 && !off) {
          throw Error("target does not implement any known event API");
        }
        if (typeof on2 !== "function") {
          throw TypeError("on method must be a function");
        }
        if (typeof off !== "function") {
          throw TypeError("off method must be a function");
        }
        this._on = on2;
        this._off = off;
        var _observers = emitter._observers;
        if (_observers) {
          _observers.push(this);
        } else {
          emitter._observers = [this];
        }
      }
      Object.assign(TargetObserver.prototype, {
        subscribe: function(event, localEvent, reducer) {
          var observer = this;
          var target = this._target;
          var emitter = this._emitter;
          var listeners = this._listeners;
          var handler = function() {
            var args = toArray2.apply(null, arguments);
            var eventObj = {
              data: args,
              name: localEvent,
              original: event
            };
            if (reducer) {
              var result = reducer.call(target, eventObj);
              if (result !== false) {
                emitter.emit.apply(emitter, [eventObj.name].concat(args));
              }
              return;
            }
            emitter.emit.apply(emitter, [localEvent].concat(args));
          };
          if (listeners[event]) {
            throw Error("Event '" + event + "' is already listening");
          }
          this._listenersCount++;
          if (emitter._newListener && emitter._removeListener && !observer._onNewListener) {
            this._onNewListener = function(_event) {
              if (_event === localEvent && listeners[event] === null) {
                listeners[event] = handler;
                observer._on.call(target, event, handler);
              }
            };
            emitter.on("newListener", this._onNewListener);
            this._onRemoveListener = function(_event) {
              if (_event === localEvent && !emitter.hasListeners(_event) && listeners[event]) {
                listeners[event] = null;
                observer._off.call(target, event, handler);
              }
            };
            listeners[event] = null;
            emitter.on("removeListener", this._onRemoveListener);
          } else {
            listeners[event] = handler;
            observer._on.call(target, event, handler);
          }
        },
        unsubscribe: function(event) {
          var observer = this;
          var listeners = this._listeners;
          var emitter = this._emitter;
          var handler;
          var events;
          var off = this._off;
          var target = this._target;
          var i6;
          if (event && typeof event !== "string") {
            throw TypeError("event must be a string");
          }
          function clearRefs() {
            if (observer._onNewListener) {
              emitter.off("newListener", observer._onNewListener);
              emitter.off("removeListener", observer._onRemoveListener);
              observer._onNewListener = null;
              observer._onRemoveListener = null;
            }
            var index = findTargetIndex.call(emitter, observer);
            emitter._observers.splice(index, 1);
          }
          if (event) {
            handler = listeners[event];
            if (!handler)
              return;
            off.call(target, event, handler);
            delete listeners[event];
            if (!--this._listenersCount) {
              clearRefs();
            }
          } else {
            events = ownKeys(listeners);
            i6 = events.length;
            while (i6-- > 0) {
              event = events[i6];
              off.call(target, event, listeners[event]);
            }
            this._listeners = {};
            this._listenersCount = 0;
            clearRefs();
          }
        }
      });
      function resolveOptions(options, schema, reducers, allowUnknown) {
        var computedOptions = Object.assign({}, schema);
        if (!options)
          return computedOptions;
        if (typeof options !== "object") {
          throw TypeError("options must be an object");
        }
        var keys = Object.keys(options);
        var length = keys.length;
        var option, value2;
        var reducer;
        function reject(reason) {
          throw Error('Invalid "' + option + '" option value' + (reason ? ". Reason: " + reason : ""));
        }
        for (var i6 = 0; i6 < length; i6++) {
          option = keys[i6];
          if (!allowUnknown && !hasOwnProperty.call(schema, option)) {
            throw Error('Unknown "' + option + '" option');
          }
          value2 = options[option];
          if (value2 !== undefined2) {
            reducer = reducers[option];
            computedOptions[option] = reducer ? reducer(value2, reject) : value2;
          }
        }
        return computedOptions;
      }
      function constructorReducer(value2, reject) {
        if (typeof value2 !== "function" || !value2.hasOwnProperty("prototype")) {
          reject("value must be a constructor");
        }
        return value2;
      }
      function makeTypeReducer(types) {
        var message = "value must be type of " + types.join("|");
        var len = types.length;
        var firstType = types[0];
        var secondType = types[1];
        if (len === 1) {
          return function(v9, reject) {
            if (typeof v9 === firstType) {
              return v9;
            }
            reject(message);
          };
        }
        if (len === 2) {
          return function(v9, reject) {
            var kind = typeof v9;
            if (kind === firstType || kind === secondType)
              return v9;
            reject(message);
          };
        }
        return function(v9, reject) {
          var kind = typeof v9;
          var i6 = len;
          while (i6-- > 0) {
            if (kind === types[i6])
              return v9;
          }
          reject(message);
        };
      }
      var functionReducer = makeTypeReducer(["function"]);
      var objectFunctionReducer = makeTypeReducer(["object", "function"]);
      function makeCancelablePromise(Promise2, executor, options) {
        var isCancelable;
        var callbacks;
        var timer3 = 0;
        var subscriptionClosed;
        var promise = new Promise2(function(resolve, reject, onCancel) {
          options = resolveOptions(options, {
            timeout: 0,
            overload: false
          }, {
            timeout: function(value2, reject2) {
              value2 *= 1;
              if (typeof value2 !== "number" || value2 < 0 || !Number.isFinite(value2)) {
                reject2("timeout must be a positive number");
              }
              return value2;
            }
          });
          isCancelable = !options.overload && typeof Promise2.prototype.cancel === "function" && typeof onCancel === "function";
          function cleanup() {
            if (callbacks) {
              callbacks = null;
            }
            if (timer3) {
              clearTimeout(timer3);
              timer3 = 0;
            }
          }
          var _resolve = function(value2) {
            cleanup();
            resolve(value2);
          };
          var _reject = function(err) {
            cleanup();
            reject(err);
          };
          if (isCancelable) {
            executor(_resolve, _reject, onCancel);
          } else {
            callbacks = [function(reason) {
              _reject(reason || Error("canceled"));
            }];
            executor(_resolve, _reject, function(cb) {
              if (subscriptionClosed) {
                throw Error("Unable to subscribe on cancel event asynchronously");
              }
              if (typeof cb !== "function") {
                throw TypeError("onCancel callback must be a function");
              }
              callbacks.push(cb);
            });
            subscriptionClosed = true;
          }
          if (options.timeout > 0) {
            timer3 = setTimeout(function() {
              var reason = Error("timeout");
              reason.code = "ETIMEDOUT";
              timer3 = 0;
              promise.cancel(reason);
              reject(reason);
            }, options.timeout);
          }
        });
        if (!isCancelable) {
          promise.cancel = function(reason) {
            if (!callbacks) {
              return;
            }
            var length = callbacks.length;
            for (var i6 = 1; i6 < length; i6++) {
              callbacks[i6](reason);
            }
            callbacks[0](reason);
            callbacks = null;
          };
        }
        return promise;
      }
      function findTargetIndex(observer) {
        var observers = this._observers;
        if (!observers) {
          return -1;
        }
        var len = observers.length;
        for (var i6 = 0; i6 < len; i6++) {
          if (observers[i6]._target === observer)
            return i6;
        }
        return -1;
      }
      function searchListenerTree(handlers, type, tree, i6, typeLength) {
        if (!tree) {
          return null;
        }
        if (i6 === 0) {
          var kind = typeof type;
          if (kind === "string") {
            var ns, n4, l6 = 0, j8 = 0, delimiter = this.delimiter, dl = delimiter.length;
            if ((n4 = type.indexOf(delimiter)) !== -1) {
              ns = new Array(5);
              do {
                ns[l6++] = type.slice(j8, n4);
                j8 = n4 + dl;
              } while ((n4 = type.indexOf(delimiter, j8)) !== -1);
              ns[l6++] = type.slice(j8);
              type = ns;
              typeLength = l6;
            } else {
              type = [type];
              typeLength = 1;
            }
          } else if (kind === "object") {
            typeLength = type.length;
          } else {
            type = [type];
            typeLength = 1;
          }
        }
        var listeners = null, branch, xTree, xxTree, isolatedBranch, endReached, currentType = type[i6], nextType = type[i6 + 1], branches, _listeners;
        if (i6 === typeLength) {
          if (tree._listeners) {
            if (typeof tree._listeners === "function") {
              handlers && handlers.push(tree._listeners);
              listeners = [tree];
            } else {
              handlers && handlers.push.apply(handlers, tree._listeners);
              listeners = [tree];
            }
          }
        } else {
          if (currentType === "*") {
            branches = ownKeys(tree);
            n4 = branches.length;
            while (n4-- > 0) {
              branch = branches[n4];
              if (branch !== "_listeners") {
                _listeners = searchListenerTree(handlers, type, tree[branch], i6 + 1, typeLength);
                if (_listeners) {
                  if (listeners) {
                    listeners.push.apply(listeners, _listeners);
                  } else {
                    listeners = _listeners;
                  }
                }
              }
            }
            return listeners;
          } else if (currentType === "**") {
            endReached = i6 + 1 === typeLength || i6 + 2 === typeLength && nextType === "*";
            if (endReached && tree._listeners) {
              listeners = searchListenerTree(handlers, type, tree, typeLength, typeLength);
            }
            branches = ownKeys(tree);
            n4 = branches.length;
            while (n4-- > 0) {
              branch = branches[n4];
              if (branch !== "_listeners") {
                if (branch === "*" || branch === "**") {
                  if (tree[branch]._listeners && !endReached) {
                    _listeners = searchListenerTree(handlers, type, tree[branch], typeLength, typeLength);
                    if (_listeners) {
                      if (listeners) {
                        listeners.push.apply(listeners, _listeners);
                      } else {
                        listeners = _listeners;
                      }
                    }
                  }
                  _listeners = searchListenerTree(handlers, type, tree[branch], i6, typeLength);
                } else if (branch === nextType) {
                  _listeners = searchListenerTree(handlers, type, tree[branch], i6 + 2, typeLength);
                } else {
                  _listeners = searchListenerTree(handlers, type, tree[branch], i6, typeLength);
                }
                if (_listeners) {
                  if (listeners) {
                    listeners.push.apply(listeners, _listeners);
                  } else {
                    listeners = _listeners;
                  }
                }
              }
            }
            return listeners;
          } else if (tree[currentType]) {
            listeners = searchListenerTree(handlers, type, tree[currentType], i6 + 1, typeLength);
          }
        }
        xTree = tree["*"];
        if (xTree) {
          searchListenerTree(handlers, type, xTree, i6 + 1, typeLength);
        }
        xxTree = tree["**"];
        if (xxTree) {
          if (i6 < typeLength) {
            if (xxTree._listeners) {
              searchListenerTree(handlers, type, xxTree, typeLength, typeLength);
            }
            branches = ownKeys(xxTree);
            n4 = branches.length;
            while (n4-- > 0) {
              branch = branches[n4];
              if (branch !== "_listeners") {
                if (branch === nextType) {
                  searchListenerTree(handlers, type, xxTree[branch], i6 + 2, typeLength);
                } else if (branch === currentType) {
                  searchListenerTree(handlers, type, xxTree[branch], i6 + 1, typeLength);
                } else {
                  isolatedBranch = {};
                  isolatedBranch[branch] = xxTree[branch];
                  searchListenerTree(handlers, type, { "**": isolatedBranch }, i6 + 1, typeLength);
                }
              }
            }
          } else if (xxTree._listeners) {
            searchListenerTree(handlers, type, xxTree, typeLength, typeLength);
          } else if (xxTree["*"] && xxTree["*"]._listeners) {
            searchListenerTree(handlers, type, xxTree["*"], typeLength, typeLength);
          }
        }
        return listeners;
      }
      function growListenerTree(type, listener, prepend) {
        var len = 0, j8 = 0, i6, delimiter = this.delimiter, dl = delimiter.length, ns;
        if (typeof type === "string") {
          if ((i6 = type.indexOf(delimiter)) !== -1) {
            ns = new Array(5);
            do {
              ns[len++] = type.slice(j8, i6);
              j8 = i6 + dl;
            } while ((i6 = type.indexOf(delimiter, j8)) !== -1);
            ns[len++] = type.slice(j8);
          } else {
            ns = [type];
            len = 1;
          }
        } else {
          ns = type;
          len = type.length;
        }
        if (len > 1) {
          for (i6 = 0; i6 + 1 < len; i6++) {
            if (ns[i6] === "**" && ns[i6 + 1] === "**") {
              return;
            }
          }
        }
        var tree = this.listenerTree, name2;
        for (i6 = 0; i6 < len; i6++) {
          name2 = ns[i6];
          tree = tree[name2] || (tree[name2] = {});
          if (i6 === len - 1) {
            if (!tree._listeners) {
              tree._listeners = listener;
            } else {
              if (typeof tree._listeners === "function") {
                tree._listeners = [tree._listeners];
              }
              if (prepend) {
                tree._listeners.unshift(listener);
              } else {
                tree._listeners.push(listener);
              }
              if (!tree._listeners.warned && this._maxListeners > 0 && tree._listeners.length > this._maxListeners) {
                tree._listeners.warned = true;
                logPossibleMemoryLeak.call(this, tree._listeners.length, name2);
              }
            }
            return true;
          }
        }
        return true;
      }
      function collectTreeEvents(tree, events, root2, asArray) {
        var branches = ownKeys(tree);
        var i6 = branches.length;
        var branch, branchName, path;
        var hasListeners = tree["_listeners"];
        var isArrayPath;
        while (i6-- > 0) {
          branchName = branches[i6];
          branch = tree[branchName];
          if (branchName === "_listeners") {
            path = root2;
          } else {
            path = root2 ? root2.concat(branchName) : [branchName];
          }
          isArrayPath = asArray || typeof branchName === "symbol";
          hasListeners && events.push(isArrayPath ? path : path.join(this.delimiter));
          if (typeof branch === "object") {
            collectTreeEvents.call(this, branch, events, path, isArrayPath);
          }
        }
        return events;
      }
      function recursivelyGarbageCollect(root2) {
        var keys = ownKeys(root2);
        var i6 = keys.length;
        var obj, key2, flag;
        while (i6-- > 0) {
          key2 = keys[i6];
          obj = root2[key2];
          if (obj) {
            flag = true;
            if (key2 !== "_listeners" && !recursivelyGarbageCollect(obj)) {
              delete root2[key2];
            }
          }
        }
        return flag;
      }
      function Listener(emitter, event, listener) {
        this.emitter = emitter;
        this.event = event;
        this.listener = listener;
      }
      Listener.prototype.off = function() {
        this.emitter.off(this.event, this.listener);
        return this;
      };
      function setupListener(event, listener, options) {
        if (options === true) {
          promisify = true;
        } else if (options === false) {
          async2 = true;
        } else {
          if (!options || typeof options !== "object") {
            throw TypeError("options should be an object or true");
          }
          var async2 = options.async;
          var promisify = options.promisify;
          var nextTick = options.nextTick;
          var objectify = options.objectify;
        }
        if (async2 || nextTick || promisify) {
          var _listener = listener;
          var _origin = listener._origin || listener;
          if (nextTick && !nextTickSupported) {
            throw Error("process.nextTick is not supported");
          }
          if (promisify === undefined2) {
            promisify = listener.constructor.name === "AsyncFunction";
          }
          listener = function() {
            var args = arguments;
            var context = this;
            var event2 = this.event;
            return promisify ? nextTick ? Promise.resolve() : new Promise(function(resolve) {
              _setImmediate(resolve);
            }).then(function() {
              context.event = event2;
              return _listener.apply(context, args);
            }) : (nextTick ? process.nextTick : _setImmediate)(function() {
              context.event = event2;
              _listener.apply(context, args);
            });
          };
          listener._async = true;
          listener._origin = _origin;
        }
        return [listener, objectify ? new Listener(this, event, listener) : this];
      }
      function EventEmitter6(conf) {
        this._events = {};
        this._newListener = false;
        this._removeListener = false;
        this.verboseMemoryLeak = false;
        configure.call(this, conf);
      }
      EventEmitter6.EventEmitter2 = EventEmitter6;
      EventEmitter6.prototype.listenTo = function(target, events, options) {
        if (typeof target !== "object") {
          throw TypeError("target musts be an object");
        }
        var emitter = this;
        options = resolveOptions(options, {
          on: undefined2,
          off: undefined2,
          reducers: undefined2
        }, {
          on: functionReducer,
          off: functionReducer,
          reducers: objectFunctionReducer
        });
        function listen(events2) {
          if (typeof events2 !== "object") {
            throw TypeError("events must be an object");
          }
          var reducers = options.reducers;
          var index = findTargetIndex.call(emitter, target);
          var observer;
          if (index === -1) {
            observer = new TargetObserver(emitter, target, options);
          } else {
            observer = emitter._observers[index];
          }
          var keys = ownKeys(events2);
          var len = keys.length;
          var event;
          var isSingleReducer = typeof reducers === "function";
          for (var i6 = 0; i6 < len; i6++) {
            event = keys[i6];
            observer.subscribe(
              event,
              events2[event] || event,
              isSingleReducer ? reducers : reducers && reducers[event]
            );
          }
        }
        isArray2(events) ? listen(toObject(events)) : typeof events === "string" ? listen(toObject(events.split(/\s+/))) : listen(events);
        return this;
      };
      EventEmitter6.prototype.stopListeningTo = function(target, event) {
        var observers = this._observers;
        if (!observers) {
          return false;
        }
        var i6 = observers.length;
        var observer;
        var matched = false;
        if (target && typeof target !== "object") {
          throw TypeError("target should be an object");
        }
        while (i6-- > 0) {
          observer = observers[i6];
          if (!target || observer._target === target) {
            observer.unsubscribe(event);
            matched = true;
          }
        }
        return matched;
      };
      EventEmitter6.prototype.delimiter = ".";
      EventEmitter6.prototype.setMaxListeners = function(n4) {
        if (n4 !== undefined2) {
          this._maxListeners = n4;
          if (!this._conf)
            this._conf = {};
          this._conf.maxListeners = n4;
        }
      };
      EventEmitter6.prototype.getMaxListeners = function() {
        return this._maxListeners;
      };
      EventEmitter6.prototype.event = "";
      EventEmitter6.prototype.once = function(event, fn2, options) {
        return this._once(event, fn2, false, options);
      };
      EventEmitter6.prototype.prependOnceListener = function(event, fn2, options) {
        return this._once(event, fn2, true, options);
      };
      EventEmitter6.prototype._once = function(event, fn2, prepend, options) {
        return this._many(event, 1, fn2, prepend, options);
      };
      EventEmitter6.prototype.many = function(event, ttl, fn2, options) {
        return this._many(event, ttl, fn2, false, options);
      };
      EventEmitter6.prototype.prependMany = function(event, ttl, fn2, options) {
        return this._many(event, ttl, fn2, true, options);
      };
      EventEmitter6.prototype._many = function(event, ttl, fn2, prepend, options) {
        var self2 = this;
        if (typeof fn2 !== "function") {
          throw new Error("many only accepts instances of Function");
        }
        function listener() {
          if (--ttl === 0) {
            self2.off(event, listener);
          }
          return fn2.apply(this, arguments);
        }
        listener._origin = fn2;
        return this._on(event, listener, prepend, options);
      };
      EventEmitter6.prototype.emit = function() {
        if (!this._events && !this._all) {
          return false;
        }
        this._events || init2.call(this);
        var type = arguments[0], ns, wildcard = this.wildcard;
        var args, l6, i6, j8, containsSymbol;
        if (type === "newListener" && !this._newListener) {
          if (!this._events.newListener) {
            return false;
          }
        }
        if (wildcard) {
          ns = type;
          if (type !== "newListener" && type !== "removeListener") {
            if (typeof type === "object") {
              l6 = type.length;
              if (symbolsSupported) {
                for (i6 = 0; i6 < l6; i6++) {
                  if (typeof type[i6] === "symbol") {
                    containsSymbol = true;
                    break;
                  }
                }
              }
              if (!containsSymbol) {
                type = type.join(this.delimiter);
              }
            }
          }
        }
        var al = arguments.length;
        var handler;
        if (this._all && this._all.length) {
          handler = this._all.slice();
          for (i6 = 0, l6 = handler.length; i6 < l6; i6++) {
            this.event = type;
            switch (al) {
              case 1:
                handler[i6].call(this, type);
                break;
              case 2:
                handler[i6].call(this, type, arguments[1]);
                break;
              case 3:
                handler[i6].call(this, type, arguments[1], arguments[2]);
                break;
              default:
                handler[i6].apply(this, arguments);
            }
          }
        }
        if (wildcard) {
          handler = [];
          searchListenerTree.call(this, handler, ns, this.listenerTree, 0, l6);
        } else {
          handler = this._events[type];
          if (typeof handler === "function") {
            this.event = type;
            switch (al) {
              case 1:
                handler.call(this);
                break;
              case 2:
                handler.call(this, arguments[1]);
                break;
              case 3:
                handler.call(this, arguments[1], arguments[2]);
                break;
              default:
                args = new Array(al - 1);
                for (j8 = 1; j8 < al; j8++)
                  args[j8 - 1] = arguments[j8];
                handler.apply(this, args);
            }
            return true;
          } else if (handler) {
            handler = handler.slice();
          }
        }
        if (handler && handler.length) {
          if (al > 3) {
            args = new Array(al - 1);
            for (j8 = 1; j8 < al; j8++)
              args[j8 - 1] = arguments[j8];
          }
          for (i6 = 0, l6 = handler.length; i6 < l6; i6++) {
            this.event = type;
            switch (al) {
              case 1:
                handler[i6].call(this);
                break;
              case 2:
                handler[i6].call(this, arguments[1]);
                break;
              case 3:
                handler[i6].call(this, arguments[1], arguments[2]);
                break;
              default:
                handler[i6].apply(this, args);
            }
          }
          return true;
        } else if (!this.ignoreErrors && !this._all && type === "error") {
          if (arguments[1] instanceof Error) {
            throw arguments[1];
          } else {
            throw new Error("Uncaught, unspecified 'error' event.");
          }
        }
        return !!this._all;
      };
      EventEmitter6.prototype.emitAsync = function() {
        if (!this._events && !this._all) {
          return false;
        }
        this._events || init2.call(this);
        var type = arguments[0], wildcard = this.wildcard, ns, containsSymbol;
        var args, l6, i6, j8;
        if (type === "newListener" && !this._newListener) {
          if (!this._events.newListener) {
            return Promise.resolve([false]);
          }
        }
        if (wildcard) {
          ns = type;
          if (type !== "newListener" && type !== "removeListener") {
            if (typeof type === "object") {
              l6 = type.length;
              if (symbolsSupported) {
                for (i6 = 0; i6 < l6; i6++) {
                  if (typeof type[i6] === "symbol") {
                    containsSymbol = true;
                    break;
                  }
                }
              }
              if (!containsSymbol) {
                type = type.join(this.delimiter);
              }
            }
          }
        }
        var promises = [];
        var al = arguments.length;
        var handler;
        if (this._all) {
          for (i6 = 0, l6 = this._all.length; i6 < l6; i6++) {
            this.event = type;
            switch (al) {
              case 1:
                promises.push(this._all[i6].call(this, type));
                break;
              case 2:
                promises.push(this._all[i6].call(this, type, arguments[1]));
                break;
              case 3:
                promises.push(this._all[i6].call(this, type, arguments[1], arguments[2]));
                break;
              default:
                promises.push(this._all[i6].apply(this, arguments));
            }
          }
        }
        if (wildcard) {
          handler = [];
          searchListenerTree.call(this, handler, ns, this.listenerTree, 0);
        } else {
          handler = this._events[type];
        }
        if (typeof handler === "function") {
          this.event = type;
          switch (al) {
            case 1:
              promises.push(handler.call(this));
              break;
            case 2:
              promises.push(handler.call(this, arguments[1]));
              break;
            case 3:
              promises.push(handler.call(this, arguments[1], arguments[2]));
              break;
            default:
              args = new Array(al - 1);
              for (j8 = 1; j8 < al; j8++)
                args[j8 - 1] = arguments[j8];
              promises.push(handler.apply(this, args));
          }
        } else if (handler && handler.length) {
          handler = handler.slice();
          if (al > 3) {
            args = new Array(al - 1);
            for (j8 = 1; j8 < al; j8++)
              args[j8 - 1] = arguments[j8];
          }
          for (i6 = 0, l6 = handler.length; i6 < l6; i6++) {
            this.event = type;
            switch (al) {
              case 1:
                promises.push(handler[i6].call(this));
                break;
              case 2:
                promises.push(handler[i6].call(this, arguments[1]));
                break;
              case 3:
                promises.push(handler[i6].call(this, arguments[1], arguments[2]));
                break;
              default:
                promises.push(handler[i6].apply(this, args));
            }
          }
        } else if (!this.ignoreErrors && !this._all && type === "error") {
          if (arguments[1] instanceof Error) {
            return Promise.reject(arguments[1]);
          } else {
            return Promise.reject("Uncaught, unspecified 'error' event.");
          }
        }
        return Promise.all(promises);
      };
      EventEmitter6.prototype.on = function(type, listener, options) {
        return this._on(type, listener, false, options);
      };
      EventEmitter6.prototype.prependListener = function(type, listener, options) {
        return this._on(type, listener, true, options);
      };
      EventEmitter6.prototype.onAny = function(fn2) {
        return this._onAny(fn2, false);
      };
      EventEmitter6.prototype.prependAny = function(fn2) {
        return this._onAny(fn2, true);
      };
      EventEmitter6.prototype.addListener = EventEmitter6.prototype.on;
      EventEmitter6.prototype._onAny = function(fn2, prepend) {
        if (typeof fn2 !== "function") {
          throw new Error("onAny only accepts instances of Function");
        }
        if (!this._all) {
          this._all = [];
        }
        if (prepend) {
          this._all.unshift(fn2);
        } else {
          this._all.push(fn2);
        }
        return this;
      };
      EventEmitter6.prototype._on = function(type, listener, prepend, options) {
        if (typeof type === "function") {
          this._onAny(type, listener);
          return this;
        }
        if (typeof listener !== "function") {
          throw new Error("on only accepts instances of Function");
        }
        this._events || init2.call(this);
        var returnValue = this, temp;
        if (options !== undefined2) {
          temp = setupListener.call(this, type, listener, options);
          listener = temp[0];
          returnValue = temp[1];
        }
        if (this._newListener) {
          this.emit("newListener", type, listener);
        }
        if (this.wildcard) {
          growListenerTree.call(this, type, listener, prepend);
          return returnValue;
        }
        if (!this._events[type]) {
          this._events[type] = listener;
        } else {
          if (typeof this._events[type] === "function") {
            this._events[type] = [this._events[type]];
          }
          if (prepend) {
            this._events[type].unshift(listener);
          } else {
            this._events[type].push(listener);
          }
          if (!this._events[type].warned && this._maxListeners > 0 && this._events[type].length > this._maxListeners) {
            this._events[type].warned = true;
            logPossibleMemoryLeak.call(this, this._events[type].length, type);
          }
        }
        return returnValue;
      };
      EventEmitter6.prototype.off = function(type, listener) {
        if (typeof listener !== "function") {
          throw new Error("removeListener only takes instances of Function");
        }
        var handlers, leafs = [];
        if (this.wildcard) {
          var ns = typeof type === "string" ? type.split(this.delimiter) : type.slice();
          leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);
          if (!leafs)
            return this;
        } else {
          if (!this._events[type])
            return this;
          handlers = this._events[type];
          leafs.push({ _listeners: handlers });
        }
        for (var iLeaf = 0; iLeaf < leafs.length; iLeaf++) {
          var leaf = leafs[iLeaf];
          handlers = leaf._listeners;
          if (isArray2(handlers)) {
            var position = -1;
            for (var i6 = 0, length = handlers.length; i6 < length; i6++) {
              if (handlers[i6] === listener || handlers[i6].listener && handlers[i6].listener === listener || handlers[i6]._origin && handlers[i6]._origin === listener) {
                position = i6;
                break;
              }
            }
            if (position < 0) {
              continue;
            }
            if (this.wildcard) {
              leaf._listeners.splice(position, 1);
            } else {
              this._events[type].splice(position, 1);
            }
            if (handlers.length === 0) {
              if (this.wildcard) {
                delete leaf._listeners;
              } else {
                delete this._events[type];
              }
            }
            if (this._removeListener)
              this.emit("removeListener", type, listener);
            return this;
          } else if (handlers === listener || handlers.listener && handlers.listener === listener || handlers._origin && handlers._origin === listener) {
            if (this.wildcard) {
              delete leaf._listeners;
            } else {
              delete this._events[type];
            }
            if (this._removeListener)
              this.emit("removeListener", type, listener);
          }
        }
        this.listenerTree && recursivelyGarbageCollect(this.listenerTree);
        return this;
      };
      EventEmitter6.prototype.offAny = function(fn2) {
        var i6 = 0, l6 = 0, fns;
        if (fn2 && this._all && this._all.length > 0) {
          fns = this._all;
          for (i6 = 0, l6 = fns.length; i6 < l6; i6++) {
            if (fn2 === fns[i6]) {
              fns.splice(i6, 1);
              if (this._removeListener)
                this.emit("removeListenerAny", fn2);
              return this;
            }
          }
        } else {
          fns = this._all;
          if (this._removeListener) {
            for (i6 = 0, l6 = fns.length; i6 < l6; i6++)
              this.emit("removeListenerAny", fns[i6]);
          }
          this._all = [];
        }
        return this;
      };
      EventEmitter6.prototype.removeListener = EventEmitter6.prototype.off;
      EventEmitter6.prototype.removeAllListeners = function(type) {
        if (type === undefined2) {
          !this._events || init2.call(this);
          return this;
        }
        if (this.wildcard) {
          var leafs = searchListenerTree.call(this, null, type, this.listenerTree, 0), leaf, i6;
          if (!leafs)
            return this;
          for (i6 = 0; i6 < leafs.length; i6++) {
            leaf = leafs[i6];
            leaf._listeners = null;
          }
          this.listenerTree && recursivelyGarbageCollect(this.listenerTree);
        } else if (this._events) {
          this._events[type] = null;
        }
        return this;
      };
      EventEmitter6.prototype.listeners = function(type) {
        var _events = this._events;
        var keys, listeners, allListeners;
        var i6;
        var listenerTree;
        if (type === undefined2) {
          if (this.wildcard) {
            throw Error("event name required for wildcard emitter");
          }
          if (!_events) {
            return [];
          }
          keys = ownKeys(_events);
          i6 = keys.length;
          allListeners = [];
          while (i6-- > 0) {
            listeners = _events[keys[i6]];
            if (typeof listeners === "function") {
              allListeners.push(listeners);
            } else {
              allListeners.push.apply(allListeners, listeners);
            }
          }
          return allListeners;
        } else {
          if (this.wildcard) {
            listenerTree = this.listenerTree;
            if (!listenerTree)
              return [];
            var handlers = [];
            var ns = typeof type === "string" ? type.split(this.delimiter) : type.slice();
            searchListenerTree.call(this, handlers, ns, listenerTree, 0);
            return handlers;
          }
          if (!_events) {
            return [];
          }
          listeners = _events[type];
          if (!listeners) {
            return [];
          }
          return typeof listeners === "function" ? [listeners] : listeners;
        }
      };
      EventEmitter6.prototype.eventNames = function(nsAsArray) {
        var _events = this._events;
        return this.wildcard ? collectTreeEvents.call(this, this.listenerTree, [], null, nsAsArray) : _events ? ownKeys(_events) : [];
      };
      EventEmitter6.prototype.listenerCount = function(type) {
        return this.listeners(type).length;
      };
      EventEmitter6.prototype.hasListeners = function(type) {
        if (this.wildcard) {
          var handlers = [];
          var ns = typeof type === "string" ? type.split(this.delimiter) : type.slice();
          searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);
          return handlers.length > 0;
        }
        var _events = this._events;
        var _all = this._all;
        return !!(_all && _all.length || _events && (type === undefined2 ? ownKeys(_events).length : _events[type]));
      };
      EventEmitter6.prototype.listenersAny = function() {
        if (this._all) {
          return this._all;
        } else {
          return [];
        }
      };
      EventEmitter6.prototype.waitFor = function(event, options) {
        var self2 = this;
        var type = typeof options;
        if (type === "number") {
          options = { timeout: options };
        } else if (type === "function") {
          options = { filter: options };
        }
        options = resolveOptions(options, {
          timeout: 0,
          filter: undefined2,
          handleError: false,
          Promise,
          overload: false
        }, {
          filter: functionReducer,
          Promise: constructorReducer
        });
        return makeCancelablePromise(options.Promise, function(resolve, reject, onCancel) {
          function listener() {
            var filter2 = options.filter;
            if (filter2 && !filter2.apply(self2, arguments)) {
              return;
            }
            self2.off(event, listener);
            if (options.handleError) {
              var err = arguments[0];
              err ? reject(err) : resolve(toArray2.apply(null, arguments).slice(1));
            } else {
              resolve(toArray2.apply(null, arguments));
            }
          }
          onCancel(function() {
            self2.off(event, listener);
          });
          self2._on(event, listener, false);
        }, {
          timeout: options.timeout,
          overload: options.overload
        });
      };
      function once(emitter, name2, options) {
        options = resolveOptions(options, {
          Promise,
          timeout: 0,
          overload: false
        }, {
          Promise: constructorReducer
        });
        var _Promise = options.Promise;
        return makeCancelablePromise(_Promise, function(resolve, reject, onCancel) {
          var handler;
          if (typeof emitter.addEventListener === "function") {
            handler = function() {
              resolve(toArray2.apply(null, arguments));
            };
            onCancel(function() {
              emitter.removeEventListener(name2, handler);
            });
            emitter.addEventListener(
              name2,
              handler,
              { once: true }
            );
            return;
          }
          var eventListener = function() {
            errorListener && emitter.removeListener("error", errorListener);
            resolve(toArray2.apply(null, arguments));
          };
          var errorListener;
          if (name2 !== "error") {
            errorListener = function(err) {
              emitter.removeListener(name2, eventListener);
              reject(err);
            };
            emitter.once("error", errorListener);
          }
          onCancel(function() {
            errorListener && emitter.removeListener("error", errorListener);
            emitter.removeListener(name2, eventListener);
          });
          emitter.once(name2, eventListener);
        }, {
          timeout: options.timeout,
          overload: options.overload
        });
      }
      var prototype = EventEmitter6.prototype;
      Object.defineProperties(EventEmitter6, {
        defaultMaxListeners: {
          get: function() {
            return prototype._maxListeners;
          },
          set: function(n4) {
            if (typeof n4 !== "number" || n4 < 0 || Number.isNaN(n4)) {
              throw TypeError("n must be a non-negative number");
            }
            prototype._maxListeners = n4;
          },
          enumerable: true
        },
        once: {
          value: once,
          writable: true,
          configurable: true
        }
      });
      Object.defineProperties(prototype, {
        _maxListeners: {
          value: defaultMaxListeners,
          writable: true,
          configurable: true
        },
        _observers: { value: null, writable: true, configurable: true }
      });
      if (typeof define === "function" && define.amd) {
        define(function() {
          return EventEmitter6;
        });
      } else if (typeof exports2 === "object") {
        module2.exports = EventEmitter6;
      } else {
        var _global = new Function("", "return this")();
        _global.EventEmitter2 = EventEmitter6;
      }
    }();
  }
});

// node_modules/buffer-reverse/index.js
var require_buffer_reverse = __commonJS({
  "node_modules/buffer-reverse/index.js"(exports2, module2) {
    module2.exports = function reverse(src) {
      var buffer2 = new Buffer(src.length);
      for (var i6 = 0, j8 = src.length - 1; i6 <= j8; ++i6, --j8) {
        buffer2[i6] = src[j8];
        buffer2[j8] = src[i6];
      }
      return buffer2;
    };
  }
});

// node_modules/crypto-js/core.js
var require_core = __commonJS({
  "node_modules/crypto-js/core.js"(exports2, module2) {
    (function(root2, factory) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory();
      } else if (typeof define === "function" && define.amd) {
        define([], factory);
      } else {
        root2.CryptoJS = factory();
      }
    })(exports2, function() {
      var CryptoJS = CryptoJS || function(Math2, undefined2) {
        var create = Object.create || function() {
          function F5() {
          }
          ;
          return function(obj) {
            var subtype;
            F5.prototype = obj;
            subtype = new F5();
            F5.prototype = null;
            return subtype;
          };
        }();
        var C5 = {};
        var C_lib = C5.lib = {};
        var Base = C_lib.Base = function() {
          return {
            extend: function(overrides) {
              var subtype = create(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            create: function() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            init: function() {
            },
            mixIn: function(properties) {
              for (var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties[propertyName];
                }
              }
              if (properties.hasOwnProperty("toString")) {
                this.toString = properties.toString;
              }
            },
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base.extend({
          init: function(words2, sigBytes) {
            words2 = this.words = words2 || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words2.length * 4;
            }
          },
          toString: function(encoder) {
            return (encoder || Hex).stringify(this);
          },
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i6 = 0; i6 < thatSigBytes; i6++) {
                var thatByte = thatWords[i6 >>> 2] >>> 24 - i6 % 4 * 8 & 255;
                thisWords[thisSigBytes + i6 >>> 2] |= thatByte << 24 - (thisSigBytes + i6) % 4 * 8;
              }
            } else {
              for (var i6 = 0; i6 < thatSigBytes; i6 += 4) {
                thisWords[thisSigBytes + i6 >>> 2] = thatWords[i6 >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          clamp: function() {
            var words2 = this.words;
            var sigBytes = this.sigBytes;
            words2[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words2.length = Math2.ceil(sigBytes / 4);
          },
          clone: function() {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);
            return clone;
          },
          random: function(nBytes) {
            var words2 = [];
            var r6 = function(m_w) {
              var m_w = m_w;
              var m_z = 987654321;
              var mask = 4294967295;
              return function() {
                m_z = 36969 * (m_z & 65535) + (m_z >> 16) & mask;
                m_w = 18e3 * (m_w & 65535) + (m_w >> 16) & mask;
                var result = (m_z << 16) + m_w & mask;
                result /= 4294967296;
                result += 0.5;
                return result * (Math2.random() > 0.5 ? 1 : -1);
              };
            };
            for (var i6 = 0, rcache; i6 < nBytes; i6 += 4) {
              var _r2 = r6((rcache || Math2.random()) * 4294967296);
              rcache = _r2() * 987654071;
              words2.push(_r2() * 4294967296 | 0);
            }
            return new WordArray.init(words2, nBytes);
          }
        });
        var C_enc = C5.enc = {};
        var Hex = C_enc.Hex = {
          stringify: function(wordArray) {
            var words2 = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i6 = 0; i6 < sigBytes; i6++) {
              var bite = words2[i6 >>> 2] >>> 24 - i6 % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words2 = [];
            for (var i6 = 0; i6 < hexStrLength; i6 += 2) {
              words2[i6 >>> 3] |= parseInt(hexStr.substr(i6, 2), 16) << 24 - i6 % 8 * 4;
            }
            return new WordArray.init(words2, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          stringify: function(wordArray) {
            var words2 = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i6 = 0; i6 < sigBytes; i6++) {
              var bite = words2[i6 >>> 2] >>> 24 - i6 % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words2 = [];
            for (var i6 = 0; i6 < latin1StrLength; i6++) {
              words2[i6 >>> 2] |= (latin1Str.charCodeAt(i6) & 255) << 24 - i6 % 4 * 8;
            }
            return new WordArray.init(words2, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e6) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          _append: function(data) {
            if (typeof data == "string") {
              data = Utf8.parse(data);
            }
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
          },
          _process: function(doFlush) {
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                this._doProcessBlock(dataWords, offset);
              }
              var processedWords = dataWords.splice(0, nWordsReady);
              data.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          clone: function() {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();
            return clone;
          },
          _minBufferSize: 0
        });
        var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
          cfg: Base.extend(),
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash3 = this._doFinalize();
            return hash3;
          },
          blockSize: 512 / 32,
          _createHelper: function(hasher) {
            return function(message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },
          _createHmacHelper: function(hasher) {
            return function(message, key2) {
              return new C_algo.HMAC.init(hasher, key2).finalize(message);
            };
          }
        });
        var C_algo = C5.algo = {};
        return C5;
      }(Math);
      return CryptoJS;
    });
  }
});

// node_modules/crypto-js/sha256.js
var require_sha256 = __commonJS({
  "node_modules/crypto-js/sha256.js"(exports2, module2) {
    (function(root2, factory) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS) {
      (function(Math2) {
        var C5 = CryptoJS;
        var C_lib = C5.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C5.algo;
        var H5 = [];
        var K5 = [];
        (function() {
          function isPrime(n5) {
            var sqrtN = Math2.sqrt(n5);
            for (var factor = 2; factor <= sqrtN; factor++) {
              if (!(n5 % factor)) {
                return false;
              }
            }
            return true;
          }
          function getFractionalBits(n5) {
            return (n5 - (n5 | 0)) * 4294967296 | 0;
          }
          var n4 = 2;
          var nPrime = 0;
          while (nPrime < 64) {
            if (isPrime(n4)) {
              if (nPrime < 8) {
                H5[nPrime] = getFractionalBits(Math2.pow(n4, 1 / 2));
              }
              K5[nPrime] = getFractionalBits(Math2.pow(n4, 1 / 3));
              nPrime++;
            }
            n4++;
          }
        })();
        var W4 = [];
        var SHA256 = C_algo.SHA256 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init(H5.slice(0));
          },
          _doProcessBlock: function(M6, offset) {
            var H6 = this._hash.words;
            var a5 = H6[0];
            var b4 = H6[1];
            var c5 = H6[2];
            var d6 = H6[3];
            var e6 = H6[4];
            var f7 = H6[5];
            var g7 = H6[6];
            var h6 = H6[7];
            for (var i6 = 0; i6 < 64; i6++) {
              if (i6 < 16) {
                W4[i6] = M6[offset + i6] | 0;
              } else {
                var gamma0x = W4[i6 - 15];
                var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                var gamma1x = W4[i6 - 2];
                var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                W4[i6] = gamma0 + W4[i6 - 7] + gamma1 + W4[i6 - 16];
              }
              var ch = e6 & f7 ^ ~e6 & g7;
              var maj = a5 & b4 ^ a5 & c5 ^ b4 & c5;
              var sigma0 = (a5 << 30 | a5 >>> 2) ^ (a5 << 19 | a5 >>> 13) ^ (a5 << 10 | a5 >>> 22);
              var sigma1 = (e6 << 26 | e6 >>> 6) ^ (e6 << 21 | e6 >>> 11) ^ (e6 << 7 | e6 >>> 25);
              var t12 = h6 + sigma1 + ch + K5[i6] + W4[i6];
              var t22 = sigma0 + maj;
              h6 = g7;
              g7 = f7;
              f7 = e6;
              e6 = d6 + t12 | 0;
              d6 = c5;
              c5 = b4;
              b4 = a5;
              a5 = t12 + t22 | 0;
            }
            H6[0] = H6[0] + a5 | 0;
            H6[1] = H6[1] + b4 | 0;
            H6[2] = H6[2] + c5 | 0;
            H6[3] = H6[3] + d6 | 0;
            H6[4] = H6[4] + e6 | 0;
            H6[5] = H6[5] + f7 | 0;
            H6[6] = H6[6] + g7 | 0;
            H6[7] = H6[7] + h6 | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math2.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C5.SHA256 = Hasher._createHelper(SHA256);
        C5.HmacSHA256 = Hasher._createHmacHelper(SHA256);
      })(Math);
      return CryptoJS.SHA256;
    });
  }
});

// node_modules/crypto-js/x64-core.js
var require_x64_core = __commonJS({
  "node_modules/crypto-js/x64-core.js"(exports2, module2) {
    (function(root2, factory) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS) {
      (function(undefined2) {
        var C5 = CryptoJS;
        var C_lib = C5.lib;
        var Base = C_lib.Base;
        var X32WordArray = C_lib.WordArray;
        var C_x64 = C5.x64 = {};
        var X64Word = C_x64.Word = Base.extend({
          init: function(high, low) {
            this.high = high;
            this.low = low;
          }
        });
        var X64WordArray = C_x64.WordArray = Base.extend({
          init: function(words2, sigBytes) {
            words2 = this.words = words2 || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words2.length * 8;
            }
          },
          toX32: function() {
            var x64Words = this.words;
            var x64WordsLength = x64Words.length;
            var x32Words = [];
            for (var i6 = 0; i6 < x64WordsLength; i6++) {
              var x64Word = x64Words[i6];
              x32Words.push(x64Word.high);
              x32Words.push(x64Word.low);
            }
            return X32WordArray.create(x32Words, this.sigBytes);
          },
          clone: function() {
            var clone = Base.clone.call(this);
            var words2 = clone.words = this.words.slice(0);
            var wordsLength = words2.length;
            for (var i6 = 0; i6 < wordsLength; i6++) {
              words2[i6] = words2[i6].clone();
            }
            return clone;
          }
        });
      })();
      return CryptoJS;
    });
  }
});

// node_modules/crypto-js/lib-typedarrays.js
var require_lib_typedarrays = __commonJS({
  "node_modules/crypto-js/lib-typedarrays.js"(exports2, module2) {
    (function(root2, factory) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS) {
      (function() {
        if (typeof ArrayBuffer != "function") {
          return;
        }
        var C5 = CryptoJS;
        var C_lib = C5.lib;
        var WordArray = C_lib.WordArray;
        var superInit = WordArray.init;
        var subInit = WordArray.init = function(typedArray) {
          if (typedArray instanceof ArrayBuffer) {
            typedArray = new Uint8Array(typedArray);
          }
          if (typedArray instanceof Int8Array || typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {
            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
          }
          if (typedArray instanceof Uint8Array) {
            var typedArrayByteLength = typedArray.byteLength;
            var words2 = [];
            for (var i6 = 0; i6 < typedArrayByteLength; i6++) {
              words2[i6 >>> 2] |= typedArray[i6] << 24 - i6 % 4 * 8;
            }
            superInit.call(this, words2, typedArrayByteLength);
          } else {
            superInit.apply(this, arguments);
          }
        };
        subInit.prototype = WordArray;
      })();
      return CryptoJS.lib.WordArray;
    });
  }
});

// node_modules/crypto-js/enc-utf16.js
var require_enc_utf16 = __commonJS({
  "node_modules/crypto-js/enc-utf16.js"(exports2, module2) {
    (function(root2, factory) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS) {
      (function() {
        var C5 = CryptoJS;
        var C_lib = C5.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C5.enc;
        var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
          stringify: function(wordArray) {
            var words2 = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i6 = 0; i6 < sigBytes; i6 += 2) {
              var codePoint = words2[i6 >>> 2] >>> 16 - i6 % 4 * 8 & 65535;
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          parse: function(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words2 = [];
            for (var i6 = 0; i6 < utf16StrLength; i6++) {
              words2[i6 >>> 1] |= utf16Str.charCodeAt(i6) << 16 - i6 % 2 * 16;
            }
            return WordArray.create(words2, utf16StrLength * 2);
          }
        };
        C_enc.Utf16LE = {
          stringify: function(wordArray) {
            var words2 = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i6 = 0; i6 < sigBytes; i6 += 2) {
              var codePoint = swapEndian(words2[i6 >>> 2] >>> 16 - i6 % 4 * 8 & 65535);
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          parse: function(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words2 = [];
            for (var i6 = 0; i6 < utf16StrLength; i6++) {
              words2[i6 >>> 1] |= swapEndian(utf16Str.charCodeAt(i6) << 16 - i6 % 2 * 16);
            }
            return WordArray.create(words2, utf16StrLength * 2);
          }
        };
        function swapEndian(word) {
          return word << 8 & 4278255360 | word >>> 8 & 16711935;
        }
      })();
      return CryptoJS.enc.Utf16;
    });
  }
});

// node_modules/crypto-js/enc-base64.js
var require_enc_base64 = __commonJS({
  "node_modules/crypto-js/enc-base64.js"(exports2, module2) {
    (function(root2, factory) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS) {
      (function() {
        var C5 = CryptoJS;
        var C_lib = C5.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C5.enc;
        var Base64 = C_enc.Base64 = {
          stringify: function(wordArray) {
            var words2 = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map2 = this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i6 = 0; i6 < sigBytes; i6 += 3) {
              var byte1 = words2[i6 >>> 2] >>> 24 - i6 % 4 * 8 & 255;
              var byte2 = words2[i6 + 1 >>> 2] >>> 24 - (i6 + 1) % 4 * 8 & 255;
              var byte3 = words2[i6 + 2 >>> 2] >>> 24 - (i6 + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j8 = 0; j8 < 4 && i6 + j8 * 0.75 < sigBytes; j8++) {
                base64Chars.push(map2.charAt(triplet >>> 6 * (3 - j8) & 63));
              }
            }
            var paddingChar = map2.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          },
          parse: function(base64Str) {
            var base64StrLength = base64Str.length;
            var map2 = this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j8 = 0; j8 < map2.length; j8++) {
                reverseMap[map2.charCodeAt(j8)] = j8;
              }
            }
            var paddingChar = map2.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words2 = [];
          var nBytes = 0;
          for (var i6 = 0; i6 < base64StrLength; i6++) {
            if (i6 % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i6 - 1)] << i6 % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i6)] >>> 6 - i6 % 4 * 2;
              words2[nBytes >>> 2] |= (bits1 | bits2) << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words2, nBytes);
        }
      })();
      return CryptoJS.enc.Base64;
    });
  }
});

// node_modules/crypto-js/md5.js
var require_md5 = __commonJS({
  "node_modules/crypto-js/md5.js"(exports2, module2) {
    (function(root2, factory) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS) {
      (function(Math2) {
        var C5 = CryptoJS;
        var C_lib = C5.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C5.algo;
        var T8 = [];
        (function() {
          for (var i6 = 0; i6 < 64; i6++) {
            T8[i6] = Math2.abs(Math2.sin(i6 + 1)) * 4294967296 | 0;
          }
        })();
        var MD5 = C_algo.MD5 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878
            ]);
          },
          _doProcessBlock: function(M6, offset) {
            for (var i6 = 0; i6 < 16; i6++) {
              var offset_i = offset + i6;
              var M_offset_i = M6[offset_i];
              M6[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H5 = this._hash.words;
            var M_offset_0 = M6[offset + 0];
            var M_offset_1 = M6[offset + 1];
            var M_offset_2 = M6[offset + 2];
            var M_offset_3 = M6[offset + 3];
            var M_offset_4 = M6[offset + 4];
            var M_offset_5 = M6[offset + 5];
            var M_offset_6 = M6[offset + 6];
            var M_offset_7 = M6[offset + 7];
            var M_offset_8 = M6[offset + 8];
            var M_offset_9 = M6[offset + 9];
            var M_offset_10 = M6[offset + 10];
            var M_offset_11 = M6[offset + 11];
            var M_offset_12 = M6[offset + 12];
            var M_offset_13 = M6[offset + 13];
            var M_offset_14 = M6[offset + 14];
            var M_offset_15 = M6[offset + 15];
            var a5 = H5[0];
            var b4 = H5[1];
            var c5 = H5[2];
            var d6 = H5[3];
            a5 = FF(a5, b4, c5, d6, M_offset_0, 7, T8[0]);
            d6 = FF(d6, a5, b4, c5, M_offset_1, 12, T8[1]);
            c5 = FF(c5, d6, a5, b4, M_offset_2, 17, T8[2]);
            b4 = FF(b4, c5, d6, a5, M_offset_3, 22, T8[3]);
            a5 = FF(a5, b4, c5, d6, M_offset_4, 7, T8[4]);
            d6 = FF(d6, a5, b4, c5, M_offset_5, 12, T8[5]);
            c5 = FF(c5, d6, a5, b4, M_offset_6, 17, T8[6]);
            b4 = FF(b4, c5, d6, a5, M_offset_7, 22, T8[7]);
            a5 = FF(a5, b4, c5, d6, M_offset_8, 7, T8[8]);
            d6 = FF(d6, a5, b4, c5, M_offset_9, 12, T8[9]);
            c5 = FF(c5, d6, a5, b4, M_offset_10, 17, T8[10]);
            b4 = FF(b4, c5, d6, a5, M_offset_11, 22, T8[11]);
            a5 = FF(a5, b4, c5, d6, M_offset_12, 7, T8[12]);
            d6 = FF(d6, a5, b4, c5, M_offset_13, 12, T8[13]);
            c5 = FF(c5, d6, a5, b4, M_offset_14, 17, T8[14]);
            b4 = FF(b4, c5, d6, a5, M_offset_15, 22, T8[15]);
            a5 = GG(a5, b4, c5, d6, M_offset_1, 5, T8[16]);
            d6 = GG(d6, a5, b4, c5, M_offset_6, 9, T8[17]);
            c5 = GG(c5, d6, a5, b4, M_offset_11, 14, T8[18]);
            b4 = GG(b4, c5, d6, a5, M_offset_0, 20, T8[19]);
            a5 = GG(a5, b4, c5, d6, M_offset_5, 5, T8[20]);
            d6 = GG(d6, a5, b4, c5, M_offset_10, 9, T8[21]);
            c5 = GG(c5, d6, a5, b4, M_offset_15, 14, T8[22]);
            b4 = GG(b4, c5, d6, a5, M_offset_4, 20, T8[23]);
            a5 = GG(a5, b4, c5, d6, M_offset_9, 5, T8[24]);
            d6 = GG(d6, a5, b4, c5, M_offset_14, 9, T8[25]);
            c5 = GG(c5, d6, a5, b4, M_offset_3, 14, T8[26]);
            b4 = GG(b4, c5, d6, a5, M_offset_8, 20, T8[27]);
            a5 = GG(a5, b4, c5, d6, M_offset_13, 5, T8[28]);
            d6 = GG(d6, a5, b4, c5, M_offset_2, 9, T8[29]);
            c5 = GG(c5, d6, a5, b4, M_offset_7, 14, T8[30]);
            b4 = GG(b4, c5, d6, a5, M_offset_12, 20, T8[31]);
            a5 = HH(a5, b4, c5, d6, M_offset_5, 4, T8[32]);
            d6 = HH(d6, a5, b4, c5, M_offset_8, 11, T8[33]);
            c5 = HH(c5, d6, a5, b4, M_offset_11, 16, T8[34]);
            b4 = HH(b4, c5, d6, a5, M_offset_14, 23, T8[35]);
            a5 = HH(a5, b4, c5, d6, M_offset_1, 4, T8[36]);
            d6 = HH(d6, a5, b4, c5, M_offset_4, 11, T8[37]);
            c5 = HH(c5, d6, a5, b4, M_offset_7, 16, T8[38]);
            b4 = HH(b4, c5, d6, a5, M_offset_10, 23, T8[39]);
            a5 = HH(a5, b4, c5, d6, M_offset_13, 4, T8[40]);
            d6 = HH(d6, a5, b4, c5, M_offset_0, 11, T8[41]);
            c5 = HH(c5, d6, a5, b4, M_offset_3, 16, T8[42]);
            b4 = HH(b4, c5, d6, a5, M_offset_6, 23, T8[43]);
            a5 = HH(a5, b4, c5, d6, M_offset_9, 4, T8[44]);
            d6 = HH(d6, a5, b4, c5, M_offset_12, 11, T8[45]);
            c5 = HH(c5, d6, a5, b4, M_offset_15, 16, T8[46]);
            b4 = HH(b4, c5, d6, a5, M_offset_2, 23, T8[47]);
            a5 = II(a5, b4, c5, d6, M_offset_0, 6, T8[48]);
            d6 = II(d6, a5, b4, c5, M_offset_7, 10, T8[49]);
            c5 = II(c5, d6, a5, b4, M_offset_14, 15, T8[50]);
            b4 = II(b4, c5, d6, a5, M_offset_5, 21, T8[51]);
            a5 = II(a5, b4, c5, d6, M_offset_12, 6, T8[52]);
            d6 = II(d6, a5, b4, c5, M_offset_3, 10, T8[53]);
            c5 = II(c5, d6, a5, b4, M_offset_10, 15, T8[54]);
            b4 = II(b4, c5, d6, a5, M_offset_1, 21, T8[55]);
            a5 = II(a5, b4, c5, d6, M_offset_8, 6, T8[56]);
            d6 = II(d6, a5, b4, c5, M_offset_15, 10, T8[57]);
            c5 = II(c5, d6, a5, b4, M_offset_6, 15, T8[58]);
            b4 = II(b4, c5, d6, a5, M_offset_13, 21, T8[59]);
            a5 = II(a5, b4, c5, d6, M_offset_4, 6, T8[60]);
            d6 = II(d6, a5, b4, c5, M_offset_11, 10, T8[61]);
            c5 = II(c5, d6, a5, b4, M_offset_2, 15, T8[62]);
            b4 = II(b4, c5, d6, a5, M_offset_9, 21, T8[63]);
            H5[0] = H5[0] + a5 | 0;
            H5[1] = H5[1] + b4 | 0;
            H5[2] = H5[2] + c5 | 0;
            H5[3] = H5[3] + d6 | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
            var nBitsTotalL = nBitsTotal;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
            data.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash3 = this._hash;
            var H5 = hash3.words;
            for (var i6 = 0; i6 < 4; i6++) {
              var H_i = H5[i6];
              H5[i6] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash3;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function FF(a5, b4, c5, d6, x6, s6, t6) {
          var n4 = a5 + (b4 & c5 | ~b4 & d6) + x6 + t6;
          return (n4 << s6 | n4 >>> 32 - s6) + b4;
        }
        function GG(a5, b4, c5, d6, x6, s6, t6) {
          var n4 = a5 + (b4 & d6 | c5 & ~d6) + x6 + t6;
          return (n4 << s6 | n4 >>> 32 - s6) + b4;
        }
        function HH(a5, b4, c5, d6, x6, s6, t6) {
          var n4 = a5 + (b4 ^ c5 ^ d6) + x6 + t6;
          return (n4 << s6 | n4 >>> 32 - s6) + b4;
        }
        function II(a5, b4, c5, d6, x6, s6, t6) {
          var n4 = a5 + (c5 ^ (b4 | ~d6)) + x6 + t6;
          return (n4 << s6 | n4 >>> 32 - s6) + b4;
        }
        C5.MD5 = Hasher._createHelper(MD5);
        C5.HmacMD5 = Hasher._createHmacHelper(MD5);
      })(Math);
      return CryptoJS.MD5;
    });
  }
});

// node_modules/crypto-js/sha1.js
var require_sha1 = __commonJS({
  "node_modules/crypto-js/sha1.js"(exports2, module2) {
    (function(root2, factory) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS) {
      (function() {
        var C5 = CryptoJS;
        var C_lib = C5.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C5.algo;
        var W4 = [];
        var SHA1 = C_algo.SHA1 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878,
              3285377520
            ]);
          },
          _doProcessBlock: function(M6, offset) {
            var H5 = this._hash.words;
            var a5 = H5[0];
            var b4 = H5[1];
            var c5 = H5[2];
            var d6 = H5[3];
            var e6 = H5[4];
            for (var i6 = 0; i6 < 80; i6++) {
              if (i6 < 16) {
                W4[i6] = M6[offset + i6] | 0;
              } else {
                var n4 = W4[i6 - 3] ^ W4[i6 - 8] ^ W4[i6 - 14] ^ W4[i6 - 16];
                W4[i6] = n4 << 1 | n4 >>> 31;
              }
              var t6 = (a5 << 5 | a5 >>> 27) + e6 + W4[i6];
              if (i6 < 20) {
                t6 += (b4 & c5 | ~b4 & d6) + 1518500249;
              } else if (i6 < 40) {
                t6 += (b4 ^ c5 ^ d6) + 1859775393;
              } else if (i6 < 60) {
                t6 += (b4 & c5 | b4 & d6 | c5 & d6) - 1894007588;
              } else {
                t6 += (b4 ^ c5 ^ d6) - 899497514;
              }
              e6 = d6;
              d6 = c5;
              c5 = b4 << 30 | b4 >>> 2;
              b4 = a5;
              a5 = t6;
            }
            H5[0] = H5[0] + a5 | 0;
            H5[1] = H5[1] + b4 | 0;
            H5[2] = H5[2] + c5 | 0;
            H5[3] = H5[3] + d6 | 0;
            H5[4] = H5[4] + e6 | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C5.SHA1 = Hasher._createHelper(SHA1);
        C5.HmacSHA1 = Hasher._createHmacHelper(SHA1);
      })();
      return CryptoJS.SHA1;
    });
  }
});

// node_modules/crypto-js/sha224.js
var require_sha224 = __commonJS({
  "node_modules/crypto-js/sha224.js"(exports2, module2) {
    (function(root2, factory, undef) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core(), require_sha256());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha256"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS) {
      (function() {
        var C5 = CryptoJS;
        var C_lib = C5.lib;
        var WordArray = C_lib.WordArray;
        var C_algo = C5.algo;
        var SHA256 = C_algo.SHA256;
        var SHA224 = C_algo.SHA224 = SHA256.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              3238371032,
              914150663,
              812702999,
              4144912697,
              4290775857,
              1750603025,
              1694076839,
              3204075428
            ]);
          },
          _doFinalize: function() {
            var hash3 = SHA256._doFinalize.call(this);
            hash3.sigBytes -= 4;
            return hash3;
          }
        });
        C5.SHA224 = SHA256._createHelper(SHA224);
        C5.HmacSHA224 = SHA256._createHmacHelper(SHA224);
      })();
      return CryptoJS.SHA224;
    });
  }
});

// node_modules/crypto-js/sha512.js
var require_sha512 = __commonJS({
  "node_modules/crypto-js/sha512.js"(exports2, module2) {
    (function(root2, factory, undef) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core(), require_x64_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS) {
      (function() {
        var C5 = CryptoJS;
        var C_lib = C5.lib;
        var Hasher = C_lib.Hasher;
        var C_x64 = C5.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C5.algo;
        function X64Word_create() {
          return X64Word.create.apply(X64Word, arguments);
        }
        var K5 = [
          X64Word_create(1116352408, 3609767458),
          X64Word_create(1899447441, 602891725),
          X64Word_create(3049323471, 3964484399),
          X64Word_create(3921009573, 2173295548),
          X64Word_create(961987163, 4081628472),
          X64Word_create(1508970993, 3053834265),
          X64Word_create(2453635748, 2937671579),
          X64Word_create(2870763221, 3664609560),
          X64Word_create(3624381080, 2734883394),
          X64Word_create(310598401, 1164996542),
          X64Word_create(607225278, 1323610764),
          X64Word_create(1426881987, 3590304994),
          X64Word_create(1925078388, 4068182383),
          X64Word_create(2162078206, 991336113),
          X64Word_create(2614888103, 633803317),
          X64Word_create(3248222580, 3479774868),
          X64Word_create(3835390401, 2666613458),
          X64Word_create(4022224774, 944711139),
          X64Word_create(264347078, 2341262773),
          X64Word_create(604807628, 2007800933),
          X64Word_create(770255983, 1495990901),
          X64Word_create(1249150122, 1856431235),
          X64Word_create(1555081692, 3175218132),
          X64Word_create(1996064986, 2198950837),
          X64Word_create(2554220882, 3999719339),
          X64Word_create(2821834349, 766784016),
          X64Word_create(2952996808, 2566594879),
          X64Word_create(3210313671, 3203337956),
          X64Word_create(3336571891, 1034457026),
          X64Word_create(3584528711, 2466948901),
          X64Word_create(113926993, 3758326383),
          X64Word_create(338241895, 168717936),
          X64Word_create(666307205, 1188179964),
          X64Word_create(773529912, 1546045734),
          X64Word_create(1294757372, 1522805485),
          X64Word_create(1396182291, 2643833823),
          X64Word_create(1695183700, 2343527390),
          X64Word_create(1986661051, 1014477480),
          X64Word_create(2177026350, 1206759142),
          X64Word_create(2456956037, 344077627),
          X64Word_create(2730485921, 1290863460),
          X64Word_create(2820302411, 3158454273),
          X64Word_create(3259730800, 3505952657),
          X64Word_create(3345764771, 106217008),
          X64Word_create(3516065817, 3606008344),
          X64Word_create(3600352804, 1432725776),
          X64Word_create(4094571909, 1467031594),
          X64Word_create(275423344, 851169720),
          X64Word_create(430227734, 3100823752),
          X64Word_create(506948616, 1363258195),
          X64Word_create(659060556, 3750685593),
          X64Word_create(883997877, 3785050280),
          X64Word_create(958139571, 3318307427),
          X64Word_create(1322822218, 3812723403),
          X64Word_create(1537002063, 2003034995),
          X64Word_create(1747873779, 3602036899),
          X64Word_create(1955562222, 1575990012),
          X64Word_create(2024104815, 1125592928),
          X64Word_create(2227730452, 2716904306),
          X64Word_create(2361852424, 442776044),
          X64Word_create(2428436474, 593698344),
          X64Word_create(2756734187, 3733110249),
          X64Word_create(3204031479, 2999351573),
          X64Word_create(3329325298, 3815920427),
          X64Word_create(3391569614, 3928383900),
          X64Word_create(3515267271, 566280711),
          X64Word_create(3940187606, 3454069534),
          X64Word_create(4118630271, 4000239992),
          X64Word_create(116418474, 1914138554),
          X64Word_create(174292421, 2731055270),
          X64Word_create(289380356, 3203993006),
          X64Word_create(460393269, 320620315),
          X64Word_create(685471733, 587496836),
          X64Word_create(852142971, 1086792851),
          X64Word_create(1017036298, 365543100),
          X64Word_create(1126000580, 2618297676),
          X64Word_create(1288033470, 3409855158),
          X64Word_create(1501505948, 4234509866),
          X64Word_create(1607167915, 987167468),
          X64Word_create(1816402316, 1246189591)
        ];
        var W4 = [];
        (function() {
          for (var i6 = 0; i6 < 80; i6++) {
            W4[i6] = X64Word_create();
          }
        })();
        var SHA512 = C_algo.SHA512 = Hasher.extend({
          _doReset: function() {
            this._hash = new X64WordArray.init([
              new X64Word.init(1779033703, 4089235720),
              new X64Word.init(3144134277, 2227873595),
              new X64Word.init(1013904242, 4271175723),
              new X64Word.init(2773480762, 1595750129),
              new X64Word.init(1359893119, 2917565137),
              new X64Word.init(2600822924, 725511199),
              new X64Word.init(528734635, 4215389547),
              new X64Word.init(1541459225, 327033209)
            ]);
          },
          _doProcessBlock: function(M6, offset) {
            var H5 = this._hash.words;
            var H02 = H5[0];
            var H1 = H5[1];
            var H22 = H5[2];
            var H32 = H5[3];
            var H42 = H5[4];
            var H52 = H5[5];
            var H6 = H5[6];
            var H7 = H5[7];
            var H0h = H02.high;
            var H0l = H02.low;
            var H1h = H1.high;
            var H1l = H1.low;
            var H2h = H22.high;
            var H2l = H22.low;
            var H3h = H32.high;
            var H3l = H32.low;
            var H4h = H42.high;
            var H4l = H42.low;
            var H5h = H52.high;
            var H5l = H52.low;
            var H6h = H6.high;
            var H6l = H6.low;
            var H7h = H7.high;
            var H7l = H7.low;
            var ah = H0h;
            var al = H0l;
            var bh = H1h;
            var bl = H1l;
            var ch = H2h;
            var cl = H2l;
            var dh = H3h;
            var dl = H3l;
            var eh = H4h;
            var el = H4l;
            var fh = H5h;
            var fl = H5l;
            var gh = H6h;
            var gl = H6l;
            var hh = H7h;
            var hl = H7l;
            for (var i6 = 0; i6 < 80; i6++) {
              var Wi3 = W4[i6];
              if (i6 < 16) {
                var Wih = Wi3.high = M6[offset + i6 * 2] | 0;
                var Wil = Wi3.low = M6[offset + i6 * 2 + 1] | 0;
              } else {
                var gamma0x = W4[i6 - 15];
                var gamma0xh = gamma0x.high;
                var gamma0xl = gamma0x.low;
                var gamma0h = (gamma0xh >>> 1 | gamma0xl << 31) ^ (gamma0xh >>> 8 | gamma0xl << 24) ^ gamma0xh >>> 7;
                var gamma0l = (gamma0xl >>> 1 | gamma0xh << 31) ^ (gamma0xl >>> 8 | gamma0xh << 24) ^ (gamma0xl >>> 7 | gamma0xh << 25);
                var gamma1x = W4[i6 - 2];
                var gamma1xh = gamma1x.high;
                var gamma1xl = gamma1x.low;
                var gamma1h = (gamma1xh >>> 19 | gamma1xl << 13) ^ (gamma1xh << 3 | gamma1xl >>> 29) ^ gamma1xh >>> 6;
                var gamma1l = (gamma1xl >>> 19 | gamma1xh << 13) ^ (gamma1xl << 3 | gamma1xh >>> 29) ^ (gamma1xl >>> 6 | gamma1xh << 26);
                var Wi7 = W4[i6 - 7];
                var Wi7h = Wi7.high;
                var Wi7l = Wi7.low;
                var Wi16 = W4[i6 - 16];
                var Wi16h = Wi16.high;
                var Wi16l = Wi16.low;
                var Wil = gamma0l + Wi7l;
                var Wih = gamma0h + Wi7h + (Wil >>> 0 < gamma0l >>> 0 ? 1 : 0);
                var Wil = Wil + gamma1l;
                var Wih = Wih + gamma1h + (Wil >>> 0 < gamma1l >>> 0 ? 1 : 0);
                var Wil = Wil + Wi16l;
                var Wih = Wih + Wi16h + (Wil >>> 0 < Wi16l >>> 0 ? 1 : 0);
                Wi3.high = Wih;
                Wi3.low = Wil;
              }
              var chh = eh & fh ^ ~eh & gh;
              var chl = el & fl ^ ~el & gl;
              var majh = ah & bh ^ ah & ch ^ bh & ch;
              var majl = al & bl ^ al & cl ^ bl & cl;
              var sigma0h = (ah >>> 28 | al << 4) ^ (ah << 30 | al >>> 2) ^ (ah << 25 | al >>> 7);
              var sigma0l = (al >>> 28 | ah << 4) ^ (al << 30 | ah >>> 2) ^ (al << 25 | ah >>> 7);
              var sigma1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9);
              var sigma1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9);
              var Ki2 = K5[i6];
              var Kih = Ki2.high;
              var Kil = Ki2.low;
              var t1l = hl + sigma1l;
              var t1h = hh + sigma1h + (t1l >>> 0 < hl >>> 0 ? 1 : 0);
              var t1l = t1l + chl;
              var t1h = t1h + chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0);
              var t1l = t1l + Kil;
              var t1h = t1h + Kih + (t1l >>> 0 < Kil >>> 0 ? 1 : 0);
              var t1l = t1l + Wil;
              var t1h = t1h + Wih + (t1l >>> 0 < Wil >>> 0 ? 1 : 0);
              var t2l = sigma0l + majl;
              var t2h = sigma0h + majh + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0);
              hh = gh;
              hl = gl;
              gh = fh;
              gl = fl;
              fh = eh;
              fl = el;
              el = dl + t1l | 0;
              eh = dh + t1h + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
              dh = ch;
              dl = cl;
              ch = bh;
              cl = bl;
              bh = ah;
              bl = al;
              al = t1l + t2l | 0;
              ah = t1h + t2h + (al >>> 0 < t1l >>> 0 ? 1 : 0) | 0;
            }
            H0l = H02.low = H0l + al;
            H02.high = H0h + ah + (H0l >>> 0 < al >>> 0 ? 1 : 0);
            H1l = H1.low = H1l + bl;
            H1.high = H1h + bh + (H1l >>> 0 < bl >>> 0 ? 1 : 0);
            H2l = H22.low = H2l + cl;
            H22.high = H2h + ch + (H2l >>> 0 < cl >>> 0 ? 1 : 0);
            H3l = H32.low = H3l + dl;
            H32.high = H3h + dh + (H3l >>> 0 < dl >>> 0 ? 1 : 0);
            H4l = H42.low = H4l + el;
            H42.high = H4h + eh + (H4l >>> 0 < el >>> 0 ? 1 : 0);
            H5l = H52.low = H5l + fl;
            H52.high = H5h + fh + (H5l >>> 0 < fl >>> 0 ? 1 : 0);
            H6l = H6.low = H6l + gl;
            H6.high = H6h + gh + (H6l >>> 0 < gl >>> 0 ? 1 : 0);
            H7l = H7.low = H7l + hl;
            H7.high = H7h + hh + (H7l >>> 0 < hl >>> 0 ? 1 : 0);
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 128 >>> 10 << 5) + 30] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 128 >>> 10 << 5) + 31] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            var hash3 = this._hash.toX32();
            return hash3;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          },
          blockSize: 1024 / 32
        });
        C5.SHA512 = Hasher._createHelper(SHA512);
        C5.HmacSHA512 = Hasher._createHmacHelper(SHA512);
      })();
      return CryptoJS.SHA512;
    });
  }
});

// node_modules/crypto-js/sha384.js
var require_sha384 = __commonJS({
  "node_modules/crypto-js/sha384.js"(exports2, module2) {
    (function(root2, factory, undef) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core(), require_x64_core(), require_sha512());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core", "./sha512"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS) {
      (function() {
        var C5 = CryptoJS;
        var C_x64 = C5.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C5.algo;
        var SHA512 = C_algo.SHA512;
        var SHA384 = C_algo.SHA384 = SHA512.extend({
          _doReset: function() {
            this._hash = new X64WordArray.init([
              new X64Word.init(3418070365, 3238371032),
              new X64Word.init(1654270250, 914150663),
              new X64Word.init(2438529370, 812702999),
              new X64Word.init(355462360, 4144912697),
              new X64Word.init(1731405415, 4290775857),
              new X64Word.init(2394180231, 1750603025),
              new X64Word.init(3675008525, 1694076839),
              new X64Word.init(1203062813, 3204075428)
            ]);
          },
          _doFinalize: function() {
            var hash3 = SHA512._doFinalize.call(this);
            hash3.sigBytes -= 16;
            return hash3;
          }
        });
        C5.SHA384 = SHA512._createHelper(SHA384);
        C5.HmacSHA384 = SHA512._createHmacHelper(SHA384);
      })();
      return CryptoJS.SHA384;
    });
  }
});

// node_modules/crypto-js/sha3.js
var require_sha32 = __commonJS({
  "node_modules/crypto-js/sha3.js"(exports2, module2) {
    (function(root2, factory, undef) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core(), require_x64_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS) {
      (function(Math2) {
        var C5 = CryptoJS;
        var C_lib = C5.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_x64 = C5.x64;
        var X64Word = C_x64.Word;
        var C_algo = C5.algo;
        var RHO_OFFSETS = [];
        var PI_INDEXES = [];
        var ROUND_CONSTANTS = [];
        (function() {
          var x6 = 1, y5 = 0;
          for (var t6 = 0; t6 < 24; t6++) {
            RHO_OFFSETS[x6 + 5 * y5] = (t6 + 1) * (t6 + 2) / 2 % 64;
            var newX = y5 % 5;
            var newY = (2 * x6 + 3 * y5) % 5;
            x6 = newX;
            y5 = newY;
          }
          for (var x6 = 0; x6 < 5; x6++) {
            for (var y5 = 0; y5 < 5; y5++) {
              PI_INDEXES[x6 + 5 * y5] = y5 + (2 * x6 + 3 * y5) % 5 * 5;
            }
          }
          var LFSR = 1;
          for (var i6 = 0; i6 < 24; i6++) {
            var roundConstantMsw = 0;
            var roundConstantLsw = 0;
            for (var j8 = 0; j8 < 7; j8++) {
              if (LFSR & 1) {
                var bitPosition = (1 << j8) - 1;
                if (bitPosition < 32) {
                  roundConstantLsw ^= 1 << bitPosition;
                } else {
                  roundConstantMsw ^= 1 << bitPosition - 32;
                }
              }
              if (LFSR & 128) {
                LFSR = LFSR << 1 ^ 113;
              } else {
                LFSR <<= 1;
              }
            }
            ROUND_CONSTANTS[i6] = X64Word.create(roundConstantMsw, roundConstantLsw);
          }
        })();
        var T8 = [];
        (function() {
          for (var i6 = 0; i6 < 25; i6++) {
            T8[i6] = X64Word.create();
          }
        })();
        var SHA3 = C_algo.SHA3 = Hasher.extend({
          cfg: Hasher.cfg.extend({
            outputLength: 512
          }),
          _doReset: function() {
            var state = this._state = [];
            for (var i6 = 0; i6 < 25; i6++) {
              state[i6] = new X64Word.init();
            }
            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
          },
          _doProcessBlock: function(M6, offset) {
            var state = this._state;
            var nBlockSizeLanes = this.blockSize / 2;
            for (var i6 = 0; i6 < nBlockSizeLanes; i6++) {
              var M2i = M6[offset + 2 * i6];
              var M2i1 = M6[offset + 2 * i6 + 1];
              M2i = (M2i << 8 | M2i >>> 24) & 16711935 | (M2i << 24 | M2i >>> 8) & 4278255360;
              M2i1 = (M2i1 << 8 | M2i1 >>> 24) & 16711935 | (M2i1 << 24 | M2i1 >>> 8) & 4278255360;
              var lane = state[i6];
              lane.high ^= M2i1;
              lane.low ^= M2i;
            }
            for (var round = 0; round < 24; round++) {
              for (var x6 = 0; x6 < 5; x6++) {
                var tMsw = 0, tLsw = 0;
                for (var y5 = 0; y5 < 5; y5++) {
                  var lane = state[x6 + 5 * y5];
                  tMsw ^= lane.high;
                  tLsw ^= lane.low;
                }
                var Tx = T8[x6];
                Tx.high = tMsw;
                Tx.low = tLsw;
              }
              for (var x6 = 0; x6 < 5; x6++) {
                var Tx4 = T8[(x6 + 4) % 5];
                var Tx1 = T8[(x6 + 1) % 5];
                var Tx1Msw = Tx1.high;
                var Tx1Lsw = Tx1.low;
                var tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31);
                var tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31);
                for (var y5 = 0; y5 < 5; y5++) {
                  var lane = state[x6 + 5 * y5];
                  lane.high ^= tMsw;
                  lane.low ^= tLsw;
                }
              }
              for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
                var lane = state[laneIndex];
                var laneMsw = lane.high;
                var laneLsw = lane.low;
                var rhoOffset = RHO_OFFSETS[laneIndex];
                if (rhoOffset < 32) {
                  var tMsw = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset;
                  var tLsw = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset;
                } else {
                  var tMsw = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset;
                  var tLsw = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset;
                }
                var TPiLane = T8[PI_INDEXES[laneIndex]];
                TPiLane.high = tMsw;
                TPiLane.low = tLsw;
              }
              var T02 = T8[0];
              var state0 = state[0];
              T02.high = state0.high;
              T02.low = state0.low;
              for (var x6 = 0; x6 < 5; x6++) {
                for (var y5 = 0; y5 < 5; y5++) {
                  var laneIndex = x6 + 5 * y5;
                  var lane = state[laneIndex];
                  var TLane = T8[laneIndex];
                  var Tx1Lane = T8[(x6 + 1) % 5 + 5 * y5];
                  var Tx2Lane = T8[(x6 + 2) % 5 + 5 * y5];
                  lane.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high;
                  lane.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;
                }
              }
              var lane = state[0];
              var roundConstant = ROUND_CONSTANTS[round];
              lane.high ^= roundConstant.high;
              lane.low ^= roundConstant.low;
              ;
            }
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            var blockSizeBits = this.blockSize * 32;
            dataWords[nBitsLeft >>> 5] |= 1 << 24 - nBitsLeft % 32;
            dataWords[(Math2.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 128;
            data.sigBytes = dataWords.length * 4;
            this._process();
            var state = this._state;
            var outputLengthBytes = this.cfg.outputLength / 8;
            var outputLengthLanes = outputLengthBytes / 8;
            var hashWords = [];
            for (var i6 = 0; i6 < outputLengthLanes; i6++) {
              var lane = state[i6];
              var laneMsw = lane.high;
              var laneLsw = lane.low;
              laneMsw = (laneMsw << 8 | laneMsw >>> 24) & 16711935 | (laneMsw << 24 | laneMsw >>> 8) & 4278255360;
              laneLsw = (laneLsw << 8 | laneLsw >>> 24) & 16711935 | (laneLsw << 24 | laneLsw >>> 8) & 4278255360;
              hashWords.push(laneLsw);
              hashWords.push(laneMsw);
            }
            return new WordArray.init(hashWords, outputLengthBytes);
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            var state = clone._state = this._state.slice(0);
            for (var i6 = 0; i6 < 25; i6++) {
              state[i6] = state[i6].clone();
            }
            return clone;
          }
        });
        C5.SHA3 = Hasher._createHelper(SHA3);
        C5.HmacSHA3 = Hasher._createHmacHelper(SHA3);
      })(Math);
      return CryptoJS.SHA3;
    });
  }
});

// node_modules/crypto-js/ripemd160.js
var require_ripemd160 = __commonJS({
  "node_modules/crypto-js/ripemd160.js"(exports2, module2) {
    (function(root2, factory) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS) {
      (function(Math2) {
        var C5 = CryptoJS;
        var C_lib = C5.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C5.algo;
        var _zl = WordArray.create([
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          7,
          4,
          13,
          1,
          10,
          6,
          15,
          3,
          12,
          0,
          9,
          5,
          2,
          14,
          11,
          8,
          3,
          10,
          14,
          4,
          9,
          15,
          8,
          1,
          2,
          7,
          0,
          6,
          13,
          11,
          5,
          12,
          1,
          9,
          11,
          10,
          0,
          8,
          12,
          4,
          13,
          3,
          7,
          15,
          14,
          5,
          6,
          2,
          4,
          0,
          5,
          9,
          7,
          12,
          2,
          10,
          14,
          1,
          3,
          8,
          11,
          6,
          15,
          13
        ]);
        var _zr = WordArray.create([
          5,
          14,
          7,
          0,
          9,
          2,
          11,
          4,
          13,
          6,
          15,
          8,
          1,
          10,
          3,
          12,
          6,
          11,
          3,
          7,
          0,
          13,
          5,
          10,
          14,
          15,
          8,
          12,
          4,
          9,
          1,
          2,
          15,
          5,
          1,
          3,
          7,
          14,
          6,
          9,
          11,
          8,
          12,
          2,
          10,
          0,
          4,
          13,
          8,
          6,
          4,
          1,
          3,
          11,
          15,
          0,
          5,
          12,
          2,
          13,
          9,
          7,
          10,
          14,
          12,
          15,
          10,
          4,
          1,
          5,
          8,
          7,
          6,
          2,
          13,
          14,
          0,
          3,
          9,
          11
        ]);
        var _sl = WordArray.create([
          11,
          14,
          15,
          12,
          5,
          8,
          7,
          9,
          11,
          13,
          14,
          15,
          6,
          7,
          9,
          8,
          7,
          6,
          8,
          13,
          11,
          9,
          7,
          15,
          7,
          12,
          15,
          9,
          11,
          7,
          13,
          12,
          11,
          13,
          6,
          7,
          14,
          9,
          13,
          15,
          14,
          8,
          13,
          6,
          5,
          12,
          7,
          5,
          11,
          12,
          14,
          15,
          14,
          15,
          9,
          8,
          9,
          14,
          5,
          6,
          8,
          6,
          5,
          12,
          9,
          15,
          5,
          11,
          6,
          8,
          13,
          12,
          5,
          12,
          13,
          14,
          11,
          8,
          5,
          6
        ]);
        var _sr = WordArray.create([
          8,
          9,
          9,
          11,
          13,
          15,
          15,
          5,
          7,
          7,
          8,
          11,
          14,
          14,
          12,
          6,
          9,
          13,
          15,
          7,
          12,
          8,
          9,
          11,
          7,
          7,
          12,
          7,
          6,
          15,
          13,
          11,
          9,
          7,
          15,
          11,
          8,
          6,
          6,
          14,
          12,
          13,
          5,
          14,
          13,
          13,
          7,
          5,
          15,
          5,
          8,
          11,
          14,
          14,
          6,
          14,
          6,
          9,
          12,
          9,
          12,
          5,
          15,
          8,
          8,
          5,
          12,
          9,
          12,
          5,
          14,
          6,
          8,
          13,
          6,
          5,
          15,
          13,
          11,
          11
        ]);
        var _hl = WordArray.create([0, 1518500249, 1859775393, 2400959708, 2840853838]);
        var _hr = WordArray.create([1352829926, 1548603684, 1836072691, 2053994217, 0]);
        var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
          _doReset: function() {
            this._hash = WordArray.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
          },
          _doProcessBlock: function(M6, offset) {
            for (var i6 = 0; i6 < 16; i6++) {
              var offset_i = offset + i6;
              var M_offset_i = M6[offset_i];
              M6[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H5 = this._hash.words;
            var hl = _hl.words;
            var hr2 = _hr.words;
            var zl = _zl.words;
            var zr2 = _zr.words;
            var sl = _sl.words;
            var sr2 = _sr.words;
            var al, bl, cl, dl, el;
            var ar3, br2, cr2, dr2, er2;
            ar3 = al = H5[0];
            br2 = bl = H5[1];
            cr2 = cl = H5[2];
            dr2 = dl = H5[3];
            er2 = el = H5[4];
            var t6;
            for (var i6 = 0; i6 < 80; i6 += 1) {
              t6 = al + M6[offset + zl[i6]] | 0;
              if (i6 < 16) {
                t6 += f1(bl, cl, dl) + hl[0];
              } else if (i6 < 32) {
                t6 += f22(bl, cl, dl) + hl[1];
              } else if (i6 < 48) {
                t6 += f32(bl, cl, dl) + hl[2];
              } else if (i6 < 64) {
                t6 += f42(bl, cl, dl) + hl[3];
              } else {
                t6 += f52(bl, cl, dl) + hl[4];
              }
              t6 = t6 | 0;
              t6 = rotl(t6, sl[i6]);
              t6 = t6 + el | 0;
              al = el;
              el = dl;
              dl = rotl(cl, 10);
              cl = bl;
              bl = t6;
              t6 = ar3 + M6[offset + zr2[i6]] | 0;
              if (i6 < 16) {
                t6 += f52(br2, cr2, dr2) + hr2[0];
              } else if (i6 < 32) {
                t6 += f42(br2, cr2, dr2) + hr2[1];
              } else if (i6 < 48) {
                t6 += f32(br2, cr2, dr2) + hr2[2];
              } else if (i6 < 64) {
                t6 += f22(br2, cr2, dr2) + hr2[3];
              } else {
                t6 += f1(br2, cr2, dr2) + hr2[4];
              }
              t6 = t6 | 0;
              t6 = rotl(t6, sr2[i6]);
              t6 = t6 + er2 | 0;
              ar3 = er2;
              er2 = dr2;
              dr2 = rotl(cr2, 10);
              cr2 = br2;
              br2 = t6;
            }
            t6 = H5[1] + cl + dr2 | 0;
            H5[1] = H5[2] + dl + er2 | 0;
            H5[2] = H5[3] + el + ar3 | 0;
            H5[3] = H5[4] + al + br2 | 0;
            H5[4] = H5[0] + bl + cr2 | 0;
            H5[0] = t6;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotal << 8 | nBitsTotal >>> 24) & 16711935 | (nBitsTotal << 24 | nBitsTotal >>> 8) & 4278255360;
            data.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash3 = this._hash;
            var H5 = hash3.words;
            for (var i6 = 0; i6 < 5; i6++) {
              var H_i = H5[i6];
              H5[i6] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash3;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function f1(x6, y5, z6) {
          return x6 ^ y5 ^ z6;
        }
        function f22(x6, y5, z6) {
          return x6 & y5 | ~x6 & z6;
        }
        function f32(x6, y5, z6) {
          return (x6 | ~y5) ^ z6;
        }
        function f42(x6, y5, z6) {
          return x6 & z6 | y5 & ~z6;
        }
        function f52(x6, y5, z6) {
          return x6 ^ (y5 | ~z6);
        }
        function rotl(x6, n4) {
          return x6 << n4 | x6 >>> 32 - n4;
        }
        C5.RIPEMD160 = Hasher._createHelper(RIPEMD160);
        C5.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
      })(Math);
      return CryptoJS.RIPEMD160;
    });
  }
});

// node_modules/crypto-js/hmac.js
var require_hmac2 = __commonJS({
  "node_modules/crypto-js/hmac.js"(exports2, module2) {
    (function(root2, factory) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS) {
      (function() {
        var C5 = CryptoJS;
        var C_lib = C5.lib;
        var Base = C_lib.Base;
        var C_enc = C5.enc;
        var Utf8 = C_enc.Utf8;
        var C_algo = C5.algo;
        var HMAC = C_algo.HMAC = Base.extend({
          init: function(hasher, key2) {
            hasher = this._hasher = new hasher.init();
            if (typeof key2 == "string") {
              key2 = Utf8.parse(key2);
            }
            var hasherBlockSize = hasher.blockSize;
            var hasherBlockSizeBytes = hasherBlockSize * 4;
            if (key2.sigBytes > hasherBlockSizeBytes) {
              key2 = hasher.finalize(key2);
            }
            key2.clamp();
            var oKey = this._oKey = key2.clone();
            var iKey = this._iKey = key2.clone();
            var oKeyWords = oKey.words;
            var iKeyWords = iKey.words;
            for (var i6 = 0; i6 < hasherBlockSize; i6++) {
              oKeyWords[i6] ^= 1549556828;
              iKeyWords[i6] ^= 909522486;
            }
            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;
            this.reset();
          },
          reset: function() {
            var hasher = this._hasher;
            hasher.reset();
            hasher.update(this._iKey);
          },
          update: function(messageUpdate) {
            this._hasher.update(messageUpdate);
            return this;
          },
          finalize: function(messageUpdate) {
            var hasher = this._hasher;
            var innerHash = hasher.finalize(messageUpdate);
            hasher.reset();
            var hmac2 = hasher.finalize(this._oKey.clone().concat(innerHash));
            return hmac2;
          }
        });
      })();
    });
  }
});

// node_modules/crypto-js/pbkdf2.js
var require_pbkdf2 = __commonJS({
  "node_modules/crypto-js/pbkdf2.js"(exports2, module2) {
    (function(root2, factory, undef) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core(), require_sha1(), require_hmac2());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha1", "./hmac"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS) {
      (function() {
        var C5 = CryptoJS;
        var C_lib = C5.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C5.algo;
        var SHA1 = C_algo.SHA1;
        var HMAC = C_algo.HMAC;
        var PBKDF2 = C_algo.PBKDF2 = Base.extend({
          cfg: Base.extend({
            keySize: 128 / 32,
            hasher: SHA1,
            iterations: 1
          }),
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          compute: function(password, salt) {
            var cfg = this.cfg;
            var hmac2 = HMAC.create(cfg.hasher, password);
            var derivedKey = WordArray.create();
            var blockIndex = WordArray.create([1]);
            var derivedKeyWords = derivedKey.words;
            var blockIndexWords = blockIndex.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              var block = hmac2.update(salt).finalize(blockIndex);
              hmac2.reset();
              var blockWords = block.words;
              var blockWordsLength = blockWords.length;
              var intermediate = block;
              for (var i6 = 1; i6 < iterations; i6++) {
                intermediate = hmac2.finalize(intermediate);
                hmac2.reset();
                var intermediateWords = intermediate.words;
                for (var j8 = 0; j8 < blockWordsLength; j8++) {
                  blockWords[j8] ^= intermediateWords[j8];
                }
              }
              derivedKey.concat(block);
              blockIndexWords[0]++;
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }
        });
        C5.PBKDF2 = function(password, salt, cfg) {
          return PBKDF2.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS.PBKDF2;
    });
  }
});

// node_modules/crypto-js/evpkdf.js
var require_evpkdf = __commonJS({
  "node_modules/crypto-js/evpkdf.js"(exports2, module2) {
    (function(root2, factory, undef) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core(), require_sha1(), require_hmac2());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha1", "./hmac"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS) {
      (function() {
        var C5 = CryptoJS;
        var C_lib = C5.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C5.algo;
        var MD5 = C_algo.MD5;
        var EvpKDF = C_algo.EvpKDF = Base.extend({
          cfg: Base.extend({
            keySize: 128 / 32,
            hasher: MD5,
            iterations: 1
          }),
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          compute: function(password, salt) {
            var cfg = this.cfg;
            var hasher = cfg.hasher.create();
            var derivedKey = WordArray.create();
            var derivedKeyWords = derivedKey.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              if (block) {
                hasher.update(block);
              }
              var block = hasher.update(password).finalize(salt);
              hasher.reset();
              for (var i6 = 1; i6 < iterations; i6++) {
                block = hasher.finalize(block);
                hasher.reset();
              }
              derivedKey.concat(block);
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }
        });
        C5.EvpKDF = function(password, salt, cfg) {
          return EvpKDF.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS.EvpKDF;
    });
  }
});

// node_modules/crypto-js/cipher-core.js
var require_cipher_core = __commonJS({
  "node_modules/crypto-js/cipher-core.js"(exports2, module2) {
    (function(root2, factory, undef) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core(), require_evpkdf());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./evpkdf"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS) {
      CryptoJS.lib.Cipher || function(undefined2) {
        var C5 = CryptoJS;
        var C_lib = C5.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
        var C_enc = C5.enc;
        var Utf8 = C_enc.Utf8;
        var Base64 = C_enc.Base64;
        var C_algo = C5.algo;
        var EvpKDF = C_algo.EvpKDF;
        var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
          cfg: Base.extend(),
          createEncryptor: function(key2, cfg) {
            return this.create(this._ENC_XFORM_MODE, key2, cfg);
          },
          createDecryptor: function(key2, cfg) {
            return this.create(this._DEC_XFORM_MODE, key2, cfg);
          },
          init: function(xformMode, key2, cfg) {
            this.cfg = this.cfg.extend(cfg);
            this._xformMode = xformMode;
            this._key = key2;
            this.reset();
          },
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          process: function(dataUpdate) {
            this._append(dataUpdate);
            return this._process();
          },
          finalize: function(dataUpdate) {
            if (dataUpdate) {
              this._append(dataUpdate);
            }
            var finalProcessedData = this._doFinalize();
            return finalProcessedData;
          },
          keySize: 128 / 32,
          ivSize: 128 / 32,
          _ENC_XFORM_MODE: 1,
          _DEC_XFORM_MODE: 2,
          _createHelper: function() {
            function selectCipherStrategy(key2) {
              if (typeof key2 == "string") {
                return PasswordBasedCipher;
              } else {
                return SerializableCipher;
              }
            }
            return function(cipher) {
              return {
                encrypt: function(message, key2, cfg) {
                  return selectCipherStrategy(key2).encrypt(cipher, message, key2, cfg);
                },
                decrypt: function(ciphertext, key2, cfg) {
                  return selectCipherStrategy(key2).decrypt(cipher, ciphertext, key2, cfg);
                }
              };
            };
          }()
        });
        var StreamCipher = C_lib.StreamCipher = Cipher.extend({
          _doFinalize: function() {
            var finalProcessedBlocks = this._process(true);
            return finalProcessedBlocks;
          },
          blockSize: 1
        });
        var C_mode = C5.mode = {};
        var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
          createEncryptor: function(cipher, iv) {
            return this.Encryptor.create(cipher, iv);
          },
          createDecryptor: function(cipher, iv) {
            return this.Decryptor.create(cipher, iv);
          },
          init: function(cipher, iv) {
            this._cipher = cipher;
            this._iv = iv;
          }
        });
        var CBC = C_mode.CBC = function() {
          var CBC2 = BlockCipherMode.extend();
          CBC2.Encryptor = CBC2.extend({
            processBlock: function(words2, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              xorBlock.call(this, words2, offset, blockSize);
              cipher.encryptBlock(words2, offset);
              this._prevBlock = words2.slice(offset, offset + blockSize);
            }
          });
          CBC2.Decryptor = CBC2.extend({
            processBlock: function(words2, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              var thisBlock = words2.slice(offset, offset + blockSize);
              cipher.decryptBlock(words2, offset);
              xorBlock.call(this, words2, offset, blockSize);
              this._prevBlock = thisBlock;
            }
          });
          function xorBlock(words2, offset, blockSize) {
            var iv = this._iv;
            if (iv) {
              var block = iv;
              this._iv = undefined2;
            } else {
              var block = this._prevBlock;
            }
            for (var i6 = 0; i6 < blockSize; i6++) {
              words2[offset + i6] ^= block[i6];
            }
          }
          return CBC2;
        }();
        var C_pad = C5.pad = {};
        var Pkcs7 = C_pad.Pkcs7 = {
          pad: function(data, blockSize) {
            var blockSizeBytes = blockSize * 4;
            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
            var paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes;
            var paddingWords = [];
            for (var i6 = 0; i6 < nPaddingBytes; i6 += 4) {
              paddingWords.push(paddingWord);
            }
            var padding2 = WordArray.create(paddingWords, nPaddingBytes);
            data.concat(padding2);
          },
          unpad: function(data) {
            var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
            data.sigBytes -= nPaddingBytes;
          }
        };
        var BlockCipher = C_lib.BlockCipher = Cipher.extend({
          cfg: Cipher.cfg.extend({
            mode: CBC,
            padding: Pkcs7
          }),
          reset: function() {
            Cipher.reset.call(this);
            var cfg = this.cfg;
            var iv = cfg.iv;
            var mode = cfg.mode;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              var modeCreator = mode.createEncryptor;
            } else {
              var modeCreator = mode.createDecryptor;
              this._minBufferSize = 1;
            }
            if (this._mode && this._mode.__creator == modeCreator) {
              this._mode.init(this, iv && iv.words);
            } else {
              this._mode = modeCreator.call(mode, this, iv && iv.words);
              this._mode.__creator = modeCreator;
            }
          },
          _doProcessBlock: function(words2, offset) {
            this._mode.processBlock(words2, offset);
          },
          _doFinalize: function() {
            var padding2 = this.cfg.padding;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              padding2.pad(this._data, this.blockSize);
              var finalProcessedBlocks = this._process(true);
            } else {
              var finalProcessedBlocks = this._process(true);
              padding2.unpad(finalProcessedBlocks);
            }
            return finalProcessedBlocks;
          },
          blockSize: 128 / 32
        });
        var CipherParams = C_lib.CipherParams = Base.extend({
          init: function(cipherParams) {
            this.mixIn(cipherParams);
          },
          toString: function(formatter) {
            return (formatter || this.formatter).stringify(this);
          }
        });
        var C_format = C5.format = {};
        var OpenSSLFormatter = C_format.OpenSSL = {
          stringify: function(cipherParams) {
            var ciphertext = cipherParams.ciphertext;
            var salt = cipherParams.salt;
            if (salt) {
              var wordArray = WordArray.create([1398893684, 1701076831]).concat(salt).concat(ciphertext);
            } else {
              var wordArray = ciphertext;
            }
            return wordArray.toString(Base64);
          },
          parse: function(openSSLStr) {
            var ciphertext = Base64.parse(openSSLStr);
            var ciphertextWords = ciphertext.words;
            if (ciphertextWords[0] == 1398893684 && ciphertextWords[1] == 1701076831) {
              var salt = WordArray.create(ciphertextWords.slice(2, 4));
              ciphertextWords.splice(0, 4);
              ciphertext.sigBytes -= 16;
            }
            return CipherParams.create({ ciphertext, salt });
          }
        };
        var SerializableCipher = C_lib.SerializableCipher = Base.extend({
          cfg: Base.extend({
            format: OpenSSLFormatter
          }),
          encrypt: function(cipher, message, key2, cfg) {
            cfg = this.cfg.extend(cfg);
            var encryptor = cipher.createEncryptor(key2, cfg);
            var ciphertext = encryptor.finalize(message);
            var cipherCfg = encryptor.cfg;
            return CipherParams.create({
              ciphertext,
              key: key2,
              iv: cipherCfg.iv,
              algorithm: cipher,
              mode: cipherCfg.mode,
              padding: cipherCfg.padding,
              blockSize: cipher.blockSize,
              formatter: cfg.format
            });
          },
          decrypt: function(cipher, ciphertext, key2, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var plaintext = cipher.createDecryptor(key2, cfg).finalize(ciphertext.ciphertext);
            return plaintext;
          },
          _parse: function(ciphertext, format) {
            if (typeof ciphertext == "string") {
              return format.parse(ciphertext, this);
            } else {
              return ciphertext;
            }
          }
        });
        var C_kdf = C5.kdf = {};
        var OpenSSLKdf = C_kdf.OpenSSL = {
          execute: function(password, keySize, ivSize, salt) {
            if (!salt) {
              salt = WordArray.random(64 / 8);
            }
            var key2 = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);
            var iv = WordArray.create(key2.words.slice(keySize), ivSize * 4);
            key2.sigBytes = keySize * 4;
            return CipherParams.create({ key: key2, iv, salt });
          }
        };
        var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
          cfg: SerializableCipher.cfg.extend({
            kdf: OpenSSLKdf
          }),
          encrypt: function(cipher, message, password, cfg) {
            cfg = this.cfg.extend(cfg);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);
            cfg.iv = derivedParams.iv;
            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);
            ciphertext.mixIn(derivedParams);
            return ciphertext;
          },
          decrypt: function(cipher, ciphertext, password, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);
            cfg.iv = derivedParams.iv;
            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
            return plaintext;
          }
        });
      }();
    });
  }
});

// node_modules/crypto-js/mode-cfb.js
var require_mode_cfb = __commonJS({
  "node_modules/crypto-js/mode-cfb.js"(exports2, module2) {
    (function(root2, factory, undef) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS) {
      CryptoJS.mode.CFB = function() {
        var CFB = CryptoJS.lib.BlockCipherMode.extend();
        CFB.Encryptor = CFB.extend({
          processBlock: function(words2, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            generateKeystreamAndEncrypt.call(this, words2, offset, blockSize, cipher);
            this._prevBlock = words2.slice(offset, offset + blockSize);
          }
        });
        CFB.Decryptor = CFB.extend({
          processBlock: function(words2, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var thisBlock = words2.slice(offset, offset + blockSize);
            generateKeystreamAndEncrypt.call(this, words2, offset, blockSize, cipher);
            this._prevBlock = thisBlock;
          }
        });
        function generateKeystreamAndEncrypt(words2, offset, blockSize, cipher) {
          var iv = this._iv;
          if (iv) {
            var keystream = iv.slice(0);
            this._iv = void 0;
          } else {
            var keystream = this._prevBlock;
          }
          cipher.encryptBlock(keystream, 0);
          for (var i6 = 0; i6 < blockSize; i6++) {
            words2[offset + i6] ^= keystream[i6];
          }
        }
        return CFB;
      }();
      return CryptoJS.mode.CFB;
    });
  }
});

// node_modules/crypto-js/mode-ctr.js
var require_mode_ctr = __commonJS({
  "node_modules/crypto-js/mode-ctr.js"(exports2, module2) {
    (function(root2, factory, undef) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS) {
      CryptoJS.mode.CTR = function() {
        var CTR = CryptoJS.lib.BlockCipherMode.extend();
        var Encryptor = CTR.Encryptor = CTR.extend({
          processBlock: function(words2, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;
            if (iv) {
              counter = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            counter[blockSize - 1] = counter[blockSize - 1] + 1 | 0;
            for (var i6 = 0; i6 < blockSize; i6++) {
              words2[offset + i6] ^= keystream[i6];
            }
          }
        });
        CTR.Decryptor = Encryptor;
        return CTR;
      }();
      return CryptoJS.mode.CTR;
    });
  }
});

// node_modules/crypto-js/mode-ctr-gladman.js
var require_mode_ctr_gladman = __commonJS({
  "node_modules/crypto-js/mode-ctr-gladman.js"(exports2, module2) {
    (function(root2, factory, undef) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS) {
      CryptoJS.mode.CTRGladman = function() {
        var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();
        function incWord(word) {
          if ((word >> 24 & 255) === 255) {
            var b1 = word >> 16 & 255;
            var b22 = word >> 8 & 255;
            var b32 = word & 255;
            if (b1 === 255) {
              b1 = 0;
              if (b22 === 255) {
                b22 = 0;
                if (b32 === 255) {
                  b32 = 0;
                } else {
                  ++b32;
                }
              } else {
                ++b22;
              }
            } else {
              ++b1;
            }
            word = 0;
            word += b1 << 16;
            word += b22 << 8;
            word += b32;
          } else {
            word += 1 << 24;
          }
          return word;
        }
        function incCounter(counter) {
          if ((counter[0] = incWord(counter[0])) === 0) {
            counter[1] = incWord(counter[1]);
          }
          return counter;
        }
        var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
          processBlock: function(words2, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;
            if (iv) {
              counter = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            incCounter(counter);
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            for (var i6 = 0; i6 < blockSize; i6++) {
              words2[offset + i6] ^= keystream[i6];
            }
          }
        });
        CTRGladman.Decryptor = Encryptor;
        return CTRGladman;
      }();
      return CryptoJS.mode.CTRGladman;
    });
  }
});

// node_modules/crypto-js/mode-ofb.js
var require_mode_ofb = __commonJS({
  "node_modules/crypto-js/mode-ofb.js"(exports2, module2) {
    (function(root2, factory, undef) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS) {
      CryptoJS.mode.OFB = function() {
        var OFB = CryptoJS.lib.BlockCipherMode.extend();
        var Encryptor = OFB.Encryptor = OFB.extend({
          processBlock: function(words2, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var keystream = this._keystream;
            if (iv) {
              keystream = this._keystream = iv.slice(0);
              this._iv = void 0;
            }
            cipher.encryptBlock(keystream, 0);
            for (var i6 = 0; i6 < blockSize; i6++) {
              words2[offset + i6] ^= keystream[i6];
            }
          }
        });
        OFB.Decryptor = Encryptor;
        return OFB;
      }();
      return CryptoJS.mode.OFB;
    });
  }
});

// node_modules/crypto-js/mode-ecb.js
var require_mode_ecb = __commonJS({
  "node_modules/crypto-js/mode-ecb.js"(exports2, module2) {
    (function(root2, factory, undef) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS) {
      CryptoJS.mode.ECB = function() {
        var ECB = CryptoJS.lib.BlockCipherMode.extend();
        ECB.Encryptor = ECB.extend({
          processBlock: function(words2, offset) {
            this._cipher.encryptBlock(words2, offset);
          }
        });
        ECB.Decryptor = ECB.extend({
          processBlock: function(words2, offset) {
            this._cipher.decryptBlock(words2, offset);
          }
        });
        return ECB;
      }();
      return CryptoJS.mode.ECB;
    });
  }
});

// node_modules/crypto-js/pad-ansix923.js
var require_pad_ansix923 = __commonJS({
  "node_modules/crypto-js/pad-ansix923.js"(exports2, module2) {
    (function(root2, factory, undef) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS) {
      CryptoJS.pad.AnsiX923 = {
        pad: function(data, blockSize) {
          var dataSigBytes = data.sigBytes;
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;
          var lastBytePos = dataSigBytes + nPaddingBytes - 1;
          data.clamp();
          data.words[lastBytePos >>> 2] |= nPaddingBytes << 24 - lastBytePos % 4 * 8;
          data.sigBytes += nPaddingBytes;
        },
        unpad: function(data) {
          var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
          data.sigBytes -= nPaddingBytes;
        }
      };
      return CryptoJS.pad.Ansix923;
    });
  }
});

// node_modules/crypto-js/pad-iso10126.js
var require_pad_iso10126 = __commonJS({
  "node_modules/crypto-js/pad-iso10126.js"(exports2, module2) {
    (function(root2, factory, undef) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS) {
      CryptoJS.pad.Iso10126 = {
        pad: function(data, blockSize) {
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
          data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));
        },
        unpad: function(data) {
          var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
          data.sigBytes -= nPaddingBytes;
        }
      };
      return CryptoJS.pad.Iso10126;
    });
  }
});

// node_modules/crypto-js/pad-iso97971.js
var require_pad_iso97971 = __commonJS({
  "node_modules/crypto-js/pad-iso97971.js"(exports2, module2) {
    (function(root2, factory, undef) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS) {
      CryptoJS.pad.Iso97971 = {
        pad: function(data, blockSize) {
          data.concat(CryptoJS.lib.WordArray.create([2147483648], 1));
          CryptoJS.pad.ZeroPadding.pad(data, blockSize);
        },
        unpad: function(data) {
          CryptoJS.pad.ZeroPadding.unpad(data);
          data.sigBytes--;
        }
      };
      return CryptoJS.pad.Iso97971;
    });
  }
});

// node_modules/crypto-js/pad-zeropadding.js
var require_pad_zeropadding = __commonJS({
  "node_modules/crypto-js/pad-zeropadding.js"(exports2, module2) {
    (function(root2, factory, undef) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS) {
      CryptoJS.pad.ZeroPadding = {
        pad: function(data, blockSize) {
          var blockSizeBytes = blockSize * 4;
          data.clamp();
          data.sigBytes += blockSizeBytes - (data.sigBytes % blockSizeBytes || blockSizeBytes);
        },
        unpad: function(data) {
          var dataWords = data.words;
          var i6 = data.sigBytes - 1;
          while (!(dataWords[i6 >>> 2] >>> 24 - i6 % 4 * 8 & 255)) {
            i6--;
          }
          data.sigBytes = i6 + 1;
        }
      };
      return CryptoJS.pad.ZeroPadding;
    });
  }
});

// node_modules/crypto-js/pad-nopadding.js
var require_pad_nopadding = __commonJS({
  "node_modules/crypto-js/pad-nopadding.js"(exports2, module2) {
    (function(root2, factory, undef) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS) {
      CryptoJS.pad.NoPadding = {
        pad: function() {
        },
        unpad: function() {
        }
      };
      return CryptoJS.pad.NoPadding;
    });
  }
});

// node_modules/crypto-js/format-hex.js
var require_format_hex = __commonJS({
  "node_modules/crypto-js/format-hex.js"(exports2, module2) {
    (function(root2, factory, undef) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS) {
      (function(undefined2) {
        var C5 = CryptoJS;
        var C_lib = C5.lib;
        var CipherParams = C_lib.CipherParams;
        var C_enc = C5.enc;
        var Hex = C_enc.Hex;
        var C_format = C5.format;
        var HexFormatter = C_format.Hex = {
          stringify: function(cipherParams) {
            return cipherParams.ciphertext.toString(Hex);
          },
          parse: function(input) {
            var ciphertext = Hex.parse(input);
            return CipherParams.create({ ciphertext });
          }
        };
      })();
      return CryptoJS.format.Hex;
    });
  }
});

// node_modules/crypto-js/aes.js
var require_aes = __commonJS({
  "node_modules/crypto-js/aes.js"(exports2, module2) {
    (function(root2, factory, undef) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS) {
      (function() {
        var C5 = CryptoJS;
        var C_lib = C5.lib;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C5.algo;
        var SBOX = [];
        var INV_SBOX = [];
        var SUB_MIX_0 = [];
        var SUB_MIX_1 = [];
        var SUB_MIX_2 = [];
        var SUB_MIX_3 = [];
        var INV_SUB_MIX_0 = [];
        var INV_SUB_MIX_1 = [];
        var INV_SUB_MIX_2 = [];
        var INV_SUB_MIX_3 = [];
        (function() {
          var d6 = [];
          for (var i6 = 0; i6 < 256; i6++) {
            if (i6 < 128) {
              d6[i6] = i6 << 1;
            } else {
              d6[i6] = i6 << 1 ^ 283;
            }
          }
          var x6 = 0;
          var xi2 = 0;
          for (var i6 = 0; i6 < 256; i6++) {
            var sx = xi2 ^ xi2 << 1 ^ xi2 << 2 ^ xi2 << 3 ^ xi2 << 4;
            sx = sx >>> 8 ^ sx & 255 ^ 99;
            SBOX[x6] = sx;
            INV_SBOX[sx] = x6;
            var x22 = d6[x6];
            var x42 = d6[x22];
            var x8 = d6[x42];
            var t6 = d6[sx] * 257 ^ sx * 16843008;
            SUB_MIX_0[x6] = t6 << 24 | t6 >>> 8;
            SUB_MIX_1[x6] = t6 << 16 | t6 >>> 16;
            SUB_MIX_2[x6] = t6 << 8 | t6 >>> 24;
            SUB_MIX_3[x6] = t6;
            var t6 = x8 * 16843009 ^ x42 * 65537 ^ x22 * 257 ^ x6 * 16843008;
            INV_SUB_MIX_0[sx] = t6 << 24 | t6 >>> 8;
            INV_SUB_MIX_1[sx] = t6 << 16 | t6 >>> 16;
            INV_SUB_MIX_2[sx] = t6 << 8 | t6 >>> 24;
            INV_SUB_MIX_3[sx] = t6;
            if (!x6) {
              x6 = xi2 = 1;
            } else {
              x6 = x22 ^ d6[d6[d6[x8 ^ x22]]];
              xi2 ^= d6[d6[xi2]];
            }
          }
        })();
        var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
        var AES = C_algo.AES = BlockCipher.extend({
          _doReset: function() {
            if (this._nRounds && this._keyPriorReset === this._key) {
              return;
            }
            var key2 = this._keyPriorReset = this._key;
            var keyWords = key2.words;
            var keySize = key2.sigBytes / 4;
            var nRounds = this._nRounds = keySize + 6;
            var ksRows = (nRounds + 1) * 4;
            var keySchedule = this._keySchedule = [];
            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
              if (ksRow < keySize) {
                keySchedule[ksRow] = keyWords[ksRow];
              } else {
                var t6 = keySchedule[ksRow - 1];
                if (!(ksRow % keySize)) {
                  t6 = t6 << 8 | t6 >>> 24;
                  t6 = SBOX[t6 >>> 24] << 24 | SBOX[t6 >>> 16 & 255] << 16 | SBOX[t6 >>> 8 & 255] << 8 | SBOX[t6 & 255];
                  t6 ^= RCON[ksRow / keySize | 0] << 24;
                } else if (keySize > 6 && ksRow % keySize == 4) {
                  t6 = SBOX[t6 >>> 24] << 24 | SBOX[t6 >>> 16 & 255] << 16 | SBOX[t6 >>> 8 & 255] << 8 | SBOX[t6 & 255];
                }
                keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t6;
              }
            }
            var invKeySchedule = this._invKeySchedule = [];
            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
              var ksRow = ksRows - invKsRow;
              if (invKsRow % 4) {
                var t6 = keySchedule[ksRow];
              } else {
                var t6 = keySchedule[ksRow - 4];
              }
              if (invKsRow < 4 || ksRow <= 4) {
                invKeySchedule[invKsRow] = t6;
              } else {
                invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t6 >>> 24]] ^ INV_SUB_MIX_1[SBOX[t6 >>> 16 & 255]] ^ INV_SUB_MIX_2[SBOX[t6 >>> 8 & 255]] ^ INV_SUB_MIX_3[SBOX[t6 & 255]];
              }
            }
          },
          encryptBlock: function(M6, offset) {
            this._doCryptBlock(M6, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
          },
          decryptBlock: function(M6, offset) {
            var t6 = M6[offset + 1];
            M6[offset + 1] = M6[offset + 3];
            M6[offset + 3] = t6;
            this._doCryptBlock(M6, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
            var t6 = M6[offset + 1];
            M6[offset + 1] = M6[offset + 3];
            M6[offset + 3] = t6;
          },
          _doCryptBlock: function(M6, offset, keySchedule, SUB_MIX_02, SUB_MIX_12, SUB_MIX_22, SUB_MIX_32, SBOX2) {
            var nRounds = this._nRounds;
            var s02 = M6[offset] ^ keySchedule[0];
            var s1 = M6[offset + 1] ^ keySchedule[1];
            var s22 = M6[offset + 2] ^ keySchedule[2];
            var s32 = M6[offset + 3] ^ keySchedule[3];
            var ksRow = 4;
            for (var round = 1; round < nRounds; round++) {
              var t02 = SUB_MIX_02[s02 >>> 24] ^ SUB_MIX_12[s1 >>> 16 & 255] ^ SUB_MIX_22[s22 >>> 8 & 255] ^ SUB_MIX_32[s32 & 255] ^ keySchedule[ksRow++];
              var t12 = SUB_MIX_02[s1 >>> 24] ^ SUB_MIX_12[s22 >>> 16 & 255] ^ SUB_MIX_22[s32 >>> 8 & 255] ^ SUB_MIX_32[s02 & 255] ^ keySchedule[ksRow++];
              var t22 = SUB_MIX_02[s22 >>> 24] ^ SUB_MIX_12[s32 >>> 16 & 255] ^ SUB_MIX_22[s02 >>> 8 & 255] ^ SUB_MIX_32[s1 & 255] ^ keySchedule[ksRow++];
              var t32 = SUB_MIX_02[s32 >>> 24] ^ SUB_MIX_12[s02 >>> 16 & 255] ^ SUB_MIX_22[s1 >>> 8 & 255] ^ SUB_MIX_32[s22 & 255] ^ keySchedule[ksRow++];
              s02 = t02;
              s1 = t12;
              s22 = t22;
              s32 = t32;
            }
            var t02 = (SBOX2[s02 >>> 24] << 24 | SBOX2[s1 >>> 16 & 255] << 16 | SBOX2[s22 >>> 8 & 255] << 8 | SBOX2[s32 & 255]) ^ keySchedule[ksRow++];
            var t12 = (SBOX2[s1 >>> 24] << 24 | SBOX2[s22 >>> 16 & 255] << 16 | SBOX2[s32 >>> 8 & 255] << 8 | SBOX2[s02 & 255]) ^ keySchedule[ksRow++];
            var t22 = (SBOX2[s22 >>> 24] << 24 | SBOX2[s32 >>> 16 & 255] << 16 | SBOX2[s02 >>> 8 & 255] << 8 | SBOX2[s1 & 255]) ^ keySchedule[ksRow++];
            var t32 = (SBOX2[s32 >>> 24] << 24 | SBOX2[s02 >>> 16 & 255] << 16 | SBOX2[s1 >>> 8 & 255] << 8 | SBOX2[s22 & 255]) ^ keySchedule[ksRow++];
            M6[offset] = t02;
            M6[offset + 1] = t12;
            M6[offset + 2] = t22;
            M6[offset + 3] = t32;
          },
          keySize: 256 / 32
        });
        C5.AES = BlockCipher._createHelper(AES);
      })();
      return CryptoJS.AES;
    });
  }
});

// node_modules/crypto-js/tripledes.js
var require_tripledes = __commonJS({
  "node_modules/crypto-js/tripledes.js"(exports2, module2) {
    (function(root2, factory, undef) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS) {
      (function() {
        var C5 = CryptoJS;
        var C_lib = C5.lib;
        var WordArray = C_lib.WordArray;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C5.algo;
        var PC1 = [
          57,
          49,
          41,
          33,
          25,
          17,
          9,
          1,
          58,
          50,
          42,
          34,
          26,
          18,
          10,
          2,
          59,
          51,
          43,
          35,
          27,
          19,
          11,
          3,
          60,
          52,
          44,
          36,
          63,
          55,
          47,
          39,
          31,
          23,
          15,
          7,
          62,
          54,
          46,
          38,
          30,
          22,
          14,
          6,
          61,
          53,
          45,
          37,
          29,
          21,
          13,
          5,
          28,
          20,
          12,
          4
        ];
        var PC2 = [
          14,
          17,
          11,
          24,
          1,
          5,
          3,
          28,
          15,
          6,
          21,
          10,
          23,
          19,
          12,
          4,
          26,
          8,
          16,
          7,
          27,
          20,
          13,
          2,
          41,
          52,
          31,
          37,
          47,
          55,
          30,
          40,
          51,
          45,
          33,
          48,
          44,
          49,
          39,
          56,
          34,
          53,
          46,
          42,
          50,
          36,
          29,
          32
        ];
        var BIT_SHIFTS = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];
        var SBOX_P = [
          {
            0: 8421888,
            268435456: 32768,
            536870912: 8421378,
            805306368: 2,
            1073741824: 512,
            1342177280: 8421890,
            1610612736: 8389122,
            1879048192: 8388608,
            2147483648: 514,
            2415919104: 8389120,
            2684354560: 33280,
            2952790016: 8421376,
            3221225472: 32770,
            3489660928: 8388610,
            3758096384: 0,
            4026531840: 33282,
            134217728: 0,
            402653184: 8421890,
            671088640: 33282,
            939524096: 32768,
            1207959552: 8421888,
            1476395008: 512,
            1744830464: 8421378,
            2013265920: 2,
            2281701376: 8389120,
            2550136832: 33280,
            2818572288: 8421376,
            3087007744: 8389122,
            3355443200: 8388610,
            3623878656: 32770,
            3892314112: 514,
            4160749568: 8388608,
            1: 32768,
            268435457: 2,
            536870913: 8421888,
            805306369: 8388608,
            1073741825: 8421378,
            1342177281: 33280,
            1610612737: 512,
            1879048193: 8389122,
            2147483649: 8421890,
            2415919105: 8421376,
            2684354561: 8388610,
            2952790017: 33282,
            3221225473: 514,
            3489660929: 8389120,
            3758096385: 32770,
            4026531841: 0,
            134217729: 8421890,
            402653185: 8421376,
            671088641: 8388608,
            939524097: 512,
            1207959553: 32768,
            1476395009: 8388610,
            1744830465: 2,
            2013265921: 33282,
            2281701377: 32770,
            2550136833: 8389122,
            2818572289: 514,
            3087007745: 8421888,
            3355443201: 8389120,
            3623878657: 0,
            3892314113: 33280,
            4160749569: 8421378
          },
          {
            0: 1074282512,
            16777216: 16384,
            33554432: 524288,
            50331648: 1074266128,
            67108864: 1073741840,
            83886080: 1074282496,
            100663296: 1073758208,
            117440512: 16,
            134217728: 540672,
            150994944: 1073758224,
            167772160: 1073741824,
            184549376: 540688,
            201326592: 524304,
            218103808: 0,
            234881024: 16400,
            251658240: 1074266112,
            8388608: 1073758208,
            25165824: 540688,
            41943040: 16,
            58720256: 1073758224,
            75497472: 1074282512,
            92274688: 1073741824,
            109051904: 524288,
            125829120: 1074266128,
            142606336: 524304,
            159383552: 0,
            176160768: 16384,
            192937984: 1074266112,
            209715200: 1073741840,
            226492416: 540672,
            243269632: 1074282496,
            260046848: 16400,
            268435456: 0,
            285212672: 1074266128,
            301989888: 1073758224,
            318767104: 1074282496,
            335544320: 1074266112,
            352321536: 16,
            369098752: 540688,
            385875968: 16384,
            402653184: 16400,
            419430400: 524288,
            436207616: 524304,
            452984832: 1073741840,
            469762048: 540672,
            486539264: 1073758208,
            503316480: 1073741824,
            520093696: 1074282512,
            276824064: 540688,
            293601280: 524288,
            310378496: 1074266112,
            327155712: 16384,
            343932928: 1073758208,
            360710144: 1074282512,
            377487360: 16,
            394264576: 1073741824,
            411041792: 1074282496,
            427819008: 1073741840,
            444596224: 1073758224,
            461373440: 524304,
            478150656: 0,
            494927872: 16400,
            511705088: 1074266128,
            528482304: 540672
          },
          {
            0: 260,
            1048576: 0,
            2097152: 67109120,
            3145728: 65796,
            4194304: 65540,
            5242880: 67108868,
            6291456: 67174660,
            7340032: 67174400,
            8388608: 67108864,
            9437184: 67174656,
            10485760: 65792,
            11534336: 67174404,
            12582912: 67109124,
            13631488: 65536,
            14680064: 4,
            15728640: 256,
            524288: 67174656,
            1572864: 67174404,
            2621440: 0,
            3670016: 67109120,
            4718592: 67108868,
            5767168: 65536,
            6815744: 65540,
            7864320: 260,
            8912896: 4,
            9961472: 256,
            11010048: 67174400,
            12058624: 65796,
            13107200: 65792,
            14155776: 67109124,
            15204352: 67174660,
            16252928: 67108864,
            16777216: 67174656,
            17825792: 65540,
            18874368: 65536,
            19922944: 67109120,
            20971520: 256,
            22020096: 67174660,
            23068672: 67108868,
            24117248: 0,
            25165824: 67109124,
            26214400: 67108864,
            27262976: 4,
            28311552: 65792,
            29360128: 67174400,
            30408704: 260,
            31457280: 65796,
            32505856: 67174404,
            17301504: 67108864,
            18350080: 260,
            19398656: 67174656,
            20447232: 0,
            21495808: 65540,
            22544384: 67109120,
            23592960: 256,
            24641536: 67174404,
            25690112: 65536,
            26738688: 67174660,
            27787264: 65796,
            28835840: 67108868,
            29884416: 67109124,
            30932992: 67174400,
            31981568: 4,
            33030144: 65792
          },
          {
            0: 2151682048,
            65536: 2147487808,
            131072: 4198464,
            196608: 2151677952,
            262144: 0,
            327680: 4198400,
            393216: 2147483712,
            458752: 4194368,
            524288: 2147483648,
            589824: 4194304,
            655360: 64,
            720896: 2147487744,
            786432: 2151678016,
            851968: 4160,
            917504: 4096,
            983040: 2151682112,
            32768: 2147487808,
            98304: 64,
            163840: 2151678016,
            229376: 2147487744,
            294912: 4198400,
            360448: 2151682112,
            425984: 0,
            491520: 2151677952,
            557056: 4096,
            622592: 2151682048,
            688128: 4194304,
            753664: 4160,
            819200: 2147483648,
            884736: 4194368,
            950272: 4198464,
            1015808: 2147483712,
            1048576: 4194368,
            1114112: 4198400,
            1179648: 2147483712,
            1245184: 0,
            1310720: 4160,
            1376256: 2151678016,
            1441792: 2151682048,
            1507328: 2147487808,
            1572864: 2151682112,
            1638400: 2147483648,
            1703936: 2151677952,
            1769472: 4198464,
            1835008: 2147487744,
            1900544: 4194304,
            1966080: 64,
            2031616: 4096,
            1081344: 2151677952,
            1146880: 2151682112,
            1212416: 0,
            1277952: 4198400,
            1343488: 4194368,
            1409024: 2147483648,
            1474560: 2147487808,
            1540096: 64,
            1605632: 2147483712,
            1671168: 4096,
            1736704: 2147487744,
            1802240: 2151678016,
            1867776: 4160,
            1933312: 2151682048,
            1998848: 4194304,
            2064384: 4198464
          },
          {
            0: 128,
            4096: 17039360,
            8192: 262144,
            12288: 536870912,
            16384: 537133184,
            20480: 16777344,
            24576: 553648256,
            28672: 262272,
            32768: 16777216,
            36864: 537133056,
            40960: 536871040,
            45056: 553910400,
            49152: 553910272,
            53248: 0,
            57344: 17039488,
            61440: 553648128,
            2048: 17039488,
            6144: 553648256,
            10240: 128,
            14336: 17039360,
            18432: 262144,
            22528: 537133184,
            26624: 553910272,
            30720: 536870912,
            34816: 537133056,
            38912: 0,
            43008: 553910400,
            47104: 16777344,
            51200: 536871040,
            55296: 553648128,
            59392: 16777216,
            63488: 262272,
            65536: 262144,
            69632: 128,
            73728: 536870912,
            77824: 553648256,
            81920: 16777344,
            86016: 553910272,
            90112: 537133184,
            94208: 16777216,
            98304: 553910400,
            102400: 553648128,
            106496: 17039360,
            110592: 537133056,
            114688: 262272,
            118784: 536871040,
            122880: 0,
            126976: 17039488,
            67584: 553648256,
            71680: 16777216,
            75776: 17039360,
            79872: 537133184,
            83968: 536870912,
            88064: 17039488,
            92160: 128,
            96256: 553910272,
            100352: 262272,
            104448: 553910400,
            108544: 0,
            112640: 553648128,
            116736: 16777344,
            120832: 262144,
            124928: 537133056,
            129024: 536871040
          },
          {
            0: 268435464,
            256: 8192,
            512: 270532608,
            768: 270540808,
            1024: 268443648,
            1280: 2097152,
            1536: 2097160,
            1792: 268435456,
            2048: 0,
            2304: 268443656,
            2560: 2105344,
            2816: 8,
            3072: 270532616,
            3328: 2105352,
            3584: 8200,
            3840: 270540800,
            128: 270532608,
            384: 270540808,
            640: 8,
            896: 2097152,
            1152: 2105352,
            1408: 268435464,
            1664: 268443648,
            1920: 8200,
            2176: 2097160,
            2432: 8192,
            2688: 268443656,
            2944: 270532616,
            3200: 0,
            3456: 270540800,
            3712: 2105344,
            3968: 268435456,
            4096: 268443648,
            4352: 270532616,
            4608: 270540808,
            4864: 8200,
            5120: 2097152,
            5376: 268435456,
            5632: 268435464,
            5888: 2105344,
            6144: 2105352,
            6400: 0,
            6656: 8,
            6912: 270532608,
            7168: 8192,
            7424: 268443656,
            7680: 270540800,
            7936: 2097160,
            4224: 8,
            4480: 2105344,
            4736: 2097152,
            4992: 268435464,
            5248: 268443648,
            5504: 8200,
            5760: 270540808,
            6016: 270532608,
            6272: 270540800,
            6528: 270532616,
            6784: 8192,
            7040: 2105352,
            7296: 2097160,
            7552: 0,
            7808: 268435456,
            8064: 268443656
          },
          {
            0: 1048576,
            16: 33555457,
            32: 1024,
            48: 1049601,
            64: 34604033,
            80: 0,
            96: 1,
            112: 34603009,
            128: 33555456,
            144: 1048577,
            160: 33554433,
            176: 34604032,
            192: 34603008,
            208: 1025,
            224: 1049600,
            240: 33554432,
            8: 34603009,
            24: 0,
            40: 33555457,
            56: 34604032,
            72: 1048576,
            88: 33554433,
            104: 33554432,
            120: 1025,
            136: 1049601,
            152: 33555456,
            168: 34603008,
            184: 1048577,
            200: 1024,
            216: 34604033,
            232: 1,
            248: 1049600,
            256: 33554432,
            272: 1048576,
            288: 33555457,
            304: 34603009,
            320: 1048577,
            336: 33555456,
            352: 34604032,
            368: 1049601,
            384: 1025,
            400: 34604033,
            416: 1049600,
            432: 1,
            448: 0,
            464: 34603008,
            480: 33554433,
            496: 1024,
            264: 1049600,
            280: 33555457,
            296: 34603009,
            312: 1,
            328: 33554432,
            344: 1048576,
            360: 1025,
            376: 34604032,
            392: 33554433,
            408: 34603008,
            424: 0,
            440: 34604033,
            456: 1049601,
            472: 1024,
            488: 33555456,
            504: 1048577
          },
          {
            0: 134219808,
            1: 131072,
            2: 134217728,
            3: 32,
            4: 131104,
            5: 134350880,
            6: 134350848,
            7: 2048,
            8: 134348800,
            9: 134219776,
            10: 133120,
            11: 134348832,
            12: 2080,
            13: 0,
            14: 134217760,
            15: 133152,
            2147483648: 2048,
            2147483649: 134350880,
            2147483650: 134219808,
            2147483651: 134217728,
            2147483652: 134348800,
            2147483653: 133120,
            2147483654: 133152,
            2147483655: 32,
            2147483656: 134217760,
            2147483657: 2080,
            2147483658: 131104,
            2147483659: 134350848,
            2147483660: 0,
            2147483661: 134348832,
            2147483662: 134219776,
            2147483663: 131072,
            16: 133152,
            17: 134350848,
            18: 32,
            19: 2048,
            20: 134219776,
            21: 134217760,
            22: 134348832,
            23: 131072,
            24: 0,
            25: 131104,
            26: 134348800,
            27: 134219808,
            28: 134350880,
            29: 133120,
            30: 2080,
            31: 134217728,
            2147483664: 131072,
            2147483665: 2048,
            2147483666: 134348832,
            2147483667: 133152,
            2147483668: 32,
            2147483669: 134348800,
            2147483670: 134217728,
            2147483671: 134219808,
            2147483672: 134350880,
            2147483673: 134217760,
            2147483674: 134219776,
            2147483675: 0,
            2147483676: 133120,
            2147483677: 2080,
            2147483678: 131104,
            2147483679: 134350848
          }
        ];
        var SBOX_MASK = [
          4160749569,
          528482304,
          33030144,
          2064384,
          129024,
          8064,
          504,
          2147483679
        ];
        var DES = C_algo.DES = BlockCipher.extend({
          _doReset: function() {
            var key2 = this._key;
            var keyWords = key2.words;
            var keyBits = [];
            for (var i6 = 0; i6 < 56; i6++) {
              var keyBitPos = PC1[i6] - 1;
              keyBits[i6] = keyWords[keyBitPos >>> 5] >>> 31 - keyBitPos % 32 & 1;
            }
            var subKeys = this._subKeys = [];
            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
              var subKey = subKeys[nSubKey] = [];
              var bitShift = BIT_SHIFTS[nSubKey];
              for (var i6 = 0; i6 < 24; i6++) {
                subKey[i6 / 6 | 0] |= keyBits[(PC2[i6] - 1 + bitShift) % 28] << 31 - i6 % 6;
                subKey[4 + (i6 / 6 | 0)] |= keyBits[28 + (PC2[i6 + 24] - 1 + bitShift) % 28] << 31 - i6 % 6;
              }
              subKey[0] = subKey[0] << 1 | subKey[0] >>> 31;
              for (var i6 = 1; i6 < 7; i6++) {
                subKey[i6] = subKey[i6] >>> (i6 - 1) * 4 + 3;
              }
              subKey[7] = subKey[7] << 5 | subKey[7] >>> 27;
            }
            var invSubKeys = this._invSubKeys = [];
            for (var i6 = 0; i6 < 16; i6++) {
              invSubKeys[i6] = subKeys[15 - i6];
            }
          },
          encryptBlock: function(M6, offset) {
            this._doCryptBlock(M6, offset, this._subKeys);
          },
          decryptBlock: function(M6, offset) {
            this._doCryptBlock(M6, offset, this._invSubKeys);
          },
          _doCryptBlock: function(M6, offset, subKeys) {
            this._lBlock = M6[offset];
            this._rBlock = M6[offset + 1];
            exchangeLR.call(this, 4, 252645135);
            exchangeLR.call(this, 16, 65535);
            exchangeRL.call(this, 2, 858993459);
            exchangeRL.call(this, 8, 16711935);
            exchangeLR.call(this, 1, 1431655765);
            for (var round = 0; round < 16; round++) {
              var subKey = subKeys[round];
              var lBlock = this._lBlock;
              var rBlock = this._rBlock;
              var f7 = 0;
              for (var i6 = 0; i6 < 8; i6++) {
                f7 |= SBOX_P[i6][((rBlock ^ subKey[i6]) & SBOX_MASK[i6]) >>> 0];
              }
              this._lBlock = rBlock;
              this._rBlock = lBlock ^ f7;
            }
            var t6 = this._lBlock;
            this._lBlock = this._rBlock;
            this._rBlock = t6;
            exchangeLR.call(this, 1, 1431655765);
            exchangeRL.call(this, 8, 16711935);
            exchangeRL.call(this, 2, 858993459);
            exchangeLR.call(this, 16, 65535);
            exchangeLR.call(this, 4, 252645135);
            M6[offset] = this._lBlock;
            M6[offset + 1] = this._rBlock;
          },
          keySize: 64 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        function exchangeLR(offset, mask) {
          var t6 = (this._lBlock >>> offset ^ this._rBlock) & mask;
          this._rBlock ^= t6;
          this._lBlock ^= t6 << offset;
        }
        function exchangeRL(offset, mask) {
          var t6 = (this._rBlock >>> offset ^ this._lBlock) & mask;
          this._lBlock ^= t6;
          this._rBlock ^= t6 << offset;
        }
        C5.DES = BlockCipher._createHelper(DES);
        var TripleDES = C_algo.TripleDES = BlockCipher.extend({
          _doReset: function() {
            var key2 = this._key;
            var keyWords = key2.words;
            this._des1 = DES.createEncryptor(WordArray.create(keyWords.slice(0, 2)));
            this._des2 = DES.createEncryptor(WordArray.create(keyWords.slice(2, 4)));
            this._des3 = DES.createEncryptor(WordArray.create(keyWords.slice(4, 6)));
          },
          encryptBlock: function(M6, offset) {
            this._des1.encryptBlock(M6, offset);
            this._des2.decryptBlock(M6, offset);
            this._des3.encryptBlock(M6, offset);
          },
          decryptBlock: function(M6, offset) {
            this._des3.decryptBlock(M6, offset);
            this._des2.encryptBlock(M6, offset);
            this._des1.decryptBlock(M6, offset);
          },
          keySize: 192 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        C5.TripleDES = BlockCipher._createHelper(TripleDES);
      })();
      return CryptoJS.TripleDES;
    });
  }
});

// node_modules/crypto-js/rc4.js
var require_rc4 = __commonJS({
  "node_modules/crypto-js/rc4.js"(exports2, module2) {
    (function(root2, factory, undef) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS) {
      (function() {
        var C5 = CryptoJS;
        var C_lib = C5.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C5.algo;
        var RC4 = C_algo.RC4 = StreamCipher.extend({
          _doReset: function() {
            var key2 = this._key;
            var keyWords = key2.words;
            var keySigBytes = key2.sigBytes;
            var S5 = this._S = [];
            for (var i6 = 0; i6 < 256; i6++) {
              S5[i6] = i6;
            }
            for (var i6 = 0, j8 = 0; i6 < 256; i6++) {
              var keyByteIndex = i6 % keySigBytes;
              var keyByte = keyWords[keyByteIndex >>> 2] >>> 24 - keyByteIndex % 4 * 8 & 255;
              j8 = (j8 + S5[i6] + keyByte) % 256;
              var t6 = S5[i6];
              S5[i6] = S5[j8];
              S5[j8] = t6;
            }
            this._i = this._j = 0;
          },
          _doProcessBlock: function(M6, offset) {
            M6[offset] ^= generateKeystreamWord.call(this);
          },
          keySize: 256 / 32,
          ivSize: 0
        });
        function generateKeystreamWord() {
          var S5 = this._S;
          var i6 = this._i;
          var j8 = this._j;
          var keystreamWord = 0;
          for (var n4 = 0; n4 < 4; n4++) {
            i6 = (i6 + 1) % 256;
            j8 = (j8 + S5[i6]) % 256;
            var t6 = S5[i6];
            S5[i6] = S5[j8];
            S5[j8] = t6;
            keystreamWord |= S5[(S5[i6] + S5[j8]) % 256] << 24 - n4 * 8;
          }
          this._i = i6;
          this._j = j8;
          return keystreamWord;
        }
        C5.RC4 = StreamCipher._createHelper(RC4);
        var RC4Drop = C_algo.RC4Drop = RC4.extend({
          cfg: RC4.cfg.extend({
            drop: 192
          }),
          _doReset: function() {
            RC4._doReset.call(this);
            for (var i6 = this.cfg.drop; i6 > 0; i6--) {
              generateKeystreamWord.call(this);
            }
          }
        });
        C5.RC4Drop = StreamCipher._createHelper(RC4Drop);
      })();
      return CryptoJS.RC4;
    });
  }
});

// node_modules/crypto-js/rabbit.js
var require_rabbit = __commonJS({
  "node_modules/crypto-js/rabbit.js"(exports2, module2) {
    (function(root2, factory, undef) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS) {
      (function() {
        var C5 = CryptoJS;
        var C_lib = C5.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C5.algo;
        var S5 = [];
        var C_ = [];
        var G3 = [];
        var Rabbit = C_algo.Rabbit = StreamCipher.extend({
          _doReset: function() {
            var K5 = this._key.words;
            var iv = this.cfg.iv;
            for (var i6 = 0; i6 < 4; i6++) {
              K5[i6] = (K5[i6] << 8 | K5[i6] >>> 24) & 16711935 | (K5[i6] << 24 | K5[i6] >>> 8) & 4278255360;
            }
            var X3 = this._X = [
              K5[0],
              K5[3] << 16 | K5[2] >>> 16,
              K5[1],
              K5[0] << 16 | K5[3] >>> 16,
              K5[2],
              K5[1] << 16 | K5[0] >>> 16,
              K5[3],
              K5[2] << 16 | K5[1] >>> 16
            ];
            var C6 = this._C = [
              K5[2] << 16 | K5[2] >>> 16,
              K5[0] & 4294901760 | K5[1] & 65535,
              K5[3] << 16 | K5[3] >>> 16,
              K5[1] & 4294901760 | K5[2] & 65535,
              K5[0] << 16 | K5[0] >>> 16,
              K5[2] & 4294901760 | K5[3] & 65535,
              K5[1] << 16 | K5[1] >>> 16,
              K5[3] & 4294901760 | K5[0] & 65535
            ];
            this._b = 0;
            for (var i6 = 0; i6 < 4; i6++) {
              nextState.call(this);
            }
            for (var i6 = 0; i6 < 8; i6++) {
              C6[i6] ^= X3[i6 + 4 & 7];
            }
            if (iv) {
              var IV = iv.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i02 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
              var i22 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
              var i1 = i02 >>> 16 | i22 & 4294901760;
              var i32 = i22 << 16 | i02 & 65535;
              C6[0] ^= i02;
              C6[1] ^= i1;
              C6[2] ^= i22;
              C6[3] ^= i32;
              C6[4] ^= i02;
              C6[5] ^= i1;
              C6[6] ^= i22;
              C6[7] ^= i32;
              for (var i6 = 0; i6 < 4; i6++) {
                nextState.call(this);
              }
            }
          },
          _doProcessBlock: function(M6, offset) {
            var X3 = this._X;
            nextState.call(this);
            S5[0] = X3[0] ^ X3[5] >>> 16 ^ X3[3] << 16;
            S5[1] = X3[2] ^ X3[7] >>> 16 ^ X3[5] << 16;
            S5[2] = X3[4] ^ X3[1] >>> 16 ^ X3[7] << 16;
            S5[3] = X3[6] ^ X3[3] >>> 16 ^ X3[1] << 16;
            for (var i6 = 0; i6 < 4; i6++) {
              S5[i6] = (S5[i6] << 8 | S5[i6] >>> 24) & 16711935 | (S5[i6] << 24 | S5[i6] >>> 8) & 4278255360;
              M6[offset + i6] ^= S5[i6];
            }
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function nextState() {
          var X3 = this._X;
          var C6 = this._C;
          for (var i6 = 0; i6 < 8; i6++) {
            C_[i6] = C6[i6];
          }
          C6[0] = C6[0] + 1295307597 + this._b | 0;
          C6[1] = C6[1] + 3545052371 + (C6[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C6[2] = C6[2] + 886263092 + (C6[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C6[3] = C6[3] + 1295307597 + (C6[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C6[4] = C6[4] + 3545052371 + (C6[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C6[5] = C6[5] + 886263092 + (C6[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C6[6] = C6[6] + 1295307597 + (C6[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C6[7] = C6[7] + 3545052371 + (C6[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C6[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i6 = 0; i6 < 8; i6++) {
            var gx = X3[i6] + C6[i6];
            var ga2 = gx & 65535;
            var gb = gx >>> 16;
            var gh = ((ga2 * ga2 >>> 17) + ga2 * gb >>> 15) + gb * gb;
            var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
            G3[i6] = gh ^ gl;
          }
          X3[0] = G3[0] + (G3[7] << 16 | G3[7] >>> 16) + (G3[6] << 16 | G3[6] >>> 16) | 0;
          X3[1] = G3[1] + (G3[0] << 8 | G3[0] >>> 24) + G3[7] | 0;
          X3[2] = G3[2] + (G3[1] << 16 | G3[1] >>> 16) + (G3[0] << 16 | G3[0] >>> 16) | 0;
          X3[3] = G3[3] + (G3[2] << 8 | G3[2] >>> 24) + G3[1] | 0;
          X3[4] = G3[4] + (G3[3] << 16 | G3[3] >>> 16) + (G3[2] << 16 | G3[2] >>> 16) | 0;
          X3[5] = G3[5] + (G3[4] << 8 | G3[4] >>> 24) + G3[3] | 0;
          X3[6] = G3[6] + (G3[5] << 16 | G3[5] >>> 16) + (G3[4] << 16 | G3[4] >>> 16) | 0;
          X3[7] = G3[7] + (G3[6] << 8 | G3[6] >>> 24) + G3[5] | 0;
        }
        C5.Rabbit = StreamCipher._createHelper(Rabbit);
      })();
      return CryptoJS.Rabbit;
    });
  }
});

// node_modules/crypto-js/rabbit-legacy.js
var require_rabbit_legacy = __commonJS({
  "node_modules/crypto-js/rabbit-legacy.js"(exports2, module2) {
    (function(root2, factory, undef) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS) {
      (function() {
        var C5 = CryptoJS;
        var C_lib = C5.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C5.algo;
        var S5 = [];
        var C_ = [];
        var G3 = [];
        var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
          _doReset: function() {
            var K5 = this._key.words;
            var iv = this.cfg.iv;
            var X3 = this._X = [
              K5[0],
              K5[3] << 16 | K5[2] >>> 16,
              K5[1],
              K5[0] << 16 | K5[3] >>> 16,
              K5[2],
              K5[1] << 16 | K5[0] >>> 16,
              K5[3],
              K5[2] << 16 | K5[1] >>> 16
            ];
            var C6 = this._C = [
              K5[2] << 16 | K5[2] >>> 16,
              K5[0] & 4294901760 | K5[1] & 65535,
              K5[3] << 16 | K5[3] >>> 16,
              K5[1] & 4294901760 | K5[2] & 65535,
              K5[0] << 16 | K5[0] >>> 16,
              K5[2] & 4294901760 | K5[3] & 65535,
              K5[1] << 16 | K5[1] >>> 16,
              K5[3] & 4294901760 | K5[0] & 65535
            ];
            this._b = 0;
            for (var i6 = 0; i6 < 4; i6++) {
              nextState.call(this);
            }
            for (var i6 = 0; i6 < 8; i6++) {
              C6[i6] ^= X3[i6 + 4 & 7];
            }
            if (iv) {
              var IV = iv.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i02 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
              var i22 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
              var i1 = i02 >>> 16 | i22 & 4294901760;
              var i32 = i22 << 16 | i02 & 65535;
              C6[0] ^= i02;
              C6[1] ^= i1;
              C6[2] ^= i22;
              C6[3] ^= i32;
              C6[4] ^= i02;
              C6[5] ^= i1;
              C6[6] ^= i22;
              C6[7] ^= i32;
              for (var i6 = 0; i6 < 4; i6++) {
                nextState.call(this);
              }
            }
          },
          _doProcessBlock: function(M6, offset) {
            var X3 = this._X;
            nextState.call(this);
            S5[0] = X3[0] ^ X3[5] >>> 16 ^ X3[3] << 16;
            S5[1] = X3[2] ^ X3[7] >>> 16 ^ X3[5] << 16;
            S5[2] = X3[4] ^ X3[1] >>> 16 ^ X3[7] << 16;
            S5[3] = X3[6] ^ X3[3] >>> 16 ^ X3[1] << 16;
            for (var i6 = 0; i6 < 4; i6++) {
              S5[i6] = (S5[i6] << 8 | S5[i6] >>> 24) & 16711935 | (S5[i6] << 24 | S5[i6] >>> 8) & 4278255360;
              M6[offset + i6] ^= S5[i6];
            }
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function nextState() {
          var X3 = this._X;
          var C6 = this._C;
          for (var i6 = 0; i6 < 8; i6++) {
            C_[i6] = C6[i6];
          }
          C6[0] = C6[0] + 1295307597 + this._b | 0;
          C6[1] = C6[1] + 3545052371 + (C6[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C6[2] = C6[2] + 886263092 + (C6[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C6[3] = C6[3] + 1295307597 + (C6[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C6[4] = C6[4] + 3545052371 + (C6[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C6[5] = C6[5] + 886263092 + (C6[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C6[6] = C6[6] + 1295307597 + (C6[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C6[7] = C6[7] + 3545052371 + (C6[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C6[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i6 = 0; i6 < 8; i6++) {
            var gx = X3[i6] + C6[i6];
            var ga2 = gx & 65535;
            var gb = gx >>> 16;
            var gh = ((ga2 * ga2 >>> 17) + ga2 * gb >>> 15) + gb * gb;
            var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
            G3[i6] = gh ^ gl;
          }
          X3[0] = G3[0] + (G3[7] << 16 | G3[7] >>> 16) + (G3[6] << 16 | G3[6] >>> 16) | 0;
          X3[1] = G3[1] + (G3[0] << 8 | G3[0] >>> 24) + G3[7] | 0;
          X3[2] = G3[2] + (G3[1] << 16 | G3[1] >>> 16) + (G3[0] << 16 | G3[0] >>> 16) | 0;
          X3[3] = G3[3] + (G3[2] << 8 | G3[2] >>> 24) + G3[1] | 0;
          X3[4] = G3[4] + (G3[3] << 16 | G3[3] >>> 16) + (G3[2] << 16 | G3[2] >>> 16) | 0;
          X3[5] = G3[5] + (G3[4] << 8 | G3[4] >>> 24) + G3[3] | 0;
          X3[6] = G3[6] + (G3[5] << 16 | G3[5] >>> 16) + (G3[4] << 16 | G3[4] >>> 16) | 0;
          X3[7] = G3[7] + (G3[6] << 8 | G3[6] >>> 24) + G3[5] | 0;
        }
        C5.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
      })();
      return CryptoJS.RabbitLegacy;
    });
  }
});

// node_modules/crypto-js/index.js
var require_crypto_js = __commonJS({
  "node_modules/crypto-js/index.js"(exports2, module2) {
    (function(root2, factory, undef) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core(), require_x64_core(), require_lib_typedarrays(), require_enc_utf16(), require_enc_base64(), require_md5(), require_sha1(), require_sha256(), require_sha224(), require_sha512(), require_sha384(), require_sha32(), require_ripemd160(), require_hmac2(), require_pbkdf2(), require_evpkdf(), require_cipher_core(), require_mode_cfb(), require_mode_ctr(), require_mode_ctr_gladman(), require_mode_ofb(), require_mode_ecb(), require_pad_ansix923(), require_pad_iso10126(), require_pad_iso97971(), require_pad_zeropadding(), require_pad_nopadding(), require_format_hex(), require_aes(), require_tripledes(), require_rc4(), require_rabbit(), require_rabbit_legacy());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core", "./lib-typedarrays", "./enc-utf16", "./enc-base64", "./md5", "./sha1", "./sha256", "./sha224", "./sha512", "./sha384", "./sha3", "./ripemd160", "./hmac", "./pbkdf2", "./evpkdf", "./cipher-core", "./mode-cfb", "./mode-ctr", "./mode-ctr-gladman", "./mode-ofb", "./mode-ecb", "./pad-ansix923", "./pad-iso10126", "./pad-iso97971", "./pad-zeropadding", "./pad-nopadding", "./format-hex", "./aes", "./tripledes", "./rc4", "./rabbit", "./rabbit-legacy"], factory);
      } else {
        root2.CryptoJS = factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS) {
      return CryptoJS;
    });
  }
});

// node_modules/merkletreejs/dist/Base.js
var require_Base = __commonJS({
  "node_modules/merkletreejs/dist/Base.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Base = void 0;
    var crypto_js_1 = __importDefault(require_crypto_js());
    var Base = class {
      print() {
        Base.print(this);
      }
      _bufferIndexOf(array, element) {
        for (let i6 = 0; i6 < array.length; i6++) {
          if (element.equals(array[i6])) {
            return i6;
          }
        }
        return -1;
      }
      static bufferify(value2) {
        if (!Buffer.isBuffer(value2)) {
          if (typeof value2 === "object" && value2.words) {
            return Buffer.from(value2.toString(crypto_js_1.default.enc.Hex), "hex");
          } else if (Base.isHexString(value2)) {
            return Buffer.from(value2.replace(/^0x/, ""), "hex");
          } else if (typeof value2 === "string") {
            return Buffer.from(value2);
          } else if (typeof value2 === "number") {
            let s6 = value2.toString();
            if (s6.length % 2) {
              s6 = `0${s6}`;
            }
            return Buffer.from(s6, "hex");
          } else if (ArrayBuffer.isView(value2)) {
            return Buffer.from(value2.buffer, value2.byteOffset, value2.byteLength);
          }
        }
        return value2;
      }
      static isHexString(v9) {
        return typeof v9 === "string" && /^(0x)?[0-9A-Fa-f]*$/.test(v9);
      }
      static print(tree) {
        console.log(tree.toString());
      }
      bufferToHex(value2, withPrefix = true) {
        return Base.bufferToHex(value2, withPrefix);
      }
      static bufferToHex(value2, withPrefix = true) {
        return `${withPrefix ? "0x" : ""}${(value2 || Buffer.alloc(0)).toString("hex")}`;
      }
      bufferify(value2) {
        return Base.bufferify(value2);
      }
      bufferifyFn(f7) {
        return (value2) => {
          const v9 = f7(value2);
          if (Buffer.isBuffer(v9)) {
            return v9;
          }
          if (this._isHexString(v9)) {
            return Buffer.from(v9.replace("0x", ""), "hex");
          }
          if (typeof v9 === "string") {
            return Buffer.from(v9);
          }
          if (ArrayBuffer.isView(v9)) {
            return Buffer.from(v9.buffer, v9.byteOffset, v9.byteLength);
          }
          return Buffer.from(f7(crypto_js_1.default.enc.Hex.parse(value2.toString("hex"))).toString(crypto_js_1.default.enc.Hex), "hex");
        };
      }
      _isHexString(value2) {
        return Base.isHexString(value2);
      }
      _log2(n4) {
        return n4 === 1 ? 0 : 1 + this._log2(n4 / 2 | 0);
      }
      _zip(a5, b4) {
        return a5.map((e6, i6) => [e6, b4[i6]]);
      }
    };
    exports2.Base = Base;
    exports2.default = Base;
  }
});

// node_modules/treeify/treeify.js
var require_treeify = __commonJS({
  "node_modules/treeify/treeify.js"(exports2, module2) {
    (function(root2, factory) {
      if (typeof exports2 === "object") {
        module2.exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define(factory);
      } else {
        root2.treeify = factory();
      }
    })(exports2, function() {
      function makePrefix(key2, last2) {
        var str = last2 ? "\u2514" : "\u251C";
        if (key2) {
          str += "\u2500 ";
        } else {
          str += "\u2500\u2500\u2510";
        }
        return str;
      }
      function filterKeys(obj, hideFunctions) {
        var keys = [];
        for (var branch in obj) {
          if (!obj.hasOwnProperty(branch)) {
            continue;
          }
          if (hideFunctions && typeof obj[branch] === "function") {
            continue;
          }
          keys.push(branch);
        }
        return keys;
      }
      function growBranch(key2, root2, last2, lastStates, showValues, hideFunctions, callback) {
        var line = "", index = 0, lastKey, circular, lastStatesCopy = lastStates.slice(0);
        if (lastStatesCopy.push([root2, last2]) && lastStates.length > 0) {
          lastStates.forEach(function(lastState, idx) {
            if (idx > 0) {
              line += (lastState[1] ? " " : "\u2502") + "  ";
            }
            if (!circular && lastState[0] === root2) {
              circular = true;
            }
          });
          line += makePrefix(key2, last2) + key2;
          showValues && (typeof root2 !== "object" || root2 instanceof Date) && (line += ": " + root2);
          circular && (line += " (circular ref.)");
          callback(line);
        }
        if (!circular && typeof root2 === "object") {
          var keys = filterKeys(root2, hideFunctions);
          keys.forEach(function(branch) {
            lastKey = ++index === keys.length;
            growBranch(branch, root2[branch], lastKey, lastStatesCopy, showValues, hideFunctions, callback);
          });
        }
      }
      ;
      var Treeify = {};
      Treeify.asLines = function(obj, showValues, hideFunctions, lineCallback) {
        var hideFunctionsArg = typeof hideFunctions !== "function" ? hideFunctions : false;
        growBranch(".", obj, false, [], showValues, hideFunctionsArg, lineCallback || hideFunctions);
      };
      Treeify.asTree = function(obj, showValues, hideFunctions) {
        var tree = "";
        growBranch(".", obj, false, [], showValues, hideFunctions, function(line) {
          tree += line + "\n";
        });
        return tree;
      };
      return Treeify;
    });
  }
});

// node_modules/merkletreejs/dist/MerkleTree.js
var require_MerkleTree = __commonJS({
  "node_modules/merkletreejs/dist/MerkleTree.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MerkleTree = void 0;
    var buffer_reverse_1 = __importDefault(require_buffer_reverse());
    var sha256_1 = __importDefault(require_sha256());
    var Base_1 = __importDefault(require_Base());
    var treeify_1 = __importDefault(require_treeify());
    var MerkleTree = class extends Base_1.default {
      constructor(leaves, hashFn = sha256_1.default, options = {}) {
        super();
        this.duplicateOdd = false;
        this.hashLeaves = false;
        this.isBitcoinTree = false;
        this.leaves = [];
        this.layers = [];
        this.sortLeaves = false;
        this.sortPairs = false;
        this.sort = false;
        this.fillDefaultHash = null;
        this.isBitcoinTree = !!options.isBitcoinTree;
        this.hashLeaves = !!options.hashLeaves;
        this.sortLeaves = !!options.sortLeaves;
        this.sortPairs = !!options.sortPairs;
        if (options.fillDefaultHash) {
          if (typeof options.fillDefaultHash === "function") {
            this.fillDefaultHash = options.fillDefaultHash;
          } else if (Buffer.isBuffer(options.fillDefaultHash) || typeof options.fillDefaultHash === "string") {
            this.fillDefaultHash = (idx, hashFn2) => options.fillDefaultHash;
          } else {
            throw new Error('method "fillDefaultHash" must be a function, Buffer, or string');
          }
        }
        this.sort = !!options.sort;
        if (this.sort) {
          this.sortLeaves = true;
          this.sortPairs = true;
        }
        this.duplicateOdd = !!options.duplicateOdd;
        this.hashFn = this.bufferifyFn(hashFn);
        this.processLeaves(leaves);
      }
      processLeaves(leaves) {
        if (this.hashLeaves) {
          leaves = leaves.map(this.hashFn);
        }
        this.leaves = leaves.map(this.bufferify);
        if (this.sortLeaves) {
          this.leaves = this.leaves.sort(Buffer.compare);
        }
        if (this.fillDefaultHash) {
          for (let i6 = 0; i6 < Math.pow(2, Math.ceil(Math.log2(this.leaves.length))); i6++) {
            if (i6 >= this.leaves.length) {
              this.leaves.push(this.bufferify(this.fillDefaultHash(i6, this.hashFn)));
            }
          }
        }
        this.layers = [this.leaves];
        this._createHashes(this.leaves);
      }
      _createHashes(nodes) {
        while (nodes.length > 1) {
          const layerIndex = this.layers.length;
          this.layers.push([]);
          for (let i6 = 0; i6 < nodes.length; i6 += 2) {
            if (i6 + 1 === nodes.length) {
              if (nodes.length % 2 === 1) {
                let data2 = nodes[nodes.length - 1];
                let hash4 = data2;
                if (this.isBitcoinTree) {
                  data2 = Buffer.concat([buffer_reverse_1.default(data2), buffer_reverse_1.default(data2)]);
                  hash4 = this.hashFn(data2);
                  hash4 = buffer_reverse_1.default(this.hashFn(hash4));
                  this.layers[layerIndex].push(hash4);
                  continue;
                } else {
                  if (this.duplicateOdd) {
                  } else {
                    this.layers[layerIndex].push(nodes[i6]);
                    continue;
                  }
                }
              }
            }
            const left = nodes[i6];
            const right = i6 + 1 === nodes.length ? left : nodes[i6 + 1];
            let data = null;
            let combined = null;
            if (this.isBitcoinTree) {
              combined = [buffer_reverse_1.default(left), buffer_reverse_1.default(right)];
            } else {
              combined = [left, right];
            }
            if (this.sortPairs) {
              combined.sort(Buffer.compare);
            }
            data = Buffer.concat(combined);
            let hash3 = this.hashFn(data);
            if (this.isBitcoinTree) {
              hash3 = buffer_reverse_1.default(this.hashFn(hash3));
            }
            this.layers[layerIndex].push(hash3);
          }
          nodes = this.layers[layerIndex];
        }
      }
      addLeaf(leaf, shouldHash = false) {
        if (shouldHash) {
          leaf = this.hashFn(leaf);
        }
        this.processLeaves(this.leaves.concat(leaf));
      }
      addLeaves(leaves, shouldHash = false) {
        if (shouldHash) {
          leaves = leaves.map(this.hashFn);
        }
        this.processLeaves(this.leaves.concat(leaves));
      }
      getLeaves(values) {
        if (Array.isArray(values)) {
          if (this.hashLeaves) {
            values = values.map(this.hashFn);
            if (this.sortLeaves) {
              values = values.sort(Buffer.compare);
            }
          }
          return this.leaves.filter((leaf) => this._bufferIndexOf(values, leaf) !== -1);
        }
        return this.leaves;
      }
      getLeaf(index) {
        if (index < 0 || index > this.leaves.length - 1) {
          return Buffer.from([]);
        }
        return this.leaves[index];
      }
      getLeafIndex(target) {
        target = this.bufferify(target);
        const leaves = this.getLeaves();
        for (let i6 = 0; i6 < leaves.length; i6++) {
          const leaf = leaves[i6];
          if (leaf.equals(target)) {
            return i6;
          }
        }
        return -1;
      }
      getLeafCount() {
        return this.leaves.length;
      }
      getHexLeaves() {
        return this.leaves.map((leaf) => this.bufferToHex(leaf));
      }
      static marshalLeaves(leaves) {
        return JSON.stringify(leaves.map((leaf) => MerkleTree.bufferToHex(leaf)), null, 2);
      }
      static unmarshalLeaves(jsonStr) {
        let parsed = null;
        if (typeof jsonStr === "string") {
          parsed = JSON.parse(jsonStr);
        } else if (jsonStr instanceof Object) {
          parsed = jsonStr;
        } else {
          throw new Error("Expected type of string or object");
        }
        if (!parsed) {
          return [];
        }
        if (!Array.isArray(parsed)) {
          throw new Error("Expected JSON string to be array");
        }
        return parsed.map(MerkleTree.bufferify);
      }
      getLayers() {
        return this.layers;
      }
      getHexLayers() {
        return this.layers.reduce((acc, item) => {
          if (Array.isArray(item)) {
            acc.push(item.map((layer) => this.bufferToHex(layer)));
          } else {
            acc.push(item);
          }
          return acc;
        }, []);
      }
      getLayersFlat() {
        const layers = this.layers.reduce((acc, item) => {
          if (Array.isArray(item)) {
            acc.unshift(...item);
          } else {
            acc.unshift(item);
          }
          return acc;
        }, []);
        layers.unshift(Buffer.from([0]));
        return layers;
      }
      getHexLayersFlat() {
        return this.getLayersFlat().map((layer) => this.bufferToHex(layer));
      }
      getLayerCount() {
        return this.getLayers().length;
      }
      getRoot() {
        if (this.layers.length === 0) {
          return Buffer.from([]);
        }
        return this.layers[this.layers.length - 1][0] || Buffer.from([]);
      }
      getHexRoot() {
        return this.bufferToHex(this.getRoot());
      }
      getProof(leaf, index) {
        if (typeof leaf === "undefined") {
          throw new Error("leaf is required");
        }
        leaf = this.bufferify(leaf);
        const proof = [];
        if (!Number.isInteger(index)) {
          index = -1;
          for (let i6 = 0; i6 < this.leaves.length; i6++) {
            if (Buffer.compare(leaf, this.leaves[i6]) === 0) {
              index = i6;
            }
          }
        }
        if (index <= -1) {
          return [];
        }
        for (let i6 = 0; i6 < this.layers.length; i6++) {
          const layer = this.layers[i6];
          const isRightNode = index % 2;
          const pairIndex = isRightNode ? index - 1 : this.isBitcoinTree && index === layer.length - 1 && i6 < this.layers.length - 1 ? index : index + 1;
          if (pairIndex < layer.length) {
            proof.push({
              position: isRightNode ? "left" : "right",
              data: layer[pairIndex]
            });
          }
          index = index / 2 | 0;
        }
        return proof;
      }
      getHexProof(leaf, index) {
        return this.getProof(leaf, index).map((item) => this.bufferToHex(item.data));
      }
      getPositionalHexProof(leaf, index) {
        return this.getProof(leaf, index).map((item) => {
          return [
            item.position === "left" ? 0 : 1,
            this.bufferToHex(item.data)
          ];
        });
      }
      static marshalProof(proof) {
        const json = proof.map((item) => {
          if (typeof item === "string") {
            return item;
          }
          if (Buffer.isBuffer(item)) {
            return MerkleTree.bufferToHex(item);
          }
          return {
            position: item.position,
            data: MerkleTree.bufferToHex(item.data)
          };
        });
        return JSON.stringify(json, null, 2);
      }
      static unmarshalProof(jsonStr) {
        let parsed = null;
        if (typeof jsonStr === "string") {
          parsed = JSON.parse(jsonStr);
        } else if (jsonStr instanceof Object) {
          parsed = jsonStr;
        } else {
          throw new Error("Expected type of string or object");
        }
        if (!parsed) {
          return [];
        }
        if (!Array.isArray(parsed)) {
          throw new Error("Expected JSON string to be array");
        }
        return parsed.map((item) => {
          if (typeof item === "string") {
            return MerkleTree.bufferify(item);
          } else if (item instanceof Object) {
            return {
              position: item.position,
              data: MerkleTree.bufferify(item.data)
            };
          } else {
            throw new Error("Expected item to be of type string or object");
          }
        });
      }
      getProofIndices(treeIndices, depth) {
        const leafCount = Math.pow(2, depth);
        let maximalIndices = /* @__PURE__ */ new Set();
        for (const index of treeIndices) {
          let x6 = leafCount + index;
          while (x6 > 1) {
            maximalIndices.add(x6 ^ 1);
            x6 = x6 / 2 | 0;
          }
        }
        const a5 = treeIndices.map((index) => leafCount + index);
        const b4 = Array.from(maximalIndices).sort((a6, b5) => a6 - b5).reverse();
        maximalIndices = a5.concat(b4);
        const redundantIndices = /* @__PURE__ */ new Set();
        const proof = [];
        for (let index of maximalIndices) {
          if (!redundantIndices.has(index)) {
            proof.push(index);
            while (index > 1) {
              redundantIndices.add(index);
              if (!redundantIndices.has(index ^ 1))
                break;
              index = index / 2 | 0;
            }
          }
        }
        return proof.filter((index) => {
          return !treeIndices.includes(index - leafCount);
        });
      }
      getProofIndicesForUnevenTree(sortedLeafIndices, leavesCount) {
        const depth = Math.ceil(Math.log2(leavesCount));
        const unevenLayers = [];
        for (let index = 0; index < depth; index++) {
          const unevenLayer = leavesCount % 2 !== 0;
          if (unevenLayer) {
            unevenLayers.push({ index, leavesCount });
          }
          leavesCount = Math.ceil(leavesCount / 2);
        }
        const proofIndices = [];
        let layerNodes = sortedLeafIndices;
        for (let layerIndex = 0; layerIndex < depth; layerIndex++) {
          const siblingIndices = layerNodes.map((index) => {
            if (index % 2 === 0) {
              return index + 1;
            }
            return index - 1;
          });
          let proofNodeIndices = siblingIndices.filter((index) => !layerNodes.includes(index));
          const unevenLayer = unevenLayers.find(({ index }) => index === layerIndex);
          if (unevenLayer && layerNodes.includes(unevenLayer.leavesCount - 1)) {
            proofNodeIndices = proofNodeIndices.slice(0, -1);
          }
          proofIndices.push(proofNodeIndices);
          layerNodes = [...new Set(layerNodes.map((index) => {
            if (index % 2 === 0) {
              return index / 2;
            }
            if (index % 2 === 0) {
              return (index + 1) / 2;
            }
            return (index - 1) / 2;
          }))];
        }
        return proofIndices;
      }
      getMultiProof(tree, indices) {
        if (!indices) {
          indices = tree;
          tree = this.getLayersFlat();
        }
        const isUneven = this.isUnevenTree();
        if (isUneven) {
          if (indices.every(Number.isInteger)) {
            return this.getMultiProofForUnevenTree(indices);
          }
        }
        if (!indices.every(Number.isInteger)) {
          let els = indices;
          if (this.sortPairs) {
            els = els.sort(Buffer.compare);
          }
          let ids = els.map((el) => this._bufferIndexOf(this.leaves, el)).sort((a5, b4) => a5 === b4 ? 0 : a5 > b4 ? 1 : -1);
          if (!ids.every((idx) => idx !== -1)) {
            throw new Error("Element does not exist in Merkle tree");
          }
          const hashes = [];
          const proof = [];
          let nextIds = [];
          for (let i6 = 0; i6 < this.layers.length; i6++) {
            const layer = this.layers[i6];
            for (let j8 = 0; j8 < ids.length; j8++) {
              const idx = ids[j8];
              const pairElement = this._getPairNode(layer, idx);
              hashes.push(layer[idx]);
              if (pairElement) {
                proof.push(pairElement);
              }
              nextIds.push(idx / 2 | 0);
            }
            ids = nextIds.filter((value2, i7, self2) => self2.indexOf(value2) === i7);
            nextIds = [];
          }
          return proof.filter((value2) => !hashes.includes(value2));
        }
        return this.getProofIndices(indices, this._log2(tree.length / 2 | 0)).map((index) => tree[index]);
      }
      getMultiProofForUnevenTree(tree, indices) {
        if (!indices) {
          indices = tree;
          tree = this.getLayers();
        }
        let proofHashes = [];
        let currentLayerIndices = indices;
        for (const treeLayer of tree) {
          const siblings = [];
          for (const index of currentLayerIndices) {
            if (index % 2 === 0) {
              const idx2 = index + 1;
              if (!currentLayerIndices.includes(idx2)) {
                if (treeLayer[idx2]) {
                  siblings.push(treeLayer[idx2]);
                  continue;
                }
              }
            }
            const idx = index - 1;
            if (!currentLayerIndices.includes(idx)) {
              if (treeLayer[idx]) {
                siblings.push(treeLayer[idx]);
                continue;
              }
            }
          }
          proofHashes = proofHashes.concat(siblings);
          const uniqueIndices = /* @__PURE__ */ new Set();
          for (const index of currentLayerIndices) {
            if (index % 2 === 0) {
              uniqueIndices.add(index / 2);
              continue;
            }
            if (index % 2 === 0) {
              uniqueIndices.add((index + 1) / 2);
              continue;
            }
            uniqueIndices.add((index - 1) / 2);
          }
          currentLayerIndices = Array.from(uniqueIndices);
        }
        return proofHashes;
      }
      getHexMultiProof(tree, indices) {
        return this.getMultiProof(tree, indices).map((x6) => this.bufferToHex(x6));
      }
      getProofFlags(leaves, proofs) {
        if (!Array.isArray(leaves) || leaves.length <= 0) {
          throw new Error("Invalid Inputs!");
        }
        let ids;
        if (leaves.every(Number.isInteger)) {
          ids = leaves.sort((a5, b4) => a5 === b4 ? 0 : a5 > b4 ? 1 : -1);
        } else {
          ids = leaves.map((el) => this._bufferIndexOf(this.leaves, el)).sort((a5, b4) => a5 === b4 ? 0 : a5 > b4 ? 1 : -1);
        }
        if (!ids.every((idx) => idx !== -1)) {
          throw new Error("Element does not exist in Merkle tree");
        }
        const _proofs = proofs.map((item) => this.bufferify(item));
        const tested = [];
        const flags = [];
        for (let index = 0; index < this.layers.length; index++) {
          const layer = this.layers[index];
          ids = ids.reduce((ids2, idx) => {
            const skipped = tested.includes(layer[idx]);
            if (!skipped) {
              const pairElement = this._getPairNode(layer, idx);
              const proofUsed = _proofs.includes(layer[idx]) || _proofs.includes(pairElement);
              pairElement && flags.push(!proofUsed);
              tested.push(layer[idx]);
              tested.push(pairElement);
            }
            ids2.push(idx / 2 | 0);
            return ids2;
          }, []);
        }
        return flags;
      }
      verify(proof, targetNode, root2) {
        let hash3 = this.bufferify(targetNode);
        root2 = this.bufferify(root2);
        if (!Array.isArray(proof) || !targetNode || !root2) {
          return false;
        }
        for (let i6 = 0; i6 < proof.length; i6++) {
          const node = proof[i6];
          let data = null;
          let isLeftNode = null;
          if (typeof node === "string") {
            data = this.bufferify(node);
            isLeftNode = true;
          } else if (Array.isArray(node)) {
            isLeftNode = node[0] === 0;
            data = this.bufferify(node[1]);
          } else if (Buffer.isBuffer(node)) {
            data = node;
            isLeftNode = true;
          } else if (node instanceof Object) {
            data = this.bufferify(node.data);
            isLeftNode = node.position === "left";
          } else {
            throw new Error("Expected node to be of type string or object");
          }
          const buffers = [];
          if (this.isBitcoinTree) {
            buffers.push(buffer_reverse_1.default(hash3));
            buffers[isLeftNode ? "unshift" : "push"](buffer_reverse_1.default(data));
            hash3 = this.hashFn(Buffer.concat(buffers));
            hash3 = buffer_reverse_1.default(this.hashFn(hash3));
          } else {
            if (this.sortPairs) {
              if (Buffer.compare(hash3, data) === -1) {
                buffers.push(hash3, data);
                hash3 = this.hashFn(Buffer.concat(buffers));
              } else {
                buffers.push(data, hash3);
                hash3 = this.hashFn(Buffer.concat(buffers));
              }
            } else {
              buffers.push(hash3);
              buffers[isLeftNode ? "unshift" : "push"](data);
              hash3 = this.hashFn(Buffer.concat(buffers));
            }
          }
        }
        return Buffer.compare(hash3, root2) === 0;
      }
      verifyMultiProof(root2, proofIndices, proofLeaves, leavesCount, proof) {
        const isUneven = this.isUnevenTree();
        if (isUneven) {
          return this.verifyMultiProofForUnevenTree(root2, proofIndices, proofLeaves, leavesCount, proof);
        }
        const depth = Math.ceil(Math.log2(leavesCount));
        root2 = this.bufferify(root2);
        proofLeaves = proofLeaves.map((leaf) => this.bufferify(leaf));
        proof = proof.map((leaf) => this.bufferify(leaf));
        const tree = {};
        for (const [index, leaf] of this._zip(proofIndices, proofLeaves)) {
          tree[Math.pow(2, depth) + index] = leaf;
        }
        for (const [index, proofitem] of this._zip(this.getProofIndices(proofIndices, depth), proof)) {
          tree[index] = proofitem;
        }
        let indexqueue = Object.keys(tree).map((value2) => +value2).sort((a5, b4) => a5 - b4);
        indexqueue = indexqueue.slice(0, indexqueue.length - 1);
        let i6 = 0;
        while (i6 < indexqueue.length) {
          const index = indexqueue[i6];
          if (index >= 2 && {}.hasOwnProperty.call(tree, index ^ 1)) {
            let pair = [tree[index - index % 2], tree[index - index % 2 + 1]];
            if (this.sortPairs) {
              pair = pair.sort(Buffer.compare);
            }
            const hash3 = pair[1] ? this.hashFn(Buffer.concat(pair)) : pair[0];
            tree[index / 2 | 0] = hash3;
            indexqueue.push(index / 2 | 0);
          }
          i6 += 1;
        }
        return !proofIndices.length || {}.hasOwnProperty.call(tree, 1) && tree[1].equals(root2);
      }
      verifyMultiProofWithFlags(root2, leaves, proofs, proofFlag) {
        root2 = this.bufferify(root2);
        leaves = leaves.map(this.bufferify);
        proofs = proofs.map(this.bufferify);
        const leavesLen = leaves.length;
        const totalHashes = proofFlag.length;
        const hashes = [];
        let leafPos = 0;
        let hashPos = 0;
        let proofPos = 0;
        for (let i6 = 0; i6 < totalHashes; i6++) {
          const bufA = proofFlag[i6] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proofs[proofPos++];
          const bufB = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];
          const buffers = [bufA, bufB].sort(Buffer.compare);
          hashes[i6] = this.hashFn(Buffer.concat(buffers));
        }
        return Buffer.compare(hashes[totalHashes - 1], root2) === 0;
      }
      verifyMultiProofForUnevenTree(root2, indices, leaves, leavesCount, proof) {
        root2 = this.bufferify(root2);
        leaves = leaves.map((leaf) => this.bufferify(leaf));
        proof = proof.map((leaf) => this.bufferify(leaf));
        const computedRoot = this.calculateRootForUnevenTree(indices, leaves, leavesCount, proof);
        return root2.equals(computedRoot);
      }
      getDepth() {
        return this.getLayers().length - 1;
      }
      getLayersAsObject() {
        const layers = this.getLayers().map((layer) => layer.map((value2) => this.bufferToHex(value2, false)));
        const objs = [];
        for (let i6 = 0; i6 < layers.length; i6++) {
          const arr = [];
          for (let j8 = 0; j8 < layers[i6].length; j8++) {
            const obj = { [layers[i6][j8]]: null };
            if (objs.length) {
              obj[layers[i6][j8]] = {};
              const a5 = objs.shift();
              const akey = Object.keys(a5)[0];
              obj[layers[i6][j8]][akey] = a5[akey];
              if (objs.length) {
                const b4 = objs.shift();
                const bkey = Object.keys(b4)[0];
                obj[layers[i6][j8]][bkey] = b4[bkey];
              }
            }
            arr.push(obj);
          }
          objs.push(...arr);
        }
        return objs[0];
      }
      static verify(proof, targetNode, root2, hashFn = sha256_1.default, options = {}) {
        const tree = new MerkleTree([], hashFn, options);
        return tree.verify(proof, targetNode, root2);
      }
      static getMultiProof(tree, indices) {
        const t6 = new MerkleTree([]);
        return t6.getMultiProof(tree, indices);
      }
      resetTree() {
        this.leaves = [];
        this.layers = [];
      }
      _getPairNode(layer, idx) {
        const pairIdx = idx % 2 === 0 ? idx + 1 : idx - 1;
        if (pairIdx < layer.length) {
          return layer[pairIdx];
        } else {
          return null;
        }
      }
      _toTreeString() {
        const obj = this.getLayersAsObject();
        return treeify_1.default.asTree(obj, true);
      }
      toString() {
        return this._toTreeString();
      }
      isUnevenTree(treeLayers) {
        const depth = (treeLayers === null || treeLayers === void 0 ? void 0 : treeLayers.length) || this.getDepth();
        return !this.isPowOf2(depth);
      }
      isPowOf2(v9) {
        return v9 && !(v9 & v9 - 1);
      }
      calculateRootForUnevenTree(leafIndices, leafHashes, totalLeavesCount, proofHashes) {
        const leafTuples = this._zip(leafIndices, leafHashes).sort(([indexA], [indexB]) => indexA - indexB);
        const leafTupleIndices = leafTuples.map(([index]) => index);
        const proofIndices = this.getProofIndicesForUnevenTree(leafTupleIndices, totalLeavesCount);
        let nextSliceStart = 0;
        const proofTuplesByLayers = [];
        for (let i6 = 0; i6 < proofIndices.length; i6++) {
          const indices = proofIndices[i6];
          const sliceStart = nextSliceStart;
          nextSliceStart += indices.length;
          proofTuplesByLayers[i6] = this._zip(indices, proofHashes.slice(sliceStart, nextSliceStart));
        }
        const tree = [leafTuples];
        for (let layerIndex = 0; layerIndex < proofTuplesByLayers.length; layerIndex++) {
          const currentLayer = proofTuplesByLayers[layerIndex].concat(tree[layerIndex]).sort(([indexA], [indexB]) => indexA - indexB).map(([, hash3]) => hash3);
          const s6 = tree[layerIndex].map(([layerIndex2]) => layerIndex2);
          const parentIndices = [...new Set(s6.map((index) => {
            if (index % 2 === 0) {
              return index / 2;
            }
            if (index % 2 === 0) {
              return (index + 1) / 2;
            }
            return (index - 1) / 2;
          }))];
          const parentLayer = [];
          for (let i6 = 0; i6 < parentIndices.length; i6++) {
            const parentNodeTreeIndex = parentIndices[i6];
            const bufA = currentLayer[i6 * 2];
            const bufB = currentLayer[i6 * 2 + 1];
            const hash3 = bufB ? this.hashFn(Buffer.concat([bufA, bufB])) : bufA;
            parentLayer.push([parentNodeTreeIndex, hash3]);
          }
          tree.push(parentLayer);
        }
        return tree[tree.length - 1][0][1];
      }
    };
    exports2.MerkleTree = MerkleTree;
    if (typeof window !== "undefined") {
      ;
      window.MerkleTree = MerkleTree;
    }
    exports2.default = MerkleTree;
  }
});

// node_modules/merkletreejs/dist/MerkleMountainRange.js
var require_MerkleMountainRange = __commonJS({
  "node_modules/merkletreejs/dist/MerkleMountainRange.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MerkleMountainRange = void 0;
    var Base_1 = __importDefault(require_Base());
    var sha256_1 = __importDefault(require_sha256());
    var MerkleMountainRange = class extends Base_1.default {
      constructor(hashFn = sha256_1.default, leaves = [], hashLeafFn, peakBaggingFn, hashBranchFn) {
        super();
        this.root = Buffer.alloc(0);
        this.size = 0;
        this.width = 0;
        this.hashes = {};
        this.data = {};
        leaves = leaves.map(this.bufferify);
        this.hashFn = this.bufferifyFn(hashFn);
        this.hashLeafFn = hashLeafFn;
        this.peakBaggingFn = peakBaggingFn;
        this.hashBranchFn = hashBranchFn;
        for (const leaf of leaves) {
          this.append(leaf);
        }
      }
      append(data) {
        data = this.bufferify(data);
        const dataHash = this.hashFn(data);
        const dataHashHex = this.bufferToHex(dataHash);
        if (!this.data[dataHashHex] || this.bufferToHex(this.hashFn(this.data[dataHashHex])) !== dataHashHex) {
          this.data[dataHashHex] = data;
        }
        const leaf = this.hashLeaf(this.size + 1, dataHash);
        this.hashes[this.size + 1] = leaf;
        this.width += 1;
        const peakIndexes = this.getPeakIndexes(this.width);
        this.size = this.getSize(this.width);
        const peaks = [];
        for (let i6 = 0; i6 < peakIndexes.length; i6++) {
          peaks[i6] = this._getOrCreateNode(peakIndexes[i6]);
        }
        this.root = this.peakBagging(this.width, peaks);
      }
      hashLeaf(index, dataHash) {
        dataHash = this.bufferify(dataHash);
        if (this.hashLeafFn) {
          return this.bufferify(this.hashLeafFn(index, dataHash));
        }
        return this.hashFn(Buffer.concat([this.bufferify(index), dataHash]));
      }
      hashBranch(index, left, right) {
        if (this.hashBranchFn) {
          return this.bufferify(this.hashBranchFn(index, left, right));
        }
        return this.hashFn(Buffer.concat([this.bufferify(index), this.bufferify(left), this.bufferify(right)]));
      }
      getPeaks() {
        const peakIndexes = this.getPeakIndexes(this.width);
        const peaks = [];
        for (let i6 = 0; i6 < peakIndexes.length; i6++) {
          peaks[i6] = this.hashes[peakIndexes[i6]];
        }
        return peaks;
      }
      getLeafIndex(width) {
        if (width % 2 === 1) {
          return this.getSize(width);
        }
        return this.getSize(width - 1) + 1;
      }
      getPeakIndexes(width) {
        const numPeaks = this.numOfPeaks(width);
        const peakIndexes = [];
        let count2 = 0;
        let size = 0;
        for (let i6 = 255; i6 > 0; i6--) {
          if ((width & 1 << i6 - 1) !== 0) {
            size = size + (1 << i6) - 1;
            peakIndexes[count2++] = size;
            if (peakIndexes.length >= numPeaks) {
              break;
            }
          }
        }
        if (count2 !== peakIndexes.length) {
          throw new Error("invalid bit calculation");
        }
        return peakIndexes;
      }
      numOfPeaks(width) {
        let bits = width;
        let num = 0;
        while (bits > 0) {
          if (bits % 2 === 1) {
            num++;
          }
          bits = bits >> 1;
        }
        return num;
      }
      peakBagging(width, peaks) {
        const size = this.getSize(width);
        if (this.numOfPeaks(width) !== peaks.length) {
          throw new Error("received invalid number of peaks");
        }
        if (width === 0 && !peaks.length) {
          return Buffer.alloc(0);
        }
        if (this.peakBaggingFn) {
          return this.bufferify(this.peakBaggingFn(size, peaks));
        }
        return this.hashFn(Buffer.concat([this.bufferify(size), ...peaks.map(this.bufferify)]));
      }
      getSize(width) {
        return (width << 1) - this.numOfPeaks(width);
      }
      getRoot() {
        return this.root;
      }
      getHexRoot() {
        return this.bufferToHex(this.getRoot());
      }
      getNode(index) {
        return this.hashes[index];
      }
      mountainHeight(size) {
        let height = 1;
        while (1 << height <= size + height) {
          height++;
        }
        return height - 1;
      }
      heightAt(index) {
        let reducedIndex = index;
        let peakIndex = 0;
        let height = 0;
        while (reducedIndex > peakIndex) {
          reducedIndex -= (1 << height) - 1;
          height = this.mountainHeight(reducedIndex);
          peakIndex = (1 << height) - 1;
        }
        return height - (peakIndex - reducedIndex);
      }
      isLeaf(index) {
        return this.heightAt(index) === 1;
      }
      getChildren(index) {
        const left = index - (1 << this.heightAt(index) - 1);
        const right = index - 1;
        if (left === right) {
          throw new Error("not a parent");
        }
        return [left, right];
      }
      getMerkleProof(index) {
        if (index > this.size) {
          throw new Error("out of range");
        }
        if (!this.isLeaf(index)) {
          throw new Error("not a leaf");
        }
        const root2 = this.root;
        const width = this.width;
        const peaks = this.getPeakIndexes(this.width);
        const peakBagging = [];
        let cursor = 0;
        for (let i6 = 0; i6 < peaks.length; i6++) {
          peakBagging[i6] = this.hashes[peaks[i6]];
          if (peaks[i6] >= index && cursor === 0) {
            cursor = peaks[i6];
          }
        }
        let left = 0;
        let right = 0;
        let height = this.heightAt(cursor);
        const siblings = [];
        while (cursor !== index) {
          height--;
          [left, right] = this.getChildren(cursor);
          cursor = index <= left ? left : right;
          siblings[height - 1] = this.hashes[index <= left ? right : left];
        }
        return {
          root: root2,
          width,
          peakBagging,
          siblings
        };
      }
      verify(root2, width, index, value2, peaks, siblings) {
        value2 = this.bufferify(value2);
        const size = this.getSize(width);
        if (size < index) {
          throw new Error("index is out of range");
        }
        if (!root2.equals(this.peakBagging(width, peaks))) {
          throw new Error("invalid root hash from the peaks");
        }
        let cursor = 0;
        let targetPeak;
        const peakIndexes = this.getPeakIndexes(width);
        for (let i6 = 0; i6 < peakIndexes.length; i6++) {
          if (peakIndexes[i6] >= index) {
            targetPeak = peaks[i6];
            cursor = peakIndexes[i6];
            break;
          }
        }
        if (!targetPeak) {
          throw new Error("target not found");
        }
        let height = siblings.length + 1;
        const path = new Array(height);
        let left = 0;
        let right = 0;
        while (height > 0) {
          path[--height] = cursor;
          if (cursor === index) {
            break;
          } else {
            [left, right] = this.getChildren(cursor);
            cursor = index > left ? right : left;
            continue;
          }
        }
        let node;
        while (height < path.length) {
          cursor = path[height];
          if (height === 0) {
            node = this.hashLeaf(cursor, this.hashFn(value2));
          } else if (cursor - 1 === path[height - 1]) {
            node = this.hashBranch(cursor, siblings[height - 1], node);
          } else {
            node = this.hashBranch(cursor, node, siblings[height - 1]);
          }
          height++;
        }
        if (!node.equals(targetPeak)) {
          throw new Error("hashed peak is invalid");
        }
        return true;
      }
      peaksToPeakMap(width, peaks) {
        const peakMap = {};
        let bitIndex = 0;
        let peakRef = 0;
        let count2 = peaks.length;
        for (let height = 1; height <= 32; height++) {
          bitIndex = 32 - height;
          peakRef = 1 << height - 1;
          if ((width & peakRef) !== 0) {
            peakMap[bitIndex] = peaks[--count2];
          } else {
            peakMap[bitIndex] = 0;
          }
        }
        if (count2 !== 0) {
          throw new Error("invalid number of peaks");
        }
        return peakMap;
      }
      peakMapToPeaks(width, peakMap) {
        const arrLength = this.numOfPeaks(width);
        const peaks = new Array(arrLength);
        let count2 = 0;
        for (let i6 = 0; i6 < 32; i6++) {
          if (peakMap[i6] !== 0) {
            peaks[count2++] = peakMap[i6];
          }
        }
        if (count2 !== arrLength) {
          throw new Error("invalid number of peaks");
        }
        return peaks;
      }
      peakUpdate(width, prevPeakMap, itemHash) {
        const nextPeakMap = {};
        const newWidth = width + 1;
        let cursorIndex = this.getLeafIndex(newWidth);
        let cursorNode = this.hashLeaf(cursorIndex, itemHash);
        let bitIndex = 0;
        let peakRef = 0;
        let prevPeakExist = false;
        let nextPeakExist = false;
        let obtained = false;
        for (let height = 1; height <= 32; height++) {
          bitIndex = 32 - height;
          if (obtained) {
            nextPeakMap[bitIndex] = prevPeakMap[bitIndex];
          } else {
            peakRef = 1 << height - 1;
            prevPeakExist = (width & peakRef) !== 0;
            nextPeakExist = (newWidth & peakRef) !== 0;
            cursorIndex++;
            if (prevPeakExist) {
              cursorNode = this.hashBranch(cursorIndex, prevPeakMap[bitIndex], cursorNode);
            }
            if (nextPeakExist) {
              if (prevPeakExist) {
                nextPeakMap[bitIndex] = prevPeakMap[bitIndex];
              } else {
                nextPeakMap[bitIndex] = cursorNode;
              }
              obtained = true;
            } else {
              nextPeakMap[bitIndex] = 0;
            }
          }
        }
        return nextPeakMap;
      }
      rollUp(root2, width, peaks, itemHashes) {
        if (!root2.equals(this.peakBagging(width, peaks))) {
          throw new Error("invalid root hash from the peaks");
        }
        let tmpWidth = width;
        let tmpPeakMap = this.peaksToPeakMap(width, peaks);
        for (let i6 = 0; i6 < itemHashes.length; i6++) {
          tmpPeakMap = this.peakUpdate(tmpWidth, tmpPeakMap, itemHashes[i6]);
          tmpWidth++;
        }
        return this.peakBagging(tmpWidth, this.peakMapToPeaks(tmpWidth, tmpPeakMap));
      }
      _getOrCreateNode(index) {
        if (index > this.size) {
          throw new Error("out of range");
        }
        if (!this.hashes[index]) {
          const [leftIndex, rightIndex] = this.getChildren(index);
          const leftHash = this._getOrCreateNode(leftIndex);
          const rightHash = this._getOrCreateNode(rightIndex);
          this.hashes[index] = this.hashBranch(index, leftHash, rightHash);
        }
        return this.hashes[index];
      }
    };
    exports2.MerkleMountainRange = MerkleMountainRange;
    exports2.default = MerkleMountainRange;
  }
});

// node_modules/merkletreejs/dist/index.js
var require_dist = __commonJS({
  "node_modules/merkletreejs/dist/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MerkleTree = void 0;
    var MerkleTree_1 = __importDefault(require_MerkleTree());
    exports2.MerkleTree = MerkleTree_1.default;
    var MerkleMountainRange_1 = require_MerkleMountainRange();
    Object.defineProperty(exports2, "MerkleMountainRange", { enumerable: true, get: function() {
      return MerkleMountainRange_1.MerkleMountainRange;
    } });
    exports2.default = MerkleTree_1.default;
  }
});

// node_modules/keccak256/node_modules/bn.js/lib/bn.js
var require_bn2 = __commonJS({
  "node_modules/keccak256/node_modules/bn.js/lib/bn.js"(exports2, module2) {
    (function(module3, exports3) {
      "use strict";
      function assert3(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN4(number, base2, endian) {
        if (BN4.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base2 === "le" || base2 === "be") {
            endian = base2;
            base2 = 10;
          }
          this._init(number || 0, base2 || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN4;
      } else {
        exports3.BN = BN4;
      }
      BN4.BN = BN4;
      BN4.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = require_buffer().Buffer;
        }
      } catch (e6) {
      }
      BN4.isBN = function isBN(num) {
        if (num instanceof BN4) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN4.wordSize && Array.isArray(num.words);
      };
      BN4.max = function max2(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN4.min = function min2(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN4.prototype._init = function init2(number, base2, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base2, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base2, endian);
        }
        if (base2 === "hex") {
          base2 = 16;
        }
        assert3(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base2 === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base2, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base2, endian);
            }
          }
        }
      };
      BN4.prototype._initNumber = function _initNumber(number, base2, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert3(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN4.prototype._initArray = function _initArray(number, base2, endian) {
        assert3(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i6 = 0; i6 < this.length; i6++) {
          this.words[i6] = 0;
        }
        var j8, w8;
        var off = 0;
        if (endian === "be") {
          for (i6 = number.length - 1, j8 = 0; i6 >= 0; i6 -= 3) {
            w8 = number[i6] | number[i6 - 1] << 8 | number[i6 - 2] << 16;
            this.words[j8] |= w8 << off & 67108863;
            this.words[j8 + 1] = w8 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j8++;
            }
          }
        } else if (endian === "le") {
          for (i6 = 0, j8 = 0; i6 < number.length; i6 += 3) {
            w8 = number[i6] | number[i6 + 1] << 8 | number[i6 + 2] << 16;
            this.words[j8] |= w8 << off & 67108863;
            this.words[j8 + 1] = w8 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j8++;
            }
          }
        }
        return this._strip();
      };
      function parseHex4Bits(string, index) {
        var c5 = string.charCodeAt(index);
        if (c5 >= 48 && c5 <= 57) {
          return c5 - 48;
        } else if (c5 >= 65 && c5 <= 70) {
          return c5 - 55;
        } else if (c5 >= 97 && c5 <= 102) {
          return c5 - 87;
        } else {
          assert3(false, "Invalid character in " + string);
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r6 = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r6 |= parseHex4Bits(string, index - 1) << 4;
        }
        return r6;
      }
      BN4.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i6 = 0; i6 < this.length; i6++) {
          this.words[i6] = 0;
        }
        var off = 0;
        var j8 = 0;
        var w8;
        if (endian === "be") {
          for (i6 = number.length - 1; i6 >= start; i6 -= 2) {
            w8 = parseHexByte(number, start, i6) << off;
            this.words[j8] |= w8 & 67108863;
            if (off >= 18) {
              off -= 18;
              j8 += 1;
              this.words[j8] |= w8 >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i6 = parseLength % 2 === 0 ? start + 1 : start; i6 < number.length; i6 += 2) {
            w8 = parseHexByte(number, start, i6) << off;
            this.words[j8] |= w8 & 67108863;
            if (off >= 18) {
              off -= 18;
              j8 += 1;
              this.words[j8] |= w8 >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this._strip();
      };
      function parseBase(str, start, end, mul3) {
        var r6 = 0;
        var b4 = 0;
        var len = Math.min(str.length, end);
        for (var i6 = start; i6 < len; i6++) {
          var c5 = str.charCodeAt(i6) - 48;
          r6 *= mul3;
          if (c5 >= 49) {
            b4 = c5 - 49 + 10;
          } else if (c5 >= 17) {
            b4 = c5 - 17 + 10;
          } else {
            b4 = c5;
          }
          assert3(c5 >= 0 && b4 < mul3, "Invalid character");
          r6 += b4;
        }
        return r6;
      }
      BN4.prototype._parseBase = function _parseBase(number, base2, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base2 | 0;
        var total = number.length - start;
        var mod2 = total % limbLen;
        var end = Math.min(total, total - mod2) + start;
        var word = 0;
        for (var i6 = start; i6 < end; i6 += limbLen) {
          word = parseBase(number, i6, i6 + limbLen, base2);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod2 !== 0) {
          var pow = 1;
          word = parseBase(number, i6, number.length, base2);
          for (i6 = 0; i6 < mod2; i6++) {
            pow *= base2;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this._strip();
      };
      BN4.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i6 = 0; i6 < this.length; i6++) {
          dest.words[i6] = this.words[i6];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      function move(dest, src) {
        dest.words = src.words;
        dest.length = src.length;
        dest.negative = src.negative;
        dest.red = src.red;
      }
      BN4.prototype._move = function _move(dest) {
        move(dest, this);
      };
      BN4.prototype.clone = function clone() {
        var r6 = new BN4(null);
        this.copy(r6);
        return r6;
      };
      BN4.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN4.prototype._strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN4.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
        try {
          BN4.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect4;
        } catch (e6) {
          BN4.prototype.inspect = inspect4;
        }
      } else {
        BN4.prototype.inspect = inspect4;
      }
      function inspect4() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var zeros2 = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN4.prototype.toString = function toString2(base2, padding2) {
        base2 = base2 || 10;
        padding2 = padding2 | 0 || 1;
        var out;
        if (base2 === 16 || base2 === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i6 = 0; i6 < this.length; i6++) {
            var w8 = this.words[i6];
            var word = ((w8 << off | carry) & 16777215).toString(16);
            carry = w8 >>> 24 - off & 16777215;
            if (carry !== 0 || i6 !== this.length - 1) {
              out = zeros2[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i6--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
          var groupSize = groupSizes[base2];
          var groupBase = groupBases[base2];
          out = "";
          var c5 = this.clone();
          c5.negative = 0;
          while (!c5.isZero()) {
            var r6 = c5.modrn(groupBase).toString(base2);
            c5 = c5.idivn(groupBase);
            if (!c5.isZero()) {
              out = zeros2[groupSize - r6.length] + r6 + out;
            } else {
              out = r6 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert3(false, "Base should be between 2 and 36");
      };
      BN4.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert3(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN4.prototype.toJSON = function toJSON2() {
        return this.toString(16, 2);
      };
      if (Buffer2) {
        BN4.prototype.toBuffer = function toBuffer(endian, length) {
          return this.toArrayLike(Buffer2, endian, length);
        };
      }
      BN4.prototype.toArray = function toArray2(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      var allocate = function allocate2(ArrayType, size) {
        if (ArrayType.allocUnsafe) {
          return ArrayType.allocUnsafe(size);
        }
        return new ArrayType(size);
      };
      BN4.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        this._strip();
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert3(byteLength <= reqLength, "byte array longer than desired length");
        assert3(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength);
        return res;
      };
      BN4.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
        var position = 0;
        var carry = 0;
        for (var i6 = 0, shift = 0; i6 < this.length; i6++) {
          var word = this.words[i6] << shift | carry;
          res[position++] = word & 255;
          if (position < res.length) {
            res[position++] = word >> 8 & 255;
          }
          if (position < res.length) {
            res[position++] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position < res.length) {
              res[position++] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position < res.length) {
          res[position++] = carry;
          while (position < res.length) {
            res[position++] = 0;
          }
        }
      };
      BN4.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
        var position = res.length - 1;
        var carry = 0;
        for (var i6 = 0, shift = 0; i6 < this.length; i6++) {
          var word = this.words[i6] << shift | carry;
          res[position--] = word & 255;
          if (position >= 0) {
            res[position--] = word >> 8 & 255;
          }
          if (position >= 0) {
            res[position--] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position >= 0) {
              res[position--] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position >= 0) {
          res[position--] = carry;
          while (position >= 0) {
            res[position--] = 0;
          }
        }
      };
      if (Math.clz32) {
        BN4.prototype._countBits = function _countBits(w8) {
          return 32 - Math.clz32(w8);
        };
      } else {
        BN4.prototype._countBits = function _countBits(w8) {
          var t6 = w8;
          var r6 = 0;
          if (t6 >= 4096) {
            r6 += 13;
            t6 >>>= 13;
          }
          if (t6 >= 64) {
            r6 += 7;
            t6 >>>= 7;
          }
          if (t6 >= 8) {
            r6 += 4;
            t6 >>>= 4;
          }
          if (t6 >= 2) {
            r6 += 2;
            t6 >>>= 2;
          }
          return r6 + t6;
        };
      }
      BN4.prototype._zeroBits = function _zeroBits(w8) {
        if (w8 === 0)
          return 26;
        var t6 = w8;
        var r6 = 0;
        if ((t6 & 8191) === 0) {
          r6 += 13;
          t6 >>>= 13;
        }
        if ((t6 & 127) === 0) {
          r6 += 7;
          t6 >>>= 7;
        }
        if ((t6 & 15) === 0) {
          r6 += 4;
          t6 >>>= 4;
        }
        if ((t6 & 3) === 0) {
          r6 += 2;
          t6 >>>= 2;
        }
        if ((t6 & 1) === 0) {
          r6++;
        }
        return r6;
      };
      BN4.prototype.bitLength = function bitLength() {
        var w8 = this.words[this.length - 1];
        var hi2 = this._countBits(w8);
        return (this.length - 1) * 26 + hi2;
      };
      function toBitArray(num) {
        var w8 = new Array(num.bitLength());
        for (var bit = 0; bit < w8.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w8[bit] = num.words[off] >>> wbit & 1;
        }
        return w8;
      }
      BN4.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r6 = 0;
        for (var i6 = 0; i6 < this.length; i6++) {
          var b4 = this._zeroBits(this.words[i6]);
          r6 += b4;
          if (b4 !== 26)
            break;
        }
        return r6;
      };
      BN4.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN4.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN4.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN4.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN4.prototype.neg = function neg3() {
        return this.clone().ineg();
      };
      BN4.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN4.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i6 = 0; i6 < num.length; i6++) {
          this.words[i6] = this.words[i6] | num.words[i6];
        }
        return this._strip();
      };
      BN4.prototype.ior = function ior(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN4.prototype.or = function or2(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN4.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN4.prototype.iuand = function iuand(num) {
        var b4;
        if (this.length > num.length) {
          b4 = num;
        } else {
          b4 = this;
        }
        for (var i6 = 0; i6 < b4.length; i6++) {
          this.words[i6] = this.words[i6] & num.words[i6];
        }
        this.length = b4.length;
        return this._strip();
      };
      BN4.prototype.iand = function iand(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN4.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN4.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN4.prototype.iuxor = function iuxor(num) {
        var a5;
        var b4;
        if (this.length > num.length) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        for (var i6 = 0; i6 < b4.length; i6++) {
          this.words[i6] = a5.words[i6] ^ b4.words[i6];
        }
        if (this !== a5) {
          for (; i6 < a5.length; i6++) {
            this.words[i6] = a5.words[i6];
          }
        }
        this.length = a5.length;
        return this._strip();
      };
      BN4.prototype.ixor = function ixor(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN4.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN4.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN4.prototype.inotn = function inotn(width) {
        assert3(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i6 = 0; i6 < bytesNeeded; i6++) {
          this.words[i6] = ~this.words[i6] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i6] = ~this.words[i6] & 67108863 >> 26 - bitsLeft;
        }
        return this._strip();
      };
      BN4.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN4.prototype.setn = function setn(bit, val) {
        assert3(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this._strip();
      };
      BN4.prototype.iadd = function iadd(num) {
        var r6;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r6 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r6 = this.isub(num);
          num.negative = 1;
          return r6._normSign();
        }
        var a5, b4;
        if (this.length > num.length) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        var carry = 0;
        for (var i6 = 0; i6 < b4.length; i6++) {
          r6 = (a5.words[i6] | 0) + (b4.words[i6] | 0) + carry;
          this.words[i6] = r6 & 67108863;
          carry = r6 >>> 26;
        }
        for (; carry !== 0 && i6 < a5.length; i6++) {
          r6 = (a5.words[i6] | 0) + carry;
          this.words[i6] = r6 & 67108863;
          carry = r6 >>> 26;
        }
        this.length = a5.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a5 !== this) {
          for (; i6 < a5.length; i6++) {
            this.words[i6] = a5.words[i6];
          }
        }
        return this;
      };
      BN4.prototype.add = function add3(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN4.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r6 = this.iadd(num);
          num.negative = 1;
          return r6._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a5, b4;
        if (cmp > 0) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        var carry = 0;
        for (var i6 = 0; i6 < b4.length; i6++) {
          r6 = (a5.words[i6] | 0) - (b4.words[i6] | 0) + carry;
          carry = r6 >> 26;
          this.words[i6] = r6 & 67108863;
        }
        for (; carry !== 0 && i6 < a5.length; i6++) {
          r6 = (a5.words[i6] | 0) + carry;
          carry = r6 >> 26;
          this.words[i6] = r6 & 67108863;
        }
        if (carry === 0 && i6 < a5.length && a5 !== this) {
          for (; i6 < a5.length; i6++) {
            this.words[i6] = a5.words[i6];
          }
        }
        this.length = Math.max(this.length, i6);
        if (a5 !== this) {
          this.negative = 1;
        }
        return this._strip();
      };
      BN4.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a5 = self2.words[0] | 0;
        var b4 = num.words[0] | 0;
        var r6 = a5 * b4;
        var lo = r6 & 67108863;
        var carry = r6 / 67108864 | 0;
        out.words[0] = lo;
        for (var k8 = 1; k8 < len; k8++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k8, num.length - 1);
          for (var j8 = Math.max(0, k8 - self2.length + 1); j8 <= maxJ; j8++) {
            var i6 = k8 - j8 | 0;
            a5 = self2.words[i6] | 0;
            b4 = num.words[j8] | 0;
            r6 = a5 * b4 + rword;
            ncarry += r6 / 67108864 | 0;
            rword = r6 & 67108863;
          }
          out.words[k8] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k8] = carry | 0;
        } else {
          out.length--;
        }
        return out._strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a5 = self2.words;
        var b4 = num.words;
        var o6 = out.words;
        var c5 = 0;
        var lo;
        var mid;
        var hi2;
        var a02 = a5[0] | 0;
        var al0 = a02 & 8191;
        var ah0 = a02 >>> 13;
        var a1 = a5[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a5[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a5[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a42 = a5[4] | 0;
        var al4 = a42 & 8191;
        var ah4 = a42 >>> 13;
        var a52 = a5[5] | 0;
        var al5 = a52 & 8191;
        var ah5 = a52 >>> 13;
        var a6 = a5[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a5[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a5[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a5[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b02 = b4[0] | 0;
        var bl0 = b02 & 8191;
        var bh0 = b02 >>> 13;
        var b1 = b4[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b4[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b4[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b42 = b4[4] | 0;
        var bl4 = b42 & 8191;
        var bh4 = b42 >>> 13;
        var b5 = b4[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b4[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b4[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b4[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b4[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi2 = Math.imul(ah0, bh0);
        var w02 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w02 >>> 26) | 0;
        w02 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi2 = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi2 = hi2 + Math.imul(ah0, bh1) | 0;
        var w1 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi2 = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi2 = hi2 + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi2 = hi2 + Math.imul(ah0, bh2) | 0;
        var w22 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi2 = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi2 = hi2 + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi2 = hi2 + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi2 = hi2 + Math.imul(ah0, bh3) | 0;
        var w32 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi2 = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi2 = hi2 + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi2 = hi2 + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi2 = hi2 + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi2 = hi2 + Math.imul(ah0, bh4) | 0;
        var w42 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
        w42 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi2 = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi2 = hi2 + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi2 = hi2 + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi2 = hi2 + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi2 = hi2 + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi2 = hi2 + Math.imul(ah0, bh5) | 0;
        var w52 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w52 >>> 26) | 0;
        w52 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi2 = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi2 = hi2 + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi2 = hi2 + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi2 = hi2 + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi2 = hi2 + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi2 = hi2 + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi2 = hi2 + Math.imul(ah0, bh6) | 0;
        var w62 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w62 >>> 26) | 0;
        w62 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi2 = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi2 = hi2 + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi2 = hi2 + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi2 = hi2 + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi2 = hi2 + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi2 = hi2 + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi2 = hi2 + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi2 = hi2 + Math.imul(ah0, bh7) | 0;
        var w72 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w72 >>> 26) | 0;
        w72 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi2 = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi2 = hi2 + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi2 = hi2 + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi2 = hi2 + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi2 = hi2 + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi2 = hi2 + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi2 = hi2 + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi2 = hi2 + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi2 = hi2 + Math.imul(ah0, bh8) | 0;
        var w8 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi2 = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi2 = hi2 + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi2 = hi2 + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi2 = hi2 + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi2 = hi2 + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi2 = hi2 + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi2 = hi2 + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi2 = hi2 + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi2 = hi2 + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi2 = hi2 + Math.imul(ah0, bh9) | 0;
        var w9 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi2 = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi2 = hi2 + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi2 = hi2 + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi2 = hi2 + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi2 = hi2 + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi2 = hi2 + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi2 = hi2 + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi2 = hi2 + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi2 = hi2 + Math.imul(ah1, bh9) | 0;
        var w10 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi2 = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi2 = hi2 + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi2 = hi2 + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi2 = hi2 + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi2 = hi2 + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi2 = hi2 + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi2 = hi2 + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi2 = hi2 + Math.imul(ah2, bh9) | 0;
        var w11 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi2 = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi2 = hi2 + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi2 = hi2 + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi2 = hi2 + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi2 = hi2 + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi2 = hi2 + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi2 = hi2 + Math.imul(ah3, bh9) | 0;
        var w12 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi2 = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi2 = hi2 + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi2 = hi2 + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi2 = hi2 + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi2 = hi2 + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi2 = hi2 + Math.imul(ah4, bh9) | 0;
        var w13 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi2 = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi2 = hi2 + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi2 = hi2 + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi2 = hi2 + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi2 = hi2 + Math.imul(ah5, bh9) | 0;
        var w14 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi2 = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi2 = hi2 + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi2 = hi2 + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi2 = hi2 + Math.imul(ah6, bh9) | 0;
        var w15 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi2 = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi2 = hi2 + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi2 = hi2 + Math.imul(ah7, bh9) | 0;
        var w16 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi2 = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi2 = hi2 + Math.imul(ah8, bh9) | 0;
        var w17 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi2 = Math.imul(ah9, bh9);
        var w18 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o6[0] = w02;
        o6[1] = w1;
        o6[2] = w22;
        o6[3] = w32;
        o6[4] = w42;
        o6[5] = w52;
        o6[6] = w62;
        o6[7] = w72;
        o6[8] = w8;
        o6[9] = w9;
        o6[10] = w10;
        o6[11] = w11;
        o6[12] = w12;
        o6[13] = w13;
        o6[14] = w14;
        o6[15] = w15;
        o6[16] = w16;
        o6[17] = w17;
        o6[18] = w18;
        if (c5 !== 0) {
          o6[19] = c5;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k8 = 0; k8 < out.length - 1; k8++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k8, num.length - 1);
          for (var j8 = Math.max(0, k8 - self2.length + 1); j8 <= maxJ; j8++) {
            var i6 = k8 - j8;
            var a5 = self2.words[i6] | 0;
            var b4 = num.words[j8] | 0;
            var r6 = a5 * b4;
            var lo = r6 & 67108863;
            ncarry = ncarry + (r6 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k8] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k8] = carry;
        } else {
          out.length--;
        }
        return out._strip();
      }
      function jumboMulTo(self2, num, out) {
        return bigMulTo(self2, num, out);
      }
      BN4.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x6, y5) {
        this.x = x6;
        this.y = y5;
      }
      FFTM.prototype.makeRBT = function makeRBT(N7) {
        var t6 = new Array(N7);
        var l6 = BN4.prototype._countBits(N7) - 1;
        for (var i6 = 0; i6 < N7; i6++) {
          t6[i6] = this.revBin(i6, l6, N7);
        }
        return t6;
      };
      FFTM.prototype.revBin = function revBin(x6, l6, N7) {
        if (x6 === 0 || x6 === N7 - 1)
          return x6;
        var rb = 0;
        for (var i6 = 0; i6 < l6; i6++) {
          rb |= (x6 & 1) << l6 - i6 - 1;
          x6 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N7) {
        for (var i6 = 0; i6 < N7; i6++) {
          rtws[i6] = rws[rbt[i6]];
          itws[i6] = iws[rbt[i6]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N7, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N7);
        for (var s6 = 1; s6 < N7; s6 <<= 1) {
          var l6 = s6 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l6);
          var itwdf = Math.sin(2 * Math.PI / l6);
          for (var p7 = 0; p7 < N7; p7 += l6) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j8 = 0; j8 < s6; j8++) {
              var re = rtws[p7 + j8];
              var ie2 = itws[p7 + j8];
              var ro3 = rtws[p7 + j8 + s6];
              var io3 = itws[p7 + j8 + s6];
              var rx = rtwdf_ * ro3 - itwdf_ * io3;
              io3 = rtwdf_ * io3 + itwdf_ * ro3;
              ro3 = rx;
              rtws[p7 + j8] = re + ro3;
              itws[p7 + j8] = ie2 + io3;
              rtws[p7 + j8 + s6] = re - ro3;
              itws[p7 + j8 + s6] = ie2 - io3;
              if (j8 !== l6) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n4, m6) {
        var N7 = Math.max(m6, n4) | 1;
        var odd = N7 & 1;
        var i6 = 0;
        for (N7 = N7 / 2 | 0; N7; N7 = N7 >>> 1) {
          i6++;
        }
        return 1 << i6 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N7) {
        if (N7 <= 1)
          return;
        for (var i6 = 0; i6 < N7 / 2; i6++) {
          var t6 = rws[i6];
          rws[i6] = rws[N7 - i6 - 1];
          rws[N7 - i6 - 1] = t6;
          t6 = iws[i6];
          iws[i6] = -iws[N7 - i6 - 1];
          iws[N7 - i6 - 1] = -t6;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws2, N7) {
        var carry = 0;
        for (var i6 = 0; i6 < N7 / 2; i6++) {
          var w8 = Math.round(ws2[2 * i6 + 1] / N7) * 8192 + Math.round(ws2[2 * i6] / N7) + carry;
          ws2[i6] = w8 & 67108863;
          if (w8 < 67108864) {
            carry = 0;
          } else {
            carry = w8 / 67108864 | 0;
          }
        }
        return ws2;
      };
      FFTM.prototype.convert13b = function convert13b(ws2, len, rws, N7) {
        var carry = 0;
        for (var i6 = 0; i6 < len; i6++) {
          carry = carry + (ws2[i6] | 0);
          rws[2 * i6] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i6 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i6 = 2 * len; i6 < N7; ++i6) {
          rws[i6] = 0;
        }
        assert3(carry === 0);
        assert3((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N7) {
        var ph = new Array(N7);
        for (var i6 = 0; i6 < N7; i6++) {
          ph[i6] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x6, y5, out) {
        var N7 = 2 * this.guessLen13b(x6.length, y5.length);
        var rbt = this.makeRBT(N7);
        var _8 = this.stub(N7);
        var rws = new Array(N7);
        var rwst = new Array(N7);
        var iwst = new Array(N7);
        var nrws = new Array(N7);
        var nrwst = new Array(N7);
        var niwst = new Array(N7);
        var rmws = out.words;
        rmws.length = N7;
        this.convert13b(x6.words, x6.length, rws, N7);
        this.convert13b(y5.words, y5.length, nrws, N7);
        this.transform(rws, _8, rwst, iwst, N7, rbt);
        this.transform(nrws, _8, nrwst, niwst, N7, rbt);
        for (var i6 = 0; i6 < N7; i6++) {
          var rx = rwst[i6] * nrwst[i6] - iwst[i6] * niwst[i6];
          iwst[i6] = rwst[i6] * niwst[i6] + iwst[i6] * nrwst[i6];
          rwst[i6] = rx;
        }
        this.conjugate(rwst, iwst, N7);
        this.transform(rwst, iwst, rmws, _8, N7, rbt);
        this.conjugate(rmws, _8, N7);
        this.normalize13b(rmws, N7);
        out.negative = x6.negative ^ y5.negative;
        out.length = x6.length + y5.length;
        return out._strip();
      };
      BN4.prototype.mul = function mul3(num) {
        var out = new BN4(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN4.prototype.mulf = function mulf(num) {
        var out = new BN4(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN4.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN4.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert3(typeof num === "number");
        assert3(num < 67108864);
        var carry = 0;
        for (var i6 = 0; i6 < this.length; i6++) {
          var w8 = (this.words[i6] | 0) * num;
          var lo = (w8 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w8 / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i6] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i6] = carry;
          this.length++;
        }
        return isNegNum ? this.ineg() : this;
      };
      BN4.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN4.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN4.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN4.prototype.pow = function pow(num) {
        var w8 = toBitArray(num);
        if (w8.length === 0)
          return new BN4(1);
        var res = this;
        for (var i6 = 0; i6 < w8.length; i6++, res = res.sqr()) {
          if (w8[i6] !== 0)
            break;
        }
        if (++i6 < w8.length) {
          for (var q8 = res.sqr(); i6 < w8.length; i6++, q8 = q8.sqr()) {
            if (w8[i6] === 0)
              continue;
            res = res.mul(q8);
          }
        }
        return res;
      };
      BN4.prototype.iushln = function iushln(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r6 = bits % 26;
        var s6 = (bits - r6) / 26;
        var carryMask = 67108863 >>> 26 - r6 << 26 - r6;
        var i6;
        if (r6 !== 0) {
          var carry = 0;
          for (i6 = 0; i6 < this.length; i6++) {
            var newCarry = this.words[i6] & carryMask;
            var c5 = (this.words[i6] | 0) - newCarry << r6;
            this.words[i6] = c5 | carry;
            carry = newCarry >>> 26 - r6;
          }
          if (carry) {
            this.words[i6] = carry;
            this.length++;
          }
        }
        if (s6 !== 0) {
          for (i6 = this.length - 1; i6 >= 0; i6--) {
            this.words[i6 + s6] = this.words[i6];
          }
          for (i6 = 0; i6 < s6; i6++) {
            this.words[i6] = 0;
          }
          this.length += s6;
        }
        return this._strip();
      };
      BN4.prototype.ishln = function ishln(bits) {
        assert3(this.negative === 0);
        return this.iushln(bits);
      };
      BN4.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert3(typeof bits === "number" && bits >= 0);
        var h6;
        if (hint) {
          h6 = (hint - hint % 26) / 26;
        } else {
          h6 = 0;
        }
        var r6 = bits % 26;
        var s6 = Math.min((bits - r6) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r6 << r6;
        var maskedWords = extended;
        h6 -= s6;
        h6 = Math.max(0, h6);
        if (maskedWords) {
          for (var i6 = 0; i6 < s6; i6++) {
            maskedWords.words[i6] = this.words[i6];
          }
          maskedWords.length = s6;
        }
        if (s6 === 0) {
        } else if (this.length > s6) {
          this.length -= s6;
          for (i6 = 0; i6 < this.length; i6++) {
            this.words[i6] = this.words[i6 + s6];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i6 = this.length - 1; i6 >= 0 && (carry !== 0 || i6 >= h6); i6--) {
          var word = this.words[i6] | 0;
          this.words[i6] = carry << 26 - r6 | word >>> r6;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this._strip();
      };
      BN4.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert3(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN4.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN4.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN4.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN4.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN4.prototype.testn = function testn(bit) {
        assert3(typeof bit === "number" && bit >= 0);
        var r6 = bit % 26;
        var s6 = (bit - r6) / 26;
        var q8 = 1 << r6;
        if (this.length <= s6)
          return false;
        var w8 = this.words[s6];
        return !!(w8 & q8);
      };
      BN4.prototype.imaskn = function imaskn(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r6 = bits % 26;
        var s6 = (bits - r6) / 26;
        assert3(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s6) {
          return this;
        }
        if (r6 !== 0) {
          s6++;
        }
        this.length = Math.min(s6, this.length);
        if (r6 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r6 << r6;
          this.words[this.length - 1] &= mask;
        }
        return this._strip();
      };
      BN4.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN4.prototype.iaddn = function iaddn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN4.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i6 = 0; i6 < this.length && this.words[i6] >= 67108864; i6++) {
          this.words[i6] -= 67108864;
          if (i6 === this.length - 1) {
            this.words[i6 + 1] = 1;
          } else {
            this.words[i6 + 1]++;
          }
        }
        this.length = Math.max(this.length, i6 + 1);
        return this;
      };
      BN4.prototype.isubn = function isubn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i6 = 0; i6 < this.length && this.words[i6] < 0; i6++) {
            this.words[i6] += 67108864;
            this.words[i6 + 1] -= 1;
          }
        }
        return this._strip();
      };
      BN4.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN4.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN4.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN4.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN4.prototype._ishlnsubmul = function _ishlnsubmul(num, mul3, shift) {
        var len = num.length + shift;
        var i6;
        this._expand(len);
        var w8;
        var carry = 0;
        for (i6 = 0; i6 < num.length; i6++) {
          w8 = (this.words[i6 + shift] | 0) + carry;
          var right = (num.words[i6] | 0) * mul3;
          w8 -= right & 67108863;
          carry = (w8 >> 26) - (right / 67108864 | 0);
          this.words[i6 + shift] = w8 & 67108863;
        }
        for (; i6 < this.length - shift; i6++) {
          w8 = (this.words[i6 + shift] | 0) + carry;
          carry = w8 >> 26;
          this.words[i6 + shift] = w8 & 67108863;
        }
        if (carry === 0)
          return this._strip();
        assert3(carry === -1);
        carry = 0;
        for (i6 = 0; i6 < this.length; i6++) {
          w8 = -(this.words[i6] | 0) + carry;
          carry = w8 >> 26;
          this.words[i6] = w8 & 67108863;
        }
        this.negative = 1;
        return this._strip();
      };
      BN4.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a5 = this.clone();
        var b4 = num;
        var bhi = b4.words[b4.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b4 = b4.ushln(shift);
          a5.iushln(shift);
          bhi = b4.words[b4.length - 1] | 0;
        }
        var m6 = a5.length - b4.length;
        var q8;
        if (mode !== "mod") {
          q8 = new BN4(null);
          q8.length = m6 + 1;
          q8.words = new Array(q8.length);
          for (var i6 = 0; i6 < q8.length; i6++) {
            q8.words[i6] = 0;
          }
        }
        var diff = a5.clone()._ishlnsubmul(b4, 1, m6);
        if (diff.negative === 0) {
          a5 = diff;
          if (q8) {
            q8.words[m6] = 1;
          }
        }
        for (var j8 = m6 - 1; j8 >= 0; j8--) {
          var qj = (a5.words[b4.length + j8] | 0) * 67108864 + (a5.words[b4.length + j8 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a5._ishlnsubmul(b4, qj, j8);
          while (a5.negative !== 0) {
            qj--;
            a5.negative = 0;
            a5._ishlnsubmul(b4, 1, j8);
            if (!a5.isZero()) {
              a5.negative ^= 1;
            }
          }
          if (q8) {
            q8.words[j8] = qj;
          }
        }
        if (q8) {
          q8._strip();
        }
        a5._strip();
        if (mode !== "div" && shift !== 0) {
          a5.iushrn(shift);
        }
        return {
          div: q8 || null,
          mod: a5
        };
      };
      BN4.prototype.divmod = function divmod(num, mode, positive) {
        assert3(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN4(0),
            mod: new BN4(0)
          };
        }
        var div, mod2, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.iadd(num);
            }
          }
          return {
            div,
            mod: mod2
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.isub(num);
            }
          }
          return {
            div: res.div,
            mod: mod2
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN4(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN4(this.modrn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN4(this.modrn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN4.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN4.prototype.mod = function mod2(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN4.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN4.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r22 = num.andln(1);
        var cmp = mod2.cmp(half);
        if (cmp < 0 || r22 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN4.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert3(num <= 67108863);
        var p7 = (1 << 26) % num;
        var acc = 0;
        for (var i6 = this.length - 1; i6 >= 0; i6--) {
          acc = (p7 * acc + (this.words[i6] | 0)) % num;
        }
        return isNegNum ? -acc : acc;
      };
      BN4.prototype.modn = function modn(num) {
        return this.modrn(num);
      };
      BN4.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert3(num <= 67108863);
        var carry = 0;
        for (var i6 = this.length - 1; i6 >= 0; i6--) {
          var w8 = (this.words[i6] | 0) + carry * 67108864;
          this.words[i6] = w8 / num | 0;
          carry = w8 % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
      };
      BN4.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN4.prototype.egcd = function egcd(p7) {
        assert3(p7.negative === 0);
        assert3(!p7.isZero());
        var x6 = this;
        var y5 = p7.clone();
        if (x6.negative !== 0) {
          x6 = x6.umod(p7);
        } else {
          x6 = x6.clone();
        }
        var A8 = new BN4(1);
        var B4 = new BN4(0);
        var C5 = new BN4(0);
        var D5 = new BN4(1);
        var g7 = 0;
        while (x6.isEven() && y5.isEven()) {
          x6.iushrn(1);
          y5.iushrn(1);
          ++g7;
        }
        var yp = y5.clone();
        var xp = x6.clone();
        while (!x6.isZero()) {
          for (var i6 = 0, im = 1; (x6.words[0] & im) === 0 && i6 < 26; ++i6, im <<= 1)
            ;
          if (i6 > 0) {
            x6.iushrn(i6);
            while (i6-- > 0) {
              if (A8.isOdd() || B4.isOdd()) {
                A8.iadd(yp);
                B4.isub(xp);
              }
              A8.iushrn(1);
              B4.iushrn(1);
            }
          }
          for (var j8 = 0, jm = 1; (y5.words[0] & jm) === 0 && j8 < 26; ++j8, jm <<= 1)
            ;
          if (j8 > 0) {
            y5.iushrn(j8);
            while (j8-- > 0) {
              if (C5.isOdd() || D5.isOdd()) {
                C5.iadd(yp);
                D5.isub(xp);
              }
              C5.iushrn(1);
              D5.iushrn(1);
            }
          }
          if (x6.cmp(y5) >= 0) {
            x6.isub(y5);
            A8.isub(C5);
            B4.isub(D5);
          } else {
            y5.isub(x6);
            C5.isub(A8);
            D5.isub(B4);
          }
        }
        return {
          a: C5,
          b: D5,
          gcd: y5.iushln(g7)
        };
      };
      BN4.prototype._invmp = function _invmp(p7) {
        assert3(p7.negative === 0);
        assert3(!p7.isZero());
        var a5 = this;
        var b4 = p7.clone();
        if (a5.negative !== 0) {
          a5 = a5.umod(p7);
        } else {
          a5 = a5.clone();
        }
        var x1 = new BN4(1);
        var x22 = new BN4(0);
        var delta = b4.clone();
        while (a5.cmpn(1) > 0 && b4.cmpn(1) > 0) {
          for (var i6 = 0, im = 1; (a5.words[0] & im) === 0 && i6 < 26; ++i6, im <<= 1)
            ;
          if (i6 > 0) {
            a5.iushrn(i6);
            while (i6-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j8 = 0, jm = 1; (b4.words[0] & jm) === 0 && j8 < 26; ++j8, jm <<= 1)
            ;
          if (j8 > 0) {
            b4.iushrn(j8);
            while (j8-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a5.cmp(b4) >= 0) {
            a5.isub(b4);
            x1.isub(x22);
          } else {
            b4.isub(a5);
            x22.isub(x1);
          }
        }
        var res;
        if (a5.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p7);
        }
        return res;
      };
      BN4.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a5 = this.clone();
        var b4 = num.clone();
        a5.negative = 0;
        b4.negative = 0;
        for (var shift = 0; a5.isEven() && b4.isEven(); shift++) {
          a5.iushrn(1);
          b4.iushrn(1);
        }
        do {
          while (a5.isEven()) {
            a5.iushrn(1);
          }
          while (b4.isEven()) {
            b4.iushrn(1);
          }
          var r6 = a5.cmp(b4);
          if (r6 < 0) {
            var t6 = a5;
            a5 = b4;
            b4 = t6;
          } else if (r6 === 0 || b4.cmpn(1) === 0) {
            break;
          }
          a5.isub(b4);
        } while (true);
        return b4.iushln(shift);
      };
      BN4.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN4.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN4.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN4.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN4.prototype.bincn = function bincn(bit) {
        assert3(typeof bit === "number");
        var r6 = bit % 26;
        var s6 = (bit - r6) / 26;
        var q8 = 1 << r6;
        if (this.length <= s6) {
          this._expand(s6 + 1);
          this.words[s6] |= q8;
          return this;
        }
        var carry = q8;
        for (var i6 = s6; carry !== 0 && i6 < this.length; i6++) {
          var w8 = this.words[i6] | 0;
          w8 += carry;
          carry = w8 >>> 26;
          w8 &= 67108863;
          this.words[i6] = w8;
        }
        if (carry !== 0) {
          this.words[i6] = carry;
          this.length++;
        }
        return this;
      };
      BN4.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN4.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this._strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert3(num <= 67108863, "Number is too big");
          var w8 = this.words[0] | 0;
          res = w8 === num ? 0 : w8 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN4.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN4.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i6 = this.length - 1; i6 >= 0; i6--) {
          var a5 = this.words[i6] | 0;
          var b4 = num.words[i6] | 0;
          if (a5 === b4)
            continue;
          if (a5 < b4) {
            res = -1;
          } else if (a5 > b4) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN4.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN4.prototype.gt = function gt2(num) {
        return this.cmp(num) === 1;
      };
      BN4.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN4.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN4.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN4.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN4.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN4.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN4.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN4.prototype.eq = function eq4(num) {
        return this.cmp(num) === 0;
      };
      BN4.red = function red(num) {
        return new Red(num);
      };
      BN4.prototype.toRed = function toRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        assert3(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN4.prototype.fromRed = function fromRed() {
        assert3(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN4.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN4.prototype.forceRed = function forceRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN4.prototype.redAdd = function redAdd(num) {
        assert3(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN4.prototype.redIAdd = function redIAdd(num) {
        assert3(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN4.prototype.redSub = function redSub(num) {
        assert3(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN4.prototype.redISub = function redISub(num) {
        assert3(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN4.prototype.redShl = function redShl(num) {
        assert3(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN4.prototype.redMul = function redMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN4.prototype.redIMul = function redIMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN4.prototype.redSqr = function redSqr() {
        assert3(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN4.prototype.redISqr = function redISqr() {
        assert3(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN4.prototype.redSqrt = function redSqrt() {
        assert3(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN4.prototype.redInvm = function redInvm() {
        assert3(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN4.prototype.redNeg = function redNeg() {
        assert3(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN4.prototype.redPow = function redPow(num) {
        assert3(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name2, p7) {
        this.name = name2;
        this.p = new BN4(p7, 16);
        this.n = this.p.bitLength();
        this.k = new BN4(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN4(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r6 = num;
        var rlen;
        do {
          this.split(r6, this.tmp);
          r6 = this.imulK(r6);
          r6 = r6.iadd(this.tmp);
          rlen = r6.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r6.ucmp(this.p);
        if (cmp === 0) {
          r6.words[0] = 0;
          r6.length = 1;
        } else if (cmp > 0) {
          r6.isub(this.p);
        } else {
          if (r6.strip !== void 0) {
            r6.strip();
          } else {
            r6._strip();
          }
        }
        return r6;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i6 = 0; i6 < outLen; i6++) {
          output.words[i6] = input.words[i6];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i6 = 10; i6 < input.length; i6++) {
          var next = input.words[i6] | 0;
          input.words[i6 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i6 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i6 = 0; i6 < num.length; i6++) {
          var w8 = num.words[i6] | 0;
          lo += w8 * 977;
          num.words[i6] = lo & 67108863;
          lo = w8 * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i6 = 0; i6 < num.length; i6++) {
          var hi2 = (num.words[i6] | 0) * 19 + carry;
          var lo = hi2 & 67108863;
          hi2 >>>= 26;
          num.words[i6] = lo;
          carry = hi2;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN4._prime = function prime(name2) {
        if (primes[name2])
          return primes[name2];
        var prime2;
        if (name2 === "k256") {
          prime2 = new K256();
        } else if (name2 === "p224") {
          prime2 = new P224();
        } else if (name2 === "p192") {
          prime2 = new P192();
        } else if (name2 === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name2);
        }
        primes[name2] = prime2;
        return prime2;
      };
      function Red(m6) {
        if (typeof m6 === "string") {
          var prime = BN4._prime(m6);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert3(m6.gtn(1), "modulus must be greater than 1");
          this.m = m6;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a5) {
        assert3(a5.negative === 0, "red works only with positives");
        assert3(a5.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a5, b4) {
        assert3((a5.negative | b4.negative) === 0, "red works only with positives");
        assert3(
          a5.red && a5.red === b4.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a5) {
        if (this.prime)
          return this.prime.ireduce(a5)._forceRed(this);
        move(a5, a5.umod(this.m)._forceRed(this));
        return a5;
      };
      Red.prototype.neg = function neg3(a5) {
        if (a5.isZero()) {
          return a5.clone();
        }
        return this.m.sub(a5)._forceRed(this);
      };
      Red.prototype.add = function add3(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.add(b4);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.iadd(b4);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.sub(b4);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.isub(b4);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a5, num) {
        this._verify1(a5);
        return this.imod(a5.ushln(num));
      };
      Red.prototype.imul = function imul(a5, b4) {
        this._verify2(a5, b4);
        return this.imod(a5.imul(b4));
      };
      Red.prototype.mul = function mul3(a5, b4) {
        this._verify2(a5, b4);
        return this.imod(a5.mul(b4));
      };
      Red.prototype.isqr = function isqr(a5) {
        return this.imul(a5, a5.clone());
      };
      Red.prototype.sqr = function sqr(a5) {
        return this.mul(a5, a5);
      };
      Red.prototype.sqrt = function sqrt(a5) {
        if (a5.isZero())
          return a5.clone();
        var mod3 = this.m.andln(3);
        assert3(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN4(1)).iushrn(2);
          return this.pow(a5, pow);
        }
        var q8 = this.m.subn(1);
        var s6 = 0;
        while (!q8.isZero() && q8.andln(1) === 0) {
          s6++;
          q8.iushrn(1);
        }
        assert3(!q8.isZero());
        var one = new BN4(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z6 = this.m.bitLength();
        z6 = new BN4(2 * z6 * z6).toRed(this);
        while (this.pow(z6, lpow).cmp(nOne) !== 0) {
          z6.redIAdd(nOne);
        }
        var c5 = this.pow(z6, q8);
        var r6 = this.pow(a5, q8.addn(1).iushrn(1));
        var t6 = this.pow(a5, q8);
        var m6 = s6;
        while (t6.cmp(one) !== 0) {
          var tmp = t6;
          for (var i6 = 0; tmp.cmp(one) !== 0; i6++) {
            tmp = tmp.redSqr();
          }
          assert3(i6 < m6);
          var b4 = this.pow(c5, new BN4(1).iushln(m6 - i6 - 1));
          r6 = r6.redMul(b4);
          c5 = b4.redSqr();
          t6 = t6.redMul(c5);
          m6 = i6;
        }
        return r6;
      };
      Red.prototype.invm = function invm(a5) {
        var inv = a5._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a5, num) {
        if (num.isZero())
          return new BN4(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a5.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN4(1).toRed(this);
        wnd[1] = a5;
        for (var i6 = 2; i6 < wnd.length; i6++) {
          wnd[i6] = this.mul(wnd[i6 - 1], a5);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i6 = num.length - 1; i6 >= 0; i6--) {
          var word = num.words[i6];
          for (var j8 = start - 1; j8 >= 0; j8--) {
            var bit = word >> j8 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i6 !== 0 || j8 !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r6 = num.umod(this.m);
        return r6 === num ? r6.clone() : r6;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN4.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m6) {
        Red.call(this, m6);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN4(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r6 = this.imod(num.mul(this.rinv));
        r6.red = null;
        return r6;
      };
      Mont.prototype.imul = function imul(a5, b4) {
        if (a5.isZero() || b4.isZero()) {
          a5.words[0] = 0;
          a5.length = 1;
          return a5;
        }
        var t6 = a5.imul(b4);
        var c5 = t6.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u7 = t6.isub(c5).iushrn(this.shift);
        var res = u7;
        if (u7.cmp(this.m) >= 0) {
          res = u7.isub(this.m);
        } else if (u7.cmpn(0) < 0) {
          res = u7.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul3(a5, b4) {
        if (a5.isZero() || b4.isZero())
          return new BN4(0)._forceRed(this);
        var t6 = a5.mul(b4);
        var c5 = t6.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u7 = t6.isub(c5).iushrn(this.shift);
        var res = u7;
        if (u7.cmp(this.m) >= 0) {
          res = u7.isub(this.m);
        } else if (u7.cmpn(0) < 0) {
          res = u7.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a5) {
        var res = this.imod(a5._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module2 === "undefined" || module2, exports2);
  }
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports2) {
    "use strict";
    exports2.byteLength = byteLength;
    exports2.toByteArray = toByteArray;
    exports2.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i6 = 0, len = code.length; i6 < len; ++i6) {
      lookup[i6] = code[i6];
      revLookup[code.charCodeAt(i6)] = i6;
    }
    var i6;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i7;
      for (i7 = 0; i7 < len2; i7 += 4) {
        tmp = revLookup[b64.charCodeAt(i7)] << 18 | revLookup[b64.charCodeAt(i7 + 1)] << 12 | revLookup[b64.charCodeAt(i7 + 2)] << 6 | revLookup[b64.charCodeAt(i7 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i7)] << 2 | revLookup[b64.charCodeAt(i7 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i7)] << 10 | revLookup[b64.charCodeAt(i7 + 1)] << 4 | revLookup[b64.charCodeAt(i7 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i7 = start; i7 < end; i7 += 3) {
        tmp = (uint8[i7] << 16 & 16711680) + (uint8[i7 + 1] << 8 & 65280) + (uint8[i7 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i7 = 0, len22 = len2 - extraBytes; i7 < len22; i7 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i7, i7 + maxChunkLength > len22 ? len22 : i7 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports2) {
    exports2.read = function(buffer2, offset, isLE, mLen, nBytes) {
      var e6, m6;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i6 = isLE ? nBytes - 1 : 0;
      var d6 = isLE ? -1 : 1;
      var s6 = buffer2[offset + i6];
      i6 += d6;
      e6 = s6 & (1 << -nBits) - 1;
      s6 >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e6 = e6 * 256 + buffer2[offset + i6], i6 += d6, nBits -= 8) {
      }
      m6 = e6 & (1 << -nBits) - 1;
      e6 >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m6 = m6 * 256 + buffer2[offset + i6], i6 += d6, nBits -= 8) {
      }
      if (e6 === 0) {
        e6 = 1 - eBias;
      } else if (e6 === eMax) {
        return m6 ? NaN : (s6 ? -1 : 1) * Infinity;
      } else {
        m6 = m6 + Math.pow(2, mLen);
        e6 = e6 - eBias;
      }
      return (s6 ? -1 : 1) * m6 * Math.pow(2, e6 - mLen);
    };
    exports2.write = function(buffer2, value2, offset, isLE, mLen, nBytes) {
      var e6, m6, c5;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt2 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i6 = isLE ? 0 : nBytes - 1;
      var d6 = isLE ? 1 : -1;
      var s6 = value2 < 0 || value2 === 0 && 1 / value2 < 0 ? 1 : 0;
      value2 = Math.abs(value2);
      if (isNaN(value2) || value2 === Infinity) {
        m6 = isNaN(value2) ? 1 : 0;
        e6 = eMax;
      } else {
        e6 = Math.floor(Math.log(value2) / Math.LN2);
        if (value2 * (c5 = Math.pow(2, -e6)) < 1) {
          e6--;
          c5 *= 2;
        }
        if (e6 + eBias >= 1) {
          value2 += rt2 / c5;
        } else {
          value2 += rt2 * Math.pow(2, 1 - eBias);
        }
        if (value2 * c5 >= 2) {
          e6++;
          c5 /= 2;
        }
        if (e6 + eBias >= eMax) {
          m6 = 0;
          e6 = eMax;
        } else if (e6 + eBias >= 1) {
          m6 = (value2 * c5 - 1) * Math.pow(2, mLen);
          e6 = e6 + eBias;
        } else {
          m6 = value2 * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e6 = 0;
        }
      }
      for (; mLen >= 8; buffer2[offset + i6] = m6 & 255, i6 += d6, m6 /= 256, mLen -= 8) {
      }
      e6 = e6 << mLen | m6;
      eLen += mLen;
      for (; eLen > 0; buffer2[offset + i6] = e6 & 255, i6 += d6, e6 /= 256, eLen -= 8) {
      }
      buffer2[offset + i6 - d6] |= s6 * 128;
    };
  }
});

// node_modules/keccak256/node_modules/buffer/index.js
var require_buffer2 = __commonJS({
  "node_modules/keccak256/node_modules/buffer/index.js"(exports2) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports2.Buffer = Buffer2;
    exports2.SlowBuffer = SlowBuffer;
    exports2.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports2.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e6) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function Buffer2(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from2(arg, encodingOrOffset, length);
    }
    Buffer2.poolSize = 8192;
    function from2(value2, encodingOrOffset, length) {
      if (typeof value2 === "string") {
        return fromString(value2, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value2)) {
        return fromArrayView(value2);
      }
      if (value2 == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value2
        );
      }
      if (isInstance(value2, ArrayBuffer) || value2 && isInstance(value2.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value2, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value2, SharedArrayBuffer) || value2 && isInstance(value2.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value2, encodingOrOffset, length);
      }
      if (typeof value2 === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value2.valueOf && value2.valueOf();
      if (valueOf != null && valueOf !== value2) {
        return Buffer2.from(valueOf, encodingOrOffset, length);
      }
      const b4 = fromObject(value2);
      if (b4)
        return b4;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value2[Symbol.toPrimitive] === "function") {
        return Buffer2.from(value2[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value2
      );
    }
    Buffer2.from = function(value2, encodingOrOffset, length) {
      return from2(value2, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);
      for (let i6 = 0; i6 < length; i6 += 1) {
        buf[i6] = array[i6] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer2.alloc(+length);
    }
    Buffer2.isBuffer = function isBuffer2(b4) {
      return b4 != null && b4._isBuffer === true && b4 !== Buffer2.prototype;
    };
    Buffer2.compare = function compare(a5, b4) {
      if (isInstance(a5, Uint8Array))
        a5 = Buffer2.from(a5, a5.offset, a5.byteLength);
      if (isInstance(b4, Uint8Array))
        b4 = Buffer2.from(b4, b4.offset, b4.byteLength);
      if (!Buffer2.isBuffer(a5) || !Buffer2.isBuffer(b4)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a5 === b4)
        return 0;
      let x6 = a5.length;
      let y5 = b4.length;
      for (let i6 = 0, len = Math.min(x6, y5); i6 < len; ++i6) {
        if (a5[i6] !== b4[i6]) {
          x6 = a5[i6];
          y5 = b4[i6];
          break;
        }
      }
      if (x6 < y5)
        return -1;
      if (y5 < x6)
        return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat4(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      let i6;
      if (length === void 0) {
        length = 0;
        for (i6 = 0; i6 < list.length; ++i6) {
          length += list[i6].length;
        }
      }
      const buffer2 = Buffer2.allocUnsafe(length);
      let pos = 0;
      for (i6 = 0; i6 < list.length; ++i6) {
        let buf = list[i6];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer2.length) {
            if (!Buffer2.isBuffer(buf))
              buf = Buffer2.from(buf);
            buf.copy(buffer2, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer2,
              buf,
              pos
            );
          }
        } else if (!Buffer2.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer2, pos);
        }
        pos += buf.length;
      }
      return buffer2;
    };
    function byteLength(string, encoding) {
      if (Buffer2.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b4, n4, m6) {
      const i6 = b4[n4];
      b4[n4] = b4[m6];
      b4[m6] = i6;
    }
    Buffer2.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i6 = 0; i6 < len; i6 += 2) {
        swap(this, i6, i6 + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i6 = 0; i6 < len; i6 += 4) {
        swap(this, i6, i6 + 3);
        swap(this, i6 + 1, i6 + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i6 = 0; i6 < len; i6 += 8) {
        swap(this, i6, i6 + 7);
        swap(this, i6 + 1, i6 + 6);
        swap(this, i6 + 2, i6 + 5);
        swap(this, i6 + 3, i6 + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString2() {
      const length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals(b4) {
      if (!Buffer2.isBuffer(b4))
        throw new TypeError("Argument must be a Buffer");
      if (this === b4)
        return true;
      return Buffer2.compare(this, b4) === 0;
    };
    Buffer2.prototype.inspect = function inspect4() {
      let str = "";
      const max2 = exports2.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max2)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      let x6 = thisEnd - thisStart;
      let y5 = end - start;
      const len = Math.min(x6, y5);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i6 = 0; i6 < len; ++i6) {
        if (thisCopy[i6] !== targetCopy[i6]) {
          x6 = thisCopy[i6];
          y5 = targetCopy[i6];
          break;
        }
      }
      if (x6 < y5)
        return -1;
      if (y5 < x6)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
      if (buffer2.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer2.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer2.length + byteOffset;
      if (byteOffset >= buffer2.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer2.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i7) {
        if (indexSize === 1) {
          return buf[i7];
        } else {
          return buf.readUInt16BE(i7 * indexSize);
        }
      }
      let i6;
      if (dir) {
        let foundIndex = -1;
        for (i6 = byteOffset; i6 < arrLength; i6++) {
          if (read(arr, i6) === read(val, foundIndex === -1 ? 0 : i6 - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i6;
            if (i6 - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i6 -= i6 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i6 = byteOffset; i6 >= 0; i6--) {
          let found = true;
          for (let j8 = 0; j8 < valLength; j8++) {
            if (read(arr, i6 + j8) !== read(val, j8)) {
              found = false;
              break;
            }
          }
          if (found)
            return i6;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i6;
      for (i6 = 0; i6 < length; ++i6) {
        const parsed = parseInt(string.substr(i6 * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i6;
        buf[offset + i6] = parsed;
      }
      return i6;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer2.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON2() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i6 = start;
      while (i6 < end) {
        const firstByte = buf[i6];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i6 + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i6 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i6 + 1];
              thirdByte = buf[i6 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i6 + 1];
              thirdByte = buf[i6 + 2];
              fourthByte = buf[i6 + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i6 += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i6 = 0;
      while (i6 < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i6, i6 += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i6 = start; i6 < end; ++i6) {
        ret += String.fromCharCode(buf[i6] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i6 = start; i6 < end; ++i6) {
        ret += String.fromCharCode(buf[i6]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      let out = "";
      for (let i6 = start; i6 < end; ++i6) {
        out += hexSliceLookupTable[buf[i6]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i6 = 0; i6 < bytes.length - 1; i6 += 2) {
        res += String.fromCharCode(bytes[i6] + bytes[i6 + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul3 = 1;
      let i6 = 0;
      while (++i6 < byteLength2 && (mul3 *= 256)) {
        val += this[offset + i6] * mul3;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul3 = 1;
      while (byteLength2 > 0 && (mul3 *= 256)) {
        val += this[offset + --byteLength2] * mul3;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first2 = this[offset];
      const last2 = this[offset + 7];
      if (first2 === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first2 + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi2 = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last2 * 2 ** 24;
      return BigInt(lo) + (BigInt(hi2) << BigInt(32));
    });
    Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first2 = this[offset];
      const last2 = this[offset + 7];
      if (first2 === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi2 = first2 * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2;
      return (BigInt(hi2) << BigInt(32)) + BigInt(lo);
    });
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul3 = 1;
      let i6 = 0;
      while (++i6 < byteLength2 && (mul3 *= 256)) {
        val += this[offset + i6] * mul3;
      }
      mul3 *= 128;
      if (val >= mul3)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let i6 = byteLength2;
      let mul3 = 1;
      let val = this[offset + --i6];
      while (i6 > 0 && (mul3 *= 256)) {
        val += this[offset + --i6] * mul3;
      }
      mul3 *= 128;
      if (val >= mul3)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first2 = this[offset];
      const last2 = this[offset + 7];
      if (first2 === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last2 << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first2 + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first2 = this[offset];
      const last2 = this[offset + 7];
      if (first2 === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first2 << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2);
    });
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value2, offset, ext, max2, min2) {
      if (!Buffer2.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value2 > max2 || value2 < min2)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value2, offset, byteLength2, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value2, offset, byteLength2, maxBytes, 0);
      }
      let mul3 = 1;
      let i6 = 0;
      this[offset] = value2 & 255;
      while (++i6 < byteLength2 && (mul3 *= 256)) {
        this[offset + i6] = value2 / mul3 & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value2, offset, byteLength2, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value2, offset, byteLength2, maxBytes, 0);
      }
      let i6 = byteLength2 - 1;
      let mul3 = 1;
      this[offset + i6] = value2 & 255;
      while (--i6 >= 0 && (mul3 *= 256)) {
        this[offset + i6] = value2 / mul3 & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 1, 255, 0);
      this[offset] = value2 & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 2, 65535, 0);
      this[offset] = value2 & 255;
      this[offset + 1] = value2 >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 2, 65535, 0);
      this[offset] = value2 >>> 8;
      this[offset + 1] = value2 & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 4, 4294967295, 0);
      this[offset + 3] = value2 >>> 24;
      this[offset + 2] = value2 >>> 16;
      this[offset + 1] = value2 >>> 8;
      this[offset] = value2 & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 4, 4294967295, 0);
      this[offset] = value2 >>> 24;
      this[offset + 1] = value2 >>> 16;
      this[offset + 2] = value2 >>> 8;
      this[offset + 3] = value2 & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value2, offset, min2, max2) {
      checkIntBI(value2, min2, max2, buf, offset, 7);
      let lo = Number(value2 & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi2 = Number(value2 >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi2;
      hi2 = hi2 >> 8;
      buf[offset++] = hi2;
      hi2 = hi2 >> 8;
      buf[offset++] = hi2;
      hi2 = hi2 >> 8;
      buf[offset++] = hi2;
      return offset;
    }
    function wrtBigUInt64BE(buf, value2, offset, min2, max2) {
      checkIntBI(value2, min2, max2, buf, offset, 7);
      let lo = Number(value2 & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi2 = Number(value2 >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi2;
      hi2 = hi2 >> 8;
      buf[offset + 2] = hi2;
      hi2 = hi2 >> 8;
      buf[offset + 1] = hi2;
      hi2 = hi2 >> 8;
      buf[offset] = hi2;
      return offset + 8;
    }
    Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value2, offset = 0) {
      return wrtBigUInt64LE(this, value2, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value2, offset = 0) {
      return wrtBigUInt64BE(this, value2, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeIntLE = function writeIntLE(value2, offset, byteLength2, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value2, offset, byteLength2, limit - 1, -limit);
      }
      let i6 = 0;
      let mul3 = 1;
      let sub = 0;
      this[offset] = value2 & 255;
      while (++i6 < byteLength2 && (mul3 *= 256)) {
        if (value2 < 0 && sub === 0 && this[offset + i6 - 1] !== 0) {
          sub = 1;
        }
        this[offset + i6] = (value2 / mul3 >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value2, offset, byteLength2, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value2, offset, byteLength2, limit - 1, -limit);
      }
      let i6 = byteLength2 - 1;
      let mul3 = 1;
      let sub = 0;
      this[offset + i6] = value2 & 255;
      while (--i6 >= 0 && (mul3 *= 256)) {
        if (value2 < 0 && sub === 0 && this[offset + i6 + 1] !== 0) {
          sub = 1;
        }
        this[offset + i6] = (value2 / mul3 >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 1, 127, -128);
      if (value2 < 0)
        value2 = 255 + value2 + 1;
      this[offset] = value2 & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 2, 32767, -32768);
      this[offset] = value2 & 255;
      this[offset + 1] = value2 >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 2, 32767, -32768);
      this[offset] = value2 >>> 8;
      this[offset + 1] = value2 & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 4, 2147483647, -2147483648);
      this[offset] = value2 & 255;
      this[offset + 1] = value2 >>> 8;
      this[offset + 2] = value2 >>> 16;
      this[offset + 3] = value2 >>> 24;
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 4, 2147483647, -2147483648);
      if (value2 < 0)
        value2 = 4294967295 + value2 + 1;
      this[offset] = value2 >>> 24;
      this[offset + 1] = value2 >>> 16;
      this[offset + 2] = value2 >>> 8;
      this[offset + 3] = value2 & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value2, offset = 0) {
      return wrtBigUInt64LE(this, value2, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value2, offset = 0) {
      return wrtBigUInt64BE(this, value2, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value2, offset, ext, max2, min2) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value2, offset, littleEndian, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value2, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value2, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value2, offset, noAssert) {
      return writeFloat(this, value2, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value2, offset, noAssert) {
      return writeFloat(this, value2, offset, false, noAssert);
    };
    function writeDouble(buf, value2, offset, littleEndian, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value2, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value2, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value2, offset, noAssert) {
      return writeDouble(this, value2, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value2, offset, noAssert) {
      return writeDouble(this, value2, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      let i6;
      if (typeof val === "number") {
        for (i6 = start; i6 < end; ++i6) {
          this[i6] = val;
        }
      } else {
        const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i6 = 0; i6 < end - start; ++i6) {
          this[i6 + start] = bytes[i6 % len];
        }
      }
      return this;
    };
    var errors = {};
    function E5(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value2) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value: value2,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E5(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name2) {
        if (name2) {
          return `${name2} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E5(
      "ERR_INVALID_ARG_TYPE",
      function(name2, actual) {
        return `The "${name2}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E5(
      "ERR_OUT_OF_RANGE",
      function(str, range2, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range2}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i6 = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i6 >= start + 4; i6 -= 3) {
        res = `_${val.slice(i6 - 3, i6)}${res}`;
      }
      return `${val.slice(0, i6)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value2, min2, max2, buf, offset, byteLength2) {
      if (value2 > max2 || value2 < min2) {
        const n4 = typeof min2 === "bigint" ? "n" : "";
        let range2;
        if (byteLength2 > 3) {
          if (min2 === 0 || min2 === BigInt(0)) {
            range2 = `>= 0${n4} and < 2${n4} ** ${(byteLength2 + 1) * 8}${n4}`;
          } else {
            range2 = `>= -(2${n4} ** ${(byteLength2 + 1) * 8 - 1}${n4}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n4}`;
          }
        } else {
          range2 = `>= ${min2}${n4} and <= ${max2}${n4}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range2, value2);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value2, name2) {
      if (typeof value2 !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name2, "number", value2);
      }
    }
    function boundsError(value2, length, type) {
      if (Math.floor(value2) !== value2) {
        validateNumber(value2, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value2);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        type || "offset",
        `>= ${type ? 1 : 0} and <= ${length}`,
        value2
      );
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i6 = 0; i6 < length; ++i6) {
        codePoint = string.charCodeAt(i6);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i6 + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i6 = 0; i6 < str.length; ++i6) {
        byteArray.push(str.charCodeAt(i6) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c5, hi2, lo;
      const byteArray = [];
      for (let i6 = 0; i6 < str.length; ++i6) {
        if ((units -= 2) < 0)
          break;
        c5 = str.charCodeAt(i6);
        hi2 = c5 >> 8;
        lo = c5 % 256;
        byteArray.push(lo);
        byteArray.push(hi2);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      let i6;
      for (i6 = 0; i6 < length; ++i6) {
        if (i6 + offset >= dst.length || i6 >= src.length)
          break;
        dst[i6 + offset] = src[i6];
      }
      return i6;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i6 = 0; i6 < 16; ++i6) {
        const i16 = i6 * 16;
        for (let j8 = 0; j8 < 16; ++j8) {
          table[i16 + j8] = alphabet[i6] + alphabet[j8];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn2) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn2;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/events/events.js"(exports2, module2) {
    "use strict";
    var R4 = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R4 && typeof R4.apply === "function" ? R4.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R4 && typeof R4.ownKeys === "function") {
      ReflectOwnKeys = R4.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn)
        console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value2) {
      return value2 !== value2;
    };
    function EventEmitter6() {
      EventEmitter6.init.call(this);
    }
    module2.exports = EventEmitter6;
    module2.exports.once = once;
    EventEmitter6.EventEmitter = EventEmitter6;
    EventEmitter6.prototype._events = void 0;
    EventEmitter6.prototype._eventsCount = 0;
    EventEmitter6.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter6, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter6.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter6.prototype.setMaxListeners = function setMaxListeners(n4) {
      if (typeof n4 !== "number" || n4 < 0 || NumberIsNaN(n4)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n4 + ".");
      }
      this._maxListeners = n4;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter6.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter6.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter6.prototype.emit = function emit(type) {
      var args = [];
      for (var i6 = 1; i6 < arguments.length; i6++)
        args.push(arguments[i6]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er2;
        if (args.length > 0)
          er2 = args[0];
        if (er2 instanceof Error) {
          throw er2;
        }
        var err = new Error("Unhandled error." + (er2 ? " (" + er2.message + ")" : ""));
        err.context = er2;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i6 = 0; i6 < len; ++i6)
          ReflectApply(listeners[i6], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m6;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === void 0) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m6 = _getMaxListeners(target);
        if (m6 > 0 && existing.length > m6 && !existing.warned) {
          existing.warned = true;
          var w8 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w8.name = "MaxListenersExceededWarning";
          w8.emitter = target;
          w8.type = type;
          w8.count = existing.length;
          ProcessEmitWarning(w8);
        }
      }
      return target;
    }
    EventEmitter6.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter6.prototype.on = EventEmitter6.prototype.addListener;
    EventEmitter6.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter6.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter6.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter6.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i6, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list = events[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i6 = list.length - 1; i6 >= 0; i6--) {
          if (list[i6] === listener || list[i6].listener === listener) {
            originalListener = list[i6].listener;
            position = i6;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events[type] = list[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter6.prototype.off = EventEmitter6.prototype.removeListener;
    EventEmitter6.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events, i6;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key2;
        for (i6 = 0; i6 < keys.length; ++i6) {
          key2 = keys[i6];
          if (key2 === "removeListener")
            continue;
          this.removeAllListeners(key2);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i6 = listeners.length - 1; i6 >= 0; i6--) {
          this.removeListener(type, listeners[i6]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter6.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter6.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter6.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter6.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter6.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n4) {
      var copy = new Array(n4);
      for (var i6 = 0; i6 < n4; ++i6)
        copy[i6] = arr[i6];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i6 = 0; i6 < ret.length; ++i6) {
        ret[i6] = arr[i6].listener || arr[i6];
      }
      return ret;
    }
    function once(emitter, name2) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name2, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name2, resolver, { once: true });
        if (name2 !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name2, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name2, listener);
        } else {
          emitter.on(name2, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name2, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name2, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/stream-browser.js
var require_stream_browser = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports2, module2) {
    module2.exports = require_events().EventEmitter;
  }
});

// node_modules/buffer/index.js
var require_buffer3 = __commonJS({
  "node_modules/buffer/index.js"(exports2) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports2.Buffer = Buffer2;
    exports2.SlowBuffer = SlowBuffer;
    exports2.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports2.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        var arr = new Uint8Array(1);
        var proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e6) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      var buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function Buffer2(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from2(arg, encodingOrOffset, length);
    }
    Buffer2.poolSize = 8192;
    function from2(value2, encodingOrOffset, length) {
      if (typeof value2 === "string") {
        return fromString(value2, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value2)) {
        return fromArrayView(value2);
      }
      if (value2 == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value2
        );
      }
      if (isInstance(value2, ArrayBuffer) || value2 && isInstance(value2.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value2, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value2, SharedArrayBuffer) || value2 && isInstance(value2.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value2, encodingOrOffset, length);
      }
      if (typeof value2 === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      var valueOf = value2.valueOf && value2.valueOf();
      if (valueOf != null && valueOf !== value2) {
        return Buffer2.from(valueOf, encodingOrOffset, length);
      }
      var b4 = fromObject(value2);
      if (b4)
        return b4;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value2[Symbol.toPrimitive] === "function") {
        return Buffer2.from(
          value2[Symbol.toPrimitive]("string"),
          encodingOrOffset,
          length
        );
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value2
      );
    }
    Buffer2.from = function(value2, encodingOrOffset, length) {
      return from2(value2, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      var length = byteLength(string, encoding) | 0;
      var buf = createBuffer(length);
      var actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      var buf = createBuffer(length);
      for (var i6 = 0; i6 < length; i6 += 1) {
        buf[i6] = array[i6] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      var buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer2.alloc(+length);
    }
    Buffer2.isBuffer = function isBuffer2(b4) {
      return b4 != null && b4._isBuffer === true && b4 !== Buffer2.prototype;
    };
    Buffer2.compare = function compare(a5, b4) {
      if (isInstance(a5, Uint8Array))
        a5 = Buffer2.from(a5, a5.offset, a5.byteLength);
      if (isInstance(b4, Uint8Array))
        b4 = Buffer2.from(b4, b4.offset, b4.byteLength);
      if (!Buffer2.isBuffer(a5) || !Buffer2.isBuffer(b4)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a5 === b4)
        return 0;
      var x6 = a5.length;
      var y5 = b4.length;
      for (var i6 = 0, len = Math.min(x6, y5); i6 < len; ++i6) {
        if (a5[i6] !== b4[i6]) {
          x6 = a5[i6];
          y5 = b4[i6];
          break;
        }
      }
      if (x6 < y5)
        return -1;
      if (y5 < x6)
        return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat4(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      var i6;
      if (length === void 0) {
        length = 0;
        for (i6 = 0; i6 < list.length; ++i6) {
          length += list[i6].length;
        }
      }
      var buffer2 = Buffer2.allocUnsafe(length);
      var pos = 0;
      for (i6 = 0; i6 < list.length; ++i6) {
        var buf = list[i6];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer2.length) {
            Buffer2.from(buf).copy(buffer2, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer2,
              buf,
              pos
            );
          }
        } else if (!Buffer2.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer2, pos);
        }
        pos += buf.length;
      }
      return buffer2;
    };
    function byteLength(string, encoding) {
      if (Buffer2.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      var len = string.length;
      var mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      var loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b4, n4, m6) {
      var i6 = b4[n4];
      b4[n4] = b4[m6];
      b4[m6] = i6;
    }
    Buffer2.prototype.swap16 = function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i6 = 0; i6 < len; i6 += 2) {
        swap(this, i6, i6 + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i6 = 0; i6 < len; i6 += 4) {
        swap(this, i6, i6 + 3);
        swap(this, i6 + 1, i6 + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i6 = 0; i6 < len; i6 += 8) {
        swap(this, i6, i6 + 7);
        swap(this, i6 + 1, i6 + 6);
        swap(this, i6 + 2, i6 + 5);
        swap(this, i6 + 3, i6 + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString2() {
      var length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals(b4) {
      if (!Buffer2.isBuffer(b4))
        throw new TypeError("Argument must be a Buffer");
      if (this === b4)
        return true;
      return Buffer2.compare(this, b4) === 0;
    };
    Buffer2.prototype.inspect = function inspect4() {
      var str = "";
      var max2 = exports2.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max2)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      var x6 = thisEnd - thisStart;
      var y5 = end - start;
      var len = Math.min(x6, y5);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i6 = 0; i6 < len; ++i6) {
        if (thisCopy[i6] !== targetCopy[i6]) {
          x6 = thisCopy[i6];
          y5 = targetCopy[i6];
          break;
        }
      }
      if (x6 < y5)
        return -1;
      if (y5 < x6)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
      if (buffer2.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer2.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer2.length + byteOffset;
      if (byteOffset >= buffer2.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer2.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i7) {
        if (indexSize === 1) {
          return buf[i7];
        } else {
          return buf.readUInt16BE(i7 * indexSize);
        }
      }
      var i6;
      if (dir) {
        var foundIndex = -1;
        for (i6 = byteOffset; i6 < arrLength; i6++) {
          if (read(arr, i6) === read(val, foundIndex === -1 ? 0 : i6 - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i6;
            if (i6 - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i6 -= i6 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i6 = byteOffset; i6 >= 0; i6--) {
          var found = true;
          for (var j8 = 0; j8 < valLength; j8++) {
            if (read(arr, i6 + j8) !== read(val, j8)) {
              found = false;
              break;
            }
          }
          if (found)
            return i6;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      var strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      for (var i6 = 0; i6 < length; ++i6) {
        var parsed = parseInt(string.substr(i6 * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i6;
        buf[offset + i6] = parsed;
      }
      return i6;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer2.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON2() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];
      var i6 = start;
      while (i6 < end) {
        var firstByte = buf[i6];
        var codePoint = null;
        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i6 + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i6 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i6 + 1];
              thirdByte = buf[i6 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i6 + 1];
              thirdByte = buf[i6 + 2];
              fourthByte = buf[i6 + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i6 += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      var res = "";
      var i6 = 0;
      while (i6 < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i6, i6 += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i6 = start; i6 < end; ++i6) {
        ret += String.fromCharCode(buf[i6] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i6 = start; i6 < end; ++i6) {
        ret += String.fromCharCode(buf[i6]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      var len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      var out = "";
      for (var i6 = start; i6 < end; ++i6) {
        out += hexSliceLookupTable[buf[i6]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = "";
      for (var i6 = 0; i6 < bytes.length - 1; i6 += 2) {
        res += String.fromCharCode(bytes[i6] + bytes[i6 + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul3 = 1;
      var i6 = 0;
      while (++i6 < byteLength2 && (mul3 *= 256)) {
        val += this[offset + i6] * mul3;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      var val = this[offset + --byteLength2];
      var mul3 = 1;
      while (byteLength2 > 0 && (mul3 *= 256)) {
        val += this[offset + --byteLength2] * mul3;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul3 = 1;
      var i6 = 0;
      while (++i6 < byteLength2 && (mul3 *= 256)) {
        val += this[offset + i6] * mul3;
      }
      mul3 *= 128;
      if (val >= mul3)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var i6 = byteLength2;
      var mul3 = 1;
      var val = this[offset + --i6];
      while (i6 > 0 && (mul3 *= 256)) {
        val += this[offset + --i6] * mul3;
      }
      mul3 *= 128;
      if (val >= mul3)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value2, offset, ext, max2, min2) {
      if (!Buffer2.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value2 > max2 || value2 < min2)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value2, offset, byteLength2, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value2, offset, byteLength2, maxBytes, 0);
      }
      var mul3 = 1;
      var i6 = 0;
      this[offset] = value2 & 255;
      while (++i6 < byteLength2 && (mul3 *= 256)) {
        this[offset + i6] = value2 / mul3 & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value2, offset, byteLength2, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value2, offset, byteLength2, maxBytes, 0);
      }
      var i6 = byteLength2 - 1;
      var mul3 = 1;
      this[offset + i6] = value2 & 255;
      while (--i6 >= 0 && (mul3 *= 256)) {
        this[offset + i6] = value2 / mul3 & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 1, 255, 0);
      this[offset] = value2 & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 2, 65535, 0);
      this[offset] = value2 & 255;
      this[offset + 1] = value2 >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 2, 65535, 0);
      this[offset] = value2 >>> 8;
      this[offset + 1] = value2 & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 4, 4294967295, 0);
      this[offset + 3] = value2 >>> 24;
      this[offset + 2] = value2 >>> 16;
      this[offset + 1] = value2 >>> 8;
      this[offset] = value2 & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 4, 4294967295, 0);
      this[offset] = value2 >>> 24;
      this[offset + 1] = value2 >>> 16;
      this[offset + 2] = value2 >>> 8;
      this[offset + 3] = value2 & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeIntLE = function writeIntLE(value2, offset, byteLength2, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value2, offset, byteLength2, limit - 1, -limit);
      }
      var i6 = 0;
      var mul3 = 1;
      var sub = 0;
      this[offset] = value2 & 255;
      while (++i6 < byteLength2 && (mul3 *= 256)) {
        if (value2 < 0 && sub === 0 && this[offset + i6 - 1] !== 0) {
          sub = 1;
        }
        this[offset + i6] = (value2 / mul3 >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value2, offset, byteLength2, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value2, offset, byteLength2, limit - 1, -limit);
      }
      var i6 = byteLength2 - 1;
      var mul3 = 1;
      var sub = 0;
      this[offset + i6] = value2 & 255;
      while (--i6 >= 0 && (mul3 *= 256)) {
        if (value2 < 0 && sub === 0 && this[offset + i6 + 1] !== 0) {
          sub = 1;
        }
        this[offset + i6] = (value2 / mul3 >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 1, 127, -128);
      if (value2 < 0)
        value2 = 255 + value2 + 1;
      this[offset] = value2 & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 2, 32767, -32768);
      this[offset] = value2 & 255;
      this[offset + 1] = value2 >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 2, 32767, -32768);
      this[offset] = value2 >>> 8;
      this[offset + 1] = value2 & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 4, 2147483647, -2147483648);
      this[offset] = value2 & 255;
      this[offset + 1] = value2 >>> 8;
      this[offset + 2] = value2 >>> 16;
      this[offset + 3] = value2 >>> 24;
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 4, 2147483647, -2147483648);
      if (value2 < 0)
        value2 = 4294967295 + value2 + 1;
      this[offset] = value2 >>> 24;
      this[offset + 1] = value2 >>> 16;
      this[offset + 2] = value2 >>> 8;
      this[offset + 3] = value2 & 255;
      return offset + 4;
    };
    function checkIEEE754(buf, value2, offset, ext, max2, min2) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value2, offset, littleEndian, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value2, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value2, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value2, offset, noAssert) {
      return writeFloat(this, value2, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value2, offset, noAssert) {
      return writeFloat(this, value2, offset, false, noAssert);
    };
    function writeDouble(buf, value2, offset, littleEndian, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value2, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value2, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value2, offset, noAssert) {
      return writeDouble(this, value2, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value2, offset, noAssert) {
      return writeDouble(this, value2, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i6;
      if (typeof val === "number") {
        for (i6 = start; i6 < end; ++i6) {
          this[i6] = val;
        }
      } else {
        var bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        var len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i6 = 0; i6 < end - start; ++i6) {
          this[i6 + start] = bytes[i6 % len];
        }
      }
      return this;
    };
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];
      for (var i6 = 0; i6 < length; ++i6) {
        codePoint = string.charCodeAt(i6);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i6 + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      var byteArray = [];
      for (var i6 = 0; i6 < str.length; ++i6) {
        byteArray.push(str.charCodeAt(i6) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      var c5, hi2, lo;
      var byteArray = [];
      for (var i6 = 0; i6 < str.length; ++i6) {
        if ((units -= 2) < 0)
          break;
        c5 = str.charCodeAt(i6);
        hi2 = c5 >> 8;
        lo = c5 % 256;
        byteArray.push(lo);
        byteArray.push(hi2);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      for (var i6 = 0; i6 < length; ++i6) {
        if (i6 + offset >= dst.length || i6 >= src.length)
          break;
        dst[i6 + offset] = src[i6];
      }
      return i6;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      var alphabet = "0123456789abcdef";
      var table = new Array(256);
      for (var i6 = 0; i6 < 16; ++i6) {
        var i16 = i6 * 16;
        for (var j8 = 0; j8 < 16; ++j8) {
          table[i16 + j8] = alphabet[i6] + alphabet[j8];
        }
      }
      return table;
    }();
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports2, module2) {
    "use strict";
    module2.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS({
  "node_modules/has-tostringtag/shams.js"(exports2, module2) {
    "use strict";
    var hasSymbols = require_shams();
    module2.exports = function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports2, module2) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module2.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports2, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var slice = Array.prototype.slice;
    var toStr = Object.prototype.toString;
    var funcType = "[object Function]";
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slice.call(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            args.concat(slice.call(arguments))
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        } else {
          return target.apply(
            that,
            args.concat(slice.call(arguments))
          );
        }
      };
      var boundLength = Math.max(0, target.length - args.length);
      var boundArgs = [];
      for (var i6 = 0; i6 < boundLength; i6++) {
        boundArgs.push("$" + i6);
      }
      bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/has/src/index.js
var require_src = __commonJS({
  "node_modules/has/src/index.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    module2.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports2, module2) {
    "use strict";
    var undefined2;
    var $SyntaxError = SyntaxError;
    var $Function = Function;
    var $TypeError = TypeError;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e6) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e6) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = Object.getPrototypeOf || function(x6) {
      return x6.__proto__;
    };
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%eval%": eval,
      "%EvalError%": EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": RangeError,
      "%ReferenceError%": ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
    };
    var doEval = function doEval2(name2) {
      var value2;
      if (name2 === "%AsyncFunction%") {
        value2 = getEvalledConstructor("async function () {}");
      } else if (name2 === "%GeneratorFunction%") {
        value2 = getEvalledConstructor("function* () {}");
      } else if (name2 === "%AsyncGeneratorFunction%") {
        value2 = getEvalledConstructor("async function* () {}");
      } else if (name2 === "%AsyncGenerator%") {
        var fn2 = doEval2("%AsyncGeneratorFunction%");
        if (fn2) {
          value2 = fn2.prototype;
        }
      } else if (name2 === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen) {
          value2 = getProto(gen.prototype);
        }
      }
      INTRINSICS[name2] = value2;
      return value2;
    };
    var LEGACY_ALIASES = {
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_src();
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var $strSlice = bind.call(Function.call, String.prototype.slice);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first2 = $strSlice(string, 0, 1);
      var last2 = $strSlice(string, -1);
      if (first2 === "%" && last2 !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last2 === "%" && first2 !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name2, allowMissing) {
      var intrinsicName = name2;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value2 = INTRINSICS[intrinsicName];
        if (value2 === needsEval) {
          value2 = doEval(intrinsicName);
        }
        if (typeof value2 === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name2 + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value: value2
        };
      }
      throw new $SyntaxError("intrinsic " + name2 + " does not exist!");
    };
    module2.exports = function GetIntrinsic(name2, allowMissing) {
      if (typeof name2 !== "string" || name2.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      var parts = stringToPath(name2);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value2 = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i6 = 1, isOwn = true; i6 < parts.length; i6 += 1) {
        var part = parts[i6];
        var first2 = $strSlice(part, 0, 1);
        var last2 = $strSlice(part, -1);
        if ((first2 === '"' || first2 === "'" || first2 === "`" || (last2 === '"' || last2 === "'" || last2 === "`")) && first2 !== last2) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value2 = INTRINSICS[intrinsicRealName];
        } else if (value2 != null) {
          if (!(part in value2)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name2 + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i6 + 1 >= parts.length) {
            var desc = $gOPD(value2, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value2 = desc.get;
            } else {
              value2 = value2[part];
            }
          } else {
            isOwn = hasOwn(value2, part);
            value2 = value2[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value2;
          }
        }
      }
      return value2;
    };
  }
});

// node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "node_modules/call-bind/index.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    var GetIntrinsic = require_get_intrinsic();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var $max = GetIntrinsic("%Math.max%");
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e6) {
        $defineProperty = null;
      }
    }
    module2.exports = function callBind(originalFunction) {
      var func = $reflectApply(bind, $call, arguments);
      if ($gOPD && $defineProperty) {
        var desc = $gOPD(func, "length");
        if (desc.configurable) {
          $defineProperty(
            func,
            "length",
            { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
          );
        }
      }
      return func;
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module2.exports, "apply", { value: applyBind });
    } else {
      module2.exports.apply = applyBind;
    }
  }
});

// node_modules/call-bind/callBound.js
var require_callBound = __commonJS({
  "node_modules/call-bind/callBound.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module2.exports = function callBoundIntrinsic(name2, allowMissing) {
      var intrinsic = GetIntrinsic(name2, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name2, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  }
});

// node_modules/is-arguments/index.js
var require_is_arguments = __commonJS({
  "node_modules/is-arguments/index.js"(exports2, module2) {
    "use strict";
    var hasToStringTag = require_shams2()();
    var callBound = require_callBound();
    var $toString = callBound("Object.prototype.toString");
    var isStandardArguments = function isArguments(value2) {
      if (hasToStringTag && value2 && typeof value2 === "object" && Symbol.toStringTag in value2) {
        return false;
      }
      return $toString(value2) === "[object Arguments]";
    };
    var isLegacyArguments = function isArguments(value2) {
      if (isStandardArguments(value2)) {
        return true;
      }
      return value2 !== null && typeof value2 === "object" && typeof value2.length === "number" && value2.length >= 0 && $toString(value2) !== "[object Array]" && $toString(value2.callee) === "[object Function]";
    };
    var supportsStandardArguments = function() {
      return isStandardArguments(arguments);
    }();
    isStandardArguments.isLegacyArguments = isLegacyArguments;
    module2.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
  }
});

// node_modules/is-generator-function/index.js
var require_is_generator_function = __commonJS({
  "node_modules/is-generator-function/index.js"(exports2, module2) {
    "use strict";
    var toStr = Object.prototype.toString;
    var fnToStr = Function.prototype.toString;
    var isFnRegex = /^\s*(?:function)?\*/;
    var hasToStringTag = require_shams2()();
    var getProto = Object.getPrototypeOf;
    var getGeneratorFunc = function() {
      if (!hasToStringTag) {
        return false;
      }
      try {
        return Function("return function*() {}")();
      } catch (e6) {
      }
    };
    var GeneratorFunction;
    module2.exports = function isGeneratorFunction(fn2) {
      if (typeof fn2 !== "function") {
        return false;
      }
      if (isFnRegex.test(fnToStr.call(fn2))) {
        return true;
      }
      if (!hasToStringTag) {
        var str = toStr.call(fn2);
        return str === "[object GeneratorFunction]";
      }
      if (!getProto) {
        return false;
      }
      if (typeof GeneratorFunction === "undefined") {
        var generatorFunc = getGeneratorFunc();
        GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
      }
      return getProto(fn2) === GeneratorFunction;
    };
  }
});

// node_modules/is-callable/index.js
var require_is_callable = __commonJS({
  "node_modules/is-callable/index.js"(exports2, module2) {
    "use strict";
    var fnToStr = Function.prototype.toString;
    var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
    var badArrayLike;
    var isCallableMarker;
    if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
      try {
        badArrayLike = Object.defineProperty({}, "length", {
          get: function() {
            throw isCallableMarker;
          }
        });
        isCallableMarker = {};
        reflectApply(function() {
          throw 42;
        }, null, badArrayLike);
      } catch (_8) {
        if (_8 !== isCallableMarker) {
          reflectApply = null;
        }
      }
    } else {
      reflectApply = null;
    }
    var constructorRegex = /^\s*class\b/;
    var isES6ClassFn = function isES6ClassFunction(value2) {
      try {
        var fnStr = fnToStr.call(value2);
        return constructorRegex.test(fnStr);
      } catch (e6) {
        return false;
      }
    };
    var tryFunctionObject = function tryFunctionToStr(value2) {
      try {
        if (isES6ClassFn(value2)) {
          return false;
        }
        fnToStr.call(value2);
        return true;
      } catch (e6) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var fnClass = "[object Function]";
    var genClass = "[object GeneratorFunction]";
    var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
    var documentDotAll = typeof document === "object" && typeof document.all === "undefined" && document.all !== void 0 ? document.all : {};
    module2.exports = reflectApply ? function isCallable(value2) {
      if (value2 === documentDotAll) {
        return true;
      }
      if (!value2) {
        return false;
      }
      if (typeof value2 !== "function" && typeof value2 !== "object") {
        return false;
      }
      if (typeof value2 === "function" && !value2.prototype) {
        return true;
      }
      try {
        reflectApply(value2, null, badArrayLike);
      } catch (e6) {
        if (e6 !== isCallableMarker) {
          return false;
        }
      }
      return !isES6ClassFn(value2);
    } : function isCallable(value2) {
      if (value2 === documentDotAll) {
        return true;
      }
      if (!value2) {
        return false;
      }
      if (typeof value2 !== "function" && typeof value2 !== "object") {
        return false;
      }
      if (typeof value2 === "function" && !value2.prototype) {
        return true;
      }
      if (hasToStringTag) {
        return tryFunctionObject(value2);
      }
      if (isES6ClassFn(value2)) {
        return false;
      }
      var strClass = toStr.call(value2);
      return strClass === fnClass || strClass === genClass;
    };
  }
});

// node_modules/for-each/index.js
var require_for_each = __commonJS({
  "node_modules/for-each/index.js"(exports2, module2) {
    "use strict";
    var isCallable = require_is_callable();
    var toStr = Object.prototype.toString;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var forEachArray = function forEachArray2(array, iterator2, receiver) {
      for (var i6 = 0, len = array.length; i6 < len; i6++) {
        if (hasOwnProperty.call(array, i6)) {
          if (receiver == null) {
            iterator2(array[i6], i6, array);
          } else {
            iterator2.call(receiver, array[i6], i6, array);
          }
        }
      }
    };
    var forEachString = function forEachString2(string, iterator2, receiver) {
      for (var i6 = 0, len = string.length; i6 < len; i6++) {
        if (receiver == null) {
          iterator2(string.charAt(i6), i6, string);
        } else {
          iterator2.call(receiver, string.charAt(i6), i6, string);
        }
      }
    };
    var forEachObject = function forEachObject2(object, iterator2, receiver) {
      for (var k8 in object) {
        if (hasOwnProperty.call(object, k8)) {
          if (receiver == null) {
            iterator2(object[k8], k8, object);
          } else {
            iterator2.call(receiver, object[k8], k8, object);
          }
        }
      }
    };
    var forEach = function forEach2(list, iterator2, thisArg) {
      if (!isCallable(iterator2)) {
        throw new TypeError("iterator must be a function");
      }
      var receiver;
      if (arguments.length >= 3) {
        receiver = thisArg;
      }
      if (toStr.call(list) === "[object Array]") {
        forEachArray(list, iterator2, receiver);
      } else if (typeof list === "string") {
        forEachString(list, iterator2, receiver);
      } else {
        forEachObject(list, iterator2, receiver);
      }
    };
    module2.exports = forEach;
  }
});

// node_modules/available-typed-arrays/index.js
var require_available_typed_arrays = __commonJS({
  "node_modules/available-typed-arrays/index.js"(exports2, module2) {
    "use strict";
    var possibleNames = [
      "BigInt64Array",
      "BigUint64Array",
      "Float32Array",
      "Float64Array",
      "Int16Array",
      "Int32Array",
      "Int8Array",
      "Uint16Array",
      "Uint32Array",
      "Uint8Array",
      "Uint8ClampedArray"
    ];
    var g7 = typeof globalThis === "undefined" ? global : globalThis;
    module2.exports = function availableTypedArrays() {
      var out = [];
      for (var i6 = 0; i6 < possibleNames.length; i6++) {
        if (typeof g7[possibleNames[i6]] === "function") {
          out[out.length] = possibleNames[i6];
        }
      }
      return out;
    };
  }
});

// node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js
var require_getOwnPropertyDescriptor = __commonJS({
  "node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e6) {
        $gOPD = null;
      }
    }
    module2.exports = $gOPD;
  }
});

// node_modules/is-typed-array/index.js
var require_is_typed_array = __commonJS({
  "node_modules/is-typed-array/index.js"(exports2, module2) {
    "use strict";
    var forEach = require_for_each();
    var availableTypedArrays = require_available_typed_arrays();
    var callBound = require_callBound();
    var $toString = callBound("Object.prototype.toString");
    var hasToStringTag = require_shams2()();
    var g7 = typeof globalThis === "undefined" ? global : globalThis;
    var typedArrays = availableTypedArrays();
    var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value2) {
      for (var i6 = 0; i6 < array.length; i6 += 1) {
        if (array[i6] === value2) {
          return i6;
        }
      }
      return -1;
    };
    var $slice = callBound("String.prototype.slice");
    var toStrTags = {};
    var gOPD = require_getOwnPropertyDescriptor();
    var getPrototypeOf = Object.getPrototypeOf;
    if (hasToStringTag && gOPD && getPrototypeOf) {
      forEach(typedArrays, function(typedArray) {
        var arr = new g7[typedArray]();
        if (Symbol.toStringTag in arr) {
          var proto = getPrototypeOf(arr);
          var descriptor = gOPD(proto, Symbol.toStringTag);
          if (!descriptor) {
            var superProto = getPrototypeOf(proto);
            descriptor = gOPD(superProto, Symbol.toStringTag);
          }
          toStrTags[typedArray] = descriptor.get;
        }
      });
    }
    var tryTypedArrays = function tryAllTypedArrays(value2) {
      var anyTrue = false;
      forEach(toStrTags, function(getter, typedArray) {
        if (!anyTrue) {
          try {
            anyTrue = getter.call(value2) === typedArray;
          } catch (e6) {
          }
        }
      });
      return anyTrue;
    };
    module2.exports = function isTypedArray2(value2) {
      if (!value2 || typeof value2 !== "object") {
        return false;
      }
      if (!hasToStringTag || !(Symbol.toStringTag in value2)) {
        var tag = $slice($toString(value2), 8, -1);
        return $indexOf(typedArrays, tag) > -1;
      }
      if (!gOPD) {
        return false;
      }
      return tryTypedArrays(value2);
    };
  }
});

// node_modules/which-typed-array/index.js
var require_which_typed_array = __commonJS({
  "node_modules/which-typed-array/index.js"(exports2, module2) {
    "use strict";
    var forEach = require_for_each();
    var availableTypedArrays = require_available_typed_arrays();
    var callBound = require_callBound();
    var $toString = callBound("Object.prototype.toString");
    var hasToStringTag = require_shams2()();
    var g7 = typeof globalThis === "undefined" ? global : globalThis;
    var typedArrays = availableTypedArrays();
    var $slice = callBound("String.prototype.slice");
    var toStrTags = {};
    var gOPD = require_getOwnPropertyDescriptor();
    var getPrototypeOf = Object.getPrototypeOf;
    if (hasToStringTag && gOPD && getPrototypeOf) {
      forEach(typedArrays, function(typedArray) {
        if (typeof g7[typedArray] === "function") {
          var arr = new g7[typedArray]();
          if (Symbol.toStringTag in arr) {
            var proto = getPrototypeOf(arr);
            var descriptor = gOPD(proto, Symbol.toStringTag);
            if (!descriptor) {
              var superProto = getPrototypeOf(proto);
              descriptor = gOPD(superProto, Symbol.toStringTag);
            }
            toStrTags[typedArray] = descriptor.get;
          }
        }
      });
    }
    var tryTypedArrays = function tryAllTypedArrays(value2) {
      var foundName = false;
      forEach(toStrTags, function(getter, typedArray) {
        if (!foundName) {
          try {
            var name2 = getter.call(value2);
            if (name2 === typedArray) {
              foundName = name2;
            }
          } catch (e6) {
          }
        }
      });
      return foundName;
    };
    var isTypedArray2 = require_is_typed_array();
    module2.exports = function whichTypedArray(value2) {
      if (!isTypedArray2(value2)) {
        return false;
      }
      if (!hasToStringTag || !(Symbol.toStringTag in value2)) {
        return $slice($toString(value2), 8, -1);
      }
      return tryTypedArrays(value2);
    };
  }
});

// node_modules/util/support/types.js
var require_types = __commonJS({
  "node_modules/util/support/types.js"(exports2) {
    "use strict";
    var isArgumentsObject = require_is_arguments();
    var isGeneratorFunction = require_is_generator_function();
    var whichTypedArray = require_which_typed_array();
    var isTypedArray2 = require_is_typed_array();
    function uncurryThis(f7) {
      return f7.call.bind(f7);
    }
    var BigIntSupported = typeof BigInt !== "undefined";
    var SymbolSupported = typeof Symbol !== "undefined";
    var ObjectToString = uncurryThis(Object.prototype.toString);
    var numberValue = uncurryThis(Number.prototype.valueOf);
    var stringValue = uncurryThis(String.prototype.valueOf);
    var booleanValue = uncurryThis(Boolean.prototype.valueOf);
    if (BigIntSupported) {
      bigIntValue = uncurryThis(BigInt.prototype.valueOf);
    }
    var bigIntValue;
    if (SymbolSupported) {
      symbolValue = uncurryThis(Symbol.prototype.valueOf);
    }
    var symbolValue;
    function checkBoxedPrimitive(value2, prototypeValueOf) {
      if (typeof value2 !== "object") {
        return false;
      }
      try {
        prototypeValueOf(value2);
        return true;
      } catch (e6) {
        return false;
      }
    }
    exports2.isArgumentsObject = isArgumentsObject;
    exports2.isGeneratorFunction = isGeneratorFunction;
    exports2.isTypedArray = isTypedArray2;
    function isPromise2(input) {
      return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
    }
    exports2.isPromise = isPromise2;
    function isArrayBufferView(value2) {
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        return ArrayBuffer.isView(value2);
      }
      return isTypedArray2(value2) || isDataView(value2);
    }
    exports2.isArrayBufferView = isArrayBufferView;
    function isUint8Array(value2) {
      return whichTypedArray(value2) === "Uint8Array";
    }
    exports2.isUint8Array = isUint8Array;
    function isUint8ClampedArray(value2) {
      return whichTypedArray(value2) === "Uint8ClampedArray";
    }
    exports2.isUint8ClampedArray = isUint8ClampedArray;
    function isUint16Array(value2) {
      return whichTypedArray(value2) === "Uint16Array";
    }
    exports2.isUint16Array = isUint16Array;
    function isUint32Array(value2) {
      return whichTypedArray(value2) === "Uint32Array";
    }
    exports2.isUint32Array = isUint32Array;
    function isInt8Array(value2) {
      return whichTypedArray(value2) === "Int8Array";
    }
    exports2.isInt8Array = isInt8Array;
    function isInt16Array(value2) {
      return whichTypedArray(value2) === "Int16Array";
    }
    exports2.isInt16Array = isInt16Array;
    function isInt32Array(value2) {
      return whichTypedArray(value2) === "Int32Array";
    }
    exports2.isInt32Array = isInt32Array;
    function isFloat32Array(value2) {
      return whichTypedArray(value2) === "Float32Array";
    }
    exports2.isFloat32Array = isFloat32Array;
    function isFloat64Array(value2) {
      return whichTypedArray(value2) === "Float64Array";
    }
    exports2.isFloat64Array = isFloat64Array;
    function isBigInt64Array(value2) {
      return whichTypedArray(value2) === "BigInt64Array";
    }
    exports2.isBigInt64Array = isBigInt64Array;
    function isBigUint64Array(value2) {
      return whichTypedArray(value2) === "BigUint64Array";
    }
    exports2.isBigUint64Array = isBigUint64Array;
    function isMapToString(value2) {
      return ObjectToString(value2) === "[object Map]";
    }
    isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
    function isMap(value2) {
      if (typeof Map === "undefined") {
        return false;
      }
      return isMapToString.working ? isMapToString(value2) : value2 instanceof Map;
    }
    exports2.isMap = isMap;
    function isSetToString(value2) {
      return ObjectToString(value2) === "[object Set]";
    }
    isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
    function isSet(value2) {
      if (typeof Set === "undefined") {
        return false;
      }
      return isSetToString.working ? isSetToString(value2) : value2 instanceof Set;
    }
    exports2.isSet = isSet;
    function isWeakMapToString(value2) {
      return ObjectToString(value2) === "[object WeakMap]";
    }
    isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
    function isWeakMap(value2) {
      if (typeof WeakMap === "undefined") {
        return false;
      }
      return isWeakMapToString.working ? isWeakMapToString(value2) : value2 instanceof WeakMap;
    }
    exports2.isWeakMap = isWeakMap;
    function isWeakSetToString(value2) {
      return ObjectToString(value2) === "[object WeakSet]";
    }
    isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
    function isWeakSet(value2) {
      return isWeakSetToString(value2);
    }
    exports2.isWeakSet = isWeakSet;
    function isArrayBufferToString(value2) {
      return ObjectToString(value2) === "[object ArrayBuffer]";
    }
    isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
    function isArrayBuffer2(value2) {
      if (typeof ArrayBuffer === "undefined") {
        return false;
      }
      return isArrayBufferToString.working ? isArrayBufferToString(value2) : value2 instanceof ArrayBuffer;
    }
    exports2.isArrayBuffer = isArrayBuffer2;
    function isDataViewToString(value2) {
      return ObjectToString(value2) === "[object DataView]";
    }
    isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
    function isDataView(value2) {
      if (typeof DataView === "undefined") {
        return false;
      }
      return isDataViewToString.working ? isDataViewToString(value2) : value2 instanceof DataView;
    }
    exports2.isDataView = isDataView;
    var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
    function isSharedArrayBufferToString(value2) {
      return ObjectToString(value2) === "[object SharedArrayBuffer]";
    }
    function isSharedArrayBuffer(value2) {
      if (typeof SharedArrayBufferCopy === "undefined") {
        return false;
      }
      if (typeof isSharedArrayBufferToString.working === "undefined") {
        isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
      }
      return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value2) : value2 instanceof SharedArrayBufferCopy;
    }
    exports2.isSharedArrayBuffer = isSharedArrayBuffer;
    function isAsyncFunction(value2) {
      return ObjectToString(value2) === "[object AsyncFunction]";
    }
    exports2.isAsyncFunction = isAsyncFunction;
    function isMapIterator(value2) {
      return ObjectToString(value2) === "[object Map Iterator]";
    }
    exports2.isMapIterator = isMapIterator;
    function isSetIterator(value2) {
      return ObjectToString(value2) === "[object Set Iterator]";
    }
    exports2.isSetIterator = isSetIterator;
    function isGeneratorObject(value2) {
      return ObjectToString(value2) === "[object Generator]";
    }
    exports2.isGeneratorObject = isGeneratorObject;
    function isWebAssemblyCompiledModule(value2) {
      return ObjectToString(value2) === "[object WebAssembly.Module]";
    }
    exports2.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
    function isNumberObject(value2) {
      return checkBoxedPrimitive(value2, numberValue);
    }
    exports2.isNumberObject = isNumberObject;
    function isStringObject(value2) {
      return checkBoxedPrimitive(value2, stringValue);
    }
    exports2.isStringObject = isStringObject;
    function isBooleanObject(value2) {
      return checkBoxedPrimitive(value2, booleanValue);
    }
    exports2.isBooleanObject = isBooleanObject;
    function isBigIntObject(value2) {
      return BigIntSupported && checkBoxedPrimitive(value2, bigIntValue);
    }
    exports2.isBigIntObject = isBigIntObject;
    function isSymbolObject(value2) {
      return SymbolSupported && checkBoxedPrimitive(value2, symbolValue);
    }
    exports2.isSymbolObject = isSymbolObject;
    function isBoxedPrimitive(value2) {
      return isNumberObject(value2) || isStringObject(value2) || isBooleanObject(value2) || isBigIntObject(value2) || isSymbolObject(value2);
    }
    exports2.isBoxedPrimitive = isBoxedPrimitive;
    function isAnyArrayBuffer(value2) {
      return typeof Uint8Array !== "undefined" && (isArrayBuffer2(value2) || isSharedArrayBuffer(value2));
    }
    exports2.isAnyArrayBuffer = isAnyArrayBuffer;
    ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method2) {
      Object.defineProperty(exports2, method2, {
        enumerable: false,
        value: function() {
          throw new Error(method2 + " is not supported in userland");
        }
      });
    });
  }
});

// node_modules/util/support/isBufferBrowser.js
var require_isBufferBrowser = __commonJS({
  "node_modules/util/support/isBufferBrowser.js"(exports2, module2) {
    module2.exports = function isBuffer2(arg) {
      return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
    };
  }
});

// node_modules/util/util.js
var require_util = __commonJS({
  "node_modules/util/util.js"(exports2) {
    var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
      var keys = Object.keys(obj);
      var descriptors = {};
      for (var i6 = 0; i6 < keys.length; i6++) {
        descriptors[keys[i6]] = Object.getOwnPropertyDescriptor(obj, keys[i6]);
      }
      return descriptors;
    };
    var formatRegExp = /%[sdj%]/g;
    exports2.format = function(f7) {
      if (!isString(f7)) {
        var objects = [];
        for (var i6 = 0; i6 < arguments.length; i6++) {
          objects.push(inspect4(arguments[i6]));
        }
        return objects.join(" ");
      }
      var i6 = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f7).replace(formatRegExp, function(x7) {
        if (x7 === "%%")
          return "%";
        if (i6 >= len)
          return x7;
        switch (x7) {
          case "%s":
            return String(args[i6++]);
          case "%d":
            return Number(args[i6++]);
          case "%j":
            try {
              return JSON.stringify(args[i6++]);
            } catch (_8) {
              return "[Circular]";
            }
          default:
            return x7;
        }
      });
      for (var x6 = args[i6]; i6 < len; x6 = args[++i6]) {
        if (isNull(x6) || !isObject2(x6)) {
          str += " " + x6;
        } else {
          str += " " + inspect4(x6);
        }
      }
      return str;
    };
    exports2.deprecate = function(fn2, msg) {
      if (typeof process !== "undefined" && process.noDeprecation === true) {
        return fn2;
      }
      if (typeof process === "undefined") {
        return function() {
          return exports2.deprecate(fn2, msg).apply(this, arguments);
        };
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (process.throwDeprecation) {
            throw new Error(msg);
          } else if (process.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn2.apply(this, arguments);
      }
      return deprecated;
    };
    var debugs = {};
    var debugEnvRegex = /^$/;
    if (process.env.NODE_DEBUG) {
      debugEnv = process.env.NODE_DEBUG;
      debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
      debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
    }
    var debugEnv;
    exports2.debuglog = function(set) {
      set = set.toUpperCase();
      if (!debugs[set]) {
        if (debugEnvRegex.test(set)) {
          var pid = process.pid;
          debugs[set] = function() {
            var msg = exports2.format.apply(exports2, arguments);
            console.error("%s %d: %s", set, pid, msg);
          };
        } else {
          debugs[set] = function() {
          };
        }
      }
      return debugs[set];
    };
    function inspect4(obj, opts) {
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      if (arguments.length >= 3)
        ctx.depth = arguments[2];
      if (arguments.length >= 4)
        ctx.colors = arguments[3];
      if (isBoolean(opts)) {
        ctx.showHidden = opts;
      } else if (opts) {
        exports2._extend(ctx, opts);
      }
      if (isUndefined(ctx.showHidden))
        ctx.showHidden = false;
      if (isUndefined(ctx.depth))
        ctx.depth = 2;
      if (isUndefined(ctx.colors))
        ctx.colors = false;
      if (isUndefined(ctx.customInspect))
        ctx.customInspect = true;
      if (ctx.colors)
        ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    exports2.inspect = inspect4;
    inspect4.colors = {
      "bold": [1, 22],
      "italic": [3, 23],
      "underline": [4, 24],
      "inverse": [7, 27],
      "white": [37, 39],
      "grey": [90, 39],
      "black": [30, 39],
      "blue": [34, 39],
      "cyan": [36, 39],
      "green": [32, 39],
      "magenta": [35, 39],
      "red": [31, 39],
      "yellow": [33, 39]
    };
    inspect4.styles = {
      "special": "cyan",
      "number": "yellow",
      "boolean": "yellow",
      "undefined": "grey",
      "null": "bold",
      "string": "green",
      "date": "magenta",
      "regexp": "red"
    };
    function stylizeWithColor(str, styleType) {
      var style = inspect4.styles[styleType];
      if (style) {
        return "\x1B[" + inspect4.colors[style][0] + "m" + str + "\x1B[" + inspect4.colors[style][1] + "m";
      } else {
        return str;
      }
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array) {
      var hash3 = {};
      array.forEach(function(val, idx) {
        hash3[val] = true;
      });
      return hash3;
    }
    function formatValue(ctx, value2, recurseTimes) {
      if (ctx.customInspect && value2 && isFunction2(value2.inspect) && value2.inspect !== exports2.inspect && !(value2.constructor && value2.constructor.prototype === value2)) {
        var ret = value2.inspect(recurseTimes, ctx);
        if (!isString(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }
      var primitive = formatPrimitive(ctx, value2);
      if (primitive) {
        return primitive;
      }
      var keys = Object.keys(value2);
      var visibleKeys = arrayToHash(keys);
      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value2);
      }
      if (isError2(value2) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
        return formatError(value2);
      }
      if (keys.length === 0) {
        if (isFunction2(value2)) {
          var name2 = value2.name ? ": " + value2.name : "";
          return ctx.stylize("[Function" + name2 + "]", "special");
        }
        if (isRegExp(value2)) {
          return ctx.stylize(RegExp.prototype.toString.call(value2), "regexp");
        }
        if (isDate2(value2)) {
          return ctx.stylize(Date.prototype.toString.call(value2), "date");
        }
        if (isError2(value2)) {
          return formatError(value2);
        }
      }
      var base2 = "", array = false, braces = ["{", "}"];
      if (isArray2(value2)) {
        array = true;
        braces = ["[", "]"];
      }
      if (isFunction2(value2)) {
        var n4 = value2.name ? ": " + value2.name : "";
        base2 = " [Function" + n4 + "]";
      }
      if (isRegExp(value2)) {
        base2 = " " + RegExp.prototype.toString.call(value2);
      }
      if (isDate2(value2)) {
        base2 = " " + Date.prototype.toUTCString.call(value2);
      }
      if (isError2(value2)) {
        base2 = " " + formatError(value2);
      }
      if (keys.length === 0 && (!array || value2.length == 0)) {
        return braces[0] + base2 + braces[1];
      }
      if (recurseTimes < 0) {
        if (isRegExp(value2)) {
          return ctx.stylize(RegExp.prototype.toString.call(value2), "regexp");
        } else {
          return ctx.stylize("[Object]", "special");
        }
      }
      ctx.seen.push(value2);
      var output;
      if (array) {
        output = formatArray(ctx, value2, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function(key2) {
          return formatProperty(ctx, value2, recurseTimes, visibleKeys, key2, array);
        });
      }
      ctx.seen.pop();
      return reduceToSingleString(output, base2, braces);
    }
    function formatPrimitive(ctx, value2) {
      if (isUndefined(value2))
        return ctx.stylize("undefined", "undefined");
      if (isString(value2)) {
        var simple = "'" + JSON.stringify(value2).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, "string");
      }
      if (isNumber(value2))
        return ctx.stylize("" + value2, "number");
      if (isBoolean(value2))
        return ctx.stylize("" + value2, "boolean");
      if (isNull(value2))
        return ctx.stylize("null", "null");
    }
    function formatError(value2) {
      return "[" + Error.prototype.toString.call(value2) + "]";
    }
    function formatArray(ctx, value2, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i6 = 0, l6 = value2.length; i6 < l6; ++i6) {
        if (hasOwnProperty(value2, String(i6))) {
          output.push(formatProperty(
            ctx,
            value2,
            recurseTimes,
            visibleKeys,
            String(i6),
            true
          ));
        } else {
          output.push("");
        }
      }
      keys.forEach(function(key2) {
        if (!key2.match(/^\d+$/)) {
          output.push(formatProperty(
            ctx,
            value2,
            recurseTimes,
            visibleKeys,
            key2,
            true
          ));
        }
      });
      return output;
    }
    function formatProperty(ctx, value2, recurseTimes, visibleKeys, key2, array) {
      var name2, str, desc;
      desc = Object.getOwnPropertyDescriptor(value2, key2) || { value: value2[key2] };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize("[Getter/Setter]", "special");
        } else {
          str = ctx.stylize("[Getter]", "special");
        }
      } else {
        if (desc.set) {
          str = ctx.stylize("[Setter]", "special");
        }
      }
      if (!hasOwnProperty(visibleKeys, key2)) {
        name2 = "[" + key2 + "]";
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf("\n") > -1) {
            if (array) {
              str = str.split("\n").map(function(line) {
                return "  " + line;
              }).join("\n").substr(2);
            } else {
              str = "\n" + str.split("\n").map(function(line) {
                return "   " + line;
              }).join("\n");
            }
          }
        } else {
          str = ctx.stylize("[Circular]", "special");
        }
      }
      if (isUndefined(name2)) {
        if (array && key2.match(/^\d+$/)) {
          return str;
        }
        name2 = JSON.stringify("" + key2);
        if (name2.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name2 = name2.substr(1, name2.length - 2);
          name2 = ctx.stylize(name2, "name");
        } else {
          name2 = name2.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name2 = ctx.stylize(name2, "string");
        }
      }
      return name2 + ": " + str;
    }
    function reduceToSingleString(output, base2, braces) {
      var numLinesEst = 0;
      var length = output.reduce(function(prev, cur) {
        numLinesEst++;
        if (cur.indexOf("\n") >= 0)
          numLinesEst++;
        return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      if (length > 60) {
        return braces[0] + (base2 === "" ? "" : base2 + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
      }
      return braces[0] + base2 + " " + output.join(", ") + " " + braces[1];
    }
    exports2.types = require_types();
    function isArray2(ar3) {
      return Array.isArray(ar3);
    }
    exports2.isArray = isArray2;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports2.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports2.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports2.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports2.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports2.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports2.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports2.isUndefined = isUndefined;
    function isRegExp(re) {
      return isObject2(re) && objectToString(re) === "[object RegExp]";
    }
    exports2.isRegExp = isRegExp;
    exports2.types.isRegExp = isRegExp;
    function isObject2(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports2.isObject = isObject2;
    function isDate2(d6) {
      return isObject2(d6) && objectToString(d6) === "[object Date]";
    }
    exports2.isDate = isDate2;
    exports2.types.isDate = isDate2;
    function isError2(e6) {
      return isObject2(e6) && (objectToString(e6) === "[object Error]" || e6 instanceof Error);
    }
    exports2.isError = isError2;
    exports2.types.isNativeError = isError2;
    function isFunction2(arg) {
      return typeof arg === "function";
    }
    exports2.isFunction = isFunction2;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
    }
    exports2.isPrimitive = isPrimitive;
    exports2.isBuffer = require_isBufferBrowser();
    function objectToString(o6) {
      return Object.prototype.toString.call(o6);
    }
    function pad(n4) {
      return n4 < 10 ? "0" + n4.toString(10) : n4.toString(10);
    }
    var months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function timestamp2() {
      var d6 = new Date();
      var time = [
        pad(d6.getHours()),
        pad(d6.getMinutes()),
        pad(d6.getSeconds())
      ].join(":");
      return [d6.getDate(), months[d6.getMonth()], time].join(" ");
    }
    exports2.log = function() {
      console.log("%s - %s", timestamp2(), exports2.format.apply(exports2, arguments));
    };
    exports2.inherits = require_inherits_browser();
    exports2._extend = function(origin, add3) {
      if (!add3 || !isObject2(add3))
        return origin;
      var keys = Object.keys(add3);
      var i6 = keys.length;
      while (i6--) {
        origin[keys[i6]] = add3[keys[i6]];
      }
      return origin;
    };
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
    exports2.promisify = function promisify(original) {
      if (typeof original !== "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
        var fn2 = original[kCustomPromisifiedSymbol];
        if (typeof fn2 !== "function") {
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        }
        Object.defineProperty(fn2, kCustomPromisifiedSymbol, {
          value: fn2,
          enumerable: false,
          writable: false,
          configurable: true
        });
        return fn2;
      }
      function fn2() {
        var promiseResolve, promiseReject;
        var promise = new Promise(function(resolve, reject) {
          promiseResolve = resolve;
          promiseReject = reject;
        });
        var args = [];
        for (var i6 = 0; i6 < arguments.length; i6++) {
          args.push(arguments[i6]);
        }
        args.push(function(err, value2) {
          if (err) {
            promiseReject(err);
          } else {
            promiseResolve(value2);
          }
        });
        try {
          original.apply(this, args);
        } catch (err) {
          promiseReject(err);
        }
        return promise;
      }
      Object.setPrototypeOf(fn2, Object.getPrototypeOf(original));
      if (kCustomPromisifiedSymbol)
        Object.defineProperty(fn2, kCustomPromisifiedSymbol, {
          value: fn2,
          enumerable: false,
          writable: false,
          configurable: true
        });
      return Object.defineProperties(
        fn2,
        getOwnPropertyDescriptors(original)
      );
    };
    exports2.promisify.custom = kCustomPromisifiedSymbol;
    function callbackifyOnRejected(reason, cb) {
      if (!reason) {
        var newReason = new Error("Promise was rejected with a falsy value");
        newReason.reason = reason;
        reason = newReason;
      }
      return cb(reason);
    }
    function callbackify(original) {
      if (typeof original !== "function") {
        throw new TypeError('The "original" argument must be of type Function');
      }
      function callbackified() {
        var args = [];
        for (var i6 = 0; i6 < arguments.length; i6++) {
          args.push(arguments[i6]);
        }
        var maybeCb = args.pop();
        if (typeof maybeCb !== "function") {
          throw new TypeError("The last argument must be of type Function");
        }
        var self2 = this;
        var cb = function() {
          return maybeCb.apply(self2, arguments);
        };
        original.apply(this, args).then(
          function(ret) {
            process.nextTick(cb.bind(null, null, ret));
          },
          function(rej) {
            process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
          }
        );
      }
      Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
      Object.defineProperties(
        callbackified,
        getOwnPropertyDescriptors(original)
      );
      return callbackified;
    }
    exports2.callbackify = callbackify;
  }
});

// node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports2, module2) {
    "use strict";
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i6 = 1; i6 < arguments.length; i6++) {
        var source = arguments[i6] != null ? arguments[i6] : {};
        if (i6 % 2) {
          ownKeys(Object(source), true).forEach(function(key2) {
            _defineProperty2(target, key2, source[key2]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key2) {
            Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
          });
        }
      }
      return target;
    }
    function _defineProperty2(obj, key2, value2) {
      if (key2 in obj) {
        Object.defineProperty(obj, key2, { value: value2, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key2] = value2;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i6 = 0; i6 < props.length; i6++) {
        var descriptor = props[i6];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    var _require = require_buffer3();
    var Buffer2 = _require.Buffer;
    var _require2 = require_util();
    var inspect4 = _require2.inspect;
    var custom2 = inspect4 && inspect4.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer2.prototype.copy.call(src, target, offset);
    }
    module2.exports = function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v9) {
          var entry = {
            data: v9,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v9) {
          var entry = {
            data: v9,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s6) {
          if (this.length === 0)
            return "";
          var p7 = this.head;
          var ret = "" + p7.data;
          while (p7 = p7.next) {
            ret += s6 + p7.data;
          }
          return ret;
        }
      }, {
        key: "concat",
        value: function concat4(n4) {
          if (this.length === 0)
            return Buffer2.alloc(0);
          var ret = Buffer2.allocUnsafe(n4 >>> 0);
          var p7 = this.head;
          var i6 = 0;
          while (p7) {
            copyBuffer(p7.data, ret, i6);
            i6 += p7.data.length;
            p7 = p7.next;
          }
          return ret;
        }
      }, {
        key: "consume",
        value: function consume(n4, hasStrings) {
          var ret;
          if (n4 < this.head.data.length) {
            ret = this.head.data.slice(0, n4);
            this.head.data = this.head.data.slice(n4);
          } else if (n4 === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n4) : this._getBuffer(n4);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first2() {
          return this.head.data;
        }
      }, {
        key: "_getString",
        value: function _getString(n4) {
          var p7 = this.head;
          var c5 = 1;
          var ret = p7.data;
          n4 -= ret.length;
          while (p7 = p7.next) {
            var str = p7.data;
            var nb = n4 > str.length ? str.length : n4;
            if (nb === str.length)
              ret += str;
            else
              ret += str.slice(0, n4);
            n4 -= nb;
            if (n4 === 0) {
              if (nb === str.length) {
                ++c5;
                if (p7.next)
                  this.head = p7.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p7;
                p7.data = str.slice(nb);
              }
              break;
            }
            ++c5;
          }
          this.length -= c5;
          return ret;
        }
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n4) {
          var ret = Buffer2.allocUnsafe(n4);
          var p7 = this.head;
          var c5 = 1;
          p7.data.copy(ret);
          n4 -= p7.data.length;
          while (p7 = p7.next) {
            var buf = p7.data;
            var nb = n4 > buf.length ? buf.length : n4;
            buf.copy(ret, ret.length - n4, 0, nb);
            n4 -= nb;
            if (n4 === 0) {
              if (nb === buf.length) {
                ++c5;
                if (p7.next)
                  this.head = p7.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p7;
                p7.data = buf.slice(nb);
              }
              break;
            }
            ++c5;
          }
          this.length -= c5;
          return ret;
        }
      }, {
        key: custom2,
        value: function value2(_8, options) {
          return inspect4(this, _objectSpread({}, options, {
            depth: 0,
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream.destroy(err);
      else
        stream.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/readable-stream/errors-browser.js
var require_errors_browser = __commonJS({
  "node_modules/readable-stream/errors-browser.js"(exports2, module2) {
    "use strict";
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      var NodeError = function(_Base) {
        _inheritsLoose(NodeError2, _Base);
        function NodeError2(arg1, arg2, arg3) {
          return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
        }
        return NodeError2;
      }(Base);
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function(i6) {
          return String(i6);
        });
        if (len > 2) {
          return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
        } else if (len === 2) {
          return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        } else {
          return "of ".concat(thing, " ").concat(expected[0]);
        }
      } else {
        return "of ".concat(thing, " ").concat(String(expected));
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name2, value2) {
      return 'The value "' + value2 + '" is invalid for option "' + name2 + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name2, expected, actual) {
      var determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      var msg;
      if (endsWith(name2, " argument")) {
        msg = "The ".concat(name2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      } else {
        var type = includes(name2, ".") ? "property" : "argument";
        msg = 'The "'.concat(name2, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      }
      msg += ". Received type ".concat(typeof actual);
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name2) {
      return "The " + name2 + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name2) {
      return "Cannot call " + name2 + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module2.exports.codes = codes;
  }
});

// node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/state.js"(exports2, module2) {
    "use strict";
    var ERR_INVALID_OPT_VALUE = require_errors_browser().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name2 = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name2, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module2.exports = {
      getHighWaterMark
    };
  }
});

// node_modules/util-deprecate/browser.js
var require_browser = __commonJS({
  "node_modules/util-deprecate/browser.js"(exports2, module2) {
    module2.exports = deprecate;
    function deprecate(fn2, msg) {
      if (config2("noDeprecation")) {
        return fn2;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (config2("throwDeprecation")) {
            throw new Error(msg);
          } else if (config2("traceDeprecation")) {
            console.trace(msg);
          } else {
            console.warn(msg);
          }
          warned = true;
        }
        return fn2.apply(this, arguments);
      }
      return deprecated;
    }
    function config2(name2) {
      try {
        if (!global.localStorage)
          return false;
      } catch (_8) {
        return false;
      }
      var val = global.localStorage[name2];
      if (null == val)
        return false;
      return String(val).toLowerCase() === "true";
    }
  }
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_browser()
    };
    var Stream = require_stream_browser();
    var Buffer2 = require_buffer3().Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits_browser()(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er2) {
        onwrite(stream, er2);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_8) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value2(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er2 = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er2);
      process.nextTick(cb, er2);
    }
    function validChunk(stream, state, chunk, cb) {
      var er2;
      if (chunk === null) {
        er2 = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er2 = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er2) {
        errorOrDestroy(stream, er2);
        process.nextTick(cb, er2);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ending)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last2 = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last2) {
          last2.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er2, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er2);
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er2);
      } else {
        cb(er2);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er2);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er2) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er2)
        onwriteError(stream, state, sync, er2, cb);
      else {
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l6 = state.bufferedRequestCount;
        var buffer2 = new Array(l6);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count2 = 0;
        var allBuffers = true;
        while (entry) {
          buffer2[count2] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count2 += 1;
        }
        buffer2.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer2, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      enumerable: false,
      get: function get() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value2) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value2;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key2 in obj) {
        keys2.push(key2);
      }
      return keys2;
    };
    module2.exports = Duplex;
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    require_inherits_browser()(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v9 = 0; v9 < keys.length; v9++) {
        method2 = keys[v9];
        if (!Duplex.prototype[method2])
          Duplex.prototype[method2] = Writable.prototype[method2];
      }
    }
    var keys;
    var method2;
    var v9;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false)
          this.readable = false;
        if (options.writable === false)
          this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended)
        return;
      process.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value2) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value2;
        this._writableState.destroyed = value2;
      }
    });
  }
});

// node_modules/string_decoder/node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/string_decoder/node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer2 = require_buffer3();
    var Buffer2 = buffer2.Buffer;
    function copyProps(src, dst) {
      for (var key2 in src) {
        dst[key2] = src[key2];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer2;
    } else {
      copyProps(buffer2, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer2.SlowBuffer(size);
    };
  }
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r6;
      var i6;
      if (this.lastNeed) {
        r6 = this.fillLast(buf);
        if (r6 === void 0)
          return "";
        i6 = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i6 = 0;
      }
      if (i6 < buf.length)
        return r6 ? r6 + this.text(buf, i6) : this.text(buf, i6);
      return r6 || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i6) {
      var j8 = buf.length - 1;
      if (j8 < i6)
        return 0;
      var nb = utf8CheckByte(buf[j8]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j8 < i6 || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j8]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j8 < i6 || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j8]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p7) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p7 = this.lastTotal - this.lastNeed;
      var r6 = utf8CheckExtraBytes(this, buf, p7);
      if (r6 !== void 0)
        return r6;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p7, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p7, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i6) {
      var total = utf8CheckIncomplete(this, buf, i6);
      if (!this.lastNeed)
        return buf.toString("utf8", i6);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i6, end);
    }
    function utf8End(buf) {
      var r6 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r6 + "\uFFFD";
      return r6;
    }
    function utf16Text(buf, i6) {
      if ((buf.length - i6) % 2 === 0) {
        var r6 = buf.toString("utf16le", i6);
        if (r6) {
          var c5 = r6.charCodeAt(r6.length - 1);
          if (c5 >= 55296 && c5 <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r6.slice(0, -1);
          }
        }
        return r6;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i6, buf.length - 1);
    }
    function utf16End(buf) {
      var r6 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r6 + this.lastChar.toString("utf16le", 0, end);
      }
      return r6;
    }
    function base64Text(buf, i6) {
      var n4 = (buf.length - i6) % 3;
      if (n4 === 0)
        return buf.toString("base64", i6);
      this.lastNeed = 3 - n4;
      this.lastTotal = 3;
      if (n4 === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i6, buf.length - n4);
    }
    function base64End(buf) {
      var r6 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r6 + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r6;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports2, module2) {
    "use strict";
    var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop3() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop3);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable)
          onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module2.exports = eos;
  }
});

// node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports2, module2) {
    "use strict";
    var _Object$setPrototypeO;
    function _defineProperty2(obj, key2, value2) {
      if (key2 in obj) {
        Object.defineProperty(obj, key2, { value: value2, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key2] = value2;
      }
      return obj;
    }
    var finished = require_end_of_stream();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value2, done) {
      return {
        value: value2,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve, reject) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty2(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty2(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator2 = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty2(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty2(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty2(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty2(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty2(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty2(_Object$create, kHandlePromise, {
        value: function value2(resolve, reject) {
          var data = iterator2[kStream].read();
          if (data) {
            iterator2[kLastPromise] = null;
            iterator2[kLastResolve] = null;
            iterator2[kLastReject] = null;
            resolve(createIterResult(data, false));
          } else {
            iterator2[kLastResolve] = resolve;
            iterator2[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator2[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator2[kLastReject];
          if (reject !== null) {
            iterator2[kLastPromise] = null;
            iterator2[kLastResolve] = null;
            iterator2[kLastReject] = null;
            reject(err);
          }
          iterator2[kError] = err;
          return;
        }
        var resolve = iterator2[kLastResolve];
        if (resolve !== null) {
          iterator2[kLastPromise] = null;
          iterator2[kLastResolve] = null;
          iterator2[kLastReject] = null;
          resolve(createIterResult(void 0, true));
        }
        iterator2[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator2));
      return iterator2;
    };
    module2.exports = createReadableStreamAsyncIterator;
  }
});

// node_modules/readable-stream/lib/internal/streams/from-browser.js
var require_from_browser = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports2, module2) {
    module2.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  }
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    module2.exports = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require_events().EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream_browser();
    var Buffer2 = require_buffer3().Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require_util();
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from2;
    require_inherits_browser()(Readable, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn2) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn2);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn2);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn2);
      else
        emitter._events[event] = [fn2, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable))
        return new Readable(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value2) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value2;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er2;
        if (!skipChunkCheck)
          er2 = chunkInvalid(state, chunk);
        if (er2) {
          errorOrDestroy(stream, er2);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er2;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er2 = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er2;
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p7 = this._readableState.buffer.head;
      var content = "";
      while (p7 !== null) {
        content += decoder.write(p7.data);
        p7 = p7.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n4) {
      if (n4 >= MAX_HWM) {
        n4 = MAX_HWM;
      } else {
        n4--;
        n4 |= n4 >>> 1;
        n4 |= n4 >>> 2;
        n4 |= n4 >>> 4;
        n4 |= n4 >>> 8;
        n4 |= n4 >>> 16;
        n4++;
      }
      return n4;
    }
    function howMuchToRead(n4, state) {
      if (n4 <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n4 !== n4) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n4 > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n4);
      if (n4 <= state.length)
        return n4;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n4) {
      debug("read", n4);
      n4 = parseInt(n4, 10);
      var state = this._readableState;
      var nOrig = n4;
      if (n4 !== 0)
        state.emittedReadable = false;
      if (n4 === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n4 = howMuchToRead(n4, state);
      if (n4 === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n4 < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n4 = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n4 > 0)
        ret = fromList(n4, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n4 = 0;
      } else {
        state.length -= n4;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n4 && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n4) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er2) {
        debug("onerror", er2);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er2);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i6 = 0; i6 < len; i6++) {
          dests[i6].emit("unpipe", this, {
            hasUnpiped: false
          });
        }
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn2) {
      var res = Stream.prototype.on.call(this, ev, fn2);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn2) {
      var res = Stream.prototype.removeListener.call(this, ev, fn2);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
        ;
      }
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i6 in stream) {
        if (this[i6] === void 0 && typeof stream[i6] === "function") {
          this[i6] = function methodWrap(method2) {
            return function methodWrapReturnFunction() {
              return stream[method2].apply(stream, arguments);
            };
          }(i6);
        }
      }
      for (var n4 = 0; n4 < kProxyEvents.length; n4++) {
        stream.on(kProxyEvents[n4], this.emit.bind(this, kProxyEvents[n4]));
      }
      this._read = function(n5) {
        debug("wrapped _read", n5);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      enumerable: false,
      get: function get() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      enumerable: false,
      get: function get() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      enumerable: false,
      get: function get() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      enumerable: false,
      get: function get() {
        return this._readableState.length;
      }
    });
    function fromList(n4, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n4 || n4 >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n4, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable.from = function(iterable, opts) {
        if (from2 === void 0) {
          from2 = require_from_browser();
        }
        return from2(Readable, iterable, opts);
      };
    }
    function indexOf(xs, x6) {
      for (var i6 = 0, l6 = xs.length; i6 < l6; i6++) {
        if (xs[i6] === x6)
          return i6;
      }
      return -1;
    }
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    module2.exports = Transform;
    var _require$codes = require_errors_browser().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex();
    require_inherits_browser()(Transform, Duplex);
    function afterTransform(er2, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er2);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er2, data) {
          done(_this, er2, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n4) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er2, data) {
      if (er2)
        return stream.emit("error", er2);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform();
    require_inherits_browser()(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports2, module2) {
    "use strict";
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors_browser().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop3(err) {
      if (err)
        throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0)
        eos = require_end_of_stream();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream))
          return stream.abort();
        if (typeof stream.destroy === "function")
          return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn2) {
      fn2();
    }
    function pipe2(from2, to2) {
      return from2.pipe(to2);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop3;
      if (typeof streams[streams.length - 1] !== "function")
        return noop3;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i6) {
        var reading = i6 < streams.length - 1;
        var writing = i6 > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe2);
    }
    module2.exports = pipeline;
  }
});

// node_modules/readable-stream/readable-browser.js
var require_readable_browser = __commonJS({
  "node_modules/readable-stream/readable-browser.js"(exports2, module2) {
    exports2 = module2.exports = require_stream_readable();
    exports2.Stream = exports2;
    exports2.Readable = exports2;
    exports2.Writable = require_stream_writable();
    exports2.Duplex = require_stream_duplex();
    exports2.Transform = require_stream_transform();
    exports2.PassThrough = require_stream_passthrough();
    exports2.finished = require_end_of_stream();
    exports2.pipeline = require_pipeline();
  }
});

// node_modules/keccak/lib/api/keccak.js
var require_keccak = __commonJS({
  "node_modules/keccak/lib/api/keccak.js"(exports2, module2) {
    var { Transform } = require_readable_browser();
    module2.exports = (KeccakState) => class Keccak extends Transform {
      constructor(rate, capacity, delimitedSuffix, hashBitLength, options) {
        super(options);
        this._rate = rate;
        this._capacity = capacity;
        this._delimitedSuffix = delimitedSuffix;
        this._hashBitLength = hashBitLength;
        this._options = options;
        this._state = new KeccakState();
        this._state.initialize(rate, capacity);
        this._finalized = false;
      }
      _transform(chunk, encoding, callback) {
        let error = null;
        try {
          this.update(chunk, encoding);
        } catch (err) {
          error = err;
        }
        callback(error);
      }
      _flush(callback) {
        let error = null;
        try {
          this.push(this.digest());
        } catch (err) {
          error = err;
        }
        callback(error);
      }
      update(data, encoding) {
        if (!Buffer.isBuffer(data) && typeof data !== "string")
          throw new TypeError("Data must be a string or a buffer");
        if (this._finalized)
          throw new Error("Digest already called");
        if (!Buffer.isBuffer(data))
          data = Buffer.from(data, encoding);
        this._state.absorb(data);
        return this;
      }
      digest(encoding) {
        if (this._finalized)
          throw new Error("Digest already called");
        this._finalized = true;
        if (this._delimitedSuffix)
          this._state.absorbLastFewBits(this._delimitedSuffix);
        let digest = this._state.squeeze(this._hashBitLength / 8);
        if (encoding !== void 0)
          digest = digest.toString(encoding);
        this._resetState();
        return digest;
      }
      _resetState() {
        this._state.initialize(this._rate, this._capacity);
        return this;
      }
      _clone() {
        const clone = new Keccak(this._rate, this._capacity, this._delimitedSuffix, this._hashBitLength, this._options);
        this._state.copy(clone._state);
        clone._finalized = this._finalized;
        return clone;
      }
    };
  }
});

// node_modules/keccak/lib/api/shake.js
var require_shake = __commonJS({
  "node_modules/keccak/lib/api/shake.js"(exports2, module2) {
    var { Transform } = require_readable_browser();
    module2.exports = (KeccakState) => class Shake extends Transform {
      constructor(rate, capacity, delimitedSuffix, options) {
        super(options);
        this._rate = rate;
        this._capacity = capacity;
        this._delimitedSuffix = delimitedSuffix;
        this._options = options;
        this._state = new KeccakState();
        this._state.initialize(rate, capacity);
        this._finalized = false;
      }
      _transform(chunk, encoding, callback) {
        let error = null;
        try {
          this.update(chunk, encoding);
        } catch (err) {
          error = err;
        }
        callback(error);
      }
      _flush() {
      }
      _read(size) {
        this.push(this.squeeze(size));
      }
      update(data, encoding) {
        if (!Buffer.isBuffer(data) && typeof data !== "string")
          throw new TypeError("Data must be a string or a buffer");
        if (this._finalized)
          throw new Error("Squeeze already called");
        if (!Buffer.isBuffer(data))
          data = Buffer.from(data, encoding);
        this._state.absorb(data);
        return this;
      }
      squeeze(dataByteLength, encoding) {
        if (!this._finalized) {
          this._finalized = true;
          this._state.absorbLastFewBits(this._delimitedSuffix);
        }
        let data = this._state.squeeze(dataByteLength);
        if (encoding !== void 0)
          data = data.toString(encoding);
        return data;
      }
      _resetState() {
        this._state.initialize(this._rate, this._capacity);
        return this;
      }
      _clone() {
        const clone = new Shake(this._rate, this._capacity, this._delimitedSuffix, this._options);
        this._state.copy(clone._state);
        clone._finalized = this._finalized;
        return clone;
      }
    };
  }
});

// node_modules/keccak/lib/api/index.js
var require_api = __commonJS({
  "node_modules/keccak/lib/api/index.js"(exports2, module2) {
    var createKeccak = require_keccak();
    var createShake = require_shake();
    module2.exports = function(KeccakState) {
      const Keccak = createKeccak(KeccakState);
      const Shake = createShake(KeccakState);
      return function(algorithm2, options) {
        const hash3 = typeof algorithm2 === "string" ? algorithm2.toLowerCase() : algorithm2;
        switch (hash3) {
          case "keccak224":
            return new Keccak(1152, 448, null, 224, options);
          case "keccak256":
            return new Keccak(1088, 512, null, 256, options);
          case "keccak384":
            return new Keccak(832, 768, null, 384, options);
          case "keccak512":
            return new Keccak(576, 1024, null, 512, options);
          case "sha3-224":
            return new Keccak(1152, 448, 6, 224, options);
          case "sha3-256":
            return new Keccak(1088, 512, 6, 256, options);
          case "sha3-384":
            return new Keccak(832, 768, 6, 384, options);
          case "sha3-512":
            return new Keccak(576, 1024, 6, 512, options);
          case "shake128":
            return new Shake(1344, 256, 31, options);
          case "shake256":
            return new Shake(1088, 512, 31, options);
          default:
            throw new Error("Invald algorithm: " + algorithm2);
        }
      };
    };
  }
});

// node_modules/keccak/lib/keccak-state-unroll.js
var require_keccak_state_unroll = __commonJS({
  "node_modules/keccak/lib/keccak-state-unroll.js"(exports2) {
    var P1600_ROUND_CONSTANTS = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
    exports2.p1600 = function(s6) {
      for (let round = 0; round < 24; ++round) {
        const lo0 = s6[0] ^ s6[10] ^ s6[20] ^ s6[30] ^ s6[40];
        const hi0 = s6[1] ^ s6[11] ^ s6[21] ^ s6[31] ^ s6[41];
        const lo1 = s6[2] ^ s6[12] ^ s6[22] ^ s6[32] ^ s6[42];
        const hi1 = s6[3] ^ s6[13] ^ s6[23] ^ s6[33] ^ s6[43];
        const lo2 = s6[4] ^ s6[14] ^ s6[24] ^ s6[34] ^ s6[44];
        const hi2 = s6[5] ^ s6[15] ^ s6[25] ^ s6[35] ^ s6[45];
        const lo3 = s6[6] ^ s6[16] ^ s6[26] ^ s6[36] ^ s6[46];
        const hi3 = s6[7] ^ s6[17] ^ s6[27] ^ s6[37] ^ s6[47];
        const lo4 = s6[8] ^ s6[18] ^ s6[28] ^ s6[38] ^ s6[48];
        const hi4 = s6[9] ^ s6[19] ^ s6[29] ^ s6[39] ^ s6[49];
        let lo = lo4 ^ (lo1 << 1 | hi1 >>> 31);
        let hi5 = hi4 ^ (hi1 << 1 | lo1 >>> 31);
        const t1slo0 = s6[0] ^ lo;
        const t1shi0 = s6[1] ^ hi5;
        const t1slo5 = s6[10] ^ lo;
        const t1shi5 = s6[11] ^ hi5;
        const t1slo10 = s6[20] ^ lo;
        const t1shi10 = s6[21] ^ hi5;
        const t1slo15 = s6[30] ^ lo;
        const t1shi15 = s6[31] ^ hi5;
        const t1slo20 = s6[40] ^ lo;
        const t1shi20 = s6[41] ^ hi5;
        lo = lo0 ^ (lo2 << 1 | hi2 >>> 31);
        hi5 = hi0 ^ (hi2 << 1 | lo2 >>> 31);
        const t1slo1 = s6[2] ^ lo;
        const t1shi1 = s6[3] ^ hi5;
        const t1slo6 = s6[12] ^ lo;
        const t1shi6 = s6[13] ^ hi5;
        const t1slo11 = s6[22] ^ lo;
        const t1shi11 = s6[23] ^ hi5;
        const t1slo16 = s6[32] ^ lo;
        const t1shi16 = s6[33] ^ hi5;
        const t1slo21 = s6[42] ^ lo;
        const t1shi21 = s6[43] ^ hi5;
        lo = lo1 ^ (lo3 << 1 | hi3 >>> 31);
        hi5 = hi1 ^ (hi3 << 1 | lo3 >>> 31);
        const t1slo2 = s6[4] ^ lo;
        const t1shi2 = s6[5] ^ hi5;
        const t1slo7 = s6[14] ^ lo;
        const t1shi7 = s6[15] ^ hi5;
        const t1slo12 = s6[24] ^ lo;
        const t1shi12 = s6[25] ^ hi5;
        const t1slo17 = s6[34] ^ lo;
        const t1shi17 = s6[35] ^ hi5;
        const t1slo22 = s6[44] ^ lo;
        const t1shi22 = s6[45] ^ hi5;
        lo = lo2 ^ (lo4 << 1 | hi4 >>> 31);
        hi5 = hi2 ^ (hi4 << 1 | lo4 >>> 31);
        const t1slo3 = s6[6] ^ lo;
        const t1shi3 = s6[7] ^ hi5;
        const t1slo8 = s6[16] ^ lo;
        const t1shi8 = s6[17] ^ hi5;
        const t1slo13 = s6[26] ^ lo;
        const t1shi13 = s6[27] ^ hi5;
        const t1slo18 = s6[36] ^ lo;
        const t1shi18 = s6[37] ^ hi5;
        const t1slo23 = s6[46] ^ lo;
        const t1shi23 = s6[47] ^ hi5;
        lo = lo3 ^ (lo0 << 1 | hi0 >>> 31);
        hi5 = hi3 ^ (hi0 << 1 | lo0 >>> 31);
        const t1slo4 = s6[8] ^ lo;
        const t1shi4 = s6[9] ^ hi5;
        const t1slo9 = s6[18] ^ lo;
        const t1shi9 = s6[19] ^ hi5;
        const t1slo14 = s6[28] ^ lo;
        const t1shi14 = s6[29] ^ hi5;
        const t1slo19 = s6[38] ^ lo;
        const t1shi19 = s6[39] ^ hi5;
        const t1slo24 = s6[48] ^ lo;
        const t1shi24 = s6[49] ^ hi5;
        const t2slo0 = t1slo0;
        const t2shi0 = t1shi0;
        const t2slo16 = t1shi5 << 4 | t1slo5 >>> 28;
        const t2shi16 = t1slo5 << 4 | t1shi5 >>> 28;
        const t2slo7 = t1slo10 << 3 | t1shi10 >>> 29;
        const t2shi7 = t1shi10 << 3 | t1slo10 >>> 29;
        const t2slo23 = t1shi15 << 9 | t1slo15 >>> 23;
        const t2shi23 = t1slo15 << 9 | t1shi15 >>> 23;
        const t2slo14 = t1slo20 << 18 | t1shi20 >>> 14;
        const t2shi14 = t1shi20 << 18 | t1slo20 >>> 14;
        const t2slo10 = t1slo1 << 1 | t1shi1 >>> 31;
        const t2shi10 = t1shi1 << 1 | t1slo1 >>> 31;
        const t2slo1 = t1shi6 << 12 | t1slo6 >>> 20;
        const t2shi1 = t1slo6 << 12 | t1shi6 >>> 20;
        const t2slo17 = t1slo11 << 10 | t1shi11 >>> 22;
        const t2shi17 = t1shi11 << 10 | t1slo11 >>> 22;
        const t2slo8 = t1shi16 << 13 | t1slo16 >>> 19;
        const t2shi8 = t1slo16 << 13 | t1shi16 >>> 19;
        const t2slo24 = t1slo21 << 2 | t1shi21 >>> 30;
        const t2shi24 = t1shi21 << 2 | t1slo21 >>> 30;
        const t2slo20 = t1shi2 << 30 | t1slo2 >>> 2;
        const t2shi20 = t1slo2 << 30 | t1shi2 >>> 2;
        const t2slo11 = t1slo7 << 6 | t1shi7 >>> 26;
        const t2shi11 = t1shi7 << 6 | t1slo7 >>> 26;
        const t2slo2 = t1shi12 << 11 | t1slo12 >>> 21;
        const t2shi2 = t1slo12 << 11 | t1shi12 >>> 21;
        const t2slo18 = t1slo17 << 15 | t1shi17 >>> 17;
        const t2shi18 = t1shi17 << 15 | t1slo17 >>> 17;
        const t2slo9 = t1shi22 << 29 | t1slo22 >>> 3;
        const t2shi9 = t1slo22 << 29 | t1shi22 >>> 3;
        const t2slo5 = t1slo3 << 28 | t1shi3 >>> 4;
        const t2shi5 = t1shi3 << 28 | t1slo3 >>> 4;
        const t2slo21 = t1shi8 << 23 | t1slo8 >>> 9;
        const t2shi21 = t1slo8 << 23 | t1shi8 >>> 9;
        const t2slo12 = t1slo13 << 25 | t1shi13 >>> 7;
        const t2shi12 = t1shi13 << 25 | t1slo13 >>> 7;
        const t2slo3 = t1slo18 << 21 | t1shi18 >>> 11;
        const t2shi3 = t1shi18 << 21 | t1slo18 >>> 11;
        const t2slo19 = t1shi23 << 24 | t1slo23 >>> 8;
        const t2shi19 = t1slo23 << 24 | t1shi23 >>> 8;
        const t2slo15 = t1slo4 << 27 | t1shi4 >>> 5;
        const t2shi15 = t1shi4 << 27 | t1slo4 >>> 5;
        const t2slo6 = t1slo9 << 20 | t1shi9 >>> 12;
        const t2shi6 = t1shi9 << 20 | t1slo9 >>> 12;
        const t2slo22 = t1shi14 << 7 | t1slo14 >>> 25;
        const t2shi22 = t1slo14 << 7 | t1shi14 >>> 25;
        const t2slo13 = t1slo19 << 8 | t1shi19 >>> 24;
        const t2shi13 = t1shi19 << 8 | t1slo19 >>> 24;
        const t2slo4 = t1slo24 << 14 | t1shi24 >>> 18;
        const t2shi4 = t1shi24 << 14 | t1slo24 >>> 18;
        s6[0] = t2slo0 ^ ~t2slo1 & t2slo2;
        s6[1] = t2shi0 ^ ~t2shi1 & t2shi2;
        s6[10] = t2slo5 ^ ~t2slo6 & t2slo7;
        s6[11] = t2shi5 ^ ~t2shi6 & t2shi7;
        s6[20] = t2slo10 ^ ~t2slo11 & t2slo12;
        s6[21] = t2shi10 ^ ~t2shi11 & t2shi12;
        s6[30] = t2slo15 ^ ~t2slo16 & t2slo17;
        s6[31] = t2shi15 ^ ~t2shi16 & t2shi17;
        s6[40] = t2slo20 ^ ~t2slo21 & t2slo22;
        s6[41] = t2shi20 ^ ~t2shi21 & t2shi22;
        s6[2] = t2slo1 ^ ~t2slo2 & t2slo3;
        s6[3] = t2shi1 ^ ~t2shi2 & t2shi3;
        s6[12] = t2slo6 ^ ~t2slo7 & t2slo8;
        s6[13] = t2shi6 ^ ~t2shi7 & t2shi8;
        s6[22] = t2slo11 ^ ~t2slo12 & t2slo13;
        s6[23] = t2shi11 ^ ~t2shi12 & t2shi13;
        s6[32] = t2slo16 ^ ~t2slo17 & t2slo18;
        s6[33] = t2shi16 ^ ~t2shi17 & t2shi18;
        s6[42] = t2slo21 ^ ~t2slo22 & t2slo23;
        s6[43] = t2shi21 ^ ~t2shi22 & t2shi23;
        s6[4] = t2slo2 ^ ~t2slo3 & t2slo4;
        s6[5] = t2shi2 ^ ~t2shi3 & t2shi4;
        s6[14] = t2slo7 ^ ~t2slo8 & t2slo9;
        s6[15] = t2shi7 ^ ~t2shi8 & t2shi9;
        s6[24] = t2slo12 ^ ~t2slo13 & t2slo14;
        s6[25] = t2shi12 ^ ~t2shi13 & t2shi14;
        s6[34] = t2slo17 ^ ~t2slo18 & t2slo19;
        s6[35] = t2shi17 ^ ~t2shi18 & t2shi19;
        s6[44] = t2slo22 ^ ~t2slo23 & t2slo24;
        s6[45] = t2shi22 ^ ~t2shi23 & t2shi24;
        s6[6] = t2slo3 ^ ~t2slo4 & t2slo0;
        s6[7] = t2shi3 ^ ~t2shi4 & t2shi0;
        s6[16] = t2slo8 ^ ~t2slo9 & t2slo5;
        s6[17] = t2shi8 ^ ~t2shi9 & t2shi5;
        s6[26] = t2slo13 ^ ~t2slo14 & t2slo10;
        s6[27] = t2shi13 ^ ~t2shi14 & t2shi10;
        s6[36] = t2slo18 ^ ~t2slo19 & t2slo15;
        s6[37] = t2shi18 ^ ~t2shi19 & t2shi15;
        s6[46] = t2slo23 ^ ~t2slo24 & t2slo20;
        s6[47] = t2shi23 ^ ~t2shi24 & t2shi20;
        s6[8] = t2slo4 ^ ~t2slo0 & t2slo1;
        s6[9] = t2shi4 ^ ~t2shi0 & t2shi1;
        s6[18] = t2slo9 ^ ~t2slo5 & t2slo6;
        s6[19] = t2shi9 ^ ~t2shi5 & t2shi6;
        s6[28] = t2slo14 ^ ~t2slo10 & t2slo11;
        s6[29] = t2shi14 ^ ~t2shi10 & t2shi11;
        s6[38] = t2slo19 ^ ~t2slo15 & t2slo16;
        s6[39] = t2shi19 ^ ~t2shi15 & t2shi16;
        s6[48] = t2slo24 ^ ~t2slo20 & t2slo21;
        s6[49] = t2shi24 ^ ~t2shi20 & t2shi21;
        s6[0] ^= P1600_ROUND_CONSTANTS[round * 2];
        s6[1] ^= P1600_ROUND_CONSTANTS[round * 2 + 1];
      }
    };
  }
});

// node_modules/keccak/lib/keccak.js
var require_keccak2 = __commonJS({
  "node_modules/keccak/lib/keccak.js"(exports2, module2) {
    var keccakState = require_keccak_state_unroll();
    function Keccak() {
      this.state = [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ];
      this.blockSize = null;
      this.count = 0;
      this.squeezing = false;
    }
    Keccak.prototype.initialize = function(rate, capacity) {
      for (let i6 = 0; i6 < 50; ++i6)
        this.state[i6] = 0;
      this.blockSize = rate / 8;
      this.count = 0;
      this.squeezing = false;
    };
    Keccak.prototype.absorb = function(data) {
      for (let i6 = 0; i6 < data.length; ++i6) {
        this.state[~~(this.count / 4)] ^= data[i6] << 8 * (this.count % 4);
        this.count += 1;
        if (this.count === this.blockSize) {
          keccakState.p1600(this.state);
          this.count = 0;
        }
      }
    };
    Keccak.prototype.absorbLastFewBits = function(bits) {
      this.state[~~(this.count / 4)] ^= bits << 8 * (this.count % 4);
      if ((bits & 128) !== 0 && this.count === this.blockSize - 1)
        keccakState.p1600(this.state);
      this.state[~~((this.blockSize - 1) / 4)] ^= 128 << 8 * ((this.blockSize - 1) % 4);
      keccakState.p1600(this.state);
      this.count = 0;
      this.squeezing = true;
    };
    Keccak.prototype.squeeze = function(length) {
      if (!this.squeezing)
        this.absorbLastFewBits(1);
      const output = Buffer.alloc(length);
      for (let i6 = 0; i6 < length; ++i6) {
        output[i6] = this.state[~~(this.count / 4)] >>> 8 * (this.count % 4) & 255;
        this.count += 1;
        if (this.count === this.blockSize) {
          keccakState.p1600(this.state);
          this.count = 0;
        }
      }
      return output;
    };
    Keccak.prototype.copy = function(dest) {
      for (let i6 = 0; i6 < 50; ++i6)
        dest.state[i6] = this.state[i6];
      dest.blockSize = this.blockSize;
      dest.count = this.count;
      dest.squeezing = this.squeezing;
    };
    module2.exports = Keccak;
  }
});

// node_modules/keccak/js.js
var require_js = __commonJS({
  "node_modules/keccak/js.js"(exports2, module2) {
    module2.exports = require_api()(require_keccak2());
  }
});

// node_modules/keccak256/dist/keccak256.js
var require_keccak256 = __commonJS({
  "node_modules/keccak256/dist/keccak256.js"(exports2, module2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    var bn_js_1 = __importDefault(require_bn2());
    var buffer_1 = __importDefault(require_buffer2());
    var keccak_1 = __importDefault(require_js());
    var Buffer2 = buffer_1.default.Buffer;
    function keccak2563(value2) {
      value2 = toBuffer(value2);
      return (0, keccak_1.default)("keccak256").update(value2).digest();
    }
    function toBuffer(value2) {
      if (!Buffer2.isBuffer(value2)) {
        if (Array.isArray(value2)) {
          value2 = Buffer2.from(value2);
        } else if (typeof value2 === "string") {
          if (isHexString4(value2)) {
            value2 = Buffer2.from(padToEven(stripHexPrefix(value2)), "hex");
          } else {
            value2 = Buffer2.from(value2);
          }
        } else if (typeof value2 === "number") {
          value2 = intToBuffer2(value2);
        } else if (value2 === null || value2 === void 0) {
          value2 = Buffer2.allocUnsafe(0);
        } else if (bn_js_1.default.isBN(value2)) {
          value2 = value2.toArrayLike(Buffer2);
        } else if (value2.toArray) {
          value2 = Buffer2.from(value2.toArray());
        } else {
          throw new Error("invalid type");
        }
      }
      return value2;
    }
    function isHexString4(value2, length) {
      if (typeof value2 !== "string" || !value2.match(/^0x[0-9A-Fa-f]*$/)) {
        return false;
      }
      if (length && value2.length !== 2 + 2 * length) {
        return false;
      }
      return true;
    }
    function padToEven(value2) {
      if (typeof value2 !== "string") {
        throw new Error(`while padding to even, value must be string, is currently ${typeof value2}, while padToEven.`);
      }
      if (value2.length % 2) {
        value2 = `0${value2}`;
      }
      return value2;
    }
    function stripHexPrefix(value2) {
      if (typeof value2 !== "string") {
        return value2;
      }
      return isHexPrefixed(value2) ? value2.slice(2) : value2;
    }
    function isHexPrefixed(value2) {
      if (typeof value2 !== "string") {
        throw new Error("value must be type 'string', is currently type " + typeof value2 + ", while checking isHexPrefixed.");
      }
      return value2.slice(0, 2) === "0x";
    }
    function intToBuffer2(i6) {
      const hex = intToHex(i6);
      return Buffer2.from(padToEven(hex.slice(2)), "hex");
    }
    function intToHex(i6) {
      const hex = i6.toString(16);
      return `0x${hex}`;
    }
    if (typeof window !== "undefined") {
      window.keccak256 = keccak2563;
    }
    module2.exports = keccak2563;
  }
});

// node_modules/object-keys/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/object-keys/isArguments.js"(exports2, module2) {
    "use strict";
    var toStr = Object.prototype.toString;
    module2.exports = function isArguments(value2) {
      var str = toStr.call(value2);
      var isArgs = str === "[object Arguments]";
      if (!isArgs) {
        isArgs = str !== "[object Array]" && value2 !== null && typeof value2 === "object" && typeof value2.length === "number" && value2.length >= 0 && toStr.call(value2.callee) === "[object Function]";
      }
      return isArgs;
    };
  }
});

// node_modules/object-keys/implementation.js
var require_implementation2 = __commonJS({
  "node_modules/object-keys/implementation.js"(exports2, module2) {
    "use strict";
    var keysShim;
    if (!Object.keys) {
      has = Object.prototype.hasOwnProperty;
      toStr = Object.prototype.toString;
      isArgs = require_isArguments();
      isEnumerable = Object.prototype.propertyIsEnumerable;
      hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
      hasProtoEnumBug = isEnumerable.call(function() {
      }, "prototype");
      dontEnums = [
        "toString",
        "toLocaleString",
        "valueOf",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "constructor"
      ];
      equalsConstructorPrototype = function(o6) {
        var ctor = o6.constructor;
        return ctor && ctor.prototype === o6;
      };
      excludedKeys = {
        $applicationCache: true,
        $console: true,
        $external: true,
        $frame: true,
        $frameElement: true,
        $frames: true,
        $innerHeight: true,
        $innerWidth: true,
        $onmozfullscreenchange: true,
        $onmozfullscreenerror: true,
        $outerHeight: true,
        $outerWidth: true,
        $pageXOffset: true,
        $pageYOffset: true,
        $parent: true,
        $scrollLeft: true,
        $scrollTop: true,
        $scrollX: true,
        $scrollY: true,
        $self: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $window: true
      };
      hasAutomationEqualityBug = function() {
        if (typeof window === "undefined") {
          return false;
        }
        for (var k8 in window) {
          try {
            if (!excludedKeys["$" + k8] && has.call(window, k8) && window[k8] !== null && typeof window[k8] === "object") {
              try {
                equalsConstructorPrototype(window[k8]);
              } catch (e6) {
                return true;
              }
            }
          } catch (e6) {
            return true;
          }
        }
        return false;
      }();
      equalsConstructorPrototypeIfNotBuggy = function(o6) {
        if (typeof window === "undefined" || !hasAutomationEqualityBug) {
          return equalsConstructorPrototype(o6);
        }
        try {
          return equalsConstructorPrototype(o6);
        } catch (e6) {
          return false;
        }
      };
      keysShim = function keys(object) {
        var isObject2 = object !== null && typeof object === "object";
        var isFunction2 = toStr.call(object) === "[object Function]";
        var isArguments = isArgs(object);
        var isString = isObject2 && toStr.call(object) === "[object String]";
        var theKeys = [];
        if (!isObject2 && !isFunction2 && !isArguments) {
          throw new TypeError("Object.keys called on a non-object");
        }
        var skipProto = hasProtoEnumBug && isFunction2;
        if (isString && object.length > 0 && !has.call(object, 0)) {
          for (var i6 = 0; i6 < object.length; ++i6) {
            theKeys.push(String(i6));
          }
        }
        if (isArguments && object.length > 0) {
          for (var j8 = 0; j8 < object.length; ++j8) {
            theKeys.push(String(j8));
          }
        } else {
          for (var name2 in object) {
            if (!(skipProto && name2 === "prototype") && has.call(object, name2)) {
              theKeys.push(String(name2));
            }
          }
        }
        if (hasDontEnumBug) {
          var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
          for (var k8 = 0; k8 < dontEnums.length; ++k8) {
            if (!(skipConstructor && dontEnums[k8] === "constructor") && has.call(object, dontEnums[k8])) {
              theKeys.push(dontEnums[k8]);
            }
          }
        }
        return theKeys;
      };
    }
    var has;
    var toStr;
    var isArgs;
    var isEnumerable;
    var hasDontEnumBug;
    var hasProtoEnumBug;
    var dontEnums;
    var equalsConstructorPrototype;
    var excludedKeys;
    var hasAutomationEqualityBug;
    var equalsConstructorPrototypeIfNotBuggy;
    module2.exports = keysShim;
  }
});

// node_modules/object-keys/index.js
var require_object_keys = __commonJS({
  "node_modules/object-keys/index.js"(exports2, module2) {
    "use strict";
    var slice = Array.prototype.slice;
    var isArgs = require_isArguments();
    var origKeys = Object.keys;
    var keysShim = origKeys ? function keys(o6) {
      return origKeys(o6);
    } : require_implementation2();
    var originalKeys = Object.keys;
    keysShim.shim = function shimObjectKeys() {
      if (Object.keys) {
        var keysWorksWithArguments = function() {
          var args = Object.keys(arguments);
          return args && args.length === arguments.length;
        }(1, 2);
        if (!keysWorksWithArguments) {
          Object.keys = function keys(object) {
            if (isArgs(object)) {
              return originalKeys(slice.call(object));
            }
            return originalKeys(object);
          };
        }
      } else {
        Object.keys = keysShim;
      }
      return Object.keys || keysShim;
    };
    module2.exports = keysShim;
  }
});

// node_modules/has-property-descriptors/index.js
var require_has_property_descriptors = __commonJS({
  "node_modules/has-property-descriptors/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var hasPropertyDescriptors = function hasPropertyDescriptors2() {
      if ($defineProperty) {
        try {
          $defineProperty({}, "a", { value: 1 });
          return true;
        } catch (e6) {
          return false;
        }
      }
      return false;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
      if (!hasPropertyDescriptors()) {
        return null;
      }
      try {
        return $defineProperty([], "length", { value: 1 }).length !== 1;
      } catch (e6) {
        return true;
      }
    };
    module2.exports = hasPropertyDescriptors;
  }
});

// node_modules/define-properties/index.js
var require_define_properties = __commonJS({
  "node_modules/define-properties/index.js"(exports2, module2) {
    "use strict";
    var keys = require_object_keys();
    var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
    var toStr = Object.prototype.toString;
    var concat4 = Array.prototype.concat;
    var origDefineProperty = Object.defineProperty;
    var isFunction2 = function(fn2) {
      return typeof fn2 === "function" && toStr.call(fn2) === "[object Function]";
    };
    var hasPropertyDescriptors = require_has_property_descriptors()();
    var supportsDescriptors = origDefineProperty && hasPropertyDescriptors;
    var defineProperty = function(object, name2, value2, predicate) {
      if (name2 in object && (!isFunction2(predicate) || !predicate())) {
        return;
      }
      if (supportsDescriptors) {
        origDefineProperty(object, name2, {
          configurable: true,
          enumerable: false,
          value: value2,
          writable: true
        });
      } else {
        object[name2] = value2;
      }
    };
    var defineProperties = function(object, map2) {
      var predicates = arguments.length > 2 ? arguments[2] : {};
      var props = keys(map2);
      if (hasSymbols) {
        props = concat4.call(props, Object.getOwnPropertySymbols(map2));
      }
      for (var i6 = 0; i6 < props.length; i6 += 1) {
        defineProperty(object, props[i6], map2[props[i6]], predicates[props[i6]]);
      }
    };
    defineProperties.supportsDescriptors = !!supportsDescriptors;
    module2.exports = defineProperties;
  }
});

// node_modules/object-is/implementation.js
var require_implementation3 = __commonJS({
  "node_modules/object-is/implementation.js"(exports2, module2) {
    "use strict";
    var numberIsNaN = function(value2) {
      return value2 !== value2;
    };
    module2.exports = function is(a5, b4) {
      if (a5 === 0 && b4 === 0) {
        return 1 / a5 === 1 / b4;
      }
      if (a5 === b4) {
        return true;
      }
      if (numberIsNaN(a5) && numberIsNaN(b4)) {
        return true;
      }
      return false;
    };
  }
});

// node_modules/object-is/polyfill.js
var require_polyfill = __commonJS({
  "node_modules/object-is/polyfill.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation3();
    module2.exports = function getPolyfill() {
      return typeof Object.is === "function" ? Object.is : implementation;
    };
  }
});

// node_modules/object-is/shim.js
var require_shim = __commonJS({
  "node_modules/object-is/shim.js"(exports2, module2) {
    "use strict";
    var getPolyfill = require_polyfill();
    var define2 = require_define_properties();
    module2.exports = function shimObjectIs() {
      var polyfill = getPolyfill();
      define2(Object, { is: polyfill }, {
        is: function testObjectIs() {
          return Object.is !== polyfill;
        }
      });
      return polyfill;
    };
  }
});

// node_modules/object-is/index.js
var require_object_is = __commonJS({
  "node_modules/object-is/index.js"(exports2, module2) {
    "use strict";
    var define2 = require_define_properties();
    var callBind = require_call_bind();
    var implementation = require_implementation3();
    var getPolyfill = require_polyfill();
    var shim = require_shim();
    var polyfill = callBind(getPolyfill(), Object);
    define2(polyfill, {
      getPolyfill,
      implementation,
      shim
    });
    module2.exports = polyfill;
  }
});

// node_modules/is-regex/index.js
var require_is_regex = __commonJS({
  "node_modules/is-regex/index.js"(exports2, module2) {
    "use strict";
    var callBound = require_callBound();
    var hasToStringTag = require_shams2()();
    var has;
    var $exec;
    var isRegexMarker;
    var badStringifier;
    if (hasToStringTag) {
      has = callBound("Object.prototype.hasOwnProperty");
      $exec = callBound("RegExp.prototype.exec");
      isRegexMarker = {};
      throwRegexMarker = function() {
        throw isRegexMarker;
      };
      badStringifier = {
        toString: throwRegexMarker,
        valueOf: throwRegexMarker
      };
      if (typeof Symbol.toPrimitive === "symbol") {
        badStringifier[Symbol.toPrimitive] = throwRegexMarker;
      }
    }
    var throwRegexMarker;
    var $toString = callBound("Object.prototype.toString");
    var gOPD = Object.getOwnPropertyDescriptor;
    var regexClass = "[object RegExp]";
    module2.exports = hasToStringTag ? function isRegex(value2) {
      if (!value2 || typeof value2 !== "object") {
        return false;
      }
      var descriptor = gOPD(value2, "lastIndex");
      var hasLastIndexDataProperty = descriptor && has(descriptor, "value");
      if (!hasLastIndexDataProperty) {
        return false;
      }
      try {
        $exec(value2, badStringifier);
      } catch (e6) {
        return e6 === isRegexMarker;
      }
    } : function isRegex(value2) {
      if (!value2 || typeof value2 !== "object" && typeof value2 !== "function") {
        return false;
      }
      return $toString(value2) === regexClass;
    };
  }
});

// node_modules/functions-have-names/index.js
var require_functions_have_names = __commonJS({
  "node_modules/functions-have-names/index.js"(exports2, module2) {
    "use strict";
    var functionsHaveNames = function functionsHaveNames2() {
      return typeof function f7() {
      }.name === "string";
    };
    var gOPD = Object.getOwnPropertyDescriptor;
    if (gOPD) {
      try {
        gOPD([], "length");
      } catch (e6) {
        gOPD = null;
      }
    }
    functionsHaveNames.functionsHaveConfigurableNames = function functionsHaveConfigurableNames() {
      if (!functionsHaveNames() || !gOPD) {
        return false;
      }
      var desc = gOPD(function() {
      }, "name");
      return !!desc && !!desc.configurable;
    };
    var $bind = Function.prototype.bind;
    functionsHaveNames.boundFunctionsHaveNames = function boundFunctionsHaveNames() {
      return functionsHaveNames() && typeof $bind === "function" && function f7() {
      }.bind().name !== "";
    };
    module2.exports = functionsHaveNames;
  }
});

// node_modules/regexp.prototype.flags/implementation.js
var require_implementation4 = __commonJS({
  "node_modules/regexp.prototype.flags/implementation.js"(exports2, module2) {
    "use strict";
    var functionsHaveConfigurableNames = require_functions_have_names().functionsHaveConfigurableNames();
    var $Object = Object;
    var $TypeError = TypeError;
    module2.exports = function flags() {
      if (this != null && this !== $Object(this)) {
        throw new $TypeError("RegExp.prototype.flags getter called on non-object");
      }
      var result = "";
      if (this.hasIndices) {
        result += "d";
      }
      if (this.global) {
        result += "g";
      }
      if (this.ignoreCase) {
        result += "i";
      }
      if (this.multiline) {
        result += "m";
      }
      if (this.dotAll) {
        result += "s";
      }
      if (this.unicode) {
        result += "u";
      }
      if (this.sticky) {
        result += "y";
      }
      return result;
    };
    if (functionsHaveConfigurableNames && Object.defineProperty) {
      Object.defineProperty(module2.exports, "name", { value: "get flags" });
    }
  }
});

// node_modules/regexp.prototype.flags/polyfill.js
var require_polyfill2 = __commonJS({
  "node_modules/regexp.prototype.flags/polyfill.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation4();
    var supportsDescriptors = require_define_properties().supportsDescriptors;
    var $gOPD = Object.getOwnPropertyDescriptor;
    module2.exports = function getPolyfill() {
      if (supportsDescriptors && /a/mig.flags === "gim") {
        var descriptor = $gOPD(RegExp.prototype, "flags");
        if (descriptor && typeof descriptor.get === "function" && typeof RegExp.prototype.dotAll === "boolean" && typeof RegExp.prototype.hasIndices === "boolean") {
          var calls = "";
          var o6 = {};
          Object.defineProperty(o6, "hasIndices", {
            get: function() {
              calls += "d";
            }
          });
          Object.defineProperty(o6, "sticky", {
            get: function() {
              calls += "y";
            }
          });
          if (calls === "dy") {
            return descriptor.get;
          }
        }
      }
      return implementation;
    };
  }
});

// node_modules/regexp.prototype.flags/shim.js
var require_shim2 = __commonJS({
  "node_modules/regexp.prototype.flags/shim.js"(exports2, module2) {
    "use strict";
    var supportsDescriptors = require_define_properties().supportsDescriptors;
    var getPolyfill = require_polyfill2();
    var gOPD = Object.getOwnPropertyDescriptor;
    var defineProperty = Object.defineProperty;
    var TypeErr = TypeError;
    var getProto = Object.getPrototypeOf;
    var regex = /a/;
    module2.exports = function shimFlags() {
      if (!supportsDescriptors || !getProto) {
        throw new TypeErr("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
      }
      var polyfill = getPolyfill();
      var proto = getProto(regex);
      var descriptor = gOPD(proto, "flags");
      if (!descriptor || descriptor.get !== polyfill) {
        defineProperty(proto, "flags", {
          configurable: true,
          enumerable: false,
          get: polyfill
        });
      }
      return polyfill;
    };
  }
});

// node_modules/regexp.prototype.flags/index.js
var require_regexp_prototype = __commonJS({
  "node_modules/regexp.prototype.flags/index.js"(exports2, module2) {
    "use strict";
    var define2 = require_define_properties();
    var callBind = require_call_bind();
    var implementation = require_implementation4();
    var getPolyfill = require_polyfill2();
    var shim = require_shim2();
    var flagsBound = callBind(getPolyfill());
    define2(flagsBound, {
      getPolyfill,
      implementation,
      shim
    });
    module2.exports = flagsBound;
  }
});

// node_modules/isarray/index.js
var require_isarray = __commonJS({
  "node_modules/isarray/index.js"(exports2, module2) {
    var toString2 = {}.toString;
    module2.exports = Array.isArray || function(arr) {
      return toString2.call(arr) == "[object Array]";
    };
  }
});

// node_modules/is-date-object/index.js
var require_is_date_object = __commonJS({
  "node_modules/is-date-object/index.js"(exports2, module2) {
    "use strict";
    var getDay = Date.prototype.getDay;
    var tryDateObject = function tryDateGetDayCall(value2) {
      try {
        getDay.call(value2);
        return true;
      } catch (e6) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var dateClass = "[object Date]";
    var hasToStringTag = require_shams2()();
    module2.exports = function isDateObject(value2) {
      if (typeof value2 !== "object" || value2 === null) {
        return false;
      }
      return hasToStringTag ? tryDateObject(value2) : toStr.call(value2) === dateClass;
    };
  }
});

// node_modules/is-string/index.js
var require_is_string = __commonJS({
  "node_modules/is-string/index.js"(exports2, module2) {
    "use strict";
    var strValue = String.prototype.valueOf;
    var tryStringObject = function tryStringObject2(value2) {
      try {
        strValue.call(value2);
        return true;
      } catch (e6) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var strClass = "[object String]";
    var hasToStringTag = require_shams2()();
    module2.exports = function isString(value2) {
      if (typeof value2 === "string") {
        return true;
      }
      if (typeof value2 !== "object") {
        return false;
      }
      return hasToStringTag ? tryStringObject(value2) : toStr.call(value2) === strClass;
    };
  }
});

// node_modules/is-number-object/index.js
var require_is_number_object = __commonJS({
  "node_modules/is-number-object/index.js"(exports2, module2) {
    "use strict";
    var numToStr = Number.prototype.toString;
    var tryNumberObject = function tryNumberObject2(value2) {
      try {
        numToStr.call(value2);
        return true;
      } catch (e6) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var numClass = "[object Number]";
    var hasToStringTag = require_shams2()();
    module2.exports = function isNumberObject(value2) {
      if (typeof value2 === "number") {
        return true;
      }
      if (typeof value2 !== "object") {
        return false;
      }
      return hasToStringTag ? tryNumberObject(value2) : toStr.call(value2) === numClass;
    };
  }
});

// node_modules/is-boolean-object/index.js
var require_is_boolean_object = __commonJS({
  "node_modules/is-boolean-object/index.js"(exports2, module2) {
    "use strict";
    var callBound = require_callBound();
    var $boolToStr = callBound("Boolean.prototype.toString");
    var $toString = callBound("Object.prototype.toString");
    var tryBooleanObject = function booleanBrandCheck(value2) {
      try {
        $boolToStr(value2);
        return true;
      } catch (e6) {
        return false;
      }
    };
    var boolClass = "[object Boolean]";
    var hasToStringTag = require_shams2()();
    module2.exports = function isBoolean(value2) {
      if (typeof value2 === "boolean") {
        return true;
      }
      if (value2 === null || typeof value2 !== "object") {
        return false;
      }
      return hasToStringTag && Symbol.toStringTag in value2 ? tryBooleanObject(value2) : $toString(value2) === boolClass;
    };
  }
});

// node_modules/is-symbol/index.js
var require_is_symbol = __commonJS({
  "node_modules/is-symbol/index.js"(exports2, module2) {
    "use strict";
    var toStr = Object.prototype.toString;
    var hasSymbols = require_has_symbols()();
    if (hasSymbols) {
      symToStr = Symbol.prototype.toString;
      symStringRegex = /^Symbol\(.*\)$/;
      isSymbolObject = function isRealSymbolObject(value2) {
        if (typeof value2.valueOf() !== "symbol") {
          return false;
        }
        return symStringRegex.test(symToStr.call(value2));
      };
      module2.exports = function isSymbol(value2) {
        if (typeof value2 === "symbol") {
          return true;
        }
        if (toStr.call(value2) !== "[object Symbol]") {
          return false;
        }
        try {
          return isSymbolObject(value2);
        } catch (e6) {
          return false;
        }
      };
    } else {
      module2.exports = function isSymbol(value2) {
        return false;
      };
    }
    var symToStr;
    var symStringRegex;
    var isSymbolObject;
  }
});

// node_modules/has-bigints/index.js
var require_has_bigints = __commonJS({
  "node_modules/has-bigints/index.js"(exports2, module2) {
    "use strict";
    var $BigInt = typeof BigInt !== "undefined" && BigInt;
    module2.exports = function hasNativeBigInts() {
      return typeof $BigInt === "function" && typeof BigInt === "function" && typeof $BigInt(42) === "bigint" && typeof BigInt(42) === "bigint";
    };
  }
});

// node_modules/is-bigint/index.js
var require_is_bigint = __commonJS({
  "node_modules/is-bigint/index.js"(exports2, module2) {
    "use strict";
    var hasBigInts = require_has_bigints()();
    if (hasBigInts) {
      bigIntValueOf = BigInt.prototype.valueOf;
      tryBigInt = function tryBigIntObject(value2) {
        try {
          bigIntValueOf.call(value2);
          return true;
        } catch (e6) {
        }
        return false;
      };
      module2.exports = function isBigInt(value2) {
        if (value2 === null || typeof value2 === "undefined" || typeof value2 === "boolean" || typeof value2 === "string" || typeof value2 === "number" || typeof value2 === "symbol" || typeof value2 === "function") {
          return false;
        }
        if (typeof value2 === "bigint") {
          return true;
        }
        return tryBigInt(value2);
      };
    } else {
      module2.exports = function isBigInt(value2) {
        return false;
      };
    }
    var bigIntValueOf;
    var tryBigInt;
  }
});

// node_modules/which-boxed-primitive/index.js
var require_which_boxed_primitive = __commonJS({
  "node_modules/which-boxed-primitive/index.js"(exports2, module2) {
    "use strict";
    var isString = require_is_string();
    var isNumber = require_is_number_object();
    var isBoolean = require_is_boolean_object();
    var isSymbol = require_is_symbol();
    var isBigInt = require_is_bigint();
    module2.exports = function whichBoxedPrimitive(value2) {
      if (value2 == null || typeof value2 !== "object" && typeof value2 !== "function") {
        return null;
      }
      if (isString(value2)) {
        return "String";
      }
      if (isNumber(value2)) {
        return "Number";
      }
      if (isBoolean(value2)) {
        return "Boolean";
      }
      if (isSymbol(value2)) {
        return "Symbol";
      }
      if (isBigInt(value2)) {
        return "BigInt";
      }
    };
  }
});

// node_modules/is-map/index.js
var require_is_map = __commonJS({
  "node_modules/is-map/index.js"(exports2, module2) {
    "use strict";
    var $Map = typeof Map === "function" && Map.prototype ? Map : null;
    var $Set = typeof Set === "function" && Set.prototype ? Set : null;
    var exported;
    if (!$Map) {
      exported = function isMap(x6) {
        return false;
      };
    }
    var $mapHas = $Map ? Map.prototype.has : null;
    var $setHas = $Set ? Set.prototype.has : null;
    if (!exported && !$mapHas) {
      exported = function isMap(x6) {
        return false;
      };
    }
    module2.exports = exported || function isMap(x6) {
      if (!x6 || typeof x6 !== "object") {
        return false;
      }
      try {
        $mapHas.call(x6);
        if ($setHas) {
          try {
            $setHas.call(x6);
          } catch (e6) {
            return true;
          }
        }
        return x6 instanceof $Map;
      } catch (e6) {
      }
      return false;
    };
  }
});

// node_modules/is-set/index.js
var require_is_set = __commonJS({
  "node_modules/is-set/index.js"(exports2, module2) {
    "use strict";
    var $Map = typeof Map === "function" && Map.prototype ? Map : null;
    var $Set = typeof Set === "function" && Set.prototype ? Set : null;
    var exported;
    if (!$Set) {
      exported = function isSet(x6) {
        return false;
      };
    }
    var $mapHas = $Map ? Map.prototype.has : null;
    var $setHas = $Set ? Set.prototype.has : null;
    if (!exported && !$setHas) {
      exported = function isSet(x6) {
        return false;
      };
    }
    module2.exports = exported || function isSet(x6) {
      if (!x6 || typeof x6 !== "object") {
        return false;
      }
      try {
        $setHas.call(x6);
        if ($mapHas) {
          try {
            $mapHas.call(x6);
          } catch (e6) {
            return true;
          }
        }
        return x6 instanceof $Set;
      } catch (e6) {
      }
      return false;
    };
  }
});

// node_modules/is-weakmap/index.js
var require_is_weakmap = __commonJS({
  "node_modules/is-weakmap/index.js"(exports2, module2) {
    "use strict";
    var $WeakMap = typeof WeakMap === "function" && WeakMap.prototype ? WeakMap : null;
    var $WeakSet = typeof WeakSet === "function" && WeakSet.prototype ? WeakSet : null;
    var exported;
    if (!$WeakMap) {
      exported = function isWeakMap(x6) {
        return false;
      };
    }
    var $mapHas = $WeakMap ? $WeakMap.prototype.has : null;
    var $setHas = $WeakSet ? $WeakSet.prototype.has : null;
    if (!exported && !$mapHas) {
      exported = function isWeakMap(x6) {
        return false;
      };
    }
    module2.exports = exported || function isWeakMap(x6) {
      if (!x6 || typeof x6 !== "object") {
        return false;
      }
      try {
        $mapHas.call(x6, $mapHas);
        if ($setHas) {
          try {
            $setHas.call(x6, $setHas);
          } catch (e6) {
            return true;
          }
        }
        return x6 instanceof $WeakMap;
      } catch (e6) {
      }
      return false;
    };
  }
});

// node_modules/is-weakset/index.js
var require_is_weakset = __commonJS({
  "node_modules/is-weakset/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var $WeakSet = GetIntrinsic("%WeakSet%", true);
    var $setHas = callBound("WeakSet.prototype.has", true);
    if ($setHas) {
      $mapHas = callBound("WeakMap.prototype.has", true);
      module2.exports = function isWeakSet(x6) {
        if (!x6 || typeof x6 !== "object") {
          return false;
        }
        try {
          $setHas(x6, $setHas);
          if ($mapHas) {
            try {
              $mapHas(x6, $mapHas);
            } catch (e6) {
              return true;
            }
          }
          return x6 instanceof $WeakSet;
        } catch (e6) {
        }
        return false;
      };
    } else {
      module2.exports = function isWeakSet(x6) {
        return false;
      };
    }
    var $mapHas;
  }
});

// node_modules/which-collection/index.js
var require_which_collection = __commonJS({
  "node_modules/which-collection/index.js"(exports2, module2) {
    "use strict";
    var isMap = require_is_map();
    var isSet = require_is_set();
    var isWeakMap = require_is_weakmap();
    var isWeakSet = require_is_weakset();
    module2.exports = function whichCollection(value2) {
      if (value2 && typeof value2 === "object") {
        if (isMap(value2)) {
          return "Map";
        }
        if (isSet(value2)) {
          return "Set";
        }
        if (isWeakMap(value2)) {
          return "WeakMap";
        }
        if (isWeakSet(value2)) {
          return "WeakSet";
        }
      }
      return false;
    };
  }
});

// node_modules/es-get-iterator/index.js
var require_es_get_iterator = __commonJS({
  "node_modules/es-get-iterator/index.js"(exports2, module2) {
    "use strict";
    var isArguments = require_is_arguments();
    if (require_has_symbols()() || require_shams()()) {
      $iterator = Symbol.iterator;
      module2.exports = function getIterator(iterable) {
        if (iterable != null && typeof iterable[$iterator] !== "undefined") {
          return iterable[$iterator]();
        }
        if (isArguments(iterable)) {
          return Array.prototype[$iterator].call(iterable);
        }
      };
    } else {
      isArray2 = require_isarray();
      isString = require_is_string();
      GetIntrinsic = require_get_intrinsic();
      $Map = GetIntrinsic("%Map%", true);
      $Set = GetIntrinsic("%Set%", true);
      callBound = require_callBound();
      $arrayPush = callBound("Array.prototype.push");
      $charCodeAt = callBound("String.prototype.charCodeAt");
      $stringSlice = callBound("String.prototype.slice");
      advanceStringIndex = function advanceStringIndex2(S5, index) {
        var length = S5.length;
        if (index + 1 >= length) {
          return index + 1;
        }
        var first2 = $charCodeAt(S5, index);
        if (first2 < 55296 || first2 > 56319) {
          return index + 1;
        }
        var second = $charCodeAt(S5, index + 1);
        if (second < 56320 || second > 57343) {
          return index + 1;
        }
        return index + 2;
      };
      getArrayIterator = function getArrayIterator2(arraylike) {
        var i6 = 0;
        return {
          next: function next() {
            var done = i6 >= arraylike.length;
            var value2;
            if (!done) {
              value2 = arraylike[i6];
              i6 += 1;
            }
            return {
              done,
              value: value2
            };
          }
        };
      };
      getNonCollectionIterator = function getNonCollectionIterator2(iterable, noPrimordialCollections) {
        if (isArray2(iterable) || isArguments(iterable)) {
          return getArrayIterator(iterable);
        }
        if (isString(iterable)) {
          var i6 = 0;
          return {
            next: function next() {
              var nextIndex = advanceStringIndex(iterable, i6);
              var value2 = $stringSlice(iterable, i6, nextIndex);
              i6 = nextIndex;
              return {
                done: nextIndex > iterable.length,
                value: value2
              };
            }
          };
        }
        if (noPrimordialCollections && typeof iterable["_es6-shim iterator_"] !== "undefined") {
          return iterable["_es6-shim iterator_"]();
        }
      };
      if (!$Map && !$Set) {
        module2.exports = function getIterator(iterable) {
          if (iterable != null) {
            return getNonCollectionIterator(iterable, true);
          }
        };
      } else {
        isMap = require_is_map();
        isSet = require_is_set();
        $mapForEach = callBound("Map.prototype.forEach", true);
        $setForEach = callBound("Set.prototype.forEach", true);
        if (typeof process === "undefined" || !process.versions || !process.versions.node) {
          $mapIterator = callBound("Map.prototype.iterator", true);
          $setIterator = callBound("Set.prototype.iterator", true);
          getStopIterationIterator = function(iterator2) {
            var done = false;
            return {
              next: function next() {
                try {
                  return {
                    done,
                    value: done ? void 0 : iterator2.next()
                  };
                } catch (e6) {
                  done = true;
                  return {
                    done: true,
                    value: void 0
                  };
                }
              }
            };
          };
        }
        $mapAtAtIterator = callBound("Map.prototype.@@iterator", true) || callBound("Map.prototype._es6-shim iterator_", true);
        $setAtAtIterator = callBound("Set.prototype.@@iterator", true) || callBound("Set.prototype._es6-shim iterator_", true);
        getCollectionIterator = function getCollectionIterator2(iterable) {
          if (isMap(iterable)) {
            if ($mapIterator) {
              return getStopIterationIterator($mapIterator(iterable));
            }
            if ($mapAtAtIterator) {
              return $mapAtAtIterator(iterable);
            }
            if ($mapForEach) {
              var entries = [];
              $mapForEach(iterable, function(v9, k8) {
                $arrayPush(entries, [k8, v9]);
              });
              return getArrayIterator(entries);
            }
          }
          if (isSet(iterable)) {
            if ($setIterator) {
              return getStopIterationIterator($setIterator(iterable));
            }
            if ($setAtAtIterator) {
              return $setAtAtIterator(iterable);
            }
            if ($setForEach) {
              var values = [];
              $setForEach(iterable, function(v9) {
                $arrayPush(values, v9);
              });
              return getArrayIterator(values);
            }
          }
        };
        module2.exports = function getIterator(iterable) {
          return getCollectionIterator(iterable) || getNonCollectionIterator(iterable);
        };
      }
    }
    var $iterator;
    var isArray2;
    var isString;
    var GetIntrinsic;
    var $Map;
    var $Set;
    var callBound;
    var $arrayPush;
    var $charCodeAt;
    var $stringSlice;
    var advanceStringIndex;
    var getArrayIterator;
    var getNonCollectionIterator;
    var isMap;
    var isSet;
    var $mapForEach;
    var $setForEach;
    var $mapIterator;
    var $setIterator;
    var getStopIterationIterator;
    var $mapAtAtIterator;
    var $setAtAtIterator;
    var getCollectionIterator;
  }
});

// (disabled):node_modules/object-inspect/util.inspect
var require_util2 = __commonJS({
  "(disabled):node_modules/object-inspect/util.inspect"() {
  }
});

// node_modules/object-inspect/index.js
var require_object_inspect = __commonJS({
  "node_modules/object-inspect/index.js"(exports2, module2) {
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O4) {
      return O4.__proto__;
    } : null);
    function addNumericSeparator(num, str) {
      if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
        return str;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num === "number") {
        var int = num < 0 ? -$floor(-num) : $floor(num);
        if (int !== num) {
          var intStr = String(int);
          var dec = $slice.call(str, intStr.length + 1);
          return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return $replace.call(str, sepRegex, "$&_");
    }
    var inspectCustom = require_util2().custom;
    var inspectSymbol = inspectCustom && isSymbol(inspectCustom) ? inspectCustom : null;
    module2.exports = function inspect_(obj, options, depth, seen) {
      var opts = options || {};
      if (has(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray2(obj) ? "[Array]" : "[Object]";
      }
      var indent = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect4(value2, from2, noIndent) {
        if (from2) {
          seen = $arrSlice.call(seen);
          seen.push(from2);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value2, newOpts, depth + 1, seen);
        }
        return inspect_(value2, opts, depth + 1, seen);
      }
      if (typeof obj === "function") {
        var name2 = nameOf(obj);
        var keys = arrObjKeys(obj, inspect4);
        return "[Function" + (name2 ? ": " + name2 : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
      }
      if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement(obj)) {
        var s6 = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i6 = 0; i6 < attrs.length; i6++) {
          s6 += " " + attrs[i6].name + "=" + wrapQuotes(quote(attrs[i6].value), "double", opts);
        }
        s6 += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s6 += "...";
        }
        s6 += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s6;
      }
      if (isArray2(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect4);
        if (indent && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent) + "]";
        }
        return "[ " + $join.call(xs, ", ") + " ]";
      }
      if (isError2(obj)) {
        var parts = arrObjKeys(obj, inspect4);
        if ("cause" in obj && !isEnumerable.call(obj, "cause")) {
          return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect4(obj.cause), parts), ", ") + " }";
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function") {
          return obj[inspectSymbol]();
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap(obj)) {
        var mapParts = [];
        mapForEach.call(obj, function(value2, key2) {
          mapParts.push(inspect4(key2, obj, true) + " => " + inspect4(value2, obj));
        });
        return collectionOf("Map", mapSize.call(obj), mapParts, indent);
      }
      if (isSet(obj)) {
        var setParts = [];
        setForEach.call(obj, function(value2) {
          setParts.push(inspect4(value2, obj));
        });
        return collectionOf("Set", setSize.call(obj), setParts, indent);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber(obj)) {
        return markBoxed(inspect4(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect4(bigIntValueOf.call(obj)));
      }
      if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString(obj)) {
        return markBoxed(inspect4(String(obj)));
      }
      if (!isDate2(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect4);
        var isPlainObject2 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag = !isPlainObject2 && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject2 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
        if (ys.length === 0) {
          return tag + "{}";
        }
        if (indent) {
          return tag + "{" + indentedJoin(ys, indent) + "}";
        }
        return tag + "{ " + $join.call(ys, ", ") + " }";
      }
      return String(obj);
    };
    function wrapQuotes(s6, defaultStyle, opts) {
      var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
      return quoteChar + s6 + quoteChar;
    }
    function quote(s6) {
      return $replace.call(String(s6), /"/g, "&quot;");
    }
    function isArray2(obj) {
      return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isDate2(obj) {
      return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isRegExp(obj) {
      return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isError2(obj) {
      return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isString(obj) {
      return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isNumber(obj) {
      return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isBoolean(obj) {
      return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isSymbol(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e6) {
      }
      return false;
    }
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e6) {
      }
      return false;
    }
    var hasOwn = Object.prototype.hasOwnProperty || function(key2) {
      return key2 in this;
    };
    function has(obj, key2) {
      return hasOwn.call(obj, key2);
    }
    function toStr(obj) {
      return objectToString.call(obj);
    }
    function nameOf(f7) {
      if (f7.name) {
        return f7.name;
      }
      var m6 = $match.call(functionToString.call(f7), /^function\s*([\w$]+)/);
      if (m6) {
        return m6[1];
      }
      return null;
    }
    function indexOf(xs, x6) {
      if (xs.indexOf) {
        return xs.indexOf(x6);
      }
      for (var i6 = 0, l6 = xs.length; i6 < l6; i6++) {
        if (xs[i6] === x6) {
          return i6;
        }
      }
      return -1;
    }
    function isMap(x6) {
      if (!mapSize || !x6 || typeof x6 !== "object") {
        return false;
      }
      try {
        mapSize.call(x6);
        try {
          setSize.call(x6);
        } catch (s6) {
          return true;
        }
        return x6 instanceof Map;
      } catch (e6) {
      }
      return false;
    }
    function isWeakMap(x6) {
      if (!weakMapHas || !x6 || typeof x6 !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x6, weakMapHas);
        try {
          weakSetHas.call(x6, weakSetHas);
        } catch (s6) {
          return true;
        }
        return x6 instanceof WeakMap;
      } catch (e6) {
      }
      return false;
    }
    function isWeakRef(x6) {
      if (!weakRefDeref || !x6 || typeof x6 !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x6);
        return true;
      } catch (e6) {
      }
      return false;
    }
    function isSet(x6) {
      if (!setSize || !x6 || typeof x6 !== "object") {
        return false;
      }
      try {
        setSize.call(x6);
        try {
          mapSize.call(x6);
        } catch (m6) {
          return true;
        }
        return x6 instanceof Set;
      } catch (e6) {
      }
      return false;
    }
    function isWeakSet(x6) {
      if (!weakSetHas || !x6 || typeof x6 !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x6, weakSetHas);
        try {
          weakMapHas.call(x6, weakMapHas);
        } catch (s6) {
          return true;
        }
        return x6 instanceof WeakSet;
      } catch (e6) {
      }
      return false;
    }
    function isElement(x6) {
      if (!x6 || typeof x6 !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x6 instanceof HTMLElement) {
        return true;
      }
      return typeof x6.nodeName === "string" && typeof x6.getAttribute === "function";
    }
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
      }
      var s6 = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s6, "single", opts);
    }
    function lowbyte(c5) {
      var n4 = c5.charCodeAt(0);
      var x6 = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n4];
      if (x6) {
        return "\\" + x6;
      }
      return "\\x" + (n4 < 16 ? "0" : "") + $toUpperCase.call(n4.toString(16));
    }
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    function weakCollectionOf(type) {
      return type + " { ? }";
    }
    function collectionOf(type, size, entries, indent) {
      var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
      return type + " (" + size + ") {" + joinedEntries + "}";
    }
    function singleLineValues(xs) {
      for (var i6 = 0; i6 < xs.length; i6++) {
        if (indexOf(xs[i6], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
      };
    }
    function indentedJoin(xs, indent) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent.prev + indent.base;
      return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
    }
    function arrObjKeys(obj, inspect4) {
      var isArr = isArray2(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i6 = 0; i6 < obj.length; i6++) {
          xs[i6] = has(obj, i6) ? inspect4(obj[i6], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k8 = 0; k8 < syms.length; k8++) {
          symMap["$" + syms[k8]] = syms[k8];
        }
      }
      for (var key2 in obj) {
        if (!has(obj, key2)) {
          continue;
        }
        if (isArr && String(Number(key2)) === key2 && key2 < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key2] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key2)) {
          xs.push(inspect4(key2, obj) + ": " + inspect4(obj[key2], obj));
        } else {
          xs.push(key2 + ": " + inspect4(obj[key2], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j8 = 0; j8 < syms.length; j8++) {
          if (isEnumerable.call(obj, syms[j8])) {
            xs.push("[" + inspect4(syms[j8]) + "]: " + inspect4(obj[syms[j8]], obj));
          }
        }
      }
      return xs;
    }
  }
});

// node_modules/side-channel/index.js
var require_side_channel = __commonJS({
  "node_modules/side-channel/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var inspect4 = require_object_inspect();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $WeakMap = GetIntrinsic("%WeakMap%", true);
    var $Map = GetIntrinsic("%Map%", true);
    var $weakMapGet = callBound("WeakMap.prototype.get", true);
    var $weakMapSet = callBound("WeakMap.prototype.set", true);
    var $weakMapHas = callBound("WeakMap.prototype.has", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSet = callBound("Map.prototype.set", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var listGetNode = function(list, key2) {
      for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
        if (curr.key === key2) {
          prev.next = curr.next;
          curr.next = list.next;
          list.next = curr;
          return curr;
        }
      }
    };
    var listGet = function(objects, key2) {
      var node = listGetNode(objects, key2);
      return node && node.value;
    };
    var listSet = function(objects, key2, value2) {
      var node = listGetNode(objects, key2);
      if (node) {
        node.value = value2;
      } else {
        objects.next = {
          key: key2,
          next: objects.next,
          value: value2
        };
      }
    };
    var listHas = function(objects, key2) {
      return !!listGetNode(objects, key2);
    };
    module2.exports = function getSideChannel() {
      var $wm;
      var $m;
      var $o3;
      var channel = {
        assert: function(key2) {
          if (!channel.has(key2)) {
            throw new $TypeError("Side channel does not contain " + inspect4(key2));
          }
        },
        get: function(key2) {
          if ($WeakMap && key2 && (typeof key2 === "object" || typeof key2 === "function")) {
            if ($wm) {
              return $weakMapGet($wm, key2);
            }
          } else if ($Map) {
            if ($m) {
              return $mapGet($m, key2);
            }
          } else {
            if ($o3) {
              return listGet($o3, key2);
            }
          }
        },
        has: function(key2) {
          if ($WeakMap && key2 && (typeof key2 === "object" || typeof key2 === "function")) {
            if ($wm) {
              return $weakMapHas($wm, key2);
            }
          } else if ($Map) {
            if ($m) {
              return $mapHas($m, key2);
            }
          } else {
            if ($o3) {
              return listHas($o3, key2);
            }
          }
          return false;
        },
        set: function(key2, value2) {
          if ($WeakMap && key2 && (typeof key2 === "object" || typeof key2 === "function")) {
            if (!$wm) {
              $wm = new $WeakMap();
            }
            $weakMapSet($wm, key2, value2);
          } else if ($Map) {
            if (!$m) {
              $m = new $Map();
            }
            $mapSet($m, key2, value2);
          } else {
            if (!$o3) {
              $o3 = { key: {}, next: null };
            }
            listSet($o3, key2, value2);
          }
        }
      };
      return channel;
    };
  }
});

// node_modules/object.assign/implementation.js
var require_implementation5 = __commonJS({
  "node_modules/object.assign/implementation.js"(exports2, module2) {
    "use strict";
    var keys = require_object_keys();
    var canBeObject = function(obj) {
      return typeof obj !== "undefined" && obj !== null;
    };
    var hasSymbols = require_shams()();
    var callBound = require_callBound();
    var toObject = Object;
    var $push = callBound("Array.prototype.push");
    var $propIsEnumerable = callBound("Object.prototype.propertyIsEnumerable");
    var originalGetSymbols = hasSymbols ? Object.getOwnPropertySymbols : null;
    module2.exports = function assign(target, source1) {
      if (!canBeObject(target)) {
        throw new TypeError("target must be an object");
      }
      var objTarget = toObject(target);
      var s6, source, i6, props, syms, value2, key2;
      for (s6 = 1; s6 < arguments.length; ++s6) {
        source = toObject(arguments[s6]);
        props = keys(source);
        var getSymbols = hasSymbols && (Object.getOwnPropertySymbols || originalGetSymbols);
        if (getSymbols) {
          syms = getSymbols(source);
          for (i6 = 0; i6 < syms.length; ++i6) {
            key2 = syms[i6];
            if ($propIsEnumerable(source, key2)) {
              $push(props, key2);
            }
          }
        }
        for (i6 = 0; i6 < props.length; ++i6) {
          key2 = props[i6];
          value2 = source[key2];
          if ($propIsEnumerable(source, key2)) {
            objTarget[key2] = value2;
          }
        }
      }
      return objTarget;
    };
  }
});

// node_modules/object.assign/polyfill.js
var require_polyfill3 = __commonJS({
  "node_modules/object.assign/polyfill.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation5();
    var lacksProperEnumerationOrder = function() {
      if (!Object.assign) {
        return false;
      }
      var str = "abcdefghijklmnopqrst";
      var letters = str.split("");
      var map2 = {};
      for (var i6 = 0; i6 < letters.length; ++i6) {
        map2[letters[i6]] = letters[i6];
      }
      var obj = Object.assign({}, map2);
      var actual = "";
      for (var k8 in obj) {
        actual += k8;
      }
      return str !== actual;
    };
    var assignHasPendingExceptions = function() {
      if (!Object.assign || !Object.preventExtensions) {
        return false;
      }
      var thrower = Object.preventExtensions({ 1: 2 });
      try {
        Object.assign(thrower, "xy");
      } catch (e6) {
        return thrower[1] === "y";
      }
      return false;
    };
    module2.exports = function getPolyfill() {
      if (!Object.assign) {
        return implementation;
      }
      if (lacksProperEnumerationOrder()) {
        return implementation;
      }
      if (assignHasPendingExceptions()) {
        return implementation;
      }
      return Object.assign;
    };
  }
});

// node_modules/object.assign/shim.js
var require_shim3 = __commonJS({
  "node_modules/object.assign/shim.js"(exports2, module2) {
    "use strict";
    var define2 = require_define_properties();
    var getPolyfill = require_polyfill3();
    module2.exports = function shimAssign() {
      var polyfill = getPolyfill();
      define2(
        Object,
        { assign: polyfill },
        { assign: function() {
          return Object.assign !== polyfill;
        } }
      );
      return polyfill;
    };
  }
});

// node_modules/object.assign/index.js
var require_object = __commonJS({
  "node_modules/object.assign/index.js"(exports2, module2) {
    "use strict";
    var defineProperties = require_define_properties();
    var callBind = require_call_bind();
    var implementation = require_implementation5();
    var getPolyfill = require_polyfill3();
    var shim = require_shim3();
    var polyfill = callBind.apply(getPolyfill());
    var bound = function assign(target, source1) {
      return polyfill(Object, arguments);
    };
    defineProperties(bound, {
      getPolyfill,
      implementation,
      shim
    });
    module2.exports = bound;
  }
});

// node_modules/deep-equal/index.js
var require_deep_equal = __commonJS({
  "node_modules/deep-equal/index.js"(exports2, module2) {
    "use strict";
    var objectKeys = require_object_keys();
    var isArguments = require_is_arguments();
    var is = require_object_is();
    var isRegex = require_is_regex();
    var flags = require_regexp_prototype();
    var isArray2 = require_isarray();
    var isDate2 = require_is_date_object();
    var whichBoxedPrimitive = require_which_boxed_primitive();
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var whichCollection = require_which_collection();
    var getIterator = require_es_get_iterator();
    var getSideChannel = require_side_channel();
    var whichTypedArray = require_which_typed_array();
    var assign = require_object();
    var $getTime = callBound("Date.prototype.getTime");
    var gPO = Object.getPrototypeOf;
    var $objToString = callBound("Object.prototype.toString");
    var $Set = GetIntrinsic("%Set%", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSize = callBound("Map.prototype.size", true);
    var $setAdd = callBound("Set.prototype.add", true);
    var $setDelete = callBound("Set.prototype.delete", true);
    var $setHas = callBound("Set.prototype.has", true);
    var $setSize = callBound("Set.prototype.size", true);
    function setHasEqualElement(set, val1, opts, channel) {
      var i6 = getIterator(set);
      var result;
      while ((result = i6.next()) && !result.done) {
        if (internalDeepEqual(val1, result.value, opts, channel)) {
          $setDelete(set, result.value);
          return true;
        }
      }
      return false;
    }
    function findLooseMatchingPrimitives(prim) {
      if (typeof prim === "undefined") {
        return null;
      }
      if (typeof prim === "object") {
        return void 0;
      }
      if (typeof prim === "symbol") {
        return false;
      }
      if (typeof prim === "string" || typeof prim === "number") {
        return +prim === +prim;
      }
      return true;
    }
    function mapMightHaveLoosePrim(a5, b4, prim, item, opts, channel) {
      var altValue = findLooseMatchingPrimitives(prim);
      if (altValue != null) {
        return altValue;
      }
      var curB = $mapGet(b4, altValue);
      var looseOpts = assign({}, opts, { strict: false });
      if (typeof curB === "undefined" && !$mapHas(b4, altValue) || !internalDeepEqual(item, curB, looseOpts, channel)) {
        return false;
      }
      return !$mapHas(a5, altValue) && internalDeepEqual(item, curB, looseOpts, channel);
    }
    function setMightHaveLoosePrim(a5, b4, prim) {
      var altValue = findLooseMatchingPrimitives(prim);
      if (altValue != null) {
        return altValue;
      }
      return $setHas(b4, altValue) && !$setHas(a5, altValue);
    }
    function mapHasEqualEntry(set, map2, key1, item1, opts, channel) {
      var i6 = getIterator(set);
      var result;
      var key2;
      while ((result = i6.next()) && !result.done) {
        key2 = result.value;
        if (internalDeepEqual(key1, key2, opts, channel) && internalDeepEqual(item1, $mapGet(map2, key2), opts, channel)) {
          $setDelete(set, key2);
          return true;
        }
      }
      return false;
    }
    function internalDeepEqual(actual, expected, options, channel) {
      var opts = options || {};
      if (opts.strict ? is(actual, expected) : actual === expected) {
        return true;
      }
      var actualBoxed = whichBoxedPrimitive(actual);
      var expectedBoxed = whichBoxedPrimitive(expected);
      if (actualBoxed !== expectedBoxed) {
        return false;
      }
      if (!actual || !expected || typeof actual !== "object" && typeof expected !== "object") {
        return opts.strict ? is(actual, expected) : actual == expected;
      }
      var hasActual = channel.has(actual);
      var hasExpected = channel.has(expected);
      var sentinel;
      if (hasActual && hasExpected) {
        if (channel.get(actual) === channel.get(expected)) {
          return true;
        }
      } else {
        sentinel = {};
      }
      if (!hasActual) {
        channel.set(actual, sentinel);
      }
      if (!hasExpected) {
        channel.set(expected, sentinel);
      }
      return objEquiv(actual, expected, opts, channel);
    }
    function isBuffer2(x6) {
      if (!x6 || typeof x6 !== "object" || typeof x6.length !== "number") {
        return false;
      }
      if (typeof x6.copy !== "function" || typeof x6.slice !== "function") {
        return false;
      }
      if (x6.length > 0 && typeof x6[0] !== "number") {
        return false;
      }
      return !!(x6.constructor && x6.constructor.isBuffer && x6.constructor.isBuffer(x6));
    }
    function setEquiv(a5, b4, opts, channel) {
      if ($setSize(a5) !== $setSize(b4)) {
        return false;
      }
      var iA = getIterator(a5);
      var iB = getIterator(b4);
      var resultA;
      var resultB;
      var set;
      while ((resultA = iA.next()) && !resultA.done) {
        if (resultA.value && typeof resultA.value === "object") {
          if (!set) {
            set = new $Set();
          }
          $setAdd(set, resultA.value);
        } else if (!$setHas(b4, resultA.value)) {
          if (opts.strict) {
            return false;
          }
          if (!setMightHaveLoosePrim(a5, b4, resultA.value)) {
            return false;
          }
          if (!set) {
            set = new $Set();
          }
          $setAdd(set, resultA.value);
        }
      }
      if (set) {
        while ((resultB = iB.next()) && !resultB.done) {
          if (resultB.value && typeof resultB.value === "object") {
            if (!setHasEqualElement(set, resultB.value, opts.strict, channel)) {
              return false;
            }
          } else if (!opts.strict && !$setHas(a5, resultB.value) && !setHasEqualElement(set, resultB.value, opts.strict, channel)) {
            return false;
          }
        }
        return $setSize(set) === 0;
      }
      return true;
    }
    function mapEquiv(a5, b4, opts, channel) {
      if ($mapSize(a5) !== $mapSize(b4)) {
        return false;
      }
      var iA = getIterator(a5);
      var iB = getIterator(b4);
      var resultA;
      var resultB;
      var set;
      var key2;
      var item1;
      var item2;
      while ((resultA = iA.next()) && !resultA.done) {
        key2 = resultA.value[0];
        item1 = resultA.value[1];
        if (key2 && typeof key2 === "object") {
          if (!set) {
            set = new $Set();
          }
          $setAdd(set, key2);
        } else {
          item2 = $mapGet(b4, key2);
          if (typeof item2 === "undefined" && !$mapHas(b4, key2) || !internalDeepEqual(item1, item2, opts, channel)) {
            if (opts.strict) {
              return false;
            }
            if (!mapMightHaveLoosePrim(a5, b4, key2, item1, opts, channel)) {
              return false;
            }
            if (!set) {
              set = new $Set();
            }
            $setAdd(set, key2);
          }
        }
      }
      if (set) {
        while ((resultB = iB.next()) && !resultB.done) {
          key2 = resultB.value[0];
          item2 = resultB.value[1];
          if (key2 && typeof key2 === "object") {
            if (!mapHasEqualEntry(set, a5, key2, item2, opts, channel)) {
              return false;
            }
          } else if (!opts.strict && (!a5.has(key2) || !internalDeepEqual($mapGet(a5, key2), item2, opts, channel)) && !mapHasEqualEntry(set, a5, key2, item2, assign({}, opts, { strict: false }), channel)) {
            return false;
          }
        }
        return $setSize(set) === 0;
      }
      return true;
    }
    function objEquiv(a5, b4, opts, channel) {
      var i6, key2;
      if (typeof a5 !== typeof b4) {
        return false;
      }
      if (a5 == null || b4 == null) {
        return false;
      }
      if ($objToString(a5) !== $objToString(b4)) {
        return false;
      }
      if (isArguments(a5) !== isArguments(b4)) {
        return false;
      }
      var aIsArray = isArray2(a5);
      var bIsArray = isArray2(b4);
      if (aIsArray !== bIsArray) {
        return false;
      }
      var aIsError = a5 instanceof Error;
      var bIsError = b4 instanceof Error;
      if (aIsError !== bIsError) {
        return false;
      }
      if (aIsError || bIsError) {
        if (a5.name !== b4.name || a5.message !== b4.message) {
          return false;
        }
      }
      var aIsRegex = isRegex(a5);
      var bIsRegex = isRegex(b4);
      if (aIsRegex !== bIsRegex) {
        return false;
      }
      if ((aIsRegex || bIsRegex) && (a5.source !== b4.source || flags(a5) !== flags(b4))) {
        return false;
      }
      var aIsDate = isDate2(a5);
      var bIsDate = isDate2(b4);
      if (aIsDate !== bIsDate) {
        return false;
      }
      if (aIsDate || bIsDate) {
        if ($getTime(a5) !== $getTime(b4)) {
          return false;
        }
      }
      if (opts.strict && gPO && gPO(a5) !== gPO(b4)) {
        return false;
      }
      if (whichTypedArray(a5) !== whichTypedArray(b4)) {
        return false;
      }
      var aIsBuffer = isBuffer2(a5);
      var bIsBuffer = isBuffer2(b4);
      if (aIsBuffer !== bIsBuffer) {
        return false;
      }
      if (aIsBuffer || bIsBuffer) {
        if (a5.length !== b4.length) {
          return false;
        }
        for (i6 = 0; i6 < a5.length; i6++) {
          if (a5[i6] !== b4[i6]) {
            return false;
          }
        }
        return true;
      }
      if (typeof a5 !== typeof b4) {
        return false;
      }
      var ka2 = objectKeys(a5);
      var kb = objectKeys(b4);
      if (ka2.length !== kb.length) {
        return false;
      }
      ka2.sort();
      kb.sort();
      for (i6 = ka2.length - 1; i6 >= 0; i6--) {
        if (ka2[i6] != kb[i6]) {
          return false;
        }
      }
      for (i6 = ka2.length - 1; i6 >= 0; i6--) {
        key2 = ka2[i6];
        if (!internalDeepEqual(a5[key2], b4[key2], opts, channel)) {
          return false;
        }
      }
      var aCollection = whichCollection(a5);
      var bCollection = whichCollection(b4);
      if (aCollection !== bCollection) {
        return false;
      }
      if (aCollection === "Set" || bCollection === "Set") {
        return setEquiv(a5, b4, opts, channel);
      }
      if (aCollection === "Map") {
        return mapEquiv(a5, b4, opts, channel);
      }
      return true;
    }
    module2.exports = function deepEqual(a5, b4, opts) {
      return internalDeepEqual(a5, b4, opts, getSideChannel());
    };
  }
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports2, module2) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix2 = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix2 = false;
    }
    function EE(fn2, context, once) {
      this.fn = fn2;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn2, context, once) {
      if (typeof fn2 !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn2, context || emitter, once), evt = prefix2 ? prefix2 + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter6() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter6.prototype.eventNames = function eventNames() {
      var names2 = [], events, name2;
      if (this._eventsCount === 0)
        return names2;
      for (name2 in events = this._events) {
        if (has.call(events, name2))
          names2.push(prefix2 ? name2.slice(1) : name2);
      }
      if (Object.getOwnPropertySymbols) {
        return names2.concat(Object.getOwnPropertySymbols(events));
      }
      return names2;
    };
    EventEmitter6.prototype.listeners = function listeners(event) {
      var evt = prefix2 ? prefix2 + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i6 = 0, l6 = handlers.length, ee3 = new Array(l6); i6 < l6; i6++) {
        ee3[i6] = handlers[i6].fn;
      }
      return ee3;
    };
    EventEmitter6.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix2 ? prefix2 + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter6.prototype.emit = function emit(event, a1, a22, a32, a42, a5) {
      var evt = prefix2 ? prefix2 + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i6;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a22), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a22, a32), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a22, a32, a42), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a22, a32, a42, a5), true;
        }
        for (i6 = 1, args = new Array(len - 1); i6 < len; i6++) {
          args[i6 - 1] = arguments[i6];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j8;
        for (i6 = 0; i6 < length; i6++) {
          if (listeners[i6].once)
            this.removeListener(event, listeners[i6].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i6].fn.call(listeners[i6].context);
              break;
            case 2:
              listeners[i6].fn.call(listeners[i6].context, a1);
              break;
            case 3:
              listeners[i6].fn.call(listeners[i6].context, a1, a22);
              break;
            case 4:
              listeners[i6].fn.call(listeners[i6].context, a1, a22, a32);
              break;
            default:
              if (!args)
                for (j8 = 1, args = new Array(len - 1); j8 < len; j8++) {
                  args[j8 - 1] = arguments[j8];
                }
              listeners[i6].fn.apply(listeners[i6].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter6.prototype.on = function on2(event, fn2, context) {
      return addListener(this, event, fn2, context, false);
    };
    EventEmitter6.prototype.once = function once(event, fn2, context) {
      return addListener(this, event, fn2, context, true);
    };
    EventEmitter6.prototype.removeListener = function removeListener(event, fn2, context, once) {
      var evt = prefix2 ? prefix2 + event : event;
      if (!this._events[evt])
        return this;
      if (!fn2) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn2 && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i6 = 0, events = [], length = listeners.length; i6 < length; i6++) {
          if (listeners[i6].fn !== fn2 || once && !listeners[i6].once || context && listeners[i6].context !== context) {
            events.push(listeners[i6]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter6.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix2 ? prefix2 + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter6.prototype.off = EventEmitter6.prototype.removeListener;
    EventEmitter6.prototype.addListener = EventEmitter6.prototype.on;
    EventEmitter6.prefixed = prefix2;
    EventEmitter6.EventEmitter = EventEmitter6;
    if ("undefined" !== typeof module2) {
      module2.exports = EventEmitter6;
    }
  }
});

// node_modules/ethers/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/ethers/lib/utils.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o6, m6, k8, k22) {
      if (k22 === void 0)
        k22 = k8;
      Object.defineProperty(o6, k22, { enumerable: true, get: function() {
        return m6[k8];
      } });
    } : function(o6, m6, k8, k22) {
      if (k22 === void 0)
        k22 = k8;
      o6[k22] = m6[k8];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o6, v9) {
      Object.defineProperty(o6, "default", { enumerable: true, value: v9 });
    } : function(o6, v9) {
      o6["default"] = v9;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k8 in mod2)
          if (k8 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k8))
            __createBinding(result, mod2, k8);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.formatBytes32String = exports2.Utf8ErrorFuncs = exports2.toUtf8String = exports2.toUtf8CodePoints = exports2.toUtf8Bytes = exports2._toEscapedUtf8String = exports2.nameprep = exports2.hexDataSlice = exports2.hexDataLength = exports2.hexZeroPad = exports2.hexValue = exports2.hexStripZeros = exports2.hexConcat = exports2.isHexString = exports2.hexlify = exports2.base64 = exports2.base58 = exports2.TransactionDescription = exports2.LogDescription = exports2.Interface = exports2.SigningKey = exports2.HDNode = exports2.defaultPath = exports2.isBytesLike = exports2.isBytes = exports2.zeroPad = exports2.stripZeros = exports2.concat = exports2.arrayify = exports2.shallowCopy = exports2.resolveProperties = exports2.getStatic = exports2.defineReadOnly = exports2.deepCopy = exports2.checkProperties = exports2.poll = exports2.fetchJson = exports2._fetchData = exports2.RLP = exports2.Logger = exports2.checkResultErrors = exports2.FormatTypes = exports2.ParamType = exports2.FunctionFragment = exports2.EventFragment = exports2.ErrorFragment = exports2.ConstructorFragment = exports2.Fragment = exports2.defaultAbiCoder = exports2.AbiCoder = void 0;
    exports2.Indexed = exports2.Utf8ErrorReason = exports2.UnicodeNormalizationForm = exports2.SupportedAlgorithm = exports2.mnemonicToSeed = exports2.isValidMnemonic = exports2.entropyToMnemonic = exports2.mnemonicToEntropy = exports2.getAccountPath = exports2.verifyTypedData = exports2.verifyMessage = exports2.recoverPublicKey = exports2.computePublicKey = exports2.recoverAddress = exports2.computeAddress = exports2.getJsonWalletAddress = exports2.TransactionTypes = exports2.serializeTransaction = exports2.parseTransaction = exports2.accessListify = exports2.joinSignature = exports2.splitSignature = exports2.soliditySha256 = exports2.solidityKeccak256 = exports2.solidityPack = exports2.shuffled = exports2.randomBytes = exports2.sha512 = exports2.sha256 = exports2.ripemd160 = exports2.keccak256 = exports2.computeHmac = exports2.commify = exports2.parseUnits = exports2.formatUnits = exports2.parseEther = exports2.formatEther = exports2.isAddress = exports2.getCreate2Address = exports2.getContractAddress = exports2.getIcapAddress = exports2.getAddress = exports2._TypedDataEncoder = exports2.id = exports2.isValidName = exports2.namehash = exports2.hashMessage = exports2.dnsEncode = exports2.parseBytes32String = void 0;
    var abi_1 = (init_lib11(), __toCommonJS(lib_exports10));
    Object.defineProperty(exports2, "AbiCoder", { enumerable: true, get: function() {
      return abi_1.AbiCoder;
    } });
    Object.defineProperty(exports2, "checkResultErrors", { enumerable: true, get: function() {
      return abi_1.checkResultErrors;
    } });
    Object.defineProperty(exports2, "ConstructorFragment", { enumerable: true, get: function() {
      return abi_1.ConstructorFragment;
    } });
    Object.defineProperty(exports2, "defaultAbiCoder", { enumerable: true, get: function() {
      return abi_1.defaultAbiCoder;
    } });
    Object.defineProperty(exports2, "ErrorFragment", { enumerable: true, get: function() {
      return abi_1.ErrorFragment;
    } });
    Object.defineProperty(exports2, "EventFragment", { enumerable: true, get: function() {
      return abi_1.EventFragment;
    } });
    Object.defineProperty(exports2, "FormatTypes", { enumerable: true, get: function() {
      return abi_1.FormatTypes;
    } });
    Object.defineProperty(exports2, "Fragment", { enumerable: true, get: function() {
      return abi_1.Fragment;
    } });
    Object.defineProperty(exports2, "FunctionFragment", { enumerable: true, get: function() {
      return abi_1.FunctionFragment;
    } });
    Object.defineProperty(exports2, "Indexed", { enumerable: true, get: function() {
      return abi_1.Indexed;
    } });
    Object.defineProperty(exports2, "Interface", { enumerable: true, get: function() {
      return abi_1.Interface;
    } });
    Object.defineProperty(exports2, "LogDescription", { enumerable: true, get: function() {
      return abi_1.LogDescription;
    } });
    Object.defineProperty(exports2, "ParamType", { enumerable: true, get: function() {
      return abi_1.ParamType;
    } });
    Object.defineProperty(exports2, "TransactionDescription", { enumerable: true, get: function() {
      return abi_1.TransactionDescription;
    } });
    var address_1 = (init_lib7(), __toCommonJS(lib_exports6));
    Object.defineProperty(exports2, "getAddress", { enumerable: true, get: function() {
      return address_1.getAddress;
    } });
    Object.defineProperty(exports2, "getCreate2Address", { enumerable: true, get: function() {
      return address_1.getCreate2Address;
    } });
    Object.defineProperty(exports2, "getContractAddress", { enumerable: true, get: function() {
      return address_1.getContractAddress;
    } });
    Object.defineProperty(exports2, "getIcapAddress", { enumerable: true, get: function() {
      return address_1.getIcapAddress;
    } });
    Object.defineProperty(exports2, "isAddress", { enumerable: true, get: function() {
      return address_1.isAddress;
    } });
    var base64 = __importStar((init_lib24(), __toCommonJS(lib_exports19)));
    exports2.base64 = base64;
    var basex_1 = (init_lib16(), __toCommonJS(lib_exports13));
    Object.defineProperty(exports2, "base58", { enumerable: true, get: function() {
      return basex_1.Base58;
    } });
    var bytes_1 = (init_lib2(), __toCommonJS(lib_exports2));
    Object.defineProperty(exports2, "arrayify", { enumerable: true, get: function() {
      return bytes_1.arrayify;
    } });
    Object.defineProperty(exports2, "concat", { enumerable: true, get: function() {
      return bytes_1.concat;
    } });
    Object.defineProperty(exports2, "hexConcat", { enumerable: true, get: function() {
      return bytes_1.hexConcat;
    } });
    Object.defineProperty(exports2, "hexDataSlice", { enumerable: true, get: function() {
      return bytes_1.hexDataSlice;
    } });
    Object.defineProperty(exports2, "hexDataLength", { enumerable: true, get: function() {
      return bytes_1.hexDataLength;
    } });
    Object.defineProperty(exports2, "hexlify", { enumerable: true, get: function() {
      return bytes_1.hexlify;
    } });
    Object.defineProperty(exports2, "hexStripZeros", { enumerable: true, get: function() {
      return bytes_1.hexStripZeros;
    } });
    Object.defineProperty(exports2, "hexValue", { enumerable: true, get: function() {
      return bytes_1.hexValue;
    } });
    Object.defineProperty(exports2, "hexZeroPad", { enumerable: true, get: function() {
      return bytes_1.hexZeroPad;
    } });
    Object.defineProperty(exports2, "isBytes", { enumerable: true, get: function() {
      return bytes_1.isBytes;
    } });
    Object.defineProperty(exports2, "isBytesLike", { enumerable: true, get: function() {
      return bytes_1.isBytesLike;
    } });
    Object.defineProperty(exports2, "isHexString", { enumerable: true, get: function() {
      return bytes_1.isHexString;
    } });
    Object.defineProperty(exports2, "joinSignature", { enumerable: true, get: function() {
      return bytes_1.joinSignature;
    } });
    Object.defineProperty(exports2, "zeroPad", { enumerable: true, get: function() {
      return bytes_1.zeroPad;
    } });
    Object.defineProperty(exports2, "splitSignature", { enumerable: true, get: function() {
      return bytes_1.splitSignature;
    } });
    Object.defineProperty(exports2, "stripZeros", { enumerable: true, get: function() {
      return bytes_1.stripZeros;
    } });
    var hash_1 = (init_lib10(), __toCommonJS(lib_exports9));
    Object.defineProperty(exports2, "_TypedDataEncoder", { enumerable: true, get: function() {
      return hash_1._TypedDataEncoder;
    } });
    Object.defineProperty(exports2, "dnsEncode", { enumerable: true, get: function() {
      return hash_1.dnsEncode;
    } });
    Object.defineProperty(exports2, "hashMessage", { enumerable: true, get: function() {
      return hash_1.hashMessage;
    } });
    Object.defineProperty(exports2, "id", { enumerable: true, get: function() {
      return hash_1.id;
    } });
    Object.defineProperty(exports2, "isValidName", { enumerable: true, get: function() {
      return hash_1.isValidName;
    } });
    Object.defineProperty(exports2, "namehash", { enumerable: true, get: function() {
      return hash_1.namehash;
    } });
    var hdnode_1 = (init_lib20(), __toCommonJS(lib_exports15));
    Object.defineProperty(exports2, "defaultPath", { enumerable: true, get: function() {
      return hdnode_1.defaultPath;
    } });
    Object.defineProperty(exports2, "entropyToMnemonic", { enumerable: true, get: function() {
      return hdnode_1.entropyToMnemonic;
    } });
    Object.defineProperty(exports2, "getAccountPath", { enumerable: true, get: function() {
      return hdnode_1.getAccountPath;
    } });
    Object.defineProperty(exports2, "HDNode", { enumerable: true, get: function() {
      return hdnode_1.HDNode;
    } });
    Object.defineProperty(exports2, "isValidMnemonic", { enumerable: true, get: function() {
      return hdnode_1.isValidMnemonic;
    } });
    Object.defineProperty(exports2, "mnemonicToEntropy", { enumerable: true, get: function() {
      return hdnode_1.mnemonicToEntropy;
    } });
    Object.defineProperty(exports2, "mnemonicToSeed", { enumerable: true, get: function() {
      return hdnode_1.mnemonicToSeed;
    } });
    var json_wallets_1 = (init_lib22(), __toCommonJS(lib_exports17));
    Object.defineProperty(exports2, "getJsonWalletAddress", { enumerable: true, get: function() {
      return json_wallets_1.getJsonWalletAddress;
    } });
    var keccak256_1 = (init_lib5(), __toCommonJS(lib_exports4));
    Object.defineProperty(exports2, "keccak256", { enumerable: true, get: function() {
      return keccak256_1.keccak256;
    } });
    var logger_1 = (init_lib(), __toCommonJS(lib_exports));
    Object.defineProperty(exports2, "Logger", { enumerable: true, get: function() {
      return logger_1.Logger;
    } });
    var sha2_1 = (init_lib17(), __toCommonJS(lib_exports14));
    Object.defineProperty(exports2, "computeHmac", { enumerable: true, get: function() {
      return sha2_1.computeHmac;
    } });
    Object.defineProperty(exports2, "ripemd160", { enumerable: true, get: function() {
      return sha2_1.ripemd160;
    } });
    Object.defineProperty(exports2, "sha256", { enumerable: true, get: function() {
      return sha2_1.sha256;
    } });
    Object.defineProperty(exports2, "sha512", { enumerable: true, get: function() {
      return sha2_1.sha512;
    } });
    var solidity_1 = (init_lib26(), __toCommonJS(lib_exports22));
    Object.defineProperty(exports2, "solidityKeccak256", { enumerable: true, get: function() {
      return solidity_1.keccak256;
    } });
    Object.defineProperty(exports2, "solidityPack", { enumerable: true, get: function() {
      return solidity_1.pack;
    } });
    Object.defineProperty(exports2, "soliditySha256", { enumerable: true, get: function() {
      return solidity_1.sha256;
    } });
    var random_1 = (init_lib21(), __toCommonJS(lib_exports16));
    Object.defineProperty(exports2, "randomBytes", { enumerable: true, get: function() {
      return random_1.randomBytes;
    } });
    Object.defineProperty(exports2, "shuffled", { enumerable: true, get: function() {
      return random_1.shuffled;
    } });
    var properties_1 = (init_lib4(), __toCommonJS(lib_exports3));
    Object.defineProperty(exports2, "checkProperties", { enumerable: true, get: function() {
      return properties_1.checkProperties;
    } });
    Object.defineProperty(exports2, "deepCopy", { enumerable: true, get: function() {
      return properties_1.deepCopy;
    } });
    Object.defineProperty(exports2, "defineReadOnly", { enumerable: true, get: function() {
      return properties_1.defineReadOnly;
    } });
    Object.defineProperty(exports2, "getStatic", { enumerable: true, get: function() {
      return properties_1.getStatic;
    } });
    Object.defineProperty(exports2, "resolveProperties", { enumerable: true, get: function() {
      return properties_1.resolveProperties;
    } });
    Object.defineProperty(exports2, "shallowCopy", { enumerable: true, get: function() {
      return properties_1.shallowCopy;
    } });
    var RLP = __importStar((init_lib6(), __toCommonJS(lib_exports5)));
    exports2.RLP = RLP;
    var signing_key_1 = (init_lib14(), __toCommonJS(lib_exports11));
    Object.defineProperty(exports2, "computePublicKey", { enumerable: true, get: function() {
      return signing_key_1.computePublicKey;
    } });
    Object.defineProperty(exports2, "recoverPublicKey", { enumerable: true, get: function() {
      return signing_key_1.recoverPublicKey;
    } });
    Object.defineProperty(exports2, "SigningKey", { enumerable: true, get: function() {
      return signing_key_1.SigningKey;
    } });
    var strings_1 = (init_lib9(), __toCommonJS(lib_exports8));
    Object.defineProperty(exports2, "formatBytes32String", { enumerable: true, get: function() {
      return strings_1.formatBytes32String;
    } });
    Object.defineProperty(exports2, "nameprep", { enumerable: true, get: function() {
      return strings_1.nameprep;
    } });
    Object.defineProperty(exports2, "parseBytes32String", { enumerable: true, get: function() {
      return strings_1.parseBytes32String;
    } });
    Object.defineProperty(exports2, "_toEscapedUtf8String", { enumerable: true, get: function() {
      return strings_1._toEscapedUtf8String;
    } });
    Object.defineProperty(exports2, "toUtf8Bytes", { enumerable: true, get: function() {
      return strings_1.toUtf8Bytes;
    } });
    Object.defineProperty(exports2, "toUtf8CodePoints", { enumerable: true, get: function() {
      return strings_1.toUtf8CodePoints;
    } });
    Object.defineProperty(exports2, "toUtf8String", { enumerable: true, get: function() {
      return strings_1.toUtf8String;
    } });
    Object.defineProperty(exports2, "Utf8ErrorFuncs", { enumerable: true, get: function() {
      return strings_1.Utf8ErrorFuncs;
    } });
    var transactions_1 = (init_lib15(), __toCommonJS(lib_exports12));
    Object.defineProperty(exports2, "accessListify", { enumerable: true, get: function() {
      return transactions_1.accessListify;
    } });
    Object.defineProperty(exports2, "computeAddress", { enumerable: true, get: function() {
      return transactions_1.computeAddress;
    } });
    Object.defineProperty(exports2, "parseTransaction", { enumerable: true, get: function() {
      return transactions_1.parse;
    } });
    Object.defineProperty(exports2, "recoverAddress", { enumerable: true, get: function() {
      return transactions_1.recoverAddress;
    } });
    Object.defineProperty(exports2, "serializeTransaction", { enumerable: true, get: function() {
      return transactions_1.serialize;
    } });
    Object.defineProperty(exports2, "TransactionTypes", { enumerable: true, get: function() {
      return transactions_1.TransactionTypes;
    } });
    var units_1 = (init_lib27(), __toCommonJS(lib_exports23));
    Object.defineProperty(exports2, "commify", { enumerable: true, get: function() {
      return units_1.commify;
    } });
    Object.defineProperty(exports2, "formatEther", { enumerable: true, get: function() {
      return units_1.formatEther;
    } });
    Object.defineProperty(exports2, "parseEther", { enumerable: true, get: function() {
      return units_1.parseEther;
    } });
    Object.defineProperty(exports2, "formatUnits", { enumerable: true, get: function() {
      return units_1.formatUnits;
    } });
    Object.defineProperty(exports2, "parseUnits", { enumerable: true, get: function() {
      return units_1.parseUnits;
    } });
    var wallet_1 = (init_lib23(), __toCommonJS(lib_exports18));
    Object.defineProperty(exports2, "verifyMessage", { enumerable: true, get: function() {
      return wallet_1.verifyMessage;
    } });
    Object.defineProperty(exports2, "verifyTypedData", { enumerable: true, get: function() {
      return wallet_1.verifyTypedData;
    } });
    var web_1 = (init_lib25(), __toCommonJS(lib_exports20));
    Object.defineProperty(exports2, "_fetchData", { enumerable: true, get: function() {
      return web_1._fetchData;
    } });
    Object.defineProperty(exports2, "fetchJson", { enumerable: true, get: function() {
      return web_1.fetchJson;
    } });
    Object.defineProperty(exports2, "poll", { enumerable: true, get: function() {
      return web_1.poll;
    } });
    var sha2_2 = (init_lib17(), __toCommonJS(lib_exports14));
    Object.defineProperty(exports2, "SupportedAlgorithm", { enumerable: true, get: function() {
      return sha2_2.SupportedAlgorithm;
    } });
    var strings_2 = (init_lib9(), __toCommonJS(lib_exports8));
    Object.defineProperty(exports2, "UnicodeNormalizationForm", { enumerable: true, get: function() {
      return strings_2.UnicodeNormalizationForm;
    } });
    Object.defineProperty(exports2, "Utf8ErrorReason", { enumerable: true, get: function() {
      return strings_2.Utf8ErrorReason;
    } });
  }
});

// node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
var require_use_sync_external_store_shim_development = __commonJS({
  "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports2) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var React11 = require_react();
        var ReactSharedInternals = React11.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function error(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        function is(x6, y5) {
          return x6 === y5 && (x6 !== 0 || 1 / x6 === 1 / y5) || x6 !== x6 && y5 !== y5;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        var useState3 = React11.useState, useEffect3 = React11.useEffect, useLayoutEffect = React11.useLayoutEffect, useDebugValue = React11.useDebugValue;
        var didWarnOld18Alpha = false;
        var didWarnUncachedGetSnapshot = false;
        function useSyncExternalStore2(subscribe, getSnapshot, getServerSnapshot) {
          {
            if (!didWarnOld18Alpha) {
              if (React11.startTransition !== void 0) {
                didWarnOld18Alpha = true;
                error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.");
              }
            }
          }
          var value2 = getSnapshot();
          {
            if (!didWarnUncachedGetSnapshot) {
              var cachedValue = getSnapshot();
              if (!objectIs(value2, cachedValue)) {
                error("The result of getSnapshot should be cached to avoid an infinite loop");
                didWarnUncachedGetSnapshot = true;
              }
            }
          }
          var _useState = useState3({
            inst: {
              value: value2,
              getSnapshot
            }
          }), inst = _useState[0].inst, forceUpdate = _useState[1];
          useLayoutEffect(function() {
            inst.value = value2;
            inst.getSnapshot = getSnapshot;
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
          }, [subscribe, value2, getSnapshot]);
          useEffect3(function() {
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
            var handleStoreChange = function() {
              if (checkIfSnapshotChanged(inst)) {
                forceUpdate({
                  inst
                });
              }
            };
            return subscribe(handleStoreChange);
          }, [subscribe]);
          useDebugValue(value2);
          return value2;
        }
        function checkIfSnapshotChanged(inst) {
          var latestGetSnapshot = inst.getSnapshot;
          var prevValue = inst.value;
          try {
            var nextValue = latestGetSnapshot();
            return !objectIs(prevValue, nextValue);
          } catch (error2) {
            return true;
          }
        }
        function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
          return getSnapshot();
        }
        var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
        var isServerEnvironment = !canUseDOM;
        var shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore2;
        var useSyncExternalStore$2 = React11.useSyncExternalStore !== void 0 ? React11.useSyncExternalStore : shim;
        exports2.useSyncExternalStore = useSyncExternalStore$2;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/use-sync-external-store/shim/index.js
var require_shim4 = __commonJS({
  "node_modules/use-sync-external-store/shim/index.js"(exports2, module2) {
    "use strict";
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_use_sync_external_store_shim_development();
    }
  }
});

// node_modules/@coinbase/wallet-sdk/dist/lib/ScopedLocalStorage.js
var require_ScopedLocalStorage = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/lib/ScopedLocalStorage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ScopedLocalStorage = void 0;
    var ScopedLocalStorage = class {
      constructor(scope) {
        this.scope = scope;
      }
      setItem(key2, value2) {
        localStorage.setItem(this.scopedKey(key2), value2);
      }
      getItem(key2) {
        return localStorage.getItem(this.scopedKey(key2));
      }
      removeItem(key2) {
        localStorage.removeItem(this.scopedKey(key2));
      }
      clear() {
        const prefix2 = this.scopedKey("");
        const keysToRemove = [];
        for (let i6 = 0; i6 < localStorage.length; i6++) {
          const key2 = localStorage.key(i6);
          if (typeof key2 === "string" && key2.startsWith(prefix2)) {
            keysToRemove.push(key2);
          }
        }
        keysToRemove.forEach((key2) => localStorage.removeItem(key2));
      }
      scopedKey(key2) {
        return `${this.scope}:${key2}`;
      }
    };
    exports2.ScopedLocalStorage = ScopedLocalStorage;
  }
});

// node_modules/@metamask/safe-event-emitter/index.js
var require_safe_event_emitter = __commonJS({
  "node_modules/@metamask/safe-event-emitter/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var events_1 = require_events();
    function safeApply(handler, context, args) {
      try {
        Reflect.apply(handler, context, args);
      } catch (err) {
        setTimeout(() => {
          throw err;
        });
      }
    }
    function arrayClone(arr) {
      const n4 = arr.length;
      const copy = new Array(n4);
      for (let i6 = 0; i6 < n4; i6 += 1) {
        copy[i6] = arr[i6];
      }
      return copy;
    }
    var SafeEventEmitter = class extends events_1.EventEmitter {
      emit(type, ...args) {
        let doError = type === "error";
        const events = this._events;
        if (events !== void 0) {
          doError = doError && events.error === void 0;
        } else if (!doError) {
          return false;
        }
        if (doError) {
          let er2;
          if (args.length > 0) {
            [er2] = args;
          }
          if (er2 instanceof Error) {
            throw er2;
          }
          const err = new Error(`Unhandled error.${er2 ? ` (${er2.message})` : ""}`);
          err.context = er2;
          throw err;
        }
        const handler = events[type];
        if (handler === void 0) {
          return false;
        }
        if (typeof handler === "function") {
          safeApply(handler, this, args);
        } else {
          const len = handler.length;
          const listeners = arrayClone(handler);
          for (let i6 = 0; i6 < len; i6 += 1) {
            safeApply(listeners[i6], this, args);
          }
        }
        return true;
      }
    };
    exports2.default = SafeEventEmitter;
  }
});

// node_modules/@coinbase/wallet-sdk/node_modules/bn.js/lib/bn.js
var require_bn3 = __commonJS({
  "node_modules/@coinbase/wallet-sdk/node_modules/bn.js/lib/bn.js"(exports2, module2) {
    (function(module3, exports3) {
      "use strict";
      function assert3(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN4(number, base2, endian) {
        if (BN4.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base2 === "le" || base2 === "be") {
            endian = base2;
            base2 = 10;
          }
          this._init(number || 0, base2 || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN4;
      } else {
        exports3.BN = BN4;
      }
      BN4.BN = BN4;
      BN4.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = require_buffer().Buffer;
        }
      } catch (e6) {
      }
      BN4.isBN = function isBN(num) {
        if (num instanceof BN4) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN4.wordSize && Array.isArray(num.words);
      };
      BN4.max = function max2(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN4.min = function min2(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN4.prototype._init = function init2(number, base2, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base2, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base2, endian);
        }
        if (base2 === "hex") {
          base2 = 16;
        }
        assert3(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base2 === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base2, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base2, endian);
            }
          }
        }
      };
      BN4.prototype._initNumber = function _initNumber(number, base2, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert3(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN4.prototype._initArray = function _initArray(number, base2, endian) {
        assert3(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i6 = 0; i6 < this.length; i6++) {
          this.words[i6] = 0;
        }
        var j8, w8;
        var off = 0;
        if (endian === "be") {
          for (i6 = number.length - 1, j8 = 0; i6 >= 0; i6 -= 3) {
            w8 = number[i6] | number[i6 - 1] << 8 | number[i6 - 2] << 16;
            this.words[j8] |= w8 << off & 67108863;
            this.words[j8 + 1] = w8 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j8++;
            }
          }
        } else if (endian === "le") {
          for (i6 = 0, j8 = 0; i6 < number.length; i6 += 3) {
            w8 = number[i6] | number[i6 + 1] << 8 | number[i6 + 2] << 16;
            this.words[j8] |= w8 << off & 67108863;
            this.words[j8 + 1] = w8 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j8++;
            }
          }
        }
        return this._strip();
      };
      function parseHex4Bits(string, index) {
        var c5 = string.charCodeAt(index);
        if (c5 >= 48 && c5 <= 57) {
          return c5 - 48;
        } else if (c5 >= 65 && c5 <= 70) {
          return c5 - 55;
        } else if (c5 >= 97 && c5 <= 102) {
          return c5 - 87;
        } else {
          assert3(false, "Invalid character in " + string);
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r6 = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r6 |= parseHex4Bits(string, index - 1) << 4;
        }
        return r6;
      }
      BN4.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i6 = 0; i6 < this.length; i6++) {
          this.words[i6] = 0;
        }
        var off = 0;
        var j8 = 0;
        var w8;
        if (endian === "be") {
          for (i6 = number.length - 1; i6 >= start; i6 -= 2) {
            w8 = parseHexByte(number, start, i6) << off;
            this.words[j8] |= w8 & 67108863;
            if (off >= 18) {
              off -= 18;
              j8 += 1;
              this.words[j8] |= w8 >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i6 = parseLength % 2 === 0 ? start + 1 : start; i6 < number.length; i6 += 2) {
            w8 = parseHexByte(number, start, i6) << off;
            this.words[j8] |= w8 & 67108863;
            if (off >= 18) {
              off -= 18;
              j8 += 1;
              this.words[j8] |= w8 >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this._strip();
      };
      function parseBase(str, start, end, mul3) {
        var r6 = 0;
        var b4 = 0;
        var len = Math.min(str.length, end);
        for (var i6 = start; i6 < len; i6++) {
          var c5 = str.charCodeAt(i6) - 48;
          r6 *= mul3;
          if (c5 >= 49) {
            b4 = c5 - 49 + 10;
          } else if (c5 >= 17) {
            b4 = c5 - 17 + 10;
          } else {
            b4 = c5;
          }
          assert3(c5 >= 0 && b4 < mul3, "Invalid character");
          r6 += b4;
        }
        return r6;
      }
      BN4.prototype._parseBase = function _parseBase(number, base2, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base2 | 0;
        var total = number.length - start;
        var mod2 = total % limbLen;
        var end = Math.min(total, total - mod2) + start;
        var word = 0;
        for (var i6 = start; i6 < end; i6 += limbLen) {
          word = parseBase(number, i6, i6 + limbLen, base2);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod2 !== 0) {
          var pow = 1;
          word = parseBase(number, i6, number.length, base2);
          for (i6 = 0; i6 < mod2; i6++) {
            pow *= base2;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this._strip();
      };
      BN4.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i6 = 0; i6 < this.length; i6++) {
          dest.words[i6] = this.words[i6];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      function move(dest, src) {
        dest.words = src.words;
        dest.length = src.length;
        dest.negative = src.negative;
        dest.red = src.red;
      }
      BN4.prototype._move = function _move(dest) {
        move(dest, this);
      };
      BN4.prototype.clone = function clone() {
        var r6 = new BN4(null);
        this.copy(r6);
        return r6;
      };
      BN4.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN4.prototype._strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN4.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
        try {
          BN4.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect4;
        } catch (e6) {
          BN4.prototype.inspect = inspect4;
        }
      } else {
        BN4.prototype.inspect = inspect4;
      }
      function inspect4() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var zeros2 = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN4.prototype.toString = function toString2(base2, padding2) {
        base2 = base2 || 10;
        padding2 = padding2 | 0 || 1;
        var out;
        if (base2 === 16 || base2 === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i6 = 0; i6 < this.length; i6++) {
            var w8 = this.words[i6];
            var word = ((w8 << off | carry) & 16777215).toString(16);
            carry = w8 >>> 24 - off & 16777215;
            if (carry !== 0 || i6 !== this.length - 1) {
              out = zeros2[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i6--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
          var groupSize = groupSizes[base2];
          var groupBase = groupBases[base2];
          out = "";
          var c5 = this.clone();
          c5.negative = 0;
          while (!c5.isZero()) {
            var r6 = c5.modrn(groupBase).toString(base2);
            c5 = c5.idivn(groupBase);
            if (!c5.isZero()) {
              out = zeros2[groupSize - r6.length] + r6 + out;
            } else {
              out = r6 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert3(false, "Base should be between 2 and 36");
      };
      BN4.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert3(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN4.prototype.toJSON = function toJSON2() {
        return this.toString(16, 2);
      };
      if (Buffer2) {
        BN4.prototype.toBuffer = function toBuffer(endian, length) {
          return this.toArrayLike(Buffer2, endian, length);
        };
      }
      BN4.prototype.toArray = function toArray2(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      var allocate = function allocate2(ArrayType, size) {
        if (ArrayType.allocUnsafe) {
          return ArrayType.allocUnsafe(size);
        }
        return new ArrayType(size);
      };
      BN4.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        this._strip();
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert3(byteLength <= reqLength, "byte array longer than desired length");
        assert3(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength);
        return res;
      };
      BN4.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
        var position = 0;
        var carry = 0;
        for (var i6 = 0, shift = 0; i6 < this.length; i6++) {
          var word = this.words[i6] << shift | carry;
          res[position++] = word & 255;
          if (position < res.length) {
            res[position++] = word >> 8 & 255;
          }
          if (position < res.length) {
            res[position++] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position < res.length) {
              res[position++] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position < res.length) {
          res[position++] = carry;
          while (position < res.length) {
            res[position++] = 0;
          }
        }
      };
      BN4.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
        var position = res.length - 1;
        var carry = 0;
        for (var i6 = 0, shift = 0; i6 < this.length; i6++) {
          var word = this.words[i6] << shift | carry;
          res[position--] = word & 255;
          if (position >= 0) {
            res[position--] = word >> 8 & 255;
          }
          if (position >= 0) {
            res[position--] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position >= 0) {
              res[position--] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position >= 0) {
          res[position--] = carry;
          while (position >= 0) {
            res[position--] = 0;
          }
        }
      };
      if (Math.clz32) {
        BN4.prototype._countBits = function _countBits(w8) {
          return 32 - Math.clz32(w8);
        };
      } else {
        BN4.prototype._countBits = function _countBits(w8) {
          var t6 = w8;
          var r6 = 0;
          if (t6 >= 4096) {
            r6 += 13;
            t6 >>>= 13;
          }
          if (t6 >= 64) {
            r6 += 7;
            t6 >>>= 7;
          }
          if (t6 >= 8) {
            r6 += 4;
            t6 >>>= 4;
          }
          if (t6 >= 2) {
            r6 += 2;
            t6 >>>= 2;
          }
          return r6 + t6;
        };
      }
      BN4.prototype._zeroBits = function _zeroBits(w8) {
        if (w8 === 0)
          return 26;
        var t6 = w8;
        var r6 = 0;
        if ((t6 & 8191) === 0) {
          r6 += 13;
          t6 >>>= 13;
        }
        if ((t6 & 127) === 0) {
          r6 += 7;
          t6 >>>= 7;
        }
        if ((t6 & 15) === 0) {
          r6 += 4;
          t6 >>>= 4;
        }
        if ((t6 & 3) === 0) {
          r6 += 2;
          t6 >>>= 2;
        }
        if ((t6 & 1) === 0) {
          r6++;
        }
        return r6;
      };
      BN4.prototype.bitLength = function bitLength() {
        var w8 = this.words[this.length - 1];
        var hi2 = this._countBits(w8);
        return (this.length - 1) * 26 + hi2;
      };
      function toBitArray(num) {
        var w8 = new Array(num.bitLength());
        for (var bit = 0; bit < w8.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w8[bit] = num.words[off] >>> wbit & 1;
        }
        return w8;
      }
      BN4.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r6 = 0;
        for (var i6 = 0; i6 < this.length; i6++) {
          var b4 = this._zeroBits(this.words[i6]);
          r6 += b4;
          if (b4 !== 26)
            break;
        }
        return r6;
      };
      BN4.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN4.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN4.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN4.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN4.prototype.neg = function neg3() {
        return this.clone().ineg();
      };
      BN4.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN4.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i6 = 0; i6 < num.length; i6++) {
          this.words[i6] = this.words[i6] | num.words[i6];
        }
        return this._strip();
      };
      BN4.prototype.ior = function ior(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN4.prototype.or = function or2(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN4.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN4.prototype.iuand = function iuand(num) {
        var b4;
        if (this.length > num.length) {
          b4 = num;
        } else {
          b4 = this;
        }
        for (var i6 = 0; i6 < b4.length; i6++) {
          this.words[i6] = this.words[i6] & num.words[i6];
        }
        this.length = b4.length;
        return this._strip();
      };
      BN4.prototype.iand = function iand(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN4.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN4.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN4.prototype.iuxor = function iuxor(num) {
        var a5;
        var b4;
        if (this.length > num.length) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        for (var i6 = 0; i6 < b4.length; i6++) {
          this.words[i6] = a5.words[i6] ^ b4.words[i6];
        }
        if (this !== a5) {
          for (; i6 < a5.length; i6++) {
            this.words[i6] = a5.words[i6];
          }
        }
        this.length = a5.length;
        return this._strip();
      };
      BN4.prototype.ixor = function ixor(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN4.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN4.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN4.prototype.inotn = function inotn(width) {
        assert3(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i6 = 0; i6 < bytesNeeded; i6++) {
          this.words[i6] = ~this.words[i6] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i6] = ~this.words[i6] & 67108863 >> 26 - bitsLeft;
        }
        return this._strip();
      };
      BN4.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN4.prototype.setn = function setn(bit, val) {
        assert3(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this._strip();
      };
      BN4.prototype.iadd = function iadd(num) {
        var r6;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r6 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r6 = this.isub(num);
          num.negative = 1;
          return r6._normSign();
        }
        var a5, b4;
        if (this.length > num.length) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        var carry = 0;
        for (var i6 = 0; i6 < b4.length; i6++) {
          r6 = (a5.words[i6] | 0) + (b4.words[i6] | 0) + carry;
          this.words[i6] = r6 & 67108863;
          carry = r6 >>> 26;
        }
        for (; carry !== 0 && i6 < a5.length; i6++) {
          r6 = (a5.words[i6] | 0) + carry;
          this.words[i6] = r6 & 67108863;
          carry = r6 >>> 26;
        }
        this.length = a5.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a5 !== this) {
          for (; i6 < a5.length; i6++) {
            this.words[i6] = a5.words[i6];
          }
        }
        return this;
      };
      BN4.prototype.add = function add3(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN4.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r6 = this.iadd(num);
          num.negative = 1;
          return r6._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a5, b4;
        if (cmp > 0) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        var carry = 0;
        for (var i6 = 0; i6 < b4.length; i6++) {
          r6 = (a5.words[i6] | 0) - (b4.words[i6] | 0) + carry;
          carry = r6 >> 26;
          this.words[i6] = r6 & 67108863;
        }
        for (; carry !== 0 && i6 < a5.length; i6++) {
          r6 = (a5.words[i6] | 0) + carry;
          carry = r6 >> 26;
          this.words[i6] = r6 & 67108863;
        }
        if (carry === 0 && i6 < a5.length && a5 !== this) {
          for (; i6 < a5.length; i6++) {
            this.words[i6] = a5.words[i6];
          }
        }
        this.length = Math.max(this.length, i6);
        if (a5 !== this) {
          this.negative = 1;
        }
        return this._strip();
      };
      BN4.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a5 = self2.words[0] | 0;
        var b4 = num.words[0] | 0;
        var r6 = a5 * b4;
        var lo = r6 & 67108863;
        var carry = r6 / 67108864 | 0;
        out.words[0] = lo;
        for (var k8 = 1; k8 < len; k8++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k8, num.length - 1);
          for (var j8 = Math.max(0, k8 - self2.length + 1); j8 <= maxJ; j8++) {
            var i6 = k8 - j8 | 0;
            a5 = self2.words[i6] | 0;
            b4 = num.words[j8] | 0;
            r6 = a5 * b4 + rword;
            ncarry += r6 / 67108864 | 0;
            rword = r6 & 67108863;
          }
          out.words[k8] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k8] = carry | 0;
        } else {
          out.length--;
        }
        return out._strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a5 = self2.words;
        var b4 = num.words;
        var o6 = out.words;
        var c5 = 0;
        var lo;
        var mid;
        var hi2;
        var a02 = a5[0] | 0;
        var al0 = a02 & 8191;
        var ah0 = a02 >>> 13;
        var a1 = a5[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a5[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a5[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a42 = a5[4] | 0;
        var al4 = a42 & 8191;
        var ah4 = a42 >>> 13;
        var a52 = a5[5] | 0;
        var al5 = a52 & 8191;
        var ah5 = a52 >>> 13;
        var a6 = a5[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a5[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a5[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a5[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b02 = b4[0] | 0;
        var bl0 = b02 & 8191;
        var bh0 = b02 >>> 13;
        var b1 = b4[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b4[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b4[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b42 = b4[4] | 0;
        var bl4 = b42 & 8191;
        var bh4 = b42 >>> 13;
        var b5 = b4[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b4[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b4[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b4[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b4[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi2 = Math.imul(ah0, bh0);
        var w02 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w02 >>> 26) | 0;
        w02 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi2 = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi2 = hi2 + Math.imul(ah0, bh1) | 0;
        var w1 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi2 = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi2 = hi2 + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi2 = hi2 + Math.imul(ah0, bh2) | 0;
        var w22 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi2 = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi2 = hi2 + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi2 = hi2 + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi2 = hi2 + Math.imul(ah0, bh3) | 0;
        var w32 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi2 = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi2 = hi2 + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi2 = hi2 + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi2 = hi2 + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi2 = hi2 + Math.imul(ah0, bh4) | 0;
        var w42 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
        w42 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi2 = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi2 = hi2 + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi2 = hi2 + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi2 = hi2 + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi2 = hi2 + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi2 = hi2 + Math.imul(ah0, bh5) | 0;
        var w52 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w52 >>> 26) | 0;
        w52 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi2 = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi2 = hi2 + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi2 = hi2 + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi2 = hi2 + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi2 = hi2 + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi2 = hi2 + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi2 = hi2 + Math.imul(ah0, bh6) | 0;
        var w62 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w62 >>> 26) | 0;
        w62 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi2 = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi2 = hi2 + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi2 = hi2 + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi2 = hi2 + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi2 = hi2 + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi2 = hi2 + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi2 = hi2 + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi2 = hi2 + Math.imul(ah0, bh7) | 0;
        var w72 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w72 >>> 26) | 0;
        w72 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi2 = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi2 = hi2 + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi2 = hi2 + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi2 = hi2 + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi2 = hi2 + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi2 = hi2 + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi2 = hi2 + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi2 = hi2 + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi2 = hi2 + Math.imul(ah0, bh8) | 0;
        var w8 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi2 = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi2 = hi2 + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi2 = hi2 + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi2 = hi2 + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi2 = hi2 + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi2 = hi2 + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi2 = hi2 + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi2 = hi2 + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi2 = hi2 + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi2 = hi2 + Math.imul(ah0, bh9) | 0;
        var w9 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi2 = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi2 = hi2 + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi2 = hi2 + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi2 = hi2 + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi2 = hi2 + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi2 = hi2 + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi2 = hi2 + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi2 = hi2 + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi2 = hi2 + Math.imul(ah1, bh9) | 0;
        var w10 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi2 = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi2 = hi2 + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi2 = hi2 + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi2 = hi2 + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi2 = hi2 + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi2 = hi2 + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi2 = hi2 + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi2 = hi2 + Math.imul(ah2, bh9) | 0;
        var w11 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi2 = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi2 = hi2 + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi2 = hi2 + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi2 = hi2 + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi2 = hi2 + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi2 = hi2 + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi2 = hi2 + Math.imul(ah3, bh9) | 0;
        var w12 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi2 = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi2 = hi2 + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi2 = hi2 + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi2 = hi2 + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi2 = hi2 + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi2 = hi2 + Math.imul(ah4, bh9) | 0;
        var w13 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi2 = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi2 = hi2 + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi2 = hi2 + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi2 = hi2 + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi2 = hi2 + Math.imul(ah5, bh9) | 0;
        var w14 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi2 = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi2 = hi2 + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi2 = hi2 + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi2 = hi2 + Math.imul(ah6, bh9) | 0;
        var w15 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi2 = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi2 = hi2 + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi2 = hi2 + Math.imul(ah7, bh9) | 0;
        var w16 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi2 = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi2 = hi2 + Math.imul(ah8, bh9) | 0;
        var w17 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi2 = Math.imul(ah9, bh9);
        var w18 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o6[0] = w02;
        o6[1] = w1;
        o6[2] = w22;
        o6[3] = w32;
        o6[4] = w42;
        o6[5] = w52;
        o6[6] = w62;
        o6[7] = w72;
        o6[8] = w8;
        o6[9] = w9;
        o6[10] = w10;
        o6[11] = w11;
        o6[12] = w12;
        o6[13] = w13;
        o6[14] = w14;
        o6[15] = w15;
        o6[16] = w16;
        o6[17] = w17;
        o6[18] = w18;
        if (c5 !== 0) {
          o6[19] = c5;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k8 = 0; k8 < out.length - 1; k8++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k8, num.length - 1);
          for (var j8 = Math.max(0, k8 - self2.length + 1); j8 <= maxJ; j8++) {
            var i6 = k8 - j8;
            var a5 = self2.words[i6] | 0;
            var b4 = num.words[j8] | 0;
            var r6 = a5 * b4;
            var lo = r6 & 67108863;
            ncarry = ncarry + (r6 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k8] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k8] = carry;
        } else {
          out.length--;
        }
        return out._strip();
      }
      function jumboMulTo(self2, num, out) {
        return bigMulTo(self2, num, out);
      }
      BN4.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x6, y5) {
        this.x = x6;
        this.y = y5;
      }
      FFTM.prototype.makeRBT = function makeRBT(N7) {
        var t6 = new Array(N7);
        var l6 = BN4.prototype._countBits(N7) - 1;
        for (var i6 = 0; i6 < N7; i6++) {
          t6[i6] = this.revBin(i6, l6, N7);
        }
        return t6;
      };
      FFTM.prototype.revBin = function revBin(x6, l6, N7) {
        if (x6 === 0 || x6 === N7 - 1)
          return x6;
        var rb = 0;
        for (var i6 = 0; i6 < l6; i6++) {
          rb |= (x6 & 1) << l6 - i6 - 1;
          x6 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N7) {
        for (var i6 = 0; i6 < N7; i6++) {
          rtws[i6] = rws[rbt[i6]];
          itws[i6] = iws[rbt[i6]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N7, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N7);
        for (var s6 = 1; s6 < N7; s6 <<= 1) {
          var l6 = s6 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l6);
          var itwdf = Math.sin(2 * Math.PI / l6);
          for (var p7 = 0; p7 < N7; p7 += l6) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j8 = 0; j8 < s6; j8++) {
              var re = rtws[p7 + j8];
              var ie2 = itws[p7 + j8];
              var ro3 = rtws[p7 + j8 + s6];
              var io3 = itws[p7 + j8 + s6];
              var rx = rtwdf_ * ro3 - itwdf_ * io3;
              io3 = rtwdf_ * io3 + itwdf_ * ro3;
              ro3 = rx;
              rtws[p7 + j8] = re + ro3;
              itws[p7 + j8] = ie2 + io3;
              rtws[p7 + j8 + s6] = re - ro3;
              itws[p7 + j8 + s6] = ie2 - io3;
              if (j8 !== l6) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n4, m6) {
        var N7 = Math.max(m6, n4) | 1;
        var odd = N7 & 1;
        var i6 = 0;
        for (N7 = N7 / 2 | 0; N7; N7 = N7 >>> 1) {
          i6++;
        }
        return 1 << i6 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N7) {
        if (N7 <= 1)
          return;
        for (var i6 = 0; i6 < N7 / 2; i6++) {
          var t6 = rws[i6];
          rws[i6] = rws[N7 - i6 - 1];
          rws[N7 - i6 - 1] = t6;
          t6 = iws[i6];
          iws[i6] = -iws[N7 - i6 - 1];
          iws[N7 - i6 - 1] = -t6;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws2, N7) {
        var carry = 0;
        for (var i6 = 0; i6 < N7 / 2; i6++) {
          var w8 = Math.round(ws2[2 * i6 + 1] / N7) * 8192 + Math.round(ws2[2 * i6] / N7) + carry;
          ws2[i6] = w8 & 67108863;
          if (w8 < 67108864) {
            carry = 0;
          } else {
            carry = w8 / 67108864 | 0;
          }
        }
        return ws2;
      };
      FFTM.prototype.convert13b = function convert13b(ws2, len, rws, N7) {
        var carry = 0;
        for (var i6 = 0; i6 < len; i6++) {
          carry = carry + (ws2[i6] | 0);
          rws[2 * i6] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i6 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i6 = 2 * len; i6 < N7; ++i6) {
          rws[i6] = 0;
        }
        assert3(carry === 0);
        assert3((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N7) {
        var ph = new Array(N7);
        for (var i6 = 0; i6 < N7; i6++) {
          ph[i6] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x6, y5, out) {
        var N7 = 2 * this.guessLen13b(x6.length, y5.length);
        var rbt = this.makeRBT(N7);
        var _8 = this.stub(N7);
        var rws = new Array(N7);
        var rwst = new Array(N7);
        var iwst = new Array(N7);
        var nrws = new Array(N7);
        var nrwst = new Array(N7);
        var niwst = new Array(N7);
        var rmws = out.words;
        rmws.length = N7;
        this.convert13b(x6.words, x6.length, rws, N7);
        this.convert13b(y5.words, y5.length, nrws, N7);
        this.transform(rws, _8, rwst, iwst, N7, rbt);
        this.transform(nrws, _8, nrwst, niwst, N7, rbt);
        for (var i6 = 0; i6 < N7; i6++) {
          var rx = rwst[i6] * nrwst[i6] - iwst[i6] * niwst[i6];
          iwst[i6] = rwst[i6] * niwst[i6] + iwst[i6] * nrwst[i6];
          rwst[i6] = rx;
        }
        this.conjugate(rwst, iwst, N7);
        this.transform(rwst, iwst, rmws, _8, N7, rbt);
        this.conjugate(rmws, _8, N7);
        this.normalize13b(rmws, N7);
        out.negative = x6.negative ^ y5.negative;
        out.length = x6.length + y5.length;
        return out._strip();
      };
      BN4.prototype.mul = function mul3(num) {
        var out = new BN4(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN4.prototype.mulf = function mulf(num) {
        var out = new BN4(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN4.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN4.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert3(typeof num === "number");
        assert3(num < 67108864);
        var carry = 0;
        for (var i6 = 0; i6 < this.length; i6++) {
          var w8 = (this.words[i6] | 0) * num;
          var lo = (w8 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w8 / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i6] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i6] = carry;
          this.length++;
        }
        return isNegNum ? this.ineg() : this;
      };
      BN4.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN4.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN4.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN4.prototype.pow = function pow(num) {
        var w8 = toBitArray(num);
        if (w8.length === 0)
          return new BN4(1);
        var res = this;
        for (var i6 = 0; i6 < w8.length; i6++, res = res.sqr()) {
          if (w8[i6] !== 0)
            break;
        }
        if (++i6 < w8.length) {
          for (var q8 = res.sqr(); i6 < w8.length; i6++, q8 = q8.sqr()) {
            if (w8[i6] === 0)
              continue;
            res = res.mul(q8);
          }
        }
        return res;
      };
      BN4.prototype.iushln = function iushln(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r6 = bits % 26;
        var s6 = (bits - r6) / 26;
        var carryMask = 67108863 >>> 26 - r6 << 26 - r6;
        var i6;
        if (r6 !== 0) {
          var carry = 0;
          for (i6 = 0; i6 < this.length; i6++) {
            var newCarry = this.words[i6] & carryMask;
            var c5 = (this.words[i6] | 0) - newCarry << r6;
            this.words[i6] = c5 | carry;
            carry = newCarry >>> 26 - r6;
          }
          if (carry) {
            this.words[i6] = carry;
            this.length++;
          }
        }
        if (s6 !== 0) {
          for (i6 = this.length - 1; i6 >= 0; i6--) {
            this.words[i6 + s6] = this.words[i6];
          }
          for (i6 = 0; i6 < s6; i6++) {
            this.words[i6] = 0;
          }
          this.length += s6;
        }
        return this._strip();
      };
      BN4.prototype.ishln = function ishln(bits) {
        assert3(this.negative === 0);
        return this.iushln(bits);
      };
      BN4.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert3(typeof bits === "number" && bits >= 0);
        var h6;
        if (hint) {
          h6 = (hint - hint % 26) / 26;
        } else {
          h6 = 0;
        }
        var r6 = bits % 26;
        var s6 = Math.min((bits - r6) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r6 << r6;
        var maskedWords = extended;
        h6 -= s6;
        h6 = Math.max(0, h6);
        if (maskedWords) {
          for (var i6 = 0; i6 < s6; i6++) {
            maskedWords.words[i6] = this.words[i6];
          }
          maskedWords.length = s6;
        }
        if (s6 === 0) {
        } else if (this.length > s6) {
          this.length -= s6;
          for (i6 = 0; i6 < this.length; i6++) {
            this.words[i6] = this.words[i6 + s6];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i6 = this.length - 1; i6 >= 0 && (carry !== 0 || i6 >= h6); i6--) {
          var word = this.words[i6] | 0;
          this.words[i6] = carry << 26 - r6 | word >>> r6;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this._strip();
      };
      BN4.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert3(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN4.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN4.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN4.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN4.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN4.prototype.testn = function testn(bit) {
        assert3(typeof bit === "number" && bit >= 0);
        var r6 = bit % 26;
        var s6 = (bit - r6) / 26;
        var q8 = 1 << r6;
        if (this.length <= s6)
          return false;
        var w8 = this.words[s6];
        return !!(w8 & q8);
      };
      BN4.prototype.imaskn = function imaskn(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r6 = bits % 26;
        var s6 = (bits - r6) / 26;
        assert3(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s6) {
          return this;
        }
        if (r6 !== 0) {
          s6++;
        }
        this.length = Math.min(s6, this.length);
        if (r6 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r6 << r6;
          this.words[this.length - 1] &= mask;
        }
        return this._strip();
      };
      BN4.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN4.prototype.iaddn = function iaddn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN4.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i6 = 0; i6 < this.length && this.words[i6] >= 67108864; i6++) {
          this.words[i6] -= 67108864;
          if (i6 === this.length - 1) {
            this.words[i6 + 1] = 1;
          } else {
            this.words[i6 + 1]++;
          }
        }
        this.length = Math.max(this.length, i6 + 1);
        return this;
      };
      BN4.prototype.isubn = function isubn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i6 = 0; i6 < this.length && this.words[i6] < 0; i6++) {
            this.words[i6] += 67108864;
            this.words[i6 + 1] -= 1;
          }
        }
        return this._strip();
      };
      BN4.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN4.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN4.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN4.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN4.prototype._ishlnsubmul = function _ishlnsubmul(num, mul3, shift) {
        var len = num.length + shift;
        var i6;
        this._expand(len);
        var w8;
        var carry = 0;
        for (i6 = 0; i6 < num.length; i6++) {
          w8 = (this.words[i6 + shift] | 0) + carry;
          var right = (num.words[i6] | 0) * mul3;
          w8 -= right & 67108863;
          carry = (w8 >> 26) - (right / 67108864 | 0);
          this.words[i6 + shift] = w8 & 67108863;
        }
        for (; i6 < this.length - shift; i6++) {
          w8 = (this.words[i6 + shift] | 0) + carry;
          carry = w8 >> 26;
          this.words[i6 + shift] = w8 & 67108863;
        }
        if (carry === 0)
          return this._strip();
        assert3(carry === -1);
        carry = 0;
        for (i6 = 0; i6 < this.length; i6++) {
          w8 = -(this.words[i6] | 0) + carry;
          carry = w8 >> 26;
          this.words[i6] = w8 & 67108863;
        }
        this.negative = 1;
        return this._strip();
      };
      BN4.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a5 = this.clone();
        var b4 = num;
        var bhi = b4.words[b4.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b4 = b4.ushln(shift);
          a5.iushln(shift);
          bhi = b4.words[b4.length - 1] | 0;
        }
        var m6 = a5.length - b4.length;
        var q8;
        if (mode !== "mod") {
          q8 = new BN4(null);
          q8.length = m6 + 1;
          q8.words = new Array(q8.length);
          for (var i6 = 0; i6 < q8.length; i6++) {
            q8.words[i6] = 0;
          }
        }
        var diff = a5.clone()._ishlnsubmul(b4, 1, m6);
        if (diff.negative === 0) {
          a5 = diff;
          if (q8) {
            q8.words[m6] = 1;
          }
        }
        for (var j8 = m6 - 1; j8 >= 0; j8--) {
          var qj = (a5.words[b4.length + j8] | 0) * 67108864 + (a5.words[b4.length + j8 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a5._ishlnsubmul(b4, qj, j8);
          while (a5.negative !== 0) {
            qj--;
            a5.negative = 0;
            a5._ishlnsubmul(b4, 1, j8);
            if (!a5.isZero()) {
              a5.negative ^= 1;
            }
          }
          if (q8) {
            q8.words[j8] = qj;
          }
        }
        if (q8) {
          q8._strip();
        }
        a5._strip();
        if (mode !== "div" && shift !== 0) {
          a5.iushrn(shift);
        }
        return {
          div: q8 || null,
          mod: a5
        };
      };
      BN4.prototype.divmod = function divmod(num, mode, positive) {
        assert3(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN4(0),
            mod: new BN4(0)
          };
        }
        var div, mod2, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.iadd(num);
            }
          }
          return {
            div,
            mod: mod2
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.isub(num);
            }
          }
          return {
            div: res.div,
            mod: mod2
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN4(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN4(this.modrn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN4(this.modrn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN4.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN4.prototype.mod = function mod2(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN4.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN4.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r22 = num.andln(1);
        var cmp = mod2.cmp(half);
        if (cmp < 0 || r22 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN4.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert3(num <= 67108863);
        var p7 = (1 << 26) % num;
        var acc = 0;
        for (var i6 = this.length - 1; i6 >= 0; i6--) {
          acc = (p7 * acc + (this.words[i6] | 0)) % num;
        }
        return isNegNum ? -acc : acc;
      };
      BN4.prototype.modn = function modn(num) {
        return this.modrn(num);
      };
      BN4.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert3(num <= 67108863);
        var carry = 0;
        for (var i6 = this.length - 1; i6 >= 0; i6--) {
          var w8 = (this.words[i6] | 0) + carry * 67108864;
          this.words[i6] = w8 / num | 0;
          carry = w8 % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
      };
      BN4.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN4.prototype.egcd = function egcd(p7) {
        assert3(p7.negative === 0);
        assert3(!p7.isZero());
        var x6 = this;
        var y5 = p7.clone();
        if (x6.negative !== 0) {
          x6 = x6.umod(p7);
        } else {
          x6 = x6.clone();
        }
        var A8 = new BN4(1);
        var B4 = new BN4(0);
        var C5 = new BN4(0);
        var D5 = new BN4(1);
        var g7 = 0;
        while (x6.isEven() && y5.isEven()) {
          x6.iushrn(1);
          y5.iushrn(1);
          ++g7;
        }
        var yp = y5.clone();
        var xp = x6.clone();
        while (!x6.isZero()) {
          for (var i6 = 0, im = 1; (x6.words[0] & im) === 0 && i6 < 26; ++i6, im <<= 1)
            ;
          if (i6 > 0) {
            x6.iushrn(i6);
            while (i6-- > 0) {
              if (A8.isOdd() || B4.isOdd()) {
                A8.iadd(yp);
                B4.isub(xp);
              }
              A8.iushrn(1);
              B4.iushrn(1);
            }
          }
          for (var j8 = 0, jm = 1; (y5.words[0] & jm) === 0 && j8 < 26; ++j8, jm <<= 1)
            ;
          if (j8 > 0) {
            y5.iushrn(j8);
            while (j8-- > 0) {
              if (C5.isOdd() || D5.isOdd()) {
                C5.iadd(yp);
                D5.isub(xp);
              }
              C5.iushrn(1);
              D5.iushrn(1);
            }
          }
          if (x6.cmp(y5) >= 0) {
            x6.isub(y5);
            A8.isub(C5);
            B4.isub(D5);
          } else {
            y5.isub(x6);
            C5.isub(A8);
            D5.isub(B4);
          }
        }
        return {
          a: C5,
          b: D5,
          gcd: y5.iushln(g7)
        };
      };
      BN4.prototype._invmp = function _invmp(p7) {
        assert3(p7.negative === 0);
        assert3(!p7.isZero());
        var a5 = this;
        var b4 = p7.clone();
        if (a5.negative !== 0) {
          a5 = a5.umod(p7);
        } else {
          a5 = a5.clone();
        }
        var x1 = new BN4(1);
        var x22 = new BN4(0);
        var delta = b4.clone();
        while (a5.cmpn(1) > 0 && b4.cmpn(1) > 0) {
          for (var i6 = 0, im = 1; (a5.words[0] & im) === 0 && i6 < 26; ++i6, im <<= 1)
            ;
          if (i6 > 0) {
            a5.iushrn(i6);
            while (i6-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j8 = 0, jm = 1; (b4.words[0] & jm) === 0 && j8 < 26; ++j8, jm <<= 1)
            ;
          if (j8 > 0) {
            b4.iushrn(j8);
            while (j8-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a5.cmp(b4) >= 0) {
            a5.isub(b4);
            x1.isub(x22);
          } else {
            b4.isub(a5);
            x22.isub(x1);
          }
        }
        var res;
        if (a5.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p7);
        }
        return res;
      };
      BN4.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a5 = this.clone();
        var b4 = num.clone();
        a5.negative = 0;
        b4.negative = 0;
        for (var shift = 0; a5.isEven() && b4.isEven(); shift++) {
          a5.iushrn(1);
          b4.iushrn(1);
        }
        do {
          while (a5.isEven()) {
            a5.iushrn(1);
          }
          while (b4.isEven()) {
            b4.iushrn(1);
          }
          var r6 = a5.cmp(b4);
          if (r6 < 0) {
            var t6 = a5;
            a5 = b4;
            b4 = t6;
          } else if (r6 === 0 || b4.cmpn(1) === 0) {
            break;
          }
          a5.isub(b4);
        } while (true);
        return b4.iushln(shift);
      };
      BN4.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN4.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN4.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN4.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN4.prototype.bincn = function bincn(bit) {
        assert3(typeof bit === "number");
        var r6 = bit % 26;
        var s6 = (bit - r6) / 26;
        var q8 = 1 << r6;
        if (this.length <= s6) {
          this._expand(s6 + 1);
          this.words[s6] |= q8;
          return this;
        }
        var carry = q8;
        for (var i6 = s6; carry !== 0 && i6 < this.length; i6++) {
          var w8 = this.words[i6] | 0;
          w8 += carry;
          carry = w8 >>> 26;
          w8 &= 67108863;
          this.words[i6] = w8;
        }
        if (carry !== 0) {
          this.words[i6] = carry;
          this.length++;
        }
        return this;
      };
      BN4.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN4.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this._strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert3(num <= 67108863, "Number is too big");
          var w8 = this.words[0] | 0;
          res = w8 === num ? 0 : w8 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN4.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN4.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i6 = this.length - 1; i6 >= 0; i6--) {
          var a5 = this.words[i6] | 0;
          var b4 = num.words[i6] | 0;
          if (a5 === b4)
            continue;
          if (a5 < b4) {
            res = -1;
          } else if (a5 > b4) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN4.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN4.prototype.gt = function gt2(num) {
        return this.cmp(num) === 1;
      };
      BN4.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN4.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN4.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN4.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN4.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN4.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN4.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN4.prototype.eq = function eq4(num) {
        return this.cmp(num) === 0;
      };
      BN4.red = function red(num) {
        return new Red(num);
      };
      BN4.prototype.toRed = function toRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        assert3(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN4.prototype.fromRed = function fromRed() {
        assert3(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN4.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN4.prototype.forceRed = function forceRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN4.prototype.redAdd = function redAdd(num) {
        assert3(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN4.prototype.redIAdd = function redIAdd(num) {
        assert3(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN4.prototype.redSub = function redSub(num) {
        assert3(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN4.prototype.redISub = function redISub(num) {
        assert3(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN4.prototype.redShl = function redShl(num) {
        assert3(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN4.prototype.redMul = function redMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN4.prototype.redIMul = function redIMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN4.prototype.redSqr = function redSqr() {
        assert3(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN4.prototype.redISqr = function redISqr() {
        assert3(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN4.prototype.redSqrt = function redSqrt() {
        assert3(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN4.prototype.redInvm = function redInvm() {
        assert3(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN4.prototype.redNeg = function redNeg() {
        assert3(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN4.prototype.redPow = function redPow(num) {
        assert3(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name2, p7) {
        this.name = name2;
        this.p = new BN4(p7, 16);
        this.n = this.p.bitLength();
        this.k = new BN4(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN4(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r6 = num;
        var rlen;
        do {
          this.split(r6, this.tmp);
          r6 = this.imulK(r6);
          r6 = r6.iadd(this.tmp);
          rlen = r6.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r6.ucmp(this.p);
        if (cmp === 0) {
          r6.words[0] = 0;
          r6.length = 1;
        } else if (cmp > 0) {
          r6.isub(this.p);
        } else {
          if (r6.strip !== void 0) {
            r6.strip();
          } else {
            r6._strip();
          }
        }
        return r6;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i6 = 0; i6 < outLen; i6++) {
          output.words[i6] = input.words[i6];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i6 = 10; i6 < input.length; i6++) {
          var next = input.words[i6] | 0;
          input.words[i6 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i6 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i6 = 0; i6 < num.length; i6++) {
          var w8 = num.words[i6] | 0;
          lo += w8 * 977;
          num.words[i6] = lo & 67108863;
          lo = w8 * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i6 = 0; i6 < num.length; i6++) {
          var hi2 = (num.words[i6] | 0) * 19 + carry;
          var lo = hi2 & 67108863;
          hi2 >>>= 26;
          num.words[i6] = lo;
          carry = hi2;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN4._prime = function prime(name2) {
        if (primes[name2])
          return primes[name2];
        var prime2;
        if (name2 === "k256") {
          prime2 = new K256();
        } else if (name2 === "p224") {
          prime2 = new P224();
        } else if (name2 === "p192") {
          prime2 = new P192();
        } else if (name2 === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name2);
        }
        primes[name2] = prime2;
        return prime2;
      };
      function Red(m6) {
        if (typeof m6 === "string") {
          var prime = BN4._prime(m6);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert3(m6.gtn(1), "modulus must be greater than 1");
          this.m = m6;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a5) {
        assert3(a5.negative === 0, "red works only with positives");
        assert3(a5.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a5, b4) {
        assert3((a5.negative | b4.negative) === 0, "red works only with positives");
        assert3(
          a5.red && a5.red === b4.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a5) {
        if (this.prime)
          return this.prime.ireduce(a5)._forceRed(this);
        move(a5, a5.umod(this.m)._forceRed(this));
        return a5;
      };
      Red.prototype.neg = function neg3(a5) {
        if (a5.isZero()) {
          return a5.clone();
        }
        return this.m.sub(a5)._forceRed(this);
      };
      Red.prototype.add = function add3(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.add(b4);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.iadd(b4);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.sub(b4);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.isub(b4);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a5, num) {
        this._verify1(a5);
        return this.imod(a5.ushln(num));
      };
      Red.prototype.imul = function imul(a5, b4) {
        this._verify2(a5, b4);
        return this.imod(a5.imul(b4));
      };
      Red.prototype.mul = function mul3(a5, b4) {
        this._verify2(a5, b4);
        return this.imod(a5.mul(b4));
      };
      Red.prototype.isqr = function isqr(a5) {
        return this.imul(a5, a5.clone());
      };
      Red.prototype.sqr = function sqr(a5) {
        return this.mul(a5, a5);
      };
      Red.prototype.sqrt = function sqrt(a5) {
        if (a5.isZero())
          return a5.clone();
        var mod3 = this.m.andln(3);
        assert3(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN4(1)).iushrn(2);
          return this.pow(a5, pow);
        }
        var q8 = this.m.subn(1);
        var s6 = 0;
        while (!q8.isZero() && q8.andln(1) === 0) {
          s6++;
          q8.iushrn(1);
        }
        assert3(!q8.isZero());
        var one = new BN4(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z6 = this.m.bitLength();
        z6 = new BN4(2 * z6 * z6).toRed(this);
        while (this.pow(z6, lpow).cmp(nOne) !== 0) {
          z6.redIAdd(nOne);
        }
        var c5 = this.pow(z6, q8);
        var r6 = this.pow(a5, q8.addn(1).iushrn(1));
        var t6 = this.pow(a5, q8);
        var m6 = s6;
        while (t6.cmp(one) !== 0) {
          var tmp = t6;
          for (var i6 = 0; tmp.cmp(one) !== 0; i6++) {
            tmp = tmp.redSqr();
          }
          assert3(i6 < m6);
          var b4 = this.pow(c5, new BN4(1).iushln(m6 - i6 - 1));
          r6 = r6.redMul(b4);
          c5 = b4.redSqr();
          t6 = t6.redMul(c5);
          m6 = i6;
        }
        return r6;
      };
      Red.prototype.invm = function invm(a5) {
        var inv = a5._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a5, num) {
        if (num.isZero())
          return new BN4(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a5.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN4(1).toRed(this);
        wnd[1] = a5;
        for (var i6 = 2; i6 < wnd.length; i6++) {
          wnd[i6] = this.mul(wnd[i6 - 1], a5);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i6 = num.length - 1; i6 >= 0; i6--) {
          var word = num.words[i6];
          for (var j8 = start - 1; j8 >= 0; j8--) {
            var bit = word >> j8 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i6 !== 0 || j8 !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r6 = num.umod(this.m);
        return r6 === num ? r6.clone() : r6;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN4.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m6) {
        Red.call(this, m6);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN4(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r6 = this.imod(num.mul(this.rinv));
        r6.red = null;
        return r6;
      };
      Mont.prototype.imul = function imul(a5, b4) {
        if (a5.isZero() || b4.isZero()) {
          a5.words[0] = 0;
          a5.length = 1;
          return a5;
        }
        var t6 = a5.imul(b4);
        var c5 = t6.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u7 = t6.isub(c5).iushrn(this.shift);
        var res = u7;
        if (u7.cmp(this.m) >= 0) {
          res = u7.isub(this.m);
        } else if (u7.cmpn(0) < 0) {
          res = u7.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul3(a5, b4) {
        if (a5.isZero() || b4.isZero())
          return new BN4(0)._forceRed(this);
        var t6 = a5.mul(b4);
        var c5 = t6.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u7 = t6.isub(c5).iushrn(this.shift);
        var res = u7;
        if (u7.cmp(this.m) >= 0) {
          res = u7.isub(this.m);
        } else if (u7.cmpn(0) < 0) {
          res = u7.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a5) {
        var res = this.imod(a5._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module2 === "undefined" || module2, exports2);
  }
});

// node_modules/fast-safe-stringify/index.js
var require_fast_safe_stringify = __commonJS({
  "node_modules/fast-safe-stringify/index.js"(exports2, module2) {
    module2.exports = stringify3;
    stringify3.default = stringify3;
    stringify3.stable = deterministicStringify;
    stringify3.stableStringify = deterministicStringify;
    var LIMIT_REPLACE_NODE = "[...]";
    var CIRCULAR_REPLACE_NODE = "[Circular]";
    var arr = [];
    var replacerStack = [];
    function defaultOptions() {
      return {
        depthLimit: Number.MAX_SAFE_INTEGER,
        edgesLimit: Number.MAX_SAFE_INTEGER
      };
    }
    function stringify3(obj, replacer, spacer, options) {
      if (typeof options === "undefined") {
        options = defaultOptions();
      }
      decirc(obj, "", 0, [], void 0, 0, options);
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(obj, replacer, spacer);
        } else {
          res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
        }
      } catch (_8) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
    function setReplace(replace, val, k8, parent) {
      var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k8);
      if (propertyDescriptor.get !== void 0) {
        if (propertyDescriptor.configurable) {
          Object.defineProperty(parent, k8, { value: replace });
          arr.push([parent, k8, val, propertyDescriptor]);
        } else {
          replacerStack.push([val, k8, replace]);
        }
      } else {
        parent[k8] = replace;
        arr.push([parent, k8, val]);
      }
    }
    function decirc(val, k8, edgeIndex, stack, parent, depth, options) {
      depth += 1;
      var i6;
      if (typeof val === "object" && val !== null) {
        for (i6 = 0; i6 < stack.length; i6++) {
          if (stack[i6] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k8, parent);
            return;
          }
        }
        if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k8, parent);
          return;
        }
        if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k8, parent);
          return;
        }
        stack.push(val);
        if (Array.isArray(val)) {
          for (i6 = 0; i6 < val.length; i6++) {
            decirc(val[i6], i6, i6, stack, val, depth, options);
          }
        } else {
          var keys = Object.keys(val);
          for (i6 = 0; i6 < keys.length; i6++) {
            var key2 = keys[i6];
            decirc(val[key2], key2, i6, stack, val, depth, options);
          }
        }
        stack.pop();
      }
    }
    function compareFunction(a5, b4) {
      if (a5 < b4) {
        return -1;
      }
      if (a5 > b4) {
        return 1;
      }
      return 0;
    }
    function deterministicStringify(obj, replacer, spacer, options) {
      if (typeof options === "undefined") {
        options = defaultOptions();
      }
      var tmp = deterministicDecirc(obj, "", 0, [], void 0, 0, options) || obj;
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(tmp, replacer, spacer);
        } else {
          res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);
        }
      } catch (_8) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
    function deterministicDecirc(val, k8, edgeIndex, stack, parent, depth, options) {
      depth += 1;
      var i6;
      if (typeof val === "object" && val !== null) {
        for (i6 = 0; i6 < stack.length; i6++) {
          if (stack[i6] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k8, parent);
            return;
          }
        }
        try {
          if (typeof val.toJSON === "function") {
            return;
          }
        } catch (_8) {
          return;
        }
        if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k8, parent);
          return;
        }
        if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k8, parent);
          return;
        }
        stack.push(val);
        if (Array.isArray(val)) {
          for (i6 = 0; i6 < val.length; i6++) {
            deterministicDecirc(val[i6], i6, i6, stack, val, depth, options);
          }
        } else {
          var tmp = {};
          var keys = Object.keys(val).sort(compareFunction);
          for (i6 = 0; i6 < keys.length; i6++) {
            var key2 = keys[i6];
            deterministicDecirc(val[key2], key2, i6, stack, val, depth, options);
            tmp[key2] = val[key2];
          }
          if (typeof parent !== "undefined") {
            arr.push([parent, k8, val]);
            parent[k8] = tmp;
          } else {
            return tmp;
          }
        }
        stack.pop();
      }
    }
    function replaceGetterValues(replacer) {
      replacer = typeof replacer !== "undefined" ? replacer : function(k8, v9) {
        return v9;
      };
      return function(key2, val) {
        if (replacerStack.length > 0) {
          for (var i6 = 0; i6 < replacerStack.length; i6++) {
            var part = replacerStack[i6];
            if (part[1] === key2 && part[0] === val) {
              val = part[2];
              replacerStack.splice(i6, 1);
              break;
            }
          }
        }
        return replacer.call(this, key2, val);
      };
    }
  }
});

// node_modules/eth-rpc-errors/dist/classes.js
var require_classes = __commonJS({
  "node_modules/eth-rpc-errors/dist/classes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EthereumProviderError = exports2.EthereumRpcError = void 0;
    var fast_safe_stringify_1 = require_fast_safe_stringify();
    var EthereumRpcError = class extends Error {
      constructor(code, message, data) {
        if (!Number.isInteger(code)) {
          throw new Error('"code" must be an integer.');
        }
        if (!message || typeof message !== "string") {
          throw new Error('"message" must be a nonempty string.');
        }
        super(message);
        this.code = code;
        if (data !== void 0) {
          this.data = data;
        }
      }
      serialize() {
        const serialized = {
          code: this.code,
          message: this.message
        };
        if (this.data !== void 0) {
          serialized.data = this.data;
        }
        if (this.stack) {
          serialized.stack = this.stack;
        }
        return serialized;
      }
      toString() {
        return fast_safe_stringify_1.default(this.serialize(), stringifyReplacer, 2);
      }
    };
    exports2.EthereumRpcError = EthereumRpcError;
    var EthereumProviderError = class extends EthereumRpcError {
      constructor(code, message, data) {
        if (!isValidEthProviderCode(code)) {
          throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
        }
        super(code, message, data);
      }
    };
    exports2.EthereumProviderError = EthereumProviderError;
    function isValidEthProviderCode(code) {
      return Number.isInteger(code) && code >= 1e3 && code <= 4999;
    }
    function stringifyReplacer(_8, value2) {
      if (value2 === "[Circular]") {
        return void 0;
      }
      return value2;
    }
  }
});

// node_modules/eth-rpc-errors/dist/error-constants.js
var require_error_constants = __commonJS({
  "node_modules/eth-rpc-errors/dist/error-constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.errorValues = exports2.errorCodes = void 0;
    exports2.errorCodes = {
      rpc: {
        invalidInput: -32e3,
        resourceNotFound: -32001,
        resourceUnavailable: -32002,
        transactionRejected: -32003,
        methodNotSupported: -32004,
        limitExceeded: -32005,
        parse: -32700,
        invalidRequest: -32600,
        methodNotFound: -32601,
        invalidParams: -32602,
        internal: -32603
      },
      provider: {
        userRejectedRequest: 4001,
        unauthorized: 4100,
        unsupportedMethod: 4200,
        disconnected: 4900,
        chainDisconnected: 4901
      }
    };
    exports2.errorValues = {
      "-32700": {
        standard: "JSON RPC 2.0",
        message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
      },
      "-32600": {
        standard: "JSON RPC 2.0",
        message: "The JSON sent is not a valid Request object."
      },
      "-32601": {
        standard: "JSON RPC 2.0",
        message: "The method does not exist / is not available."
      },
      "-32602": {
        standard: "JSON RPC 2.0",
        message: "Invalid method parameter(s)."
      },
      "-32603": {
        standard: "JSON RPC 2.0",
        message: "Internal JSON-RPC error."
      },
      "-32000": {
        standard: "EIP-1474",
        message: "Invalid input."
      },
      "-32001": {
        standard: "EIP-1474",
        message: "Resource not found."
      },
      "-32002": {
        standard: "EIP-1474",
        message: "Resource unavailable."
      },
      "-32003": {
        standard: "EIP-1474",
        message: "Transaction rejected."
      },
      "-32004": {
        standard: "EIP-1474",
        message: "Method not supported."
      },
      "-32005": {
        standard: "EIP-1474",
        message: "Request limit exceeded."
      },
      "4001": {
        standard: "EIP-1193",
        message: "User rejected the request."
      },
      "4100": {
        standard: "EIP-1193",
        message: "The requested account and/or method has not been authorized by the user."
      },
      "4200": {
        standard: "EIP-1193",
        message: "The requested method is not supported by this Ethereum provider."
      },
      "4900": {
        standard: "EIP-1193",
        message: "The provider is disconnected from all chains."
      },
      "4901": {
        standard: "EIP-1193",
        message: "The provider is disconnected from the specified chain."
      }
    };
  }
});

// node_modules/eth-rpc-errors/dist/utils.js
var require_utils3 = __commonJS({
  "node_modules/eth-rpc-errors/dist/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.serializeError = exports2.isValidCode = exports2.getMessageFromCode = exports2.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
    var error_constants_1 = require_error_constants();
    var classes_1 = require_classes();
    var FALLBACK_ERROR_CODE = error_constants_1.errorCodes.rpc.internal;
    var FALLBACK_MESSAGE = "Unspecified error message. This is a bug, please report it.";
    var FALLBACK_ERROR = {
      code: FALLBACK_ERROR_CODE,
      message: getMessageFromCode(FALLBACK_ERROR_CODE)
    };
    exports2.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
    function getMessageFromCode(code, fallbackMessage = FALLBACK_MESSAGE) {
      if (Number.isInteger(code)) {
        const codeString = code.toString();
        if (hasKey(error_constants_1.errorValues, codeString)) {
          return error_constants_1.errorValues[codeString].message;
        }
        if (isJsonRpcServerError(code)) {
          return exports2.JSON_RPC_SERVER_ERROR_MESSAGE;
        }
      }
      return fallbackMessage;
    }
    exports2.getMessageFromCode = getMessageFromCode;
    function isValidCode(code) {
      if (!Number.isInteger(code)) {
        return false;
      }
      const codeString = code.toString();
      if (error_constants_1.errorValues[codeString]) {
        return true;
      }
      if (isJsonRpcServerError(code)) {
        return true;
      }
      return false;
    }
    exports2.isValidCode = isValidCode;
    function serializeError(error, { fallbackError = FALLBACK_ERROR, shouldIncludeStack = false } = {}) {
      var _a2, _b;
      if (!fallbackError || !Number.isInteger(fallbackError.code) || typeof fallbackError.message !== "string") {
        throw new Error("Must provide fallback error with integer number code and string message.");
      }
      if (error instanceof classes_1.EthereumRpcError) {
        return error.serialize();
      }
      const serialized = {};
      if (error && typeof error === "object" && !Array.isArray(error) && hasKey(error, "code") && isValidCode(error.code)) {
        const _error = error;
        serialized.code = _error.code;
        if (_error.message && typeof _error.message === "string") {
          serialized.message = _error.message;
          if (hasKey(_error, "data")) {
            serialized.data = _error.data;
          }
        } else {
          serialized.message = getMessageFromCode(serialized.code);
          serialized.data = { originalError: assignOriginalError(error) };
        }
      } else {
        serialized.code = fallbackError.code;
        const message = (_a2 = error) === null || _a2 === void 0 ? void 0 : _a2.message;
        serialized.message = message && typeof message === "string" ? message : fallbackError.message;
        serialized.data = { originalError: assignOriginalError(error) };
      }
      const stack = (_b = error) === null || _b === void 0 ? void 0 : _b.stack;
      if (shouldIncludeStack && error && stack && typeof stack === "string") {
        serialized.stack = stack;
      }
      return serialized;
    }
    exports2.serializeError = serializeError;
    function isJsonRpcServerError(code) {
      return code >= -32099 && code <= -32e3;
    }
    function assignOriginalError(error) {
      if (error && typeof error === "object" && !Array.isArray(error)) {
        return Object.assign({}, error);
      }
      return error;
    }
    function hasKey(obj, key2) {
      return Object.prototype.hasOwnProperty.call(obj, key2);
    }
  }
});

// node_modules/eth-rpc-errors/dist/errors.js
var require_errors = __commonJS({
  "node_modules/eth-rpc-errors/dist/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ethErrors = void 0;
    var classes_1 = require_classes();
    var utils_12 = require_utils3();
    var error_constants_1 = require_error_constants();
    exports2.ethErrors = {
      rpc: {
        parse: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.parse, arg),
        invalidRequest: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidRequest, arg),
        invalidParams: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidParams, arg),
        methodNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotFound, arg),
        internal: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.internal, arg),
        server: (opts) => {
          if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
            throw new Error("Ethereum RPC Server errors must provide single object argument.");
          }
          const { code } = opts;
          if (!Number.isInteger(code) || code > -32005 || code < -32099) {
            throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
          }
          return getEthJsonRpcError(code, opts);
        },
        invalidInput: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidInput, arg),
        resourceNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceNotFound, arg),
        resourceUnavailable: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceUnavailable, arg),
        transactionRejected: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.transactionRejected, arg),
        methodNotSupported: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotSupported, arg),
        limitExceeded: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.limitExceeded, arg)
      },
      provider: {
        userRejectedRequest: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.userRejectedRequest, arg);
        },
        unauthorized: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.unauthorized, arg);
        },
        unsupportedMethod: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.unsupportedMethod, arg);
        },
        disconnected: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.disconnected, arg);
        },
        chainDisconnected: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.chainDisconnected, arg);
        },
        custom: (opts) => {
          if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
            throw new Error("Ethereum Provider custom errors must provide single object argument.");
          }
          const { code, message, data } = opts;
          if (!message || typeof message !== "string") {
            throw new Error('"message" must be a nonempty string');
          }
          return new classes_1.EthereumProviderError(code, message, data);
        }
      }
    };
    function getEthJsonRpcError(code, arg) {
      const [message, data] = parseOpts(arg);
      return new classes_1.EthereumRpcError(code, message || utils_12.getMessageFromCode(code), data);
    }
    function getEthProviderError(code, arg) {
      const [message, data] = parseOpts(arg);
      return new classes_1.EthereumProviderError(code, message || utils_12.getMessageFromCode(code), data);
    }
    function parseOpts(arg) {
      if (arg) {
        if (typeof arg === "string") {
          return [arg];
        } else if (typeof arg === "object" && !Array.isArray(arg)) {
          const { message, data } = arg;
          if (message && typeof message !== "string") {
            throw new Error("Must specify string message.");
          }
          return [message || void 0, data];
        }
      }
      return [];
    }
  }
});

// node_modules/eth-rpc-errors/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/eth-rpc-errors/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getMessageFromCode = exports2.serializeError = exports2.EthereumProviderError = exports2.EthereumRpcError = exports2.ethErrors = exports2.errorCodes = void 0;
    var classes_1 = require_classes();
    Object.defineProperty(exports2, "EthereumRpcError", { enumerable: true, get: function() {
      return classes_1.EthereumRpcError;
    } });
    Object.defineProperty(exports2, "EthereumProviderError", { enumerable: true, get: function() {
      return classes_1.EthereumProviderError;
    } });
    var utils_12 = require_utils3();
    Object.defineProperty(exports2, "serializeError", { enumerable: true, get: function() {
      return utils_12.serializeError;
    } });
    Object.defineProperty(exports2, "getMessageFromCode", { enumerable: true, get: function() {
      return utils_12.getMessageFromCode;
    } });
    var errors_1 = require_errors();
    Object.defineProperty(exports2, "ethErrors", { enumerable: true, get: function() {
      return errors_1.ethErrors;
    } });
    var error_constants_1 = require_error_constants();
    Object.defineProperty(exports2, "errorCodes", { enumerable: true, get: function() {
      return error_constants_1.errorCodes;
    } });
  }
});

// node_modules/@coinbase/wallet-sdk/dist/connection/EventListener.js
var require_EventListener = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/connection/EventListener.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EVENTS = void 0;
    exports2.EVENTS = {
      STARTED_CONNECTING: "walletlink_sdk.started.connecting",
      CONNECTED_STATE_CHANGE: "walletlink_sdk.connected",
      DISCONNECTED: "walletlink_sdk.disconnected",
      METADATA_DESTROYED: "walletlink_sdk_metadata_destroyed",
      LINKED: "walletlink_sdk.linked",
      FAILURE: "walletlink_sdk.generic_failure",
      SESSION_CONFIG_RECEIVED: "walletlink_sdk.session_config_event_received",
      ETH_ACCOUNTS_STATE: "walletlink_sdk.eth_accounts_state",
      SESSION_STATE_CHANGE: "walletlink_sdk.session_state_change",
      UNLINKED_ERROR_STATE: "walletlink_sdk.unlinked_error_state",
      SKIPPED_CLEARING_SESSION: "walletlink_sdk.skipped_clearing_session",
      GENERAL_ERROR: "walletlink_sdk.general_error",
      WEB3_REQUEST: "walletlink_sdk.web3.request",
      WEB3_REQUEST_PUBLISHED: "walletlink_sdk.web3.request_published",
      WEB3_RESPONSE: "walletlink_sdk.web3.response",
      UNKNOWN_ADDRESS_ENCOUNTERED: "walletlink_sdk.unknown_address_encountered"
    };
  }
});

// node_modules/js-sha256/src/sha256.js
var require_sha2562 = __commonJS({
  "node_modules/js-sha256/src/sha256.js"(exports, module) {
    (function() {
      "use strict";
      var ERROR = "input is invalid type";
      var WINDOW = typeof window === "object";
      var root = WINDOW ? window : {};
      if (root.JS_SHA256_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = global;
      } else if (WEB_WORKER) {
        root = self;
      }
      var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && typeof module === "object" && module.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var EXTRA = [-2147483648, 8388608, 32768, 128];
      var SHIFT = [24, 16, 8, 0];
      var K = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ];
      var OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"];
      var blocks = [];
      if (root.JS_SHA256_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      if (ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var createOutputMethod = function(outputType, is2242) {
        return function(message) {
          return new Sha256(is2242, true).update(message)[outputType]();
        };
      };
      var createMethod = function(is2242) {
        var method2 = createOutputMethod("hex", is2242);
        if (NODE_JS) {
          method2 = nodeWrap(method2, is2242);
        }
        method2.create = function() {
          return new Sha256(is2242);
        };
        method2.update = function(message) {
          return method2.create().update(message);
        };
        for (var i6 = 0; i6 < OUTPUT_TYPES.length; ++i6) {
          var type = OUTPUT_TYPES[i6];
          method2[type] = createOutputMethod(type, is2242);
        }
        return method2;
      };
      var nodeWrap = function(method, is224) {
        var crypto = eval("require('crypto')");
        var Buffer = eval("require('buffer').Buffer");
        var algorithm = is224 ? "sha224" : "sha256";
        var nodeMethod = function(message) {
          if (typeof message === "string") {
            return crypto.createHash(algorithm).update(message, "utf8").digest("hex");
          } else {
            if (message === null || message === void 0) {
              throw new Error(ERROR);
            } else if (message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            }
          }
          if (Array.isArray(message) || ArrayBuffer.isView(message) || message.constructor === Buffer) {
            return crypto.createHash(algorithm).update(new Buffer(message)).digest("hex");
          } else {
            return method(message);
          }
        };
        return nodeMethod;
      };
      var createHmacOutputMethod = function(outputType, is2242) {
        return function(key2, message) {
          return new HmacSha256(key2, is2242, true).update(message)[outputType]();
        };
      };
      var createHmacMethod = function(is2242) {
        var method2 = createHmacOutputMethod("hex", is2242);
        method2.create = function(key2) {
          return new HmacSha256(key2, is2242);
        };
        method2.update = function(key2, message) {
          return method2.create(key2).update(message);
        };
        for (var i6 = 0; i6 < OUTPUT_TYPES.length; ++i6) {
          var type = OUTPUT_TYPES[i6];
          method2[type] = createHmacOutputMethod(type, is2242);
        }
        return method2;
      };
      function Sha256(is2242, sharedMemory) {
        if (sharedMemory) {
          blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
          this.blocks = blocks;
        } else {
          this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        }
        if (is2242) {
          this.h0 = 3238371032;
          this.h1 = 914150663;
          this.h2 = 812702999;
          this.h3 = 4144912697;
          this.h4 = 4290775857;
          this.h5 = 1750603025;
          this.h6 = 1694076839;
          this.h7 = 3204075428;
        } else {
          this.h0 = 1779033703;
          this.h1 = 3144134277;
          this.h2 = 1013904242;
          this.h3 = 2773480762;
          this.h4 = 1359893119;
          this.h5 = 2600822924;
          this.h6 = 528734635;
          this.h7 = 1541459225;
        }
        this.block = this.start = this.bytes = this.hBytes = 0;
        this.finalized = this.hashed = false;
        this.first = true;
        this.is224 = is2242;
      }
      Sha256.prototype.update = function(message) {
        if (this.finalized) {
          return;
        }
        var notString, type = typeof message;
        if (type !== "string") {
          if (type === "object") {
            if (message === null) {
              throw new Error(ERROR);
            } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            } else if (!Array.isArray(message)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                throw new Error(ERROR);
              }
            }
          } else {
            throw new Error(ERROR);
          }
          notString = true;
        }
        var code, index = 0, i6, length = message.length, blocks2 = this.blocks;
        while (index < length) {
          if (this.hashed) {
            this.hashed = false;
            blocks2[0] = this.block;
            blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
          }
          if (notString) {
            for (i6 = this.start; index < length && i6 < 64; ++index) {
              blocks2[i6 >> 2] |= message[index] << SHIFT[i6++ & 3];
            }
          } else {
            for (i6 = this.start; index < length && i6 < 64; ++index) {
              code = message.charCodeAt(index);
              if (code < 128) {
                blocks2[i6 >> 2] |= code << SHIFT[i6++ & 3];
              } else if (code < 2048) {
                blocks2[i6 >> 2] |= (192 | code >> 6) << SHIFT[i6++ & 3];
                blocks2[i6 >> 2] |= (128 | code & 63) << SHIFT[i6++ & 3];
              } else if (code < 55296 || code >= 57344) {
                blocks2[i6 >> 2] |= (224 | code >> 12) << SHIFT[i6++ & 3];
                blocks2[i6 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i6++ & 3];
                blocks2[i6 >> 2] |= (128 | code & 63) << SHIFT[i6++ & 3];
              } else {
                code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                blocks2[i6 >> 2] |= (240 | code >> 18) << SHIFT[i6++ & 3];
                blocks2[i6 >> 2] |= (128 | code >> 12 & 63) << SHIFT[i6++ & 3];
                blocks2[i6 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i6++ & 3];
                blocks2[i6 >> 2] |= (128 | code & 63) << SHIFT[i6++ & 3];
              }
            }
          }
          this.lastByteIndex = i6;
          this.bytes += i6 - this.start;
          if (i6 >= 64) {
            this.block = blocks2[16];
            this.start = i6 - 64;
            this.hash();
            this.hashed = true;
          } else {
            this.start = i6;
          }
        }
        if (this.bytes > 4294967295) {
          this.hBytes += this.bytes / 4294967296 << 0;
          this.bytes = this.bytes % 4294967296;
        }
        return this;
      };
      Sha256.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks2 = this.blocks, i6 = this.lastByteIndex;
        blocks2[16] = this.block;
        blocks2[i6 >> 2] |= EXTRA[i6 & 3];
        this.block = blocks2[16];
        if (i6 >= 56) {
          if (!this.hashed) {
            this.hash();
          }
          blocks2[0] = this.block;
          blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
        }
        blocks2[14] = this.hBytes << 3 | this.bytes >>> 29;
        blocks2[15] = this.bytes << 3;
        this.hash();
      };
      Sha256.prototype.hash = function() {
        var a5 = this.h0, b4 = this.h1, c5 = this.h2, d6 = this.h3, e6 = this.h4, f7 = this.h5, g7 = this.h6, h6 = this.h7, blocks2 = this.blocks, j8, s02, s1, maj, t12, t22, ch, ab, da2, cd, bc;
        for (j8 = 16; j8 < 64; ++j8) {
          t12 = blocks2[j8 - 15];
          s02 = (t12 >>> 7 | t12 << 25) ^ (t12 >>> 18 | t12 << 14) ^ t12 >>> 3;
          t12 = blocks2[j8 - 2];
          s1 = (t12 >>> 17 | t12 << 15) ^ (t12 >>> 19 | t12 << 13) ^ t12 >>> 10;
          blocks2[j8] = blocks2[j8 - 16] + s02 + blocks2[j8 - 7] + s1 << 0;
        }
        bc = b4 & c5;
        for (j8 = 0; j8 < 64; j8 += 4) {
          if (this.first) {
            if (this.is224) {
              ab = 300032;
              t12 = blocks2[0] - 1413257819;
              h6 = t12 - 150054599 << 0;
              d6 = t12 + 24177077 << 0;
            } else {
              ab = 704751109;
              t12 = blocks2[0] - 210244248;
              h6 = t12 - 1521486534 << 0;
              d6 = t12 + 143694565 << 0;
            }
            this.first = false;
          } else {
            s02 = (a5 >>> 2 | a5 << 30) ^ (a5 >>> 13 | a5 << 19) ^ (a5 >>> 22 | a5 << 10);
            s1 = (e6 >>> 6 | e6 << 26) ^ (e6 >>> 11 | e6 << 21) ^ (e6 >>> 25 | e6 << 7);
            ab = a5 & b4;
            maj = ab ^ a5 & c5 ^ bc;
            ch = e6 & f7 ^ ~e6 & g7;
            t12 = h6 + s1 + ch + K[j8] + blocks2[j8];
            t22 = s02 + maj;
            h6 = d6 + t12 << 0;
            d6 = t12 + t22 << 0;
          }
          s02 = (d6 >>> 2 | d6 << 30) ^ (d6 >>> 13 | d6 << 19) ^ (d6 >>> 22 | d6 << 10);
          s1 = (h6 >>> 6 | h6 << 26) ^ (h6 >>> 11 | h6 << 21) ^ (h6 >>> 25 | h6 << 7);
          da2 = d6 & a5;
          maj = da2 ^ d6 & b4 ^ ab;
          ch = h6 & e6 ^ ~h6 & f7;
          t12 = g7 + s1 + ch + K[j8 + 1] + blocks2[j8 + 1];
          t22 = s02 + maj;
          g7 = c5 + t12 << 0;
          c5 = t12 + t22 << 0;
          s02 = (c5 >>> 2 | c5 << 30) ^ (c5 >>> 13 | c5 << 19) ^ (c5 >>> 22 | c5 << 10);
          s1 = (g7 >>> 6 | g7 << 26) ^ (g7 >>> 11 | g7 << 21) ^ (g7 >>> 25 | g7 << 7);
          cd = c5 & d6;
          maj = cd ^ c5 & a5 ^ da2;
          ch = g7 & h6 ^ ~g7 & e6;
          t12 = f7 + s1 + ch + K[j8 + 2] + blocks2[j8 + 2];
          t22 = s02 + maj;
          f7 = b4 + t12 << 0;
          b4 = t12 + t22 << 0;
          s02 = (b4 >>> 2 | b4 << 30) ^ (b4 >>> 13 | b4 << 19) ^ (b4 >>> 22 | b4 << 10);
          s1 = (f7 >>> 6 | f7 << 26) ^ (f7 >>> 11 | f7 << 21) ^ (f7 >>> 25 | f7 << 7);
          bc = b4 & c5;
          maj = bc ^ b4 & d6 ^ cd;
          ch = f7 & g7 ^ ~f7 & h6;
          t12 = e6 + s1 + ch + K[j8 + 3] + blocks2[j8 + 3];
          t22 = s02 + maj;
          e6 = a5 + t12 << 0;
          a5 = t12 + t22 << 0;
        }
        this.h0 = this.h0 + a5 << 0;
        this.h1 = this.h1 + b4 << 0;
        this.h2 = this.h2 + c5 << 0;
        this.h3 = this.h3 + d6 << 0;
        this.h4 = this.h4 + e6 << 0;
        this.h5 = this.h5 + f7 << 0;
        this.h6 = this.h6 + g7 << 0;
        this.h7 = this.h7 + h6 << 0;
      };
      Sha256.prototype.hex = function() {
        this.finalize();
        var h0 = this.h0, h1 = this.h1, h22 = this.h2, h32 = this.h3, h42 = this.h4, h52 = this.h5, h6 = this.h6, h7 = this.h7;
        var hex = HEX_CHARS[h0 >> 28 & 15] + HEX_CHARS[h0 >> 24 & 15] + HEX_CHARS[h0 >> 20 & 15] + HEX_CHARS[h0 >> 16 & 15] + HEX_CHARS[h0 >> 12 & 15] + HEX_CHARS[h0 >> 8 & 15] + HEX_CHARS[h0 >> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h1 >> 28 & 15] + HEX_CHARS[h1 >> 24 & 15] + HEX_CHARS[h1 >> 20 & 15] + HEX_CHARS[h1 >> 16 & 15] + HEX_CHARS[h1 >> 12 & 15] + HEX_CHARS[h1 >> 8 & 15] + HEX_CHARS[h1 >> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h22 >> 28 & 15] + HEX_CHARS[h22 >> 24 & 15] + HEX_CHARS[h22 >> 20 & 15] + HEX_CHARS[h22 >> 16 & 15] + HEX_CHARS[h22 >> 12 & 15] + HEX_CHARS[h22 >> 8 & 15] + HEX_CHARS[h22 >> 4 & 15] + HEX_CHARS[h22 & 15] + HEX_CHARS[h32 >> 28 & 15] + HEX_CHARS[h32 >> 24 & 15] + HEX_CHARS[h32 >> 20 & 15] + HEX_CHARS[h32 >> 16 & 15] + HEX_CHARS[h32 >> 12 & 15] + HEX_CHARS[h32 >> 8 & 15] + HEX_CHARS[h32 >> 4 & 15] + HEX_CHARS[h32 & 15] + HEX_CHARS[h42 >> 28 & 15] + HEX_CHARS[h42 >> 24 & 15] + HEX_CHARS[h42 >> 20 & 15] + HEX_CHARS[h42 >> 16 & 15] + HEX_CHARS[h42 >> 12 & 15] + HEX_CHARS[h42 >> 8 & 15] + HEX_CHARS[h42 >> 4 & 15] + HEX_CHARS[h42 & 15] + HEX_CHARS[h52 >> 28 & 15] + HEX_CHARS[h52 >> 24 & 15] + HEX_CHARS[h52 >> 20 & 15] + HEX_CHARS[h52 >> 16 & 15] + HEX_CHARS[h52 >> 12 & 15] + HEX_CHARS[h52 >> 8 & 15] + HEX_CHARS[h52 >> 4 & 15] + HEX_CHARS[h52 & 15] + HEX_CHARS[h6 >> 28 & 15] + HEX_CHARS[h6 >> 24 & 15] + HEX_CHARS[h6 >> 20 & 15] + HEX_CHARS[h6 >> 16 & 15] + HEX_CHARS[h6 >> 12 & 15] + HEX_CHARS[h6 >> 8 & 15] + HEX_CHARS[h6 >> 4 & 15] + HEX_CHARS[h6 & 15];
        if (!this.is224) {
          hex += HEX_CHARS[h7 >> 28 & 15] + HEX_CHARS[h7 >> 24 & 15] + HEX_CHARS[h7 >> 20 & 15] + HEX_CHARS[h7 >> 16 & 15] + HEX_CHARS[h7 >> 12 & 15] + HEX_CHARS[h7 >> 8 & 15] + HEX_CHARS[h7 >> 4 & 15] + HEX_CHARS[h7 & 15];
        }
        return hex;
      };
      Sha256.prototype.toString = Sha256.prototype.hex;
      Sha256.prototype.digest = function() {
        this.finalize();
        var h0 = this.h0, h1 = this.h1, h22 = this.h2, h32 = this.h3, h42 = this.h4, h52 = this.h5, h6 = this.h6, h7 = this.h7;
        var arr = [
          h0 >> 24 & 255,
          h0 >> 16 & 255,
          h0 >> 8 & 255,
          h0 & 255,
          h1 >> 24 & 255,
          h1 >> 16 & 255,
          h1 >> 8 & 255,
          h1 & 255,
          h22 >> 24 & 255,
          h22 >> 16 & 255,
          h22 >> 8 & 255,
          h22 & 255,
          h32 >> 24 & 255,
          h32 >> 16 & 255,
          h32 >> 8 & 255,
          h32 & 255,
          h42 >> 24 & 255,
          h42 >> 16 & 255,
          h42 >> 8 & 255,
          h42 & 255,
          h52 >> 24 & 255,
          h52 >> 16 & 255,
          h52 >> 8 & 255,
          h52 & 255,
          h6 >> 24 & 255,
          h6 >> 16 & 255,
          h6 >> 8 & 255,
          h6 & 255
        ];
        if (!this.is224) {
          arr.push(h7 >> 24 & 255, h7 >> 16 & 255, h7 >> 8 & 255, h7 & 255);
        }
        return arr;
      };
      Sha256.prototype.array = Sha256.prototype.digest;
      Sha256.prototype.arrayBuffer = function() {
        this.finalize();
        var buffer2 = new ArrayBuffer(this.is224 ? 28 : 32);
        var dataView = new DataView(buffer2);
        dataView.setUint32(0, this.h0);
        dataView.setUint32(4, this.h1);
        dataView.setUint32(8, this.h2);
        dataView.setUint32(12, this.h3);
        dataView.setUint32(16, this.h4);
        dataView.setUint32(20, this.h5);
        dataView.setUint32(24, this.h6);
        if (!this.is224) {
          dataView.setUint32(28, this.h7);
        }
        return buffer2;
      };
      function HmacSha256(key2, is2242, sharedMemory) {
        var i6, type = typeof key2;
        if (type === "string") {
          var bytes = [], length = key2.length, index = 0, code;
          for (i6 = 0; i6 < length; ++i6) {
            code = key2.charCodeAt(i6);
            if (code < 128) {
              bytes[index++] = code;
            } else if (code < 2048) {
              bytes[index++] = 192 | code >> 6;
              bytes[index++] = 128 | code & 63;
            } else if (code < 55296 || code >= 57344) {
              bytes[index++] = 224 | code >> 12;
              bytes[index++] = 128 | code >> 6 & 63;
              bytes[index++] = 128 | code & 63;
            } else {
              code = 65536 + ((code & 1023) << 10 | key2.charCodeAt(++i6) & 1023);
              bytes[index++] = 240 | code >> 18;
              bytes[index++] = 128 | code >> 12 & 63;
              bytes[index++] = 128 | code >> 6 & 63;
              bytes[index++] = 128 | code & 63;
            }
          }
          key2 = bytes;
        } else {
          if (type === "object") {
            if (key2 === null) {
              throw new Error(ERROR);
            } else if (ARRAY_BUFFER && key2.constructor === ArrayBuffer) {
              key2 = new Uint8Array(key2);
            } else if (!Array.isArray(key2)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(key2)) {
                throw new Error(ERROR);
              }
            }
          } else {
            throw new Error(ERROR);
          }
        }
        if (key2.length > 64) {
          key2 = new Sha256(is2242, true).update(key2).array();
        }
        var oKeyPad = [], iKeyPad = [];
        for (i6 = 0; i6 < 64; ++i6) {
          var b4 = key2[i6] || 0;
          oKeyPad[i6] = 92 ^ b4;
          iKeyPad[i6] = 54 ^ b4;
        }
        Sha256.call(this, is2242, sharedMemory);
        this.update(iKeyPad);
        this.oKeyPad = oKeyPad;
        this.inner = true;
        this.sharedMemory = sharedMemory;
      }
      HmacSha256.prototype = new Sha256();
      HmacSha256.prototype.finalize = function() {
        Sha256.prototype.finalize.call(this);
        if (this.inner) {
          this.inner = false;
          var innerHash = this.array();
          Sha256.call(this, this.is224, this.sharedMemory);
          this.update(this.oKeyPad);
          this.update(innerHash);
          Sha256.prototype.finalize.call(this);
        }
      };
      var exports = createMethod();
      exports.sha256 = exports;
      exports.sha224 = createMethod(true);
      exports.sha256.hmac = createHmacMethod();
      exports.sha224.hmac = createHmacMethod(true);
      if (COMMON_JS) {
        module.exports = exports;
      } else {
        root.sha256 = exports.sha256;
        root.sha224 = exports.sha224;
        if (AMD) {
          define(function() {
            return exports;
          });
        }
      }
    })();
  }
});

// node_modules/rxjs/node_modules/tslib/tslib.es6.js
function __extends(d6, b4) {
  extendStatics(d6, b4);
  function __() {
    this.constructor = d6;
  }
  d6.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
}
var extendStatics;
var init_tslib_es6 = __esm({
  "node_modules/rxjs/node_modules/tslib/tslib.es6.js"() {
    extendStatics = function(d6, b4) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d7, b5) {
        d7.__proto__ = b5;
      } || function(d7, b5) {
        for (var p7 in b5)
          if (b5.hasOwnProperty(p7))
            d7[p7] = b5[p7];
      };
      return extendStatics(d6, b4);
    };
  }
});

// node_modules/rxjs/_esm5/internal/util/isFunction.js
function isFunction(x6) {
  return typeof x6 === "function";
}
var init_isFunction = __esm({
  "node_modules/rxjs/_esm5/internal/util/isFunction.js"() {
  }
});

// node_modules/rxjs/_esm5/internal/config.js
var _enable_super_gross_mode_that_will_cause_bad_things, config;
var init_config = __esm({
  "node_modules/rxjs/_esm5/internal/config.js"() {
    _enable_super_gross_mode_that_will_cause_bad_things = false;
    config = {
      Promise: void 0,
      set useDeprecatedSynchronousErrorHandling(value2) {
        if (value2) {
          var error = new Error();
          console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n" + error.stack);
        } else if (_enable_super_gross_mode_that_will_cause_bad_things) {
          console.log("RxJS: Back to a better error behavior. Thank you. <3");
        }
        _enable_super_gross_mode_that_will_cause_bad_things = value2;
      },
      get useDeprecatedSynchronousErrorHandling() {
        return _enable_super_gross_mode_that_will_cause_bad_things;
      }
    };
  }
});

// node_modules/rxjs/_esm5/internal/util/hostReportError.js
function hostReportError(err) {
  setTimeout(function() {
    throw err;
  }, 0);
}
var init_hostReportError = __esm({
  "node_modules/rxjs/_esm5/internal/util/hostReportError.js"() {
  }
});

// node_modules/rxjs/_esm5/internal/Observer.js
var empty;
var init_Observer = __esm({
  "node_modules/rxjs/_esm5/internal/Observer.js"() {
    init_config();
    init_hostReportError();
    empty = {
      closed: true,
      next: function(value2) {
      },
      error: function(err) {
        if (config.useDeprecatedSynchronousErrorHandling) {
          throw err;
        } else {
          hostReportError(err);
        }
      },
      complete: function() {
      }
    };
  }
});

// node_modules/rxjs/_esm5/internal/util/isArray.js
var isArray;
var init_isArray = __esm({
  "node_modules/rxjs/_esm5/internal/util/isArray.js"() {
    isArray = function() {
      return Array.isArray || function(x6) {
        return x6 && typeof x6.length === "number";
      };
    }();
  }
});

// node_modules/rxjs/_esm5/internal/util/isObject.js
function isObject(x6) {
  return x6 !== null && typeof x6 === "object";
}
var init_isObject = __esm({
  "node_modules/rxjs/_esm5/internal/util/isObject.js"() {
  }
});

// node_modules/rxjs/_esm5/internal/util/UnsubscriptionError.js
var UnsubscriptionErrorImpl, UnsubscriptionError;
var init_UnsubscriptionError = __esm({
  "node_modules/rxjs/_esm5/internal/util/UnsubscriptionError.js"() {
    UnsubscriptionErrorImpl = function() {
      function UnsubscriptionErrorImpl2(errors) {
        Error.call(this);
        this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i6) {
          return i6 + 1 + ") " + err.toString();
        }).join("\n  ") : "";
        this.name = "UnsubscriptionError";
        this.errors = errors;
        return this;
      }
      UnsubscriptionErrorImpl2.prototype = Object.create(Error.prototype);
      return UnsubscriptionErrorImpl2;
    }();
    UnsubscriptionError = UnsubscriptionErrorImpl;
  }
});

// node_modules/rxjs/_esm5/internal/Subscription.js
function flattenUnsubscriptionErrors(errors) {
  return errors.reduce(function(errs, err) {
    return errs.concat(err instanceof UnsubscriptionError ? err.errors : err);
  }, []);
}
var Subscription;
var init_Subscription = __esm({
  "node_modules/rxjs/_esm5/internal/Subscription.js"() {
    init_isArray();
    init_isObject();
    init_isFunction();
    init_UnsubscriptionError();
    Subscription = function() {
      function Subscription2(unsubscribe) {
        this.closed = false;
        this._parentOrParents = null;
        this._subscriptions = null;
        if (unsubscribe) {
          this._ctorUnsubscribe = true;
          this._unsubscribe = unsubscribe;
        }
      }
      Subscription2.prototype.unsubscribe = function() {
        var errors;
        if (this.closed) {
          return;
        }
        var _a2 = this, _parentOrParents = _a2._parentOrParents, _ctorUnsubscribe = _a2._ctorUnsubscribe, _unsubscribe = _a2._unsubscribe, _subscriptions = _a2._subscriptions;
        this.closed = true;
        this._parentOrParents = null;
        this._subscriptions = null;
        if (_parentOrParents instanceof Subscription2) {
          _parentOrParents.remove(this);
        } else if (_parentOrParents !== null) {
          for (var index = 0; index < _parentOrParents.length; ++index) {
            var parent_1 = _parentOrParents[index];
            parent_1.remove(this);
          }
        }
        if (isFunction(_unsubscribe)) {
          if (_ctorUnsubscribe) {
            this._unsubscribe = void 0;
          }
          try {
            _unsubscribe.call(this);
          } catch (e6) {
            errors = e6 instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e6.errors) : [e6];
          }
        }
        if (isArray(_subscriptions)) {
          var index = -1;
          var len = _subscriptions.length;
          while (++index < len) {
            var sub = _subscriptions[index];
            if (isObject(sub)) {
              try {
                sub.unsubscribe();
              } catch (e6) {
                errors = errors || [];
                if (e6 instanceof UnsubscriptionError) {
                  errors = errors.concat(flattenUnsubscriptionErrors(e6.errors));
                } else {
                  errors.push(e6);
                }
              }
            }
          }
        }
        if (errors) {
          throw new UnsubscriptionError(errors);
        }
      };
      Subscription2.prototype.add = function(teardown) {
        var subscription = teardown;
        if (!teardown) {
          return Subscription2.EMPTY;
        }
        switch (typeof teardown) {
          case "function":
            subscription = new Subscription2(teardown);
          case "object":
            if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== "function") {
              return subscription;
            } else if (this.closed) {
              subscription.unsubscribe();
              return subscription;
            } else if (!(subscription instanceof Subscription2)) {
              var tmp = subscription;
              subscription = new Subscription2();
              subscription._subscriptions = [tmp];
            }
            break;
          default: {
            throw new Error("unrecognized teardown " + teardown + " added to Subscription.");
          }
        }
        var _parentOrParents = subscription._parentOrParents;
        if (_parentOrParents === null) {
          subscription._parentOrParents = this;
        } else if (_parentOrParents instanceof Subscription2) {
          if (_parentOrParents === this) {
            return subscription;
          }
          subscription._parentOrParents = [_parentOrParents, this];
        } else if (_parentOrParents.indexOf(this) === -1) {
          _parentOrParents.push(this);
        } else {
          return subscription;
        }
        var subscriptions = this._subscriptions;
        if (subscriptions === null) {
          this._subscriptions = [subscription];
        } else {
          subscriptions.push(subscription);
        }
        return subscription;
      };
      Subscription2.prototype.remove = function(subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
          var subscriptionIndex = subscriptions.indexOf(subscription);
          if (subscriptionIndex !== -1) {
            subscriptions.splice(subscriptionIndex, 1);
          }
        }
      };
      Subscription2.EMPTY = function(empty3) {
        empty3.closed = true;
        return empty3;
      }(new Subscription2());
      return Subscription2;
    }();
  }
});

// node_modules/rxjs/_esm5/internal/symbol/rxSubscriber.js
var rxSubscriber;
var init_rxSubscriber = __esm({
  "node_modules/rxjs/_esm5/internal/symbol/rxSubscriber.js"() {
    rxSubscriber = function() {
      return typeof Symbol === "function" ? Symbol("rxSubscriber") : "@@rxSubscriber_" + Math.random();
    }();
  }
});

// node_modules/rxjs/_esm5/internal/Subscriber.js
var Subscriber, SafeSubscriber;
var init_Subscriber = __esm({
  "node_modules/rxjs/_esm5/internal/Subscriber.js"() {
    init_tslib_es6();
    init_isFunction();
    init_Observer();
    init_Subscription();
    init_rxSubscriber();
    init_config();
    init_hostReportError();
    Subscriber = function(_super) {
      __extends(Subscriber2, _super);
      function Subscriber2(destinationOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this.syncErrorValue = null;
        _this.syncErrorThrown = false;
        _this.syncErrorThrowable = false;
        _this.isStopped = false;
        switch (arguments.length) {
          case 0:
            _this.destination = empty;
            break;
          case 1:
            if (!destinationOrNext) {
              _this.destination = empty;
              break;
            }
            if (typeof destinationOrNext === "object") {
              if (destinationOrNext instanceof Subscriber2) {
                _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
                _this.destination = destinationOrNext;
                destinationOrNext.add(_this);
              } else {
                _this.syncErrorThrowable = true;
                _this.destination = new SafeSubscriber(_this, destinationOrNext);
              }
              break;
            }
          default:
            _this.syncErrorThrowable = true;
            _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
            break;
        }
        return _this;
      }
      Subscriber2.prototype[rxSubscriber] = function() {
        return this;
      };
      Subscriber2.create = function(next, error, complete) {
        var subscriber = new Subscriber2(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
      };
      Subscriber2.prototype.next = function(value2) {
        if (!this.isStopped) {
          this._next(value2);
        }
      };
      Subscriber2.prototype.error = function(err) {
        if (!this.isStopped) {
          this.isStopped = true;
          this._error(err);
        }
      };
      Subscriber2.prototype.complete = function() {
        if (!this.isStopped) {
          this.isStopped = true;
          this._complete();
        }
      };
      Subscriber2.prototype.unsubscribe = function() {
        if (this.closed) {
          return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
      };
      Subscriber2.prototype._next = function(value2) {
        this.destination.next(value2);
      };
      Subscriber2.prototype._error = function(err) {
        this.destination.error(err);
        this.unsubscribe();
      };
      Subscriber2.prototype._complete = function() {
        this.destination.complete();
        this.unsubscribe();
      };
      Subscriber2.prototype._unsubscribeAndRecycle = function() {
        var _parentOrParents = this._parentOrParents;
        this._parentOrParents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parentOrParents = _parentOrParents;
        return this;
      };
      return Subscriber2;
    }(Subscription);
    SafeSubscriber = function(_super) {
      __extends(SafeSubscriber2, _super);
      function SafeSubscriber2(_parentSubscriber, observerOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this._parentSubscriber = _parentSubscriber;
        var next;
        var context = _this;
        if (isFunction(observerOrNext)) {
          next = observerOrNext;
        } else if (observerOrNext) {
          next = observerOrNext.next;
          error = observerOrNext.error;
          complete = observerOrNext.complete;
          if (observerOrNext !== empty) {
            context = Object.create(observerOrNext);
            if (isFunction(context.unsubscribe)) {
              _this.add(context.unsubscribe.bind(context));
            }
            context.unsubscribe = _this.unsubscribe.bind(_this);
          }
        }
        _this._context = context;
        _this._next = next;
        _this._error = error;
        _this._complete = complete;
        return _this;
      }
      SafeSubscriber2.prototype.next = function(value2) {
        if (!this.isStopped && this._next) {
          var _parentSubscriber = this._parentSubscriber;
          if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
            this.__tryOrUnsub(this._next, value2);
          } else if (this.__tryOrSetError(_parentSubscriber, this._next, value2)) {
            this.unsubscribe();
          }
        }
      };
      SafeSubscriber2.prototype.error = function(err) {
        if (!this.isStopped) {
          var _parentSubscriber = this._parentSubscriber;
          var useDeprecatedSynchronousErrorHandling = config.useDeprecatedSynchronousErrorHandling;
          if (this._error) {
            if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
              this.__tryOrUnsub(this._error, err);
              this.unsubscribe();
            } else {
              this.__tryOrSetError(_parentSubscriber, this._error, err);
              this.unsubscribe();
            }
          } else if (!_parentSubscriber.syncErrorThrowable) {
            this.unsubscribe();
            if (useDeprecatedSynchronousErrorHandling) {
              throw err;
            }
            hostReportError(err);
          } else {
            if (useDeprecatedSynchronousErrorHandling) {
              _parentSubscriber.syncErrorValue = err;
              _parentSubscriber.syncErrorThrown = true;
            } else {
              hostReportError(err);
            }
            this.unsubscribe();
          }
        }
      };
      SafeSubscriber2.prototype.complete = function() {
        var _this = this;
        if (!this.isStopped) {
          var _parentSubscriber = this._parentSubscriber;
          if (this._complete) {
            var wrappedComplete = function() {
              return _this._complete.call(_this._context);
            };
            if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
              this.__tryOrUnsub(wrappedComplete);
              this.unsubscribe();
            } else {
              this.__tryOrSetError(_parentSubscriber, wrappedComplete);
              this.unsubscribe();
            }
          } else {
            this.unsubscribe();
          }
        }
      };
      SafeSubscriber2.prototype.__tryOrUnsub = function(fn2, value2) {
        try {
          fn2.call(this._context, value2);
        } catch (err) {
          this.unsubscribe();
          if (config.useDeprecatedSynchronousErrorHandling) {
            throw err;
          } else {
            hostReportError(err);
          }
        }
      };
      SafeSubscriber2.prototype.__tryOrSetError = function(parent, fn2, value2) {
        if (!config.useDeprecatedSynchronousErrorHandling) {
          throw new Error("bad call");
        }
        try {
          fn2.call(this._context, value2);
        } catch (err) {
          if (config.useDeprecatedSynchronousErrorHandling) {
            parent.syncErrorValue = err;
            parent.syncErrorThrown = true;
            return true;
          } else {
            hostReportError(err);
            return true;
          }
        }
        return false;
      };
      SafeSubscriber2.prototype._unsubscribe = function() {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
      };
      return SafeSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/util/canReportError.js
function canReportError(observer) {
  while (observer) {
    var _a2 = observer, closed_1 = _a2.closed, destination = _a2.destination, isStopped = _a2.isStopped;
    if (closed_1 || isStopped) {
      return false;
    } else if (destination && destination instanceof Subscriber) {
      observer = destination;
    } else {
      observer = null;
    }
  }
  return true;
}
var init_canReportError = __esm({
  "node_modules/rxjs/_esm5/internal/util/canReportError.js"() {
    init_Subscriber();
  }
});

// node_modules/rxjs/_esm5/internal/util/toSubscriber.js
function toSubscriber(nextOrObserver, error, complete) {
  if (nextOrObserver) {
    if (nextOrObserver instanceof Subscriber) {
      return nextOrObserver;
    }
    if (nextOrObserver[rxSubscriber]) {
      return nextOrObserver[rxSubscriber]();
    }
  }
  if (!nextOrObserver && !error && !complete) {
    return new Subscriber(empty);
  }
  return new Subscriber(nextOrObserver, error, complete);
}
var init_toSubscriber = __esm({
  "node_modules/rxjs/_esm5/internal/util/toSubscriber.js"() {
    init_Subscriber();
    init_rxSubscriber();
    init_Observer();
  }
});

// node_modules/rxjs/_esm5/internal/symbol/observable.js
var observable;
var init_observable = __esm({
  "node_modules/rxjs/_esm5/internal/symbol/observable.js"() {
    observable = function() {
      return typeof Symbol === "function" && Symbol.observable || "@@observable";
    }();
  }
});

// node_modules/rxjs/_esm5/internal/util/identity.js
function identity(x6) {
  return x6;
}
var init_identity = __esm({
  "node_modules/rxjs/_esm5/internal/util/identity.js"() {
  }
});

// node_modules/rxjs/_esm5/internal/util/pipe.js
function pipe() {
  var fns = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    fns[_i2] = arguments[_i2];
  }
  return pipeFromArray(fns);
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn2) {
      return fn2(prev);
    }, input);
  };
}
var init_pipe = __esm({
  "node_modules/rxjs/_esm5/internal/util/pipe.js"() {
    init_identity();
  }
});

// node_modules/rxjs/_esm5/internal/Observable.js
function getPromiseCtor(promiseCtor) {
  if (!promiseCtor) {
    promiseCtor = config.Promise || Promise;
  }
  if (!promiseCtor) {
    throw new Error("no Promise impl found");
  }
  return promiseCtor;
}
var Observable;
var init_Observable = __esm({
  "node_modules/rxjs/_esm5/internal/Observable.js"() {
    init_canReportError();
    init_toSubscriber();
    init_observable();
    init_pipe();
    init_config();
    Observable = function() {
      function Observable2(subscribe) {
        this._isScalar = false;
        if (subscribe) {
          this._subscribe = subscribe;
        }
      }
      Observable2.prototype.lift = function(operator) {
        var observable2 = new Observable2();
        observable2.source = this;
        observable2.operator = operator;
        return observable2;
      };
      Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber(observerOrNext, error, complete);
        if (operator) {
          sink.add(operator.call(sink, this.source));
        } else {
          sink.add(this.source || config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));
        }
        if (config.useDeprecatedSynchronousErrorHandling) {
          if (sink.syncErrorThrowable) {
            sink.syncErrorThrowable = false;
            if (sink.syncErrorThrown) {
              throw sink.syncErrorValue;
            }
          }
        }
        return sink;
      };
      Observable2.prototype._trySubscribe = function(sink) {
        try {
          return this._subscribe(sink);
        } catch (err) {
          if (config.useDeprecatedSynchronousErrorHandling) {
            sink.syncErrorThrown = true;
            sink.syncErrorValue = err;
          }
          if (canReportError(sink)) {
            sink.error(err);
          } else {
            console.warn(err);
          }
        }
      };
      Observable2.prototype.forEach = function(next, promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function(resolve, reject) {
          var subscription;
          subscription = _this.subscribe(function(value2) {
            try {
              next(value2);
            } catch (err) {
              reject(err);
              if (subscription) {
                subscription.unsubscribe();
              }
            }
          }, reject, resolve);
        });
      };
      Observable2.prototype._subscribe = function(subscriber) {
        var source = this.source;
        return source && source.subscribe(subscriber);
      };
      Observable2.prototype[observable] = function() {
        return this;
      };
      Observable2.prototype.pipe = function() {
        var operations = [];
        for (var _i2 = 0; _i2 < arguments.length; _i2++) {
          operations[_i2] = arguments[_i2];
        }
        if (operations.length === 0) {
          return this;
        }
        return pipeFromArray(operations)(this);
      };
      Observable2.prototype.toPromise = function(promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function(resolve, reject) {
          var value2;
          _this.subscribe(function(x6) {
            return value2 = x6;
          }, function(err) {
            return reject(err);
          }, function() {
            return resolve(value2);
          });
        });
      };
      Observable2.create = function(subscribe) {
        return new Observable2(subscribe);
      };
      return Observable2;
    }();
  }
});

// node_modules/rxjs/_esm5/internal/util/ObjectUnsubscribedError.js
var ObjectUnsubscribedErrorImpl, ObjectUnsubscribedError;
var init_ObjectUnsubscribedError = __esm({
  "node_modules/rxjs/_esm5/internal/util/ObjectUnsubscribedError.js"() {
    ObjectUnsubscribedErrorImpl = function() {
      function ObjectUnsubscribedErrorImpl2() {
        Error.call(this);
        this.message = "object unsubscribed";
        this.name = "ObjectUnsubscribedError";
        return this;
      }
      ObjectUnsubscribedErrorImpl2.prototype = Object.create(Error.prototype);
      return ObjectUnsubscribedErrorImpl2;
    }();
    ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;
  }
});

// node_modules/rxjs/_esm5/internal/SubjectSubscription.js
var SubjectSubscription;
var init_SubjectSubscription = __esm({
  "node_modules/rxjs/_esm5/internal/SubjectSubscription.js"() {
    init_tslib_es6();
    init_Subscription();
    SubjectSubscription = function(_super) {
      __extends(SubjectSubscription2, _super);
      function SubjectSubscription2(subject, subscriber) {
        var _this = _super.call(this) || this;
        _this.subject = subject;
        _this.subscriber = subscriber;
        _this.closed = false;
        return _this;
      }
      SubjectSubscription2.prototype.unsubscribe = function() {
        if (this.closed) {
          return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
          return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
          observers.splice(subscriberIndex, 1);
        }
      };
      return SubjectSubscription2;
    }(Subscription);
  }
});

// node_modules/rxjs/_esm5/internal/Subject.js
var SubjectSubscriber, Subject, AnonymousSubject;
var init_Subject = __esm({
  "node_modules/rxjs/_esm5/internal/Subject.js"() {
    init_tslib_es6();
    init_Observable();
    init_Subscriber();
    init_Subscription();
    init_ObjectUnsubscribedError();
    init_SubjectSubscription();
    init_rxSubscriber();
    SubjectSubscriber = function(_super) {
      __extends(SubjectSubscriber2, _super);
      function SubjectSubscriber2(destination) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        return _this;
      }
      return SubjectSubscriber2;
    }(Subscriber);
    Subject = function(_super) {
      __extends(Subject2, _super);
      function Subject2() {
        var _this = _super.call(this) || this;
        _this.observers = [];
        _this.closed = false;
        _this.isStopped = false;
        _this.hasError = false;
        _this.thrownError = null;
        return _this;
      }
      Subject2.prototype[rxSubscriber] = function() {
        return new SubjectSubscriber(this);
      };
      Subject2.prototype.lift = function(operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
      };
      Subject2.prototype.next = function(value2) {
        if (this.closed) {
          throw new ObjectUnsubscribedError();
        }
        if (!this.isStopped) {
          var observers = this.observers;
          var len = observers.length;
          var copy = observers.slice();
          for (var i6 = 0; i6 < len; i6++) {
            copy[i6].next(value2);
          }
        }
      };
      Subject2.prototype.error = function(err) {
        if (this.closed) {
          throw new ObjectUnsubscribedError();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i6 = 0; i6 < len; i6++) {
          copy[i6].error(err);
        }
        this.observers.length = 0;
      };
      Subject2.prototype.complete = function() {
        if (this.closed) {
          throw new ObjectUnsubscribedError();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i6 = 0; i6 < len; i6++) {
          copy[i6].complete();
        }
        this.observers.length = 0;
      };
      Subject2.prototype.unsubscribe = function() {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
      };
      Subject2.prototype._trySubscribe = function(subscriber) {
        if (this.closed) {
          throw new ObjectUnsubscribedError();
        } else {
          return _super.prototype._trySubscribe.call(this, subscriber);
        }
      };
      Subject2.prototype._subscribe = function(subscriber) {
        if (this.closed) {
          throw new ObjectUnsubscribedError();
        } else if (this.hasError) {
          subscriber.error(this.thrownError);
          return Subscription.EMPTY;
        } else if (this.isStopped) {
          subscriber.complete();
          return Subscription.EMPTY;
        } else {
          this.observers.push(subscriber);
          return new SubjectSubscription(this, subscriber);
        }
      };
      Subject2.prototype.asObservable = function() {
        var observable2 = new Observable();
        observable2.source = this;
        return observable2;
      };
      Subject2.create = function(destination, source) {
        return new AnonymousSubject(destination, source);
      };
      return Subject2;
    }(Observable);
    AnonymousSubject = function(_super) {
      __extends(AnonymousSubject2, _super);
      function AnonymousSubject2(destination, source) {
        var _this = _super.call(this) || this;
        _this.destination = destination;
        _this.source = source;
        return _this;
      }
      AnonymousSubject2.prototype.next = function(value2) {
        var destination = this.destination;
        if (destination && destination.next) {
          destination.next(value2);
        }
      };
      AnonymousSubject2.prototype.error = function(err) {
        var destination = this.destination;
        if (destination && destination.error) {
          this.destination.error(err);
        }
      };
      AnonymousSubject2.prototype.complete = function() {
        var destination = this.destination;
        if (destination && destination.complete) {
          this.destination.complete();
        }
      };
      AnonymousSubject2.prototype._subscribe = function(subscriber) {
        var source = this.source;
        if (source) {
          return this.source.subscribe(subscriber);
        } else {
          return Subscription.EMPTY;
        }
      };
      return AnonymousSubject2;
    }(Subject);
  }
});

// node_modules/rxjs/_esm5/internal/operators/refCount.js
function refCount() {
  return function refCountOperatorFunction(source) {
    return source.lift(new RefCountOperator(source));
  };
}
var RefCountOperator, RefCountSubscriber;
var init_refCount = __esm({
  "node_modules/rxjs/_esm5/internal/operators/refCount.js"() {
    init_tslib_es6();
    init_Subscriber();
    RefCountOperator = function() {
      function RefCountOperator3(connectable) {
        this.connectable = connectable;
      }
      RefCountOperator3.prototype.call = function(subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
          refCounter.connection = connectable.connect();
        }
        return subscription;
      };
      return RefCountOperator3;
    }();
    RefCountSubscriber = function(_super) {
      __extends(RefCountSubscriber3, _super);
      function RefCountSubscriber3(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
      }
      RefCountSubscriber3.prototype._unsubscribe = function() {
        var connectable = this.connectable;
        if (!connectable) {
          this.connection = null;
          return;
        }
        this.connectable = null;
        var refCount2 = connectable._refCount;
        if (refCount2 <= 0) {
          this.connection = null;
          return;
        }
        connectable._refCount = refCount2 - 1;
        if (refCount2 > 1) {
          this.connection = null;
          return;
        }
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
          sharedConnection.unsubscribe();
        }
      };
      return RefCountSubscriber3;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/observable/ConnectableObservable.js
var ConnectableObservable, connectableObservableDescriptor, ConnectableSubscriber, RefCountOperator2, RefCountSubscriber2;
var init_ConnectableObservable = __esm({
  "node_modules/rxjs/_esm5/internal/observable/ConnectableObservable.js"() {
    init_tslib_es6();
    init_Subject();
    init_Observable();
    init_Subscriber();
    init_Subscription();
    init_refCount();
    ConnectableObservable = function(_super) {
      __extends(ConnectableObservable2, _super);
      function ConnectableObservable2(source, subjectFactory) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subjectFactory = subjectFactory;
        _this._refCount = 0;
        _this._isComplete = false;
        return _this;
      }
      ConnectableObservable2.prototype._subscribe = function(subscriber) {
        return this.getSubject().subscribe(subscriber);
      };
      ConnectableObservable2.prototype.getSubject = function() {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
          this._subject = this.subjectFactory();
        }
        return this._subject;
      };
      ConnectableObservable2.prototype.connect = function() {
        var connection = this._connection;
        if (!connection) {
          this._isComplete = false;
          connection = this._connection = new Subscription();
          connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));
          if (connection.closed) {
            this._connection = null;
            connection = Subscription.EMPTY;
          }
        }
        return connection;
      };
      ConnectableObservable2.prototype.refCount = function() {
        return refCount()(this);
      };
      return ConnectableObservable2;
    }(Observable);
    connectableObservableDescriptor = function() {
      var connectableProto = ConnectableObservable.prototype;
      return {
        operator: { value: null },
        _refCount: { value: 0, writable: true },
        _subject: { value: null, writable: true },
        _connection: { value: null, writable: true },
        _subscribe: { value: connectableProto._subscribe },
        _isComplete: { value: connectableProto._isComplete, writable: true },
        getSubject: { value: connectableProto.getSubject },
        connect: { value: connectableProto.connect },
        refCount: { value: connectableProto.refCount }
      };
    }();
    ConnectableSubscriber = function(_super) {
      __extends(ConnectableSubscriber2, _super);
      function ConnectableSubscriber2(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
      }
      ConnectableSubscriber2.prototype._error = function(err) {
        this._unsubscribe();
        _super.prototype._error.call(this, err);
      };
      ConnectableSubscriber2.prototype._complete = function() {
        this.connectable._isComplete = true;
        this._unsubscribe();
        _super.prototype._complete.call(this);
      };
      ConnectableSubscriber2.prototype._unsubscribe = function() {
        var connectable = this.connectable;
        if (connectable) {
          this.connectable = null;
          var connection = connectable._connection;
          connectable._refCount = 0;
          connectable._subject = null;
          connectable._connection = null;
          if (connection) {
            connection.unsubscribe();
          }
        }
      };
      return ConnectableSubscriber2;
    }(SubjectSubscriber);
    RefCountOperator2 = function() {
      function RefCountOperator3(connectable) {
        this.connectable = connectable;
      }
      RefCountOperator3.prototype.call = function(subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber2(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
          refCounter.connection = connectable.connect();
        }
        return subscription;
      };
      return RefCountOperator3;
    }();
    RefCountSubscriber2 = function(_super) {
      __extends(RefCountSubscriber3, _super);
      function RefCountSubscriber3(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
      }
      RefCountSubscriber3.prototype._unsubscribe = function() {
        var connectable = this.connectable;
        if (!connectable) {
          this.connection = null;
          return;
        }
        this.connectable = null;
        var refCount2 = connectable._refCount;
        if (refCount2 <= 0) {
          this.connection = null;
          return;
        }
        connectable._refCount = refCount2 - 1;
        if (refCount2 > 1) {
          this.connection = null;
          return;
        }
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
          sharedConnection.unsubscribe();
        }
      };
      return RefCountSubscriber3;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/groupBy.js
function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {
  return function(source) {
    return source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));
  };
}
var GroupByOperator, GroupBySubscriber, GroupDurationSubscriber, GroupedObservable, InnerRefCountSubscription;
var init_groupBy = __esm({
  "node_modules/rxjs/_esm5/internal/operators/groupBy.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_Subscription();
    init_Observable();
    init_Subject();
    GroupByOperator = function() {
      function GroupByOperator2(keySelector, elementSelector, durationSelector, subjectSelector) {
        this.keySelector = keySelector;
        this.elementSelector = elementSelector;
        this.durationSelector = durationSelector;
        this.subjectSelector = subjectSelector;
      }
      GroupByOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
      };
      return GroupByOperator2;
    }();
    GroupBySubscriber = function(_super) {
      __extends(GroupBySubscriber2, _super);
      function GroupBySubscriber2(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.elementSelector = elementSelector;
        _this.durationSelector = durationSelector;
        _this.subjectSelector = subjectSelector;
        _this.groups = null;
        _this.attemptedToUnsubscribe = false;
        _this.count = 0;
        return _this;
      }
      GroupBySubscriber2.prototype._next = function(value2) {
        var key2;
        try {
          key2 = this.keySelector(value2);
        } catch (err) {
          this.error(err);
          return;
        }
        this._group(value2, key2);
      };
      GroupBySubscriber2.prototype._group = function(value2, key2) {
        var groups = this.groups;
        if (!groups) {
          groups = this.groups = /* @__PURE__ */ new Map();
        }
        var group = groups.get(key2);
        var element;
        if (this.elementSelector) {
          try {
            element = this.elementSelector(value2);
          } catch (err) {
            this.error(err);
          }
        } else {
          element = value2;
        }
        if (!group) {
          group = this.subjectSelector ? this.subjectSelector() : new Subject();
          groups.set(key2, group);
          var groupedObservable = new GroupedObservable(key2, group, this);
          this.destination.next(groupedObservable);
          if (this.durationSelector) {
            var duration = void 0;
            try {
              duration = this.durationSelector(new GroupedObservable(key2, group));
            } catch (err) {
              this.error(err);
              return;
            }
            this.add(duration.subscribe(new GroupDurationSubscriber(key2, group, this)));
          }
        }
        if (!group.closed) {
          group.next(element);
        }
      };
      GroupBySubscriber2.prototype._error = function(err) {
        var groups = this.groups;
        if (groups) {
          groups.forEach(function(group, key2) {
            group.error(err);
          });
          groups.clear();
        }
        this.destination.error(err);
      };
      GroupBySubscriber2.prototype._complete = function() {
        var groups = this.groups;
        if (groups) {
          groups.forEach(function(group, key2) {
            group.complete();
          });
          groups.clear();
        }
        this.destination.complete();
      };
      GroupBySubscriber2.prototype.removeGroup = function(key2) {
        this.groups.delete(key2);
      };
      GroupBySubscriber2.prototype.unsubscribe = function() {
        if (!this.closed) {
          this.attemptedToUnsubscribe = true;
          if (this.count === 0) {
            _super.prototype.unsubscribe.call(this);
          }
        }
      };
      return GroupBySubscriber2;
    }(Subscriber);
    GroupDurationSubscriber = function(_super) {
      __extends(GroupDurationSubscriber2, _super);
      function GroupDurationSubscriber2(key2, group, parent) {
        var _this = _super.call(this, group) || this;
        _this.key = key2;
        _this.group = group;
        _this.parent = parent;
        return _this;
      }
      GroupDurationSubscriber2.prototype._next = function(value2) {
        this.complete();
      };
      GroupDurationSubscriber2.prototype._unsubscribe = function() {
        var _a2 = this, parent = _a2.parent, key2 = _a2.key;
        this.key = this.parent = null;
        if (parent) {
          parent.removeGroup(key2);
        }
      };
      return GroupDurationSubscriber2;
    }(Subscriber);
    GroupedObservable = function(_super) {
      __extends(GroupedObservable2, _super);
      function GroupedObservable2(key2, groupSubject, refCountSubscription) {
        var _this = _super.call(this) || this;
        _this.key = key2;
        _this.groupSubject = groupSubject;
        _this.refCountSubscription = refCountSubscription;
        return _this;
      }
      GroupedObservable2.prototype._subscribe = function(subscriber) {
        var subscription = new Subscription();
        var _a2 = this, refCountSubscription = _a2.refCountSubscription, groupSubject = _a2.groupSubject;
        if (refCountSubscription && !refCountSubscription.closed) {
          subscription.add(new InnerRefCountSubscription(refCountSubscription));
        }
        subscription.add(groupSubject.subscribe(subscriber));
        return subscription;
      };
      return GroupedObservable2;
    }(Observable);
    InnerRefCountSubscription = function(_super) {
      __extends(InnerRefCountSubscription2, _super);
      function InnerRefCountSubscription2(parent) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        parent.count++;
        return _this;
      }
      InnerRefCountSubscription2.prototype.unsubscribe = function() {
        var parent = this.parent;
        if (!parent.closed && !this.closed) {
          _super.prototype.unsubscribe.call(this);
          parent.count -= 1;
          if (parent.count === 0 && parent.attemptedToUnsubscribe) {
            parent.unsubscribe();
          }
        }
      };
      return InnerRefCountSubscription2;
    }(Subscription);
  }
});

// node_modules/rxjs/_esm5/internal/BehaviorSubject.js
var BehaviorSubject;
var init_BehaviorSubject = __esm({
  "node_modules/rxjs/_esm5/internal/BehaviorSubject.js"() {
    init_tslib_es6();
    init_Subject();
    init_ObjectUnsubscribedError();
    BehaviorSubject = function(_super) {
      __extends(BehaviorSubject2, _super);
      function BehaviorSubject2(_value) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        return _this;
      }
      Object.defineProperty(BehaviorSubject2.prototype, "value", {
        get: function() {
          return this.getValue();
        },
        enumerable: true,
        configurable: true
      });
      BehaviorSubject2.prototype._subscribe = function(subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        if (subscription && !subscription.closed) {
          subscriber.next(this._value);
        }
        return subscription;
      };
      BehaviorSubject2.prototype.getValue = function() {
        if (this.hasError) {
          throw this.thrownError;
        } else if (this.closed) {
          throw new ObjectUnsubscribedError();
        } else {
          return this._value;
        }
      };
      BehaviorSubject2.prototype.next = function(value2) {
        _super.prototype.next.call(this, this._value = value2);
      };
      return BehaviorSubject2;
    }(Subject);
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/Action.js
var Action;
var init_Action = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/Action.js"() {
    init_tslib_es6();
    init_Subscription();
    Action = function(_super) {
      __extends(Action2, _super);
      function Action2(scheduler, work) {
        return _super.call(this) || this;
      }
      Action2.prototype.schedule = function(state, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        return this;
      };
      return Action2;
    }(Subscription);
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js
var AsyncAction;
var init_AsyncAction = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js"() {
    init_tslib_es6();
    init_Action();
    AsyncAction = function(_super) {
      __extends(AsyncAction2, _super);
      function AsyncAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.pending = false;
        return _this;
      }
      AsyncAction2.prototype.schedule = function(state, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (this.closed) {
          return this;
        }
        this.state = state;
        var id2 = this.id;
        var scheduler = this.scheduler;
        if (id2 != null) {
          this.id = this.recycleAsyncId(scheduler, id2, delay2);
        }
        this.pending = true;
        this.delay = delay2;
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay2);
        return this;
      };
      AsyncAction2.prototype.requestAsyncId = function(scheduler, id2, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        return setInterval(scheduler.flush.bind(scheduler, this), delay2);
      };
      AsyncAction2.prototype.recycleAsyncId = function(scheduler, id2, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 !== null && this.delay === delay2 && this.pending === false) {
          return id2;
        }
        clearInterval(id2);
        return void 0;
      };
      AsyncAction2.prototype.execute = function(state, delay2) {
        if (this.closed) {
          return new Error("executing a cancelled action");
        }
        this.pending = false;
        var error = this._execute(state, delay2);
        if (error) {
          return error;
        } else if (this.pending === false && this.id != null) {
          this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
      };
      AsyncAction2.prototype._execute = function(state, delay2) {
        var errored = false;
        var errorValue = void 0;
        try {
          this.work(state);
        } catch (e6) {
          errored = true;
          errorValue = !!e6 && e6 || new Error(e6);
        }
        if (errored) {
          this.unsubscribe();
          return errorValue;
        }
      };
      AsyncAction2.prototype._unsubscribe = function() {
        var id2 = this.id;
        var scheduler = this.scheduler;
        var actions = scheduler.actions;
        var index = actions.indexOf(this);
        this.work = null;
        this.state = null;
        this.pending = false;
        this.scheduler = null;
        if (index !== -1) {
          actions.splice(index, 1);
        }
        if (id2 != null) {
          this.id = this.recycleAsyncId(scheduler, id2, null);
        }
        this.delay = null;
      };
      return AsyncAction2;
    }(Action);
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/QueueAction.js
var QueueAction;
var init_QueueAction = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/QueueAction.js"() {
    init_tslib_es6();
    init_AsyncAction();
    QueueAction = function(_super) {
      __extends(QueueAction2, _super);
      function QueueAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
      }
      QueueAction2.prototype.schedule = function(state, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 > 0) {
          return _super.prototype.schedule.call(this, state, delay2);
        }
        this.delay = delay2;
        this.state = state;
        this.scheduler.flush(this);
        return this;
      };
      QueueAction2.prototype.execute = function(state, delay2) {
        return delay2 > 0 || this.closed ? _super.prototype.execute.call(this, state, delay2) : this._execute(state, delay2);
      };
      QueueAction2.prototype.requestAsyncId = function(scheduler, id2, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 !== null && delay2 > 0 || delay2 === null && this.delay > 0) {
          return _super.prototype.requestAsyncId.call(this, scheduler, id2, delay2);
        }
        return scheduler.flush(this);
      };
      return QueueAction2;
    }(AsyncAction);
  }
});

// node_modules/rxjs/_esm5/internal/Scheduler.js
var Scheduler;
var init_Scheduler = __esm({
  "node_modules/rxjs/_esm5/internal/Scheduler.js"() {
    Scheduler = function() {
      function Scheduler2(SchedulerAction, now2) {
        if (now2 === void 0) {
          now2 = Scheduler2.now;
        }
        this.SchedulerAction = SchedulerAction;
        this.now = now2;
      }
      Scheduler2.prototype.schedule = function(work, delay2, state) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        return new this.SchedulerAction(this, work).schedule(state, delay2);
      };
      Scheduler2.now = function() {
        return Date.now();
      };
      return Scheduler2;
    }();
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js
var AsyncScheduler;
var init_AsyncScheduler = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js"() {
    init_tslib_es6();
    init_Scheduler();
    AsyncScheduler = function(_super) {
      __extends(AsyncScheduler2, _super);
      function AsyncScheduler2(SchedulerAction, now2) {
        if (now2 === void 0) {
          now2 = Scheduler.now;
        }
        var _this = _super.call(this, SchedulerAction, function() {
          if (AsyncScheduler2.delegate && AsyncScheduler2.delegate !== _this) {
            return AsyncScheduler2.delegate.now();
          } else {
            return now2();
          }
        }) || this;
        _this.actions = [];
        _this.active = false;
        _this.scheduled = void 0;
        return _this;
      }
      AsyncScheduler2.prototype.schedule = function(work, delay2, state) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (AsyncScheduler2.delegate && AsyncScheduler2.delegate !== this) {
          return AsyncScheduler2.delegate.schedule(work, delay2, state);
        } else {
          return _super.prototype.schedule.call(this, work, delay2, state);
        }
      };
      AsyncScheduler2.prototype.flush = function(action) {
        var actions = this.actions;
        if (this.active) {
          actions.push(action);
          return;
        }
        var error;
        this.active = true;
        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while (action = actions.shift());
        this.active = false;
        if (error) {
          while (action = actions.shift()) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      return AsyncScheduler2;
    }(Scheduler);
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/QueueScheduler.js
var QueueScheduler;
var init_QueueScheduler = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/QueueScheduler.js"() {
    init_tslib_es6();
    init_AsyncScheduler();
    QueueScheduler = function(_super) {
      __extends(QueueScheduler2, _super);
      function QueueScheduler2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return QueueScheduler2;
    }(AsyncScheduler);
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/queue.js
var queueScheduler, queue;
var init_queue = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/queue.js"() {
    init_QueueAction();
    init_QueueScheduler();
    queueScheduler = new QueueScheduler(QueueAction);
    queue = queueScheduler;
  }
});

// node_modules/rxjs/_esm5/internal/observable/empty.js
function empty2(scheduler) {
  return scheduler ? emptyScheduled(scheduler) : EMPTY;
}
function emptyScheduled(scheduler) {
  return new Observable(function(subscriber) {
    return scheduler.schedule(function() {
      return subscriber.complete();
    });
  });
}
var EMPTY;
var init_empty = __esm({
  "node_modules/rxjs/_esm5/internal/observable/empty.js"() {
    init_Observable();
    EMPTY = new Observable(function(subscriber) {
      return subscriber.complete();
    });
  }
});

// node_modules/rxjs/_esm5/internal/util/isScheduler.js
function isScheduler(value2) {
  return value2 && typeof value2.schedule === "function";
}
var init_isScheduler = __esm({
  "node_modules/rxjs/_esm5/internal/util/isScheduler.js"() {
  }
});

// node_modules/rxjs/_esm5/internal/util/subscribeToArray.js
var subscribeToArray;
var init_subscribeToArray = __esm({
  "node_modules/rxjs/_esm5/internal/util/subscribeToArray.js"() {
    subscribeToArray = function(array) {
      return function(subscriber) {
        for (var i6 = 0, len = array.length; i6 < len && !subscriber.closed; i6++) {
          subscriber.next(array[i6]);
        }
        subscriber.complete();
      };
    };
  }
});

// node_modules/rxjs/_esm5/internal/scheduled/scheduleArray.js
function scheduleArray(input, scheduler) {
  return new Observable(function(subscriber) {
    var sub = new Subscription();
    var i6 = 0;
    sub.add(scheduler.schedule(function() {
      if (i6 === input.length) {
        subscriber.complete();
        return;
      }
      subscriber.next(input[i6++]);
      if (!subscriber.closed) {
        sub.add(this.schedule());
      }
    }));
    return sub;
  });
}
var init_scheduleArray = __esm({
  "node_modules/rxjs/_esm5/internal/scheduled/scheduleArray.js"() {
    init_Observable();
    init_Subscription();
  }
});

// node_modules/rxjs/_esm5/internal/observable/fromArray.js
function fromArray(input, scheduler) {
  if (!scheduler) {
    return new Observable(subscribeToArray(input));
  } else {
    return scheduleArray(input, scheduler);
  }
}
var init_fromArray = __esm({
  "node_modules/rxjs/_esm5/internal/observable/fromArray.js"() {
    init_Observable();
    init_subscribeToArray();
    init_scheduleArray();
  }
});

// node_modules/rxjs/_esm5/internal/observable/of.js
function of() {
  var args = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    args[_i2] = arguments[_i2];
  }
  var scheduler = args[args.length - 1];
  if (isScheduler(scheduler)) {
    args.pop();
    return scheduleArray(args, scheduler);
  } else {
    return fromArray(args);
  }
}
var init_of = __esm({
  "node_modules/rxjs/_esm5/internal/observable/of.js"() {
    init_isScheduler();
    init_fromArray();
    init_scheduleArray();
  }
});

// node_modules/rxjs/_esm5/internal/observable/throwError.js
function throwError(error, scheduler) {
  if (!scheduler) {
    return new Observable(function(subscriber) {
      return subscriber.error(error);
    });
  } else {
    return new Observable(function(subscriber) {
      return scheduler.schedule(dispatch, 0, { error, subscriber });
    });
  }
}
function dispatch(_a2) {
  var error = _a2.error, subscriber = _a2.subscriber;
  subscriber.error(error);
}
var init_throwError = __esm({
  "node_modules/rxjs/_esm5/internal/observable/throwError.js"() {
    init_Observable();
  }
});

// node_modules/rxjs/_esm5/internal/Notification.js
var NotificationKind, Notification;
var init_Notification = __esm({
  "node_modules/rxjs/_esm5/internal/Notification.js"() {
    init_empty();
    init_of();
    init_throwError();
    (function(NotificationKind2) {
      NotificationKind2["NEXT"] = "N";
      NotificationKind2["ERROR"] = "E";
      NotificationKind2["COMPLETE"] = "C";
    })(NotificationKind || (NotificationKind = {}));
    Notification = function() {
      function Notification2(kind, value2, error) {
        this.kind = kind;
        this.value = value2;
        this.error = error;
        this.hasValue = kind === "N";
      }
      Notification2.prototype.observe = function(observer) {
        switch (this.kind) {
          case "N":
            return observer.next && observer.next(this.value);
          case "E":
            return observer.error && observer.error(this.error);
          case "C":
            return observer.complete && observer.complete();
        }
      };
      Notification2.prototype.do = function(next, error, complete) {
        var kind = this.kind;
        switch (kind) {
          case "N":
            return next && next(this.value);
          case "E":
            return error && error(this.error);
          case "C":
            return complete && complete();
        }
      };
      Notification2.prototype.accept = function(nextOrObserver, error, complete) {
        if (nextOrObserver && typeof nextOrObserver.next === "function") {
          return this.observe(nextOrObserver);
        } else {
          return this.do(nextOrObserver, error, complete);
        }
      };
      Notification2.prototype.toObservable = function() {
        var kind = this.kind;
        switch (kind) {
          case "N":
            return of(this.value);
          case "E":
            return throwError(this.error);
          case "C":
            return empty2();
        }
        throw new Error("unexpected notification kind value");
      };
      Notification2.createNext = function(value2) {
        if (typeof value2 !== "undefined") {
          return new Notification2("N", value2);
        }
        return Notification2.undefinedValueNotification;
      };
      Notification2.createError = function(err) {
        return new Notification2("E", void 0, err);
      };
      Notification2.createComplete = function() {
        return Notification2.completeNotification;
      };
      Notification2.completeNotification = new Notification2("C");
      Notification2.undefinedValueNotification = new Notification2("N", void 0);
      return Notification2;
    }();
  }
});

// node_modules/rxjs/_esm5/internal/operators/observeOn.js
function observeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return function observeOnOperatorFunction(source) {
    return source.lift(new ObserveOnOperator(scheduler, delay2));
  };
}
var ObserveOnOperator, ObserveOnSubscriber, ObserveOnMessage;
var init_observeOn = __esm({
  "node_modules/rxjs/_esm5/internal/operators/observeOn.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_Notification();
    ObserveOnOperator = function() {
      function ObserveOnOperator2(scheduler, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        this.scheduler = scheduler;
        this.delay = delay2;
      }
      ObserveOnOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
      };
      return ObserveOnOperator2;
    }();
    ObserveOnSubscriber = function(_super) {
      __extends(ObserveOnSubscriber2, _super);
      function ObserveOnSubscriber2(destination, scheduler, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        var _this = _super.call(this, destination) || this;
        _this.scheduler = scheduler;
        _this.delay = delay2;
        return _this;
      }
      ObserveOnSubscriber2.dispatch = function(arg) {
        var notification = arg.notification, destination = arg.destination;
        notification.observe(destination);
        this.unsubscribe();
      };
      ObserveOnSubscriber2.prototype.scheduleMessage = function(notification) {
        var destination = this.destination;
        destination.add(this.scheduler.schedule(ObserveOnSubscriber2.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
      };
      ObserveOnSubscriber2.prototype._next = function(value2) {
        this.scheduleMessage(Notification.createNext(value2));
      };
      ObserveOnSubscriber2.prototype._error = function(err) {
        this.scheduleMessage(Notification.createError(err));
        this.unsubscribe();
      };
      ObserveOnSubscriber2.prototype._complete = function() {
        this.scheduleMessage(Notification.createComplete());
        this.unsubscribe();
      };
      return ObserveOnSubscriber2;
    }(Subscriber);
    ObserveOnMessage = function() {
      function ObserveOnMessage2(notification, destination) {
        this.notification = notification;
        this.destination = destination;
      }
      return ObserveOnMessage2;
    }();
  }
});

// node_modules/rxjs/_esm5/internal/ReplaySubject.js
var ReplaySubject, ReplayEvent;
var init_ReplaySubject = __esm({
  "node_modules/rxjs/_esm5/internal/ReplaySubject.js"() {
    init_tslib_es6();
    init_Subject();
    init_queue();
    init_Subscription();
    init_observeOn();
    init_ObjectUnsubscribedError();
    init_SubjectSubscription();
    ReplaySubject = function(_super) {
      __extends(ReplaySubject2, _super);
      function ReplaySubject2(bufferSize, windowTime2, scheduler) {
        if (bufferSize === void 0) {
          bufferSize = Number.POSITIVE_INFINITY;
        }
        if (windowTime2 === void 0) {
          windowTime2 = Number.POSITIVE_INFINITY;
        }
        var _this = _super.call(this) || this;
        _this.scheduler = scheduler;
        _this._events = [];
        _this._infiniteTimeWindow = false;
        _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
        _this._windowTime = windowTime2 < 1 ? 1 : windowTime2;
        if (windowTime2 === Number.POSITIVE_INFINITY) {
          _this._infiniteTimeWindow = true;
          _this.next = _this.nextInfiniteTimeWindow;
        } else {
          _this.next = _this.nextTimeWindow;
        }
        return _this;
      }
      ReplaySubject2.prototype.nextInfiniteTimeWindow = function(value2) {
        if (!this.isStopped) {
          var _events = this._events;
          _events.push(value2);
          if (_events.length > this._bufferSize) {
            _events.shift();
          }
        }
        _super.prototype.next.call(this, value2);
      };
      ReplaySubject2.prototype.nextTimeWindow = function(value2) {
        if (!this.isStopped) {
          this._events.push(new ReplayEvent(this._getNow(), value2));
          this._trimBufferThenGetEvents();
        }
        _super.prototype.next.call(this, value2);
      };
      ReplaySubject2.prototype._subscribe = function(subscriber) {
        var _infiniteTimeWindow = this._infiniteTimeWindow;
        var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();
        var scheduler = this.scheduler;
        var len = _events.length;
        var subscription;
        if (this.closed) {
          throw new ObjectUnsubscribedError();
        } else if (this.isStopped || this.hasError) {
          subscription = Subscription.EMPTY;
        } else {
          this.observers.push(subscriber);
          subscription = new SubjectSubscription(this, subscriber);
        }
        if (scheduler) {
          subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));
        }
        if (_infiniteTimeWindow) {
          for (var i6 = 0; i6 < len && !subscriber.closed; i6++) {
            subscriber.next(_events[i6]);
          }
        } else {
          for (var i6 = 0; i6 < len && !subscriber.closed; i6++) {
            subscriber.next(_events[i6].value);
          }
        }
        if (this.hasError) {
          subscriber.error(this.thrownError);
        } else if (this.isStopped) {
          subscriber.complete();
        }
        return subscription;
      };
      ReplaySubject2.prototype._getNow = function() {
        return (this.scheduler || queue).now();
      };
      ReplaySubject2.prototype._trimBufferThenGetEvents = function() {
        var now2 = this._getNow();
        var _bufferSize = this._bufferSize;
        var _windowTime = this._windowTime;
        var _events = this._events;
        var eventsCount = _events.length;
        var spliceCount = 0;
        while (spliceCount < eventsCount) {
          if (now2 - _events[spliceCount].time < _windowTime) {
            break;
          }
          spliceCount++;
        }
        if (eventsCount > _bufferSize) {
          spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
        }
        if (spliceCount > 0) {
          _events.splice(0, spliceCount);
        }
        return _events;
      };
      return ReplaySubject2;
    }(Subject);
    ReplayEvent = function() {
      function ReplayEvent2(time, value2) {
        this.time = time;
        this.value = value2;
      }
      return ReplayEvent2;
    }();
  }
});

// node_modules/rxjs/_esm5/internal/AsyncSubject.js
var AsyncSubject;
var init_AsyncSubject = __esm({
  "node_modules/rxjs/_esm5/internal/AsyncSubject.js"() {
    init_tslib_es6();
    init_Subject();
    init_Subscription();
    AsyncSubject = function(_super) {
      __extends(AsyncSubject2, _super);
      function AsyncSubject2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.value = null;
        _this.hasNext = false;
        _this.hasCompleted = false;
        return _this;
      }
      AsyncSubject2.prototype._subscribe = function(subscriber) {
        if (this.hasError) {
          subscriber.error(this.thrownError);
          return Subscription.EMPTY;
        } else if (this.hasCompleted && this.hasNext) {
          subscriber.next(this.value);
          subscriber.complete();
          return Subscription.EMPTY;
        }
        return _super.prototype._subscribe.call(this, subscriber);
      };
      AsyncSubject2.prototype.next = function(value2) {
        if (!this.hasCompleted) {
          this.value = value2;
          this.hasNext = true;
        }
      };
      AsyncSubject2.prototype.error = function(error) {
        if (!this.hasCompleted) {
          _super.prototype.error.call(this, error);
        }
      };
      AsyncSubject2.prototype.complete = function() {
        this.hasCompleted = true;
        if (this.hasNext) {
          _super.prototype.next.call(this, this.value);
        }
        _super.prototype.complete.call(this);
      };
      return AsyncSubject2;
    }(Subject);
  }
});

// node_modules/rxjs/_esm5/internal/util/Immediate.js
function findAndClearHandle(handle) {
  if (handle in activeHandles) {
    delete activeHandles[handle];
    return true;
  }
  return false;
}
var nextHandle, RESOLVED, activeHandles, Immediate;
var init_Immediate = __esm({
  "node_modules/rxjs/_esm5/internal/util/Immediate.js"() {
    nextHandle = 1;
    RESOLVED = function() {
      return Promise.resolve();
    }();
    activeHandles = {};
    Immediate = {
      setImmediate: function(cb) {
        var handle = nextHandle++;
        activeHandles[handle] = true;
        RESOLVED.then(function() {
          return findAndClearHandle(handle) && cb();
        });
        return handle;
      },
      clearImmediate: function(handle) {
        findAndClearHandle(handle);
      }
    };
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/AsapAction.js
var AsapAction;
var init_AsapAction = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/AsapAction.js"() {
    init_tslib_es6();
    init_Immediate();
    init_AsyncAction();
    AsapAction = function(_super) {
      __extends(AsapAction2, _super);
      function AsapAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
      }
      AsapAction2.prototype.requestAsyncId = function(scheduler, id2, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 !== null && delay2 > 0) {
          return _super.prototype.requestAsyncId.call(this, scheduler, id2, delay2);
        }
        scheduler.actions.push(this);
        return scheduler.scheduled || (scheduler.scheduled = Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));
      };
      AsapAction2.prototype.recycleAsyncId = function(scheduler, id2, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 !== null && delay2 > 0 || delay2 === null && this.delay > 0) {
          return _super.prototype.recycleAsyncId.call(this, scheduler, id2, delay2);
        }
        if (scheduler.actions.length === 0) {
          Immediate.clearImmediate(id2);
          scheduler.scheduled = void 0;
        }
        return void 0;
      };
      return AsapAction2;
    }(AsyncAction);
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/AsapScheduler.js
var AsapScheduler;
var init_AsapScheduler = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/AsapScheduler.js"() {
    init_tslib_es6();
    init_AsyncScheduler();
    AsapScheduler = function(_super) {
      __extends(AsapScheduler2, _super);
      function AsapScheduler2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      AsapScheduler2.prototype.flush = function(action) {
        this.active = true;
        this.scheduled = void 0;
        var actions = this.actions;
        var error;
        var index = -1;
        var count2 = actions.length;
        action = action || actions.shift();
        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while (++index < count2 && (action = actions.shift()));
        this.active = false;
        if (error) {
          while (++index < count2 && (action = actions.shift())) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      return AsapScheduler2;
    }(AsyncScheduler);
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/asap.js
var asapScheduler, asap;
var init_asap = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/asap.js"() {
    init_AsapAction();
    init_AsapScheduler();
    asapScheduler = new AsapScheduler(AsapAction);
    asap = asapScheduler;
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/async.js
var asyncScheduler, async;
var init_async = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/async.js"() {
    init_AsyncAction();
    init_AsyncScheduler();
    asyncScheduler = new AsyncScheduler(AsyncAction);
    async = asyncScheduler;
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/AnimationFrameAction.js
var AnimationFrameAction;
var init_AnimationFrameAction = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/AnimationFrameAction.js"() {
    init_tslib_es6();
    init_AsyncAction();
    AnimationFrameAction = function(_super) {
      __extends(AnimationFrameAction2, _super);
      function AnimationFrameAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
      }
      AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id2, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 !== null && delay2 > 0) {
          return _super.prototype.requestAsyncId.call(this, scheduler, id2, delay2);
        }
        scheduler.actions.push(this);
        return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(function() {
          return scheduler.flush(null);
        }));
      };
      AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id2, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 !== null && delay2 > 0 || delay2 === null && this.delay > 0) {
          return _super.prototype.recycleAsyncId.call(this, scheduler, id2, delay2);
        }
        if (scheduler.actions.length === 0) {
          cancelAnimationFrame(id2);
          scheduler.scheduled = void 0;
        }
        return void 0;
      };
      return AnimationFrameAction2;
    }(AsyncAction);
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/AnimationFrameScheduler.js
var AnimationFrameScheduler;
var init_AnimationFrameScheduler = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/AnimationFrameScheduler.js"() {
    init_tslib_es6();
    init_AsyncScheduler();
    AnimationFrameScheduler = function(_super) {
      __extends(AnimationFrameScheduler2, _super);
      function AnimationFrameScheduler2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      AnimationFrameScheduler2.prototype.flush = function(action) {
        this.active = true;
        this.scheduled = void 0;
        var actions = this.actions;
        var error;
        var index = -1;
        var count2 = actions.length;
        action = action || actions.shift();
        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while (++index < count2 && (action = actions.shift()));
        this.active = false;
        if (error) {
          while (++index < count2 && (action = actions.shift())) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      return AnimationFrameScheduler2;
    }(AsyncScheduler);
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/animationFrame.js
var animationFrameScheduler, animationFrame;
var init_animationFrame = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/animationFrame.js"() {
    init_AnimationFrameAction();
    init_AnimationFrameScheduler();
    animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);
    animationFrame = animationFrameScheduler;
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/VirtualTimeScheduler.js
var VirtualTimeScheduler, VirtualAction;
var init_VirtualTimeScheduler = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/VirtualTimeScheduler.js"() {
    init_tslib_es6();
    init_AsyncAction();
    init_AsyncScheduler();
    VirtualTimeScheduler = function(_super) {
      __extends(VirtualTimeScheduler2, _super);
      function VirtualTimeScheduler2(SchedulerAction, maxFrames) {
        if (SchedulerAction === void 0) {
          SchedulerAction = VirtualAction;
        }
        if (maxFrames === void 0) {
          maxFrames = Number.POSITIVE_INFINITY;
        }
        var _this = _super.call(this, SchedulerAction, function() {
          return _this.frame;
        }) || this;
        _this.maxFrames = maxFrames;
        _this.frame = 0;
        _this.index = -1;
        return _this;
      }
      VirtualTimeScheduler2.prototype.flush = function() {
        var _a2 = this, actions = _a2.actions, maxFrames = _a2.maxFrames;
        var error, action;
        while ((action = actions[0]) && action.delay <= maxFrames) {
          actions.shift();
          this.frame = action.delay;
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        }
        if (error) {
          while (action = actions.shift()) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      VirtualTimeScheduler2.frameTimeFactor = 10;
      return VirtualTimeScheduler2;
    }(AsyncScheduler);
    VirtualAction = function(_super) {
      __extends(VirtualAction2, _super);
      function VirtualAction2(scheduler, work, index) {
        if (index === void 0) {
          index = scheduler.index += 1;
        }
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.index = index;
        _this.active = true;
        _this.index = scheduler.index = index;
        return _this;
      }
      VirtualAction2.prototype.schedule = function(state, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (!this.id) {
          return _super.prototype.schedule.call(this, state, delay2);
        }
        this.active = false;
        var action = new VirtualAction2(this.scheduler, this.work);
        this.add(action);
        return action.schedule(state, delay2);
      };
      VirtualAction2.prototype.requestAsyncId = function(scheduler, id2, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        this.delay = scheduler.frame + delay2;
        var actions = scheduler.actions;
        actions.push(this);
        actions.sort(VirtualAction2.sortActions);
        return true;
      };
      VirtualAction2.prototype.recycleAsyncId = function(scheduler, id2, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        return void 0;
      };
      VirtualAction2.prototype._execute = function(state, delay2) {
        if (this.active === true) {
          return _super.prototype._execute.call(this, state, delay2);
        }
      };
      VirtualAction2.sortActions = function(a5, b4) {
        if (a5.delay === b4.delay) {
          if (a5.index === b4.index) {
            return 0;
          } else if (a5.index > b4.index) {
            return 1;
          } else {
            return -1;
          }
        } else if (a5.delay > b4.delay) {
          return 1;
        } else {
          return -1;
        }
      };
      return VirtualAction2;
    }(AsyncAction);
  }
});

// node_modules/rxjs/_esm5/internal/util/noop.js
function noop2() {
}
var init_noop = __esm({
  "node_modules/rxjs/_esm5/internal/util/noop.js"() {
  }
});

// node_modules/rxjs/_esm5/internal/util/isObservable.js
function isObservable(obj) {
  return !!obj && (obj instanceof Observable || typeof obj.lift === "function" && typeof obj.subscribe === "function");
}
var init_isObservable = __esm({
  "node_modules/rxjs/_esm5/internal/util/isObservable.js"() {
    init_Observable();
  }
});

// node_modules/rxjs/_esm5/internal/util/ArgumentOutOfRangeError.js
var ArgumentOutOfRangeErrorImpl, ArgumentOutOfRangeError;
var init_ArgumentOutOfRangeError = __esm({
  "node_modules/rxjs/_esm5/internal/util/ArgumentOutOfRangeError.js"() {
    ArgumentOutOfRangeErrorImpl = function() {
      function ArgumentOutOfRangeErrorImpl2() {
        Error.call(this);
        this.message = "argument out of range";
        this.name = "ArgumentOutOfRangeError";
        return this;
      }
      ArgumentOutOfRangeErrorImpl2.prototype = Object.create(Error.prototype);
      return ArgumentOutOfRangeErrorImpl2;
    }();
    ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;
  }
});

// node_modules/rxjs/_esm5/internal/util/EmptyError.js
var EmptyErrorImpl, EmptyError;
var init_EmptyError = __esm({
  "node_modules/rxjs/_esm5/internal/util/EmptyError.js"() {
    EmptyErrorImpl = function() {
      function EmptyErrorImpl2() {
        Error.call(this);
        this.message = "no elements in sequence";
        this.name = "EmptyError";
        return this;
      }
      EmptyErrorImpl2.prototype = Object.create(Error.prototype);
      return EmptyErrorImpl2;
    }();
    EmptyError = EmptyErrorImpl;
  }
});

// node_modules/rxjs/_esm5/internal/util/TimeoutError.js
var TimeoutErrorImpl, TimeoutError;
var init_TimeoutError = __esm({
  "node_modules/rxjs/_esm5/internal/util/TimeoutError.js"() {
    TimeoutErrorImpl = function() {
      function TimeoutErrorImpl2() {
        Error.call(this);
        this.message = "Timeout has occurred";
        this.name = "TimeoutError";
        return this;
      }
      TimeoutErrorImpl2.prototype = Object.create(Error.prototype);
      return TimeoutErrorImpl2;
    }();
    TimeoutError = TimeoutErrorImpl;
  }
});

// node_modules/rxjs/_esm5/internal/operators/map.js
function map(project, thisArg) {
  return function mapOperation(source) {
    if (typeof project !== "function") {
      throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");
    }
    return source.lift(new MapOperator(project, thisArg));
  };
}
var MapOperator, MapSubscriber;
var init_map = __esm({
  "node_modules/rxjs/_esm5/internal/operators/map.js"() {
    init_tslib_es6();
    init_Subscriber();
    MapOperator = function() {
      function MapOperator2(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
      }
      MapOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
      };
      return MapOperator2;
    }();
    MapSubscriber = function(_super) {
      __extends(MapSubscriber2, _super);
      function MapSubscriber2(destination, project, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.count = 0;
        _this.thisArg = thisArg || _this;
        return _this;
      }
      MapSubscriber2.prototype._next = function(value2) {
        var result;
        try {
          result = this.project.call(this.thisArg, value2, this.count++);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        this.destination.next(result);
      };
      return MapSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/observable/bindCallback.js
function bindCallback(callbackFunc, resultSelector, scheduler) {
  if (resultSelector) {
    if (isScheduler(resultSelector)) {
      scheduler = resultSelector;
    } else {
      return function() {
        var args = [];
        for (var _i2 = 0; _i2 < arguments.length; _i2++) {
          args[_i2] = arguments[_i2];
        }
        return bindCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map(function(args2) {
          return isArray(args2) ? resultSelector.apply(void 0, args2) : resultSelector(args2);
        }));
      };
    }
  }
  return function() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    var context = this;
    var subject;
    var params = {
      context,
      subject,
      callbackFunc,
      scheduler
    };
    return new Observable(function(subscriber) {
      if (!scheduler) {
        if (!subject) {
          subject = new AsyncSubject();
          var handler = function() {
            var innerArgs = [];
            for (var _i3 = 0; _i3 < arguments.length; _i3++) {
              innerArgs[_i3] = arguments[_i3];
            }
            subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
            subject.complete();
          };
          try {
            callbackFunc.apply(context, args.concat([handler]));
          } catch (err) {
            if (canReportError(subject)) {
              subject.error(err);
            } else {
              console.warn(err);
            }
          }
        }
        return subject.subscribe(subscriber);
      } else {
        var state = {
          args,
          subscriber,
          params
        };
        return scheduler.schedule(dispatch2, 0, state);
      }
    });
  };
}
function dispatch2(state) {
  var _this = this;
  var self2 = this;
  var args = state.args, subscriber = state.subscriber, params = state.params;
  var callbackFunc = params.callbackFunc, context = params.context, scheduler = params.scheduler;
  var subject = params.subject;
  if (!subject) {
    subject = params.subject = new AsyncSubject();
    var handler = function() {
      var innerArgs = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        innerArgs[_i2] = arguments[_i2];
      }
      var value2 = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
      _this.add(scheduler.schedule(dispatchNext, 0, { value: value2, subject }));
    };
    try {
      callbackFunc.apply(context, args.concat([handler]));
    } catch (err) {
      subject.error(err);
    }
  }
  this.add(subject.subscribe(subscriber));
}
function dispatchNext(state) {
  var value2 = state.value, subject = state.subject;
  subject.next(value2);
  subject.complete();
}
var init_bindCallback = __esm({
  "node_modules/rxjs/_esm5/internal/observable/bindCallback.js"() {
    init_Observable();
    init_AsyncSubject();
    init_map();
    init_canReportError();
    init_isArray();
    init_isScheduler();
  }
});

// node_modules/rxjs/_esm5/internal/observable/bindNodeCallback.js
function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
  if (resultSelector) {
    if (isScheduler(resultSelector)) {
      scheduler = resultSelector;
    } else {
      return function() {
        var args = [];
        for (var _i2 = 0; _i2 < arguments.length; _i2++) {
          args[_i2] = arguments[_i2];
        }
        return bindNodeCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map(function(args2) {
          return isArray(args2) ? resultSelector.apply(void 0, args2) : resultSelector(args2);
        }));
      };
    }
  }
  return function() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    var params = {
      subject: void 0,
      args,
      callbackFunc,
      scheduler,
      context: this
    };
    return new Observable(function(subscriber) {
      var context = params.context;
      var subject = params.subject;
      if (!scheduler) {
        if (!subject) {
          subject = params.subject = new AsyncSubject();
          var handler = function() {
            var innerArgs = [];
            for (var _i3 = 0; _i3 < arguments.length; _i3++) {
              innerArgs[_i3] = arguments[_i3];
            }
            var err = innerArgs.shift();
            if (err) {
              subject.error(err);
              return;
            }
            subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
            subject.complete();
          };
          try {
            callbackFunc.apply(context, args.concat([handler]));
          } catch (err) {
            if (canReportError(subject)) {
              subject.error(err);
            } else {
              console.warn(err);
            }
          }
        }
        return subject.subscribe(subscriber);
      } else {
        return scheduler.schedule(dispatch3, 0, { params, subscriber, context });
      }
    });
  };
}
function dispatch3(state) {
  var _this = this;
  var params = state.params, subscriber = state.subscriber, context = state.context;
  var callbackFunc = params.callbackFunc, args = params.args, scheduler = params.scheduler;
  var subject = params.subject;
  if (!subject) {
    subject = params.subject = new AsyncSubject();
    var handler = function() {
      var innerArgs = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        innerArgs[_i2] = arguments[_i2];
      }
      var err = innerArgs.shift();
      if (err) {
        _this.add(scheduler.schedule(dispatchError, 0, { err, subject }));
      } else {
        var value2 = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
        _this.add(scheduler.schedule(dispatchNext2, 0, { value: value2, subject }));
      }
    };
    try {
      callbackFunc.apply(context, args.concat([handler]));
    } catch (err) {
      this.add(scheduler.schedule(dispatchError, 0, { err, subject }));
    }
  }
  this.add(subject.subscribe(subscriber));
}
function dispatchNext2(arg) {
  var value2 = arg.value, subject = arg.subject;
  subject.next(value2);
  subject.complete();
}
function dispatchError(arg) {
  var err = arg.err, subject = arg.subject;
  subject.error(err);
}
var init_bindNodeCallback = __esm({
  "node_modules/rxjs/_esm5/internal/observable/bindNodeCallback.js"() {
    init_Observable();
    init_AsyncSubject();
    init_map();
    init_canReportError();
    init_isScheduler();
    init_isArray();
  }
});

// node_modules/rxjs/_esm5/internal/OuterSubscriber.js
var OuterSubscriber;
var init_OuterSubscriber = __esm({
  "node_modules/rxjs/_esm5/internal/OuterSubscriber.js"() {
    init_tslib_es6();
    init_Subscriber();
    OuterSubscriber = function(_super) {
      __extends(OuterSubscriber2, _super);
      function OuterSubscriber2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      OuterSubscriber2.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
      };
      OuterSubscriber2.prototype.notifyError = function(error, innerSub) {
        this.destination.error(error);
      };
      OuterSubscriber2.prototype.notifyComplete = function(innerSub) {
        this.destination.complete();
      };
      return OuterSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/InnerSubscriber.js
var InnerSubscriber;
var init_InnerSubscriber = __esm({
  "node_modules/rxjs/_esm5/internal/InnerSubscriber.js"() {
    init_tslib_es6();
    init_Subscriber();
    InnerSubscriber = function(_super) {
      __extends(InnerSubscriber2, _super);
      function InnerSubscriber2(parent, outerValue, outerIndex) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.outerValue = outerValue;
        _this.outerIndex = outerIndex;
        _this.index = 0;
        return _this;
      }
      InnerSubscriber2.prototype._next = function(value2) {
        this.parent.notifyNext(this.outerValue, value2, this.outerIndex, this.index++, this);
      };
      InnerSubscriber2.prototype._error = function(error) {
        this.parent.notifyError(error, this);
        this.unsubscribe();
      };
      InnerSubscriber2.prototype._complete = function() {
        this.parent.notifyComplete(this);
        this.unsubscribe();
      };
      return InnerSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/util/subscribeToPromise.js
var subscribeToPromise;
var init_subscribeToPromise = __esm({
  "node_modules/rxjs/_esm5/internal/util/subscribeToPromise.js"() {
    init_hostReportError();
    subscribeToPromise = function(promise) {
      return function(subscriber) {
        promise.then(function(value2) {
          if (!subscriber.closed) {
            subscriber.next(value2);
            subscriber.complete();
          }
        }, function(err) {
          return subscriber.error(err);
        }).then(null, hostReportError);
        return subscriber;
      };
    };
  }
});

// node_modules/rxjs/_esm5/internal/symbol/iterator.js
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator;
var init_iterator = __esm({
  "node_modules/rxjs/_esm5/internal/symbol/iterator.js"() {
    iterator = getSymbolIterator();
  }
});

// node_modules/rxjs/_esm5/internal/util/subscribeToIterable.js
var subscribeToIterable;
var init_subscribeToIterable = __esm({
  "node_modules/rxjs/_esm5/internal/util/subscribeToIterable.js"() {
    init_iterator();
    subscribeToIterable = function(iterable) {
      return function(subscriber) {
        var iterator2 = iterable[iterator]();
        do {
          var item = void 0;
          try {
            item = iterator2.next();
          } catch (err) {
            subscriber.error(err);
            return subscriber;
          }
          if (item.done) {
            subscriber.complete();
            break;
          }
          subscriber.next(item.value);
          if (subscriber.closed) {
            break;
          }
        } while (true);
        if (typeof iterator2.return === "function") {
          subscriber.add(function() {
            if (iterator2.return) {
              iterator2.return();
            }
          });
        }
        return subscriber;
      };
    };
  }
});

// node_modules/rxjs/_esm5/internal/util/subscribeToObservable.js
var subscribeToObservable;
var init_subscribeToObservable = __esm({
  "node_modules/rxjs/_esm5/internal/util/subscribeToObservable.js"() {
    init_observable();
    subscribeToObservable = function(obj) {
      return function(subscriber) {
        var obs = obj[observable]();
        if (typeof obs.subscribe !== "function") {
          throw new TypeError("Provided object does not correctly implement Symbol.observable");
        } else {
          return obs.subscribe(subscriber);
        }
      };
    };
  }
});

// node_modules/rxjs/_esm5/internal/util/isArrayLike.js
var isArrayLike;
var init_isArrayLike = __esm({
  "node_modules/rxjs/_esm5/internal/util/isArrayLike.js"() {
    isArrayLike = function(x6) {
      return x6 && typeof x6.length === "number" && typeof x6 !== "function";
    };
  }
});

// node_modules/rxjs/_esm5/internal/util/isPromise.js
function isPromise(value2) {
  return !!value2 && typeof value2.subscribe !== "function" && typeof value2.then === "function";
}
var init_isPromise = __esm({
  "node_modules/rxjs/_esm5/internal/util/isPromise.js"() {
  }
});

// node_modules/rxjs/_esm5/internal/util/subscribeTo.js
var subscribeTo;
var init_subscribeTo = __esm({
  "node_modules/rxjs/_esm5/internal/util/subscribeTo.js"() {
    init_subscribeToArray();
    init_subscribeToPromise();
    init_subscribeToIterable();
    init_subscribeToObservable();
    init_isArrayLike();
    init_isPromise();
    init_isObject();
    init_iterator();
    init_observable();
    subscribeTo = function(result) {
      if (!!result && typeof result[observable] === "function") {
        return subscribeToObservable(result);
      } else if (isArrayLike(result)) {
        return subscribeToArray(result);
      } else if (isPromise(result)) {
        return subscribeToPromise(result);
      } else if (!!result && typeof result[iterator] === "function") {
        return subscribeToIterable(result);
      } else {
        var value2 = isObject(result) ? "an invalid object" : "'" + result + "'";
        var msg = "You provided " + value2 + " where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.";
        throw new TypeError(msg);
      }
    };
  }
});

// node_modules/rxjs/_esm5/internal/util/subscribeToResult.js
function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, innerSubscriber) {
  if (innerSubscriber === void 0) {
    innerSubscriber = new InnerSubscriber(outerSubscriber, outerValue, outerIndex);
  }
  if (innerSubscriber.closed) {
    return void 0;
  }
  if (result instanceof Observable) {
    return result.subscribe(innerSubscriber);
  }
  return subscribeTo(result)(innerSubscriber);
}
var init_subscribeToResult = __esm({
  "node_modules/rxjs/_esm5/internal/util/subscribeToResult.js"() {
    init_InnerSubscriber();
    init_subscribeTo();
    init_Observable();
  }
});

// node_modules/rxjs/_esm5/internal/observable/combineLatest.js
function combineLatest() {
  var observables = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    observables[_i2] = arguments[_i2];
  }
  var resultSelector = void 0;
  var scheduler = void 0;
  if (isScheduler(observables[observables.length - 1])) {
    scheduler = observables.pop();
  }
  if (typeof observables[observables.length - 1] === "function") {
    resultSelector = observables.pop();
  }
  if (observables.length === 1 && isArray(observables[0])) {
    observables = observables[0];
  }
  return fromArray(observables, scheduler).lift(new CombineLatestOperator(resultSelector));
}
var NONE, CombineLatestOperator, CombineLatestSubscriber;
var init_combineLatest = __esm({
  "node_modules/rxjs/_esm5/internal/observable/combineLatest.js"() {
    init_tslib_es6();
    init_isScheduler();
    init_isArray();
    init_OuterSubscriber();
    init_subscribeToResult();
    init_fromArray();
    NONE = {};
    CombineLatestOperator = function() {
      function CombineLatestOperator2(resultSelector) {
        this.resultSelector = resultSelector;
      }
      CombineLatestOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
      };
      return CombineLatestOperator2;
    }();
    CombineLatestSubscriber = function(_super) {
      __extends(CombineLatestSubscriber2, _super);
      function CombineLatestSubscriber2(destination, resultSelector) {
        var _this = _super.call(this, destination) || this;
        _this.resultSelector = resultSelector;
        _this.active = 0;
        _this.values = [];
        _this.observables = [];
        return _this;
      }
      CombineLatestSubscriber2.prototype._next = function(observable2) {
        this.values.push(NONE);
        this.observables.push(observable2);
      };
      CombineLatestSubscriber2.prototype._complete = function() {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
          this.destination.complete();
        } else {
          this.active = len;
          this.toRespond = len;
          for (var i6 = 0; i6 < len; i6++) {
            var observable2 = observables[i6];
            this.add(subscribeToResult(this, observable2, void 0, i6));
          }
        }
      };
      CombineLatestSubscriber2.prototype.notifyComplete = function(unused) {
        if ((this.active -= 1) === 0) {
          this.destination.complete();
        }
      };
      CombineLatestSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
        var values = this.values;
        var oldVal = values[outerIndex];
        var toRespond = !this.toRespond ? 0 : oldVal === NONE ? --this.toRespond : this.toRespond;
        values[outerIndex] = innerValue;
        if (toRespond === 0) {
          if (this.resultSelector) {
            this._tryResultSelector(values);
          } else {
            this.destination.next(values.slice());
          }
        }
      };
      CombineLatestSubscriber2.prototype._tryResultSelector = function(values) {
        var result;
        try {
          result = this.resultSelector.apply(this, values);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        this.destination.next(result);
      };
      return CombineLatestSubscriber2;
    }(OuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/scheduled/scheduleObservable.js
function scheduleObservable(input, scheduler) {
  return new Observable(function(subscriber) {
    var sub = new Subscription();
    sub.add(scheduler.schedule(function() {
      var observable2 = input[observable]();
      sub.add(observable2.subscribe({
        next: function(value2) {
          sub.add(scheduler.schedule(function() {
            return subscriber.next(value2);
          }));
        },
        error: function(err) {
          sub.add(scheduler.schedule(function() {
            return subscriber.error(err);
          }));
        },
        complete: function() {
          sub.add(scheduler.schedule(function() {
            return subscriber.complete();
          }));
        }
      }));
    }));
    return sub;
  });
}
var init_scheduleObservable = __esm({
  "node_modules/rxjs/_esm5/internal/scheduled/scheduleObservable.js"() {
    init_Observable();
    init_Subscription();
    init_observable();
  }
});

// node_modules/rxjs/_esm5/internal/scheduled/schedulePromise.js
function schedulePromise(input, scheduler) {
  return new Observable(function(subscriber) {
    var sub = new Subscription();
    sub.add(scheduler.schedule(function() {
      return input.then(function(value2) {
        sub.add(scheduler.schedule(function() {
          subscriber.next(value2);
          sub.add(scheduler.schedule(function() {
            return subscriber.complete();
          }));
        }));
      }, function(err) {
        sub.add(scheduler.schedule(function() {
          return subscriber.error(err);
        }));
      });
    }));
    return sub;
  });
}
var init_schedulePromise = __esm({
  "node_modules/rxjs/_esm5/internal/scheduled/schedulePromise.js"() {
    init_Observable();
    init_Subscription();
  }
});

// node_modules/rxjs/_esm5/internal/scheduled/scheduleIterable.js
function scheduleIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable(function(subscriber) {
    var sub = new Subscription();
    var iterator2;
    sub.add(function() {
      if (iterator2 && typeof iterator2.return === "function") {
        iterator2.return();
      }
    });
    sub.add(scheduler.schedule(function() {
      iterator2 = input[iterator]();
      sub.add(scheduler.schedule(function() {
        if (subscriber.closed) {
          return;
        }
        var value2;
        var done;
        try {
          var result = iterator2.next();
          value2 = result.value;
          done = result.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value2);
          this.schedule();
        }
      }));
    }));
    return sub;
  });
}
var init_scheduleIterable = __esm({
  "node_modules/rxjs/_esm5/internal/scheduled/scheduleIterable.js"() {
    init_Observable();
    init_Subscription();
    init_iterator();
  }
});

// node_modules/rxjs/_esm5/internal/util/isInteropObservable.js
function isInteropObservable(input) {
  return input && typeof input[observable] === "function";
}
var init_isInteropObservable = __esm({
  "node_modules/rxjs/_esm5/internal/util/isInteropObservable.js"() {
    init_observable();
  }
});

// node_modules/rxjs/_esm5/internal/util/isIterable.js
function isIterable(input) {
  return input && typeof input[iterator] === "function";
}
var init_isIterable = __esm({
  "node_modules/rxjs/_esm5/internal/util/isIterable.js"() {
    init_iterator();
  }
});

// node_modules/rxjs/_esm5/internal/scheduled/scheduled.js
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    } else if (isPromise(input)) {
      return schedulePromise(input, scheduler);
    } else if (isArrayLike(input)) {
      return scheduleArray(input, scheduler);
    } else if (isIterable(input) || typeof input === "string") {
      return scheduleIterable(input, scheduler);
    }
  }
  throw new TypeError((input !== null && typeof input || input) + " is not observable");
}
var init_scheduled = __esm({
  "node_modules/rxjs/_esm5/internal/scheduled/scheduled.js"() {
    init_scheduleObservable();
    init_schedulePromise();
    init_scheduleArray();
    init_scheduleIterable();
    init_isInteropObservable();
    init_isPromise();
    init_isArrayLike();
    init_isIterable();
  }
});

// node_modules/rxjs/_esm5/internal/observable/from.js
function from(input, scheduler) {
  if (!scheduler) {
    if (input instanceof Observable) {
      return input;
    }
    return new Observable(subscribeTo(input));
  } else {
    return scheduled(input, scheduler);
  }
}
var init_from = __esm({
  "node_modules/rxjs/_esm5/internal/observable/from.js"() {
    init_Observable();
    init_subscribeTo();
    init_scheduled();
  }
});

// node_modules/rxjs/_esm5/internal/innerSubscribe.js
function innerSubscribe(result, innerSubscriber) {
  if (innerSubscriber.closed) {
    return void 0;
  }
  if (result instanceof Observable) {
    return result.subscribe(innerSubscriber);
  }
  var subscription;
  try {
    subscription = subscribeTo(result)(innerSubscriber);
  } catch (error) {
    innerSubscriber.error(error);
  }
  return subscription;
}
var SimpleInnerSubscriber, ComplexInnerSubscriber, SimpleOuterSubscriber, ComplexOuterSubscriber;
var init_innerSubscribe = __esm({
  "node_modules/rxjs/_esm5/internal/innerSubscribe.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_Observable();
    init_subscribeTo();
    SimpleInnerSubscriber = function(_super) {
      __extends(SimpleInnerSubscriber2, _super);
      function SimpleInnerSubscriber2(parent) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        return _this;
      }
      SimpleInnerSubscriber2.prototype._next = function(value2) {
        this.parent.notifyNext(value2);
      };
      SimpleInnerSubscriber2.prototype._error = function(error) {
        this.parent.notifyError(error);
        this.unsubscribe();
      };
      SimpleInnerSubscriber2.prototype._complete = function() {
        this.parent.notifyComplete();
        this.unsubscribe();
      };
      return SimpleInnerSubscriber2;
    }(Subscriber);
    ComplexInnerSubscriber = function(_super) {
      __extends(ComplexInnerSubscriber2, _super);
      function ComplexInnerSubscriber2(parent, outerValue, outerIndex) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.outerValue = outerValue;
        _this.outerIndex = outerIndex;
        return _this;
      }
      ComplexInnerSubscriber2.prototype._next = function(value2) {
        this.parent.notifyNext(this.outerValue, value2, this.outerIndex, this);
      };
      ComplexInnerSubscriber2.prototype._error = function(error) {
        this.parent.notifyError(error);
        this.unsubscribe();
      };
      ComplexInnerSubscriber2.prototype._complete = function() {
        this.parent.notifyComplete(this);
        this.unsubscribe();
      };
      return ComplexInnerSubscriber2;
    }(Subscriber);
    SimpleOuterSubscriber = function(_super) {
      __extends(SimpleOuterSubscriber2, _super);
      function SimpleOuterSubscriber2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      SimpleOuterSubscriber2.prototype.notifyNext = function(innerValue) {
        this.destination.next(innerValue);
      };
      SimpleOuterSubscriber2.prototype.notifyError = function(err) {
        this.destination.error(err);
      };
      SimpleOuterSubscriber2.prototype.notifyComplete = function() {
        this.destination.complete();
      };
      return SimpleOuterSubscriber2;
    }(Subscriber);
    ComplexOuterSubscriber = function(_super) {
      __extends(ComplexOuterSubscriber2, _super);
      function ComplexOuterSubscriber2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      ComplexOuterSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, _outerIndex, _innerSub) {
        this.destination.next(innerValue);
      };
      ComplexOuterSubscriber2.prototype.notifyError = function(error) {
        this.destination.error(error);
      };
      ComplexOuterSubscriber2.prototype.notifyComplete = function(_innerSub) {
        this.destination.complete();
      };
      return ComplexOuterSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/mergeMap.js
function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  if (typeof resultSelector === "function") {
    return function(source) {
      return source.pipe(mergeMap(function(a5, i6) {
        return from(project(a5, i6)).pipe(map(function(b4, ii3) {
          return resultSelector(a5, b4, i6, ii3);
        }));
      }, concurrent));
    };
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return function(source) {
    return source.lift(new MergeMapOperator(project, concurrent));
  };
}
var MergeMapOperator, MergeMapSubscriber, flatMap;
var init_mergeMap = __esm({
  "node_modules/rxjs/_esm5/internal/operators/mergeMap.js"() {
    init_tslib_es6();
    init_map();
    init_from();
    init_innerSubscribe();
    MergeMapOperator = function() {
      function MergeMapOperator2(project, concurrent) {
        if (concurrent === void 0) {
          concurrent = Number.POSITIVE_INFINITY;
        }
        this.project = project;
        this.concurrent = concurrent;
      }
      MergeMapOperator2.prototype.call = function(observer, source) {
        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
      };
      return MergeMapOperator2;
    }();
    MergeMapSubscriber = function(_super) {
      __extends(MergeMapSubscriber2, _super);
      function MergeMapSubscriber2(destination, project, concurrent) {
        if (concurrent === void 0) {
          concurrent = Number.POSITIVE_INFINITY;
        }
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.concurrent = concurrent;
        _this.hasCompleted = false;
        _this.buffer = [];
        _this.active = 0;
        _this.index = 0;
        return _this;
      }
      MergeMapSubscriber2.prototype._next = function(value2) {
        if (this.active < this.concurrent) {
          this._tryNext(value2);
        } else {
          this.buffer.push(value2);
        }
      };
      MergeMapSubscriber2.prototype._tryNext = function(value2) {
        var result;
        var index = this.index++;
        try {
          result = this.project(value2, index);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        this.active++;
        this._innerSub(result);
      };
      MergeMapSubscriber2.prototype._innerSub = function(ish) {
        var innerSubscriber = new SimpleInnerSubscriber(this);
        var destination = this.destination;
        destination.add(innerSubscriber);
        var innerSubscription = innerSubscribe(ish, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
          destination.add(innerSubscription);
        }
      };
      MergeMapSubscriber2.prototype._complete = function() {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
          this.destination.complete();
        }
        this.unsubscribe();
      };
      MergeMapSubscriber2.prototype.notifyNext = function(innerValue) {
        this.destination.next(innerValue);
      };
      MergeMapSubscriber2.prototype.notifyComplete = function() {
        var buffer2 = this.buffer;
        this.active--;
        if (buffer2.length > 0) {
          this._next(buffer2.shift());
        } else if (this.active === 0 && this.hasCompleted) {
          this.destination.complete();
        }
      };
      return MergeMapSubscriber2;
    }(SimpleOuterSubscriber);
    flatMap = mergeMap;
  }
});

// node_modules/rxjs/_esm5/internal/operators/mergeAll.js
function mergeAll(concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  return mergeMap(identity, concurrent);
}
var init_mergeAll = __esm({
  "node_modules/rxjs/_esm5/internal/operators/mergeAll.js"() {
    init_mergeMap();
    init_identity();
  }
});

// node_modules/rxjs/_esm5/internal/operators/concatAll.js
function concatAll() {
  return mergeAll(1);
}
var init_concatAll = __esm({
  "node_modules/rxjs/_esm5/internal/operators/concatAll.js"() {
    init_mergeAll();
  }
});

// node_modules/rxjs/_esm5/internal/observable/concat.js
function concat2() {
  var observables = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    observables[_i2] = arguments[_i2];
  }
  return concatAll()(of.apply(void 0, observables));
}
var init_concat = __esm({
  "node_modules/rxjs/_esm5/internal/observable/concat.js"() {
    init_of();
    init_concatAll();
  }
});

// node_modules/rxjs/_esm5/internal/observable/defer.js
function defer(observableFactory) {
  return new Observable(function(subscriber) {
    var input;
    try {
      input = observableFactory();
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    var source = input ? from(input) : empty2();
    return source.subscribe(subscriber);
  });
}
var init_defer = __esm({
  "node_modules/rxjs/_esm5/internal/observable/defer.js"() {
    init_Observable();
    init_from();
    init_empty();
  }
});

// node_modules/rxjs/_esm5/internal/observable/forkJoin.js
function forkJoin() {
  var sources = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    sources[_i2] = arguments[_i2];
  }
  if (sources.length === 1) {
    var first_1 = sources[0];
    if (isArray(first_1)) {
      return forkJoinInternal(first_1, null);
    }
    if (isObject(first_1) && Object.getPrototypeOf(first_1) === Object.prototype) {
      var keys = Object.keys(first_1);
      return forkJoinInternal(keys.map(function(key2) {
        return first_1[key2];
      }), keys);
    }
  }
  if (typeof sources[sources.length - 1] === "function") {
    var resultSelector_1 = sources.pop();
    sources = sources.length === 1 && isArray(sources[0]) ? sources[0] : sources;
    return forkJoinInternal(sources, null).pipe(map(function(args) {
      return resultSelector_1.apply(void 0, args);
    }));
  }
  return forkJoinInternal(sources, null);
}
function forkJoinInternal(sources, keys) {
  return new Observable(function(subscriber) {
    var len = sources.length;
    if (len === 0) {
      subscriber.complete();
      return;
    }
    var values = new Array(len);
    var completed = 0;
    var emitted = 0;
    var _loop_1 = function(i7) {
      var source = from(sources[i7]);
      var hasValue = false;
      subscriber.add(source.subscribe({
        next: function(value2) {
          if (!hasValue) {
            hasValue = true;
            emitted++;
          }
          values[i7] = value2;
        },
        error: function(err) {
          return subscriber.error(err);
        },
        complete: function() {
          completed++;
          if (completed === len || !hasValue) {
            if (emitted === len) {
              subscriber.next(keys ? keys.reduce(function(result, key2, i8) {
                return result[key2] = values[i8], result;
              }, {}) : values);
            }
            subscriber.complete();
          }
        }
      }));
    };
    for (var i6 = 0; i6 < len; i6++) {
      _loop_1(i6);
    }
  });
}
var init_forkJoin = __esm({
  "node_modules/rxjs/_esm5/internal/observable/forkJoin.js"() {
    init_Observable();
    init_isArray();
    init_map();
    init_isObject();
    init_from();
  }
});

// node_modules/rxjs/_esm5/internal/observable/fromEvent.js
function fromEvent(target, eventName, options, resultSelector) {
  if (isFunction(options)) {
    resultSelector = options;
    options = void 0;
  }
  if (resultSelector) {
    return fromEvent(target, eventName, options).pipe(map(function(args) {
      return isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args);
    }));
  }
  return new Observable(function(subscriber) {
    function handler(e6) {
      if (arguments.length > 1) {
        subscriber.next(Array.prototype.slice.call(arguments));
      } else {
        subscriber.next(e6);
      }
    }
    setupSubscription(target, eventName, handler, subscriber, options);
  });
}
function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
  var unsubscribe;
  if (isEventTarget(sourceObj)) {
    var source_1 = sourceObj;
    sourceObj.addEventListener(eventName, handler, options);
    unsubscribe = function() {
      return source_1.removeEventListener(eventName, handler, options);
    };
  } else if (isJQueryStyleEventEmitter(sourceObj)) {
    var source_2 = sourceObj;
    sourceObj.on(eventName, handler);
    unsubscribe = function() {
      return source_2.off(eventName, handler);
    };
  } else if (isNodeStyleEventEmitter(sourceObj)) {
    var source_3 = sourceObj;
    sourceObj.addListener(eventName, handler);
    unsubscribe = function() {
      return source_3.removeListener(eventName, handler);
    };
  } else if (sourceObj && sourceObj.length) {
    for (var i6 = 0, len = sourceObj.length; i6 < len; i6++) {
      setupSubscription(sourceObj[i6], eventName, handler, subscriber, options);
    }
  } else {
    throw new TypeError("Invalid event target");
  }
  subscriber.add(unsubscribe);
}
function isNodeStyleEventEmitter(sourceObj) {
  return sourceObj && typeof sourceObj.addListener === "function" && typeof sourceObj.removeListener === "function";
}
function isJQueryStyleEventEmitter(sourceObj) {
  return sourceObj && typeof sourceObj.on === "function" && typeof sourceObj.off === "function";
}
function isEventTarget(sourceObj) {
  return sourceObj && typeof sourceObj.addEventListener === "function" && typeof sourceObj.removeEventListener === "function";
}
var toString;
var init_fromEvent = __esm({
  "node_modules/rxjs/_esm5/internal/observable/fromEvent.js"() {
    init_Observable();
    init_isArray();
    init_isFunction();
    init_map();
    toString = function() {
      return Object.prototype.toString;
    }();
  }
});

// node_modules/rxjs/_esm5/internal/observable/fromEventPattern.js
function fromEventPattern(addHandler, removeHandler, resultSelector) {
  if (resultSelector) {
    return fromEventPattern(addHandler, removeHandler).pipe(map(function(args) {
      return isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args);
    }));
  }
  return new Observable(function(subscriber) {
    var handler = function() {
      var e6 = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        e6[_i2] = arguments[_i2];
      }
      return subscriber.next(e6.length === 1 ? e6[0] : e6);
    };
    var retValue;
    try {
      retValue = addHandler(handler);
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    if (!isFunction(removeHandler)) {
      return void 0;
    }
    return function() {
      return removeHandler(handler, retValue);
    };
  });
}
var init_fromEventPattern = __esm({
  "node_modules/rxjs/_esm5/internal/observable/fromEventPattern.js"() {
    init_Observable();
    init_isArray();
    init_isFunction();
    init_map();
  }
});

// node_modules/rxjs/_esm5/internal/observable/generate.js
function generate2(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {
  var resultSelector;
  var initialState;
  if (arguments.length == 1) {
    var options = initialStateOrOptions;
    initialState = options.initialState;
    condition = options.condition;
    iterate = options.iterate;
    resultSelector = options.resultSelector || identity;
    scheduler = options.scheduler;
  } else if (resultSelectorOrObservable === void 0 || isScheduler(resultSelectorOrObservable)) {
    initialState = initialStateOrOptions;
    resultSelector = identity;
    scheduler = resultSelectorOrObservable;
  } else {
    initialState = initialStateOrOptions;
    resultSelector = resultSelectorOrObservable;
  }
  return new Observable(function(subscriber) {
    var state = initialState;
    if (scheduler) {
      return scheduler.schedule(dispatch4, 0, {
        subscriber,
        iterate,
        condition,
        resultSelector,
        state
      });
    }
    do {
      if (condition) {
        var conditionResult = void 0;
        try {
          conditionResult = condition(state);
        } catch (err) {
          subscriber.error(err);
          return void 0;
        }
        if (!conditionResult) {
          subscriber.complete();
          break;
        }
      }
      var value2 = void 0;
      try {
        value2 = resultSelector(state);
      } catch (err) {
        subscriber.error(err);
        return void 0;
      }
      subscriber.next(value2);
      if (subscriber.closed) {
        break;
      }
      try {
        state = iterate(state);
      } catch (err) {
        subscriber.error(err);
        return void 0;
      }
    } while (true);
    return void 0;
  });
}
function dispatch4(state) {
  var subscriber = state.subscriber, condition = state.condition;
  if (subscriber.closed) {
    return void 0;
  }
  if (state.needIterate) {
    try {
      state.state = state.iterate(state.state);
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
  } else {
    state.needIterate = true;
  }
  if (condition) {
    var conditionResult = void 0;
    try {
      conditionResult = condition(state.state);
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    if (!conditionResult) {
      subscriber.complete();
      return void 0;
    }
    if (subscriber.closed) {
      return void 0;
    }
  }
  var value2;
  try {
    value2 = state.resultSelector(state.state);
  } catch (err) {
    subscriber.error(err);
    return void 0;
  }
  if (subscriber.closed) {
    return void 0;
  }
  subscriber.next(value2);
  if (subscriber.closed) {
    return void 0;
  }
  return this.schedule(state);
}
var init_generate = __esm({
  "node_modules/rxjs/_esm5/internal/observable/generate.js"() {
    init_Observable();
    init_identity();
    init_isScheduler();
  }
});

// node_modules/rxjs/_esm5/internal/observable/iif.js
function iif(condition, trueResult, falseResult) {
  if (trueResult === void 0) {
    trueResult = EMPTY;
  }
  if (falseResult === void 0) {
    falseResult = EMPTY;
  }
  return defer(function() {
    return condition() ? trueResult : falseResult;
  });
}
var init_iif = __esm({
  "node_modules/rxjs/_esm5/internal/observable/iif.js"() {
    init_defer();
    init_empty();
  }
});

// node_modules/rxjs/_esm5/internal/util/isNumeric.js
function isNumeric(val) {
  return !isArray(val) && val - parseFloat(val) + 1 >= 0;
}
var init_isNumeric = __esm({
  "node_modules/rxjs/_esm5/internal/util/isNumeric.js"() {
    init_isArray();
  }
});

// node_modules/rxjs/_esm5/internal/observable/interval.js
function interval(period, scheduler) {
  if (period === void 0) {
    period = 0;
  }
  if (scheduler === void 0) {
    scheduler = async;
  }
  if (!isNumeric(period) || period < 0) {
    period = 0;
  }
  if (!scheduler || typeof scheduler.schedule !== "function") {
    scheduler = async;
  }
  return new Observable(function(subscriber) {
    subscriber.add(scheduler.schedule(dispatch5, period, { subscriber, counter: 0, period }));
    return subscriber;
  });
}
function dispatch5(state) {
  var subscriber = state.subscriber, counter = state.counter, period = state.period;
  subscriber.next(counter);
  this.schedule({ subscriber, counter: counter + 1, period }, period);
}
var init_interval = __esm({
  "node_modules/rxjs/_esm5/internal/observable/interval.js"() {
    init_Observable();
    init_async();
    init_isNumeric();
  }
});

// node_modules/rxjs/_esm5/internal/observable/merge.js
function merge() {
  var observables = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    observables[_i2] = arguments[_i2];
  }
  var concurrent = Number.POSITIVE_INFINITY;
  var scheduler = null;
  var last2 = observables[observables.length - 1];
  if (isScheduler(last2)) {
    scheduler = observables.pop();
    if (observables.length > 1 && typeof observables[observables.length - 1] === "number") {
      concurrent = observables.pop();
    }
  } else if (typeof last2 === "number") {
    concurrent = observables.pop();
  }
  if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable) {
    return observables[0];
  }
  return mergeAll(concurrent)(fromArray(observables, scheduler));
}
var init_merge = __esm({
  "node_modules/rxjs/_esm5/internal/observable/merge.js"() {
    init_Observable();
    init_isScheduler();
    init_mergeAll();
    init_fromArray();
  }
});

// node_modules/rxjs/_esm5/internal/observable/never.js
function never() {
  return NEVER;
}
var NEVER;
var init_never = __esm({
  "node_modules/rxjs/_esm5/internal/observable/never.js"() {
    init_Observable();
    init_noop();
    NEVER = new Observable(noop2);
  }
});

// node_modules/rxjs/_esm5/internal/observable/onErrorResumeNext.js
function onErrorResumeNext() {
  var sources = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    sources[_i2] = arguments[_i2];
  }
  if (sources.length === 0) {
    return EMPTY;
  }
  var first2 = sources[0], remainder = sources.slice(1);
  if (sources.length === 1 && isArray(first2)) {
    return onErrorResumeNext.apply(void 0, first2);
  }
  return new Observable(function(subscriber) {
    var subNext = function() {
      return subscriber.add(onErrorResumeNext.apply(void 0, remainder).subscribe(subscriber));
    };
    return from(first2).subscribe({
      next: function(value2) {
        subscriber.next(value2);
      },
      error: subNext,
      complete: subNext
    });
  });
}
var init_onErrorResumeNext = __esm({
  "node_modules/rxjs/_esm5/internal/observable/onErrorResumeNext.js"() {
    init_Observable();
    init_from();
    init_isArray();
    init_empty();
  }
});

// node_modules/rxjs/_esm5/internal/observable/pairs.js
function pairs(obj, scheduler) {
  if (!scheduler) {
    return new Observable(function(subscriber) {
      var keys = Object.keys(obj);
      for (var i6 = 0; i6 < keys.length && !subscriber.closed; i6++) {
        var key2 = keys[i6];
        if (obj.hasOwnProperty(key2)) {
          subscriber.next([key2, obj[key2]]);
        }
      }
      subscriber.complete();
    });
  } else {
    return new Observable(function(subscriber) {
      var keys = Object.keys(obj);
      var subscription = new Subscription();
      subscription.add(scheduler.schedule(dispatch6, 0, { keys, index: 0, subscriber, subscription, obj }));
      return subscription;
    });
  }
}
function dispatch6(state) {
  var keys = state.keys, index = state.index, subscriber = state.subscriber, subscription = state.subscription, obj = state.obj;
  if (!subscriber.closed) {
    if (index < keys.length) {
      var key2 = keys[index];
      subscriber.next([key2, obj[key2]]);
      subscription.add(this.schedule({ keys, index: index + 1, subscriber, subscription, obj }));
    } else {
      subscriber.complete();
    }
  }
}
var init_pairs = __esm({
  "node_modules/rxjs/_esm5/internal/observable/pairs.js"() {
    init_Observable();
    init_Subscription();
  }
});

// node_modules/rxjs/_esm5/internal/util/not.js
function not(pred, thisArg) {
  function notPred() {
    return !notPred.pred.apply(notPred.thisArg, arguments);
  }
  notPred.pred = pred;
  notPred.thisArg = thisArg;
  return notPred;
}
var init_not = __esm({
  "node_modules/rxjs/_esm5/internal/util/not.js"() {
  }
});

// node_modules/rxjs/_esm5/internal/operators/filter.js
function filter(predicate, thisArg) {
  return function filterOperatorFunction(source) {
    return source.lift(new FilterOperator(predicate, thisArg));
  };
}
var FilterOperator, FilterSubscriber;
var init_filter = __esm({
  "node_modules/rxjs/_esm5/internal/operators/filter.js"() {
    init_tslib_es6();
    init_Subscriber();
    FilterOperator = function() {
      function FilterOperator2(predicate, thisArg) {
        this.predicate = predicate;
        this.thisArg = thisArg;
      }
      FilterOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
      };
      return FilterOperator2;
    }();
    FilterSubscriber = function(_super) {
      __extends(FilterSubscriber2, _super);
      function FilterSubscriber2(destination, predicate, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.thisArg = thisArg;
        _this.count = 0;
        return _this;
      }
      FilterSubscriber2.prototype._next = function(value2) {
        var result;
        try {
          result = this.predicate.call(this.thisArg, value2, this.count++);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        if (result) {
          this.destination.next(value2);
        }
      };
      return FilterSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/observable/partition.js
function partition(source, predicate, thisArg) {
  return [
    filter(predicate, thisArg)(new Observable(subscribeTo(source))),
    filter(not(predicate, thisArg))(new Observable(subscribeTo(source)))
  ];
}
var init_partition = __esm({
  "node_modules/rxjs/_esm5/internal/observable/partition.js"() {
    init_not();
    init_subscribeTo();
    init_filter();
    init_Observable();
  }
});

// node_modules/rxjs/_esm5/internal/observable/race.js
function race() {
  var observables = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    observables[_i2] = arguments[_i2];
  }
  if (observables.length === 1) {
    if (isArray(observables[0])) {
      observables = observables[0];
    } else {
      return observables[0];
    }
  }
  return fromArray(observables, void 0).lift(new RaceOperator());
}
var RaceOperator, RaceSubscriber;
var init_race = __esm({
  "node_modules/rxjs/_esm5/internal/observable/race.js"() {
    init_tslib_es6();
    init_isArray();
    init_fromArray();
    init_OuterSubscriber();
    init_subscribeToResult();
    RaceOperator = function() {
      function RaceOperator2() {
      }
      RaceOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new RaceSubscriber(subscriber));
      };
      return RaceOperator2;
    }();
    RaceSubscriber = function(_super) {
      __extends(RaceSubscriber2, _super);
      function RaceSubscriber2(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasFirst = false;
        _this.observables = [];
        _this.subscriptions = [];
        return _this;
      }
      RaceSubscriber2.prototype._next = function(observable2) {
        this.observables.push(observable2);
      };
      RaceSubscriber2.prototype._complete = function() {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
          this.destination.complete();
        } else {
          for (var i6 = 0; i6 < len && !this.hasFirst; i6++) {
            var observable2 = observables[i6];
            var subscription = subscribeToResult(this, observable2, void 0, i6);
            if (this.subscriptions) {
              this.subscriptions.push(subscription);
            }
            this.add(subscription);
          }
          this.observables = null;
        }
      };
      RaceSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
        if (!this.hasFirst) {
          this.hasFirst = true;
          for (var i6 = 0; i6 < this.subscriptions.length; i6++) {
            if (i6 !== outerIndex) {
              var subscription = this.subscriptions[i6];
              subscription.unsubscribe();
              this.remove(subscription);
            }
          }
          this.subscriptions = null;
        }
        this.destination.next(innerValue);
      };
      return RaceSubscriber2;
    }(OuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/observable/range.js
function range(start, count2, scheduler) {
  if (start === void 0) {
    start = 0;
  }
  return new Observable(function(subscriber) {
    if (count2 === void 0) {
      count2 = start;
      start = 0;
    }
    var index = 0;
    var current = start;
    if (scheduler) {
      return scheduler.schedule(dispatch7, 0, {
        index,
        count: count2,
        start,
        subscriber
      });
    } else {
      do {
        if (index++ >= count2) {
          subscriber.complete();
          break;
        }
        subscriber.next(current++);
        if (subscriber.closed) {
          break;
        }
      } while (true);
    }
    return void 0;
  });
}
function dispatch7(state) {
  var start = state.start, index = state.index, count2 = state.count, subscriber = state.subscriber;
  if (index >= count2) {
    subscriber.complete();
    return;
  }
  subscriber.next(start);
  if (subscriber.closed) {
    return;
  }
  state.index = index + 1;
  state.start = start + 1;
  this.schedule(state);
}
var init_range = __esm({
  "node_modules/rxjs/_esm5/internal/observable/range.js"() {
    init_Observable();
  }
});

// node_modules/rxjs/_esm5/internal/observable/timer.js
function timer2(dueTime, periodOrScheduler, scheduler) {
  if (dueTime === void 0) {
    dueTime = 0;
  }
  var period = -1;
  if (isNumeric(periodOrScheduler)) {
    period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);
  } else if (isScheduler(periodOrScheduler)) {
    scheduler = periodOrScheduler;
  }
  if (!isScheduler(scheduler)) {
    scheduler = async;
  }
  return new Observable(function(subscriber) {
    var due = isNumeric(dueTime) ? dueTime : +dueTime - scheduler.now();
    return scheduler.schedule(dispatch8, due, {
      index: 0,
      period,
      subscriber
    });
  });
}
function dispatch8(state) {
  var index = state.index, period = state.period, subscriber = state.subscriber;
  subscriber.next(index);
  if (subscriber.closed) {
    return;
  } else if (period === -1) {
    return subscriber.complete();
  }
  state.index = index + 1;
  this.schedule(state, period);
}
var init_timer = __esm({
  "node_modules/rxjs/_esm5/internal/observable/timer.js"() {
    init_Observable();
    init_async();
    init_isNumeric();
    init_isScheduler();
  }
});

// node_modules/rxjs/_esm5/internal/observable/using.js
function using(resourceFactory, observableFactory) {
  return new Observable(function(subscriber) {
    var resource;
    try {
      resource = resourceFactory();
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    var result;
    try {
      result = observableFactory(resource);
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    var source = result ? from(result) : EMPTY;
    var subscription = source.subscribe(subscriber);
    return function() {
      subscription.unsubscribe();
      if (resource) {
        resource.unsubscribe();
      }
    };
  });
}
var init_using = __esm({
  "node_modules/rxjs/_esm5/internal/observable/using.js"() {
    init_Observable();
    init_from();
    init_empty();
  }
});

// node_modules/rxjs/_esm5/internal/observable/zip.js
function zip() {
  var observables = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    observables[_i2] = arguments[_i2];
  }
  var resultSelector = observables[observables.length - 1];
  if (typeof resultSelector === "function") {
    observables.pop();
  }
  return fromArray(observables, void 0).lift(new ZipOperator(resultSelector));
}
var ZipOperator, ZipSubscriber, StaticIterator, StaticArrayIterator, ZipBufferIterator;
var init_zip = __esm({
  "node_modules/rxjs/_esm5/internal/observable/zip.js"() {
    init_tslib_es6();
    init_fromArray();
    init_isArray();
    init_Subscriber();
    init_iterator();
    init_innerSubscribe();
    ZipOperator = function() {
      function ZipOperator2(resultSelector) {
        this.resultSelector = resultSelector;
      }
      ZipOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));
      };
      return ZipOperator2;
    }();
    ZipSubscriber = function(_super) {
      __extends(ZipSubscriber2, _super);
      function ZipSubscriber2(destination, resultSelector, values) {
        if (values === void 0) {
          values = /* @__PURE__ */ Object.create(null);
        }
        var _this = _super.call(this, destination) || this;
        _this.resultSelector = resultSelector;
        _this.iterators = [];
        _this.active = 0;
        _this.resultSelector = typeof resultSelector === "function" ? resultSelector : void 0;
        return _this;
      }
      ZipSubscriber2.prototype._next = function(value2) {
        var iterators = this.iterators;
        if (isArray(value2)) {
          iterators.push(new StaticArrayIterator(value2));
        } else if (typeof value2[iterator] === "function") {
          iterators.push(new StaticIterator(value2[iterator]()));
        } else {
          iterators.push(new ZipBufferIterator(this.destination, this, value2));
        }
      };
      ZipSubscriber2.prototype._complete = function() {
        var iterators = this.iterators;
        var len = iterators.length;
        this.unsubscribe();
        if (len === 0) {
          this.destination.complete();
          return;
        }
        this.active = len;
        for (var i6 = 0; i6 < len; i6++) {
          var iterator2 = iterators[i6];
          if (iterator2.stillUnsubscribed) {
            var destination = this.destination;
            destination.add(iterator2.subscribe());
          } else {
            this.active--;
          }
        }
      };
      ZipSubscriber2.prototype.notifyInactive = function() {
        this.active--;
        if (this.active === 0) {
          this.destination.complete();
        }
      };
      ZipSubscriber2.prototype.checkIterators = function() {
        var iterators = this.iterators;
        var len = iterators.length;
        var destination = this.destination;
        for (var i6 = 0; i6 < len; i6++) {
          var iterator2 = iterators[i6];
          if (typeof iterator2.hasValue === "function" && !iterator2.hasValue()) {
            return;
          }
        }
        var shouldComplete = false;
        var args = [];
        for (var i6 = 0; i6 < len; i6++) {
          var iterator2 = iterators[i6];
          var result = iterator2.next();
          if (iterator2.hasCompleted()) {
            shouldComplete = true;
          }
          if (result.done) {
            destination.complete();
            return;
          }
          args.push(result.value);
        }
        if (this.resultSelector) {
          this._tryresultSelector(args);
        } else {
          destination.next(args);
        }
        if (shouldComplete) {
          destination.complete();
        }
      };
      ZipSubscriber2.prototype._tryresultSelector = function(args) {
        var result;
        try {
          result = this.resultSelector.apply(this, args);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        this.destination.next(result);
      };
      return ZipSubscriber2;
    }(Subscriber);
    StaticIterator = function() {
      function StaticIterator2(iterator2) {
        this.iterator = iterator2;
        this.nextResult = iterator2.next();
      }
      StaticIterator2.prototype.hasValue = function() {
        return true;
      };
      StaticIterator2.prototype.next = function() {
        var result = this.nextResult;
        this.nextResult = this.iterator.next();
        return result;
      };
      StaticIterator2.prototype.hasCompleted = function() {
        var nextResult = this.nextResult;
        return Boolean(nextResult && nextResult.done);
      };
      return StaticIterator2;
    }();
    StaticArrayIterator = function() {
      function StaticArrayIterator2(array) {
        this.array = array;
        this.index = 0;
        this.length = 0;
        this.length = array.length;
      }
      StaticArrayIterator2.prototype[iterator] = function() {
        return this;
      };
      StaticArrayIterator2.prototype.next = function(value2) {
        var i6 = this.index++;
        var array = this.array;
        return i6 < this.length ? { value: array[i6], done: false } : { value: null, done: true };
      };
      StaticArrayIterator2.prototype.hasValue = function() {
        return this.array.length > this.index;
      };
      StaticArrayIterator2.prototype.hasCompleted = function() {
        return this.array.length === this.index;
      };
      return StaticArrayIterator2;
    }();
    ZipBufferIterator = function(_super) {
      __extends(ZipBufferIterator2, _super);
      function ZipBufferIterator2(destination, parent, observable2) {
        var _this = _super.call(this, destination) || this;
        _this.parent = parent;
        _this.observable = observable2;
        _this.stillUnsubscribed = true;
        _this.buffer = [];
        _this.isComplete = false;
        return _this;
      }
      ZipBufferIterator2.prototype[iterator] = function() {
        return this;
      };
      ZipBufferIterator2.prototype.next = function() {
        var buffer2 = this.buffer;
        if (buffer2.length === 0 && this.isComplete) {
          return { value: null, done: true };
        } else {
          return { value: buffer2.shift(), done: false };
        }
      };
      ZipBufferIterator2.prototype.hasValue = function() {
        return this.buffer.length > 0;
      };
      ZipBufferIterator2.prototype.hasCompleted = function() {
        return this.buffer.length === 0 && this.isComplete;
      };
      ZipBufferIterator2.prototype.notifyComplete = function() {
        if (this.buffer.length > 0) {
          this.isComplete = true;
          this.parent.notifyInactive();
        } else {
          this.destination.complete();
        }
      };
      ZipBufferIterator2.prototype.notifyNext = function(innerValue) {
        this.buffer.push(innerValue);
        this.parent.checkIterators();
      };
      ZipBufferIterator2.prototype.subscribe = function() {
        return innerSubscribe(this.observable, new SimpleInnerSubscriber(this));
      };
      return ZipBufferIterator2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/index.js
var esm5_exports = {};
__export(esm5_exports, {
  ArgumentOutOfRangeError: () => ArgumentOutOfRangeError,
  AsyncSubject: () => AsyncSubject,
  BehaviorSubject: () => BehaviorSubject,
  ConnectableObservable: () => ConnectableObservable,
  EMPTY: () => EMPTY,
  EmptyError: () => EmptyError,
  GroupedObservable: () => GroupedObservable,
  NEVER: () => NEVER,
  Notification: () => Notification,
  NotificationKind: () => NotificationKind,
  ObjectUnsubscribedError: () => ObjectUnsubscribedError,
  Observable: () => Observable,
  ReplaySubject: () => ReplaySubject,
  Scheduler: () => Scheduler,
  Subject: () => Subject,
  Subscriber: () => Subscriber,
  Subscription: () => Subscription,
  TimeoutError: () => TimeoutError,
  UnsubscriptionError: () => UnsubscriptionError,
  VirtualAction: () => VirtualAction,
  VirtualTimeScheduler: () => VirtualTimeScheduler,
  animationFrame: () => animationFrame,
  animationFrameScheduler: () => animationFrameScheduler,
  asap: () => asap,
  asapScheduler: () => asapScheduler,
  async: () => async,
  asyncScheduler: () => asyncScheduler,
  bindCallback: () => bindCallback,
  bindNodeCallback: () => bindNodeCallback,
  combineLatest: () => combineLatest,
  concat: () => concat2,
  config: () => config,
  defer: () => defer,
  empty: () => empty2,
  forkJoin: () => forkJoin,
  from: () => from,
  fromEvent: () => fromEvent,
  fromEventPattern: () => fromEventPattern,
  generate: () => generate2,
  identity: () => identity,
  iif: () => iif,
  interval: () => interval,
  isObservable: () => isObservable,
  merge: () => merge,
  never: () => never,
  noop: () => noop2,
  observable: () => observable,
  of: () => of,
  onErrorResumeNext: () => onErrorResumeNext,
  pairs: () => pairs,
  partition: () => partition,
  pipe: () => pipe,
  queue: () => queue,
  queueScheduler: () => queueScheduler,
  race: () => race,
  range: () => range,
  scheduled: () => scheduled,
  throwError: () => throwError,
  timer: () => timer2,
  using: () => using,
  zip: () => zip
});
var init_esm5 = __esm({
  "node_modules/rxjs/_esm5/index.js"() {
    init_Observable();
    init_ConnectableObservable();
    init_groupBy();
    init_observable();
    init_Subject();
    init_BehaviorSubject();
    init_ReplaySubject();
    init_AsyncSubject();
    init_asap();
    init_async();
    init_queue();
    init_animationFrame();
    init_VirtualTimeScheduler();
    init_Scheduler();
    init_Subscription();
    init_Subscriber();
    init_Notification();
    init_pipe();
    init_noop();
    init_identity();
    init_isObservable();
    init_ArgumentOutOfRangeError();
    init_EmptyError();
    init_ObjectUnsubscribedError();
    init_UnsubscriptionError();
    init_TimeoutError();
    init_bindCallback();
    init_bindNodeCallback();
    init_combineLatest();
    init_concat();
    init_defer();
    init_empty();
    init_forkJoin();
    init_from();
    init_fromEvent();
    init_fromEventPattern();
    init_generate();
    init_iif();
    init_interval();
    init_merge();
    init_never();
    init_of();
    init_onErrorResumeNext();
    init_pairs();
    init_partition();
    init_race();
    init_range();
    init_throwError();
    init_timer();
    init_using();
    init_zip();
    init_scheduled();
    init_empty();
    init_never();
    init_config();
  }
});

// node_modules/rxjs/_esm5/internal/operators/audit.js
function audit(durationSelector) {
  return function auditOperatorFunction(source) {
    return source.lift(new AuditOperator(durationSelector));
  };
}
var AuditOperator, AuditSubscriber;
var init_audit = __esm({
  "node_modules/rxjs/_esm5/internal/operators/audit.js"() {
    init_tslib_es6();
    init_innerSubscribe();
    AuditOperator = function() {
      function AuditOperator2(durationSelector) {
        this.durationSelector = durationSelector;
      }
      AuditOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));
      };
      return AuditOperator2;
    }();
    AuditSubscriber = function(_super) {
      __extends(AuditSubscriber2, _super);
      function AuditSubscriber2(destination, durationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.durationSelector = durationSelector;
        _this.hasValue = false;
        return _this;
      }
      AuditSubscriber2.prototype._next = function(value2) {
        this.value = value2;
        this.hasValue = true;
        if (!this.throttled) {
          var duration = void 0;
          try {
            var durationSelector = this.durationSelector;
            duration = durationSelector(value2);
          } catch (err) {
            return this.destination.error(err);
          }
          var innerSubscription = innerSubscribe(duration, new SimpleInnerSubscriber(this));
          if (!innerSubscription || innerSubscription.closed) {
            this.clearThrottle();
          } else {
            this.add(this.throttled = innerSubscription);
          }
        }
      };
      AuditSubscriber2.prototype.clearThrottle = function() {
        var _a2 = this, value2 = _a2.value, hasValue = _a2.hasValue, throttled = _a2.throttled;
        if (throttled) {
          this.remove(throttled);
          this.throttled = void 0;
          throttled.unsubscribe();
        }
        if (hasValue) {
          this.value = void 0;
          this.hasValue = false;
          this.destination.next(value2);
        }
      };
      AuditSubscriber2.prototype.notifyNext = function() {
        this.clearThrottle();
      };
      AuditSubscriber2.prototype.notifyComplete = function() {
        this.clearThrottle();
      };
      return AuditSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/auditTime.js
function auditTime(duration, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return audit(function() {
    return timer2(duration, scheduler);
  });
}
var init_auditTime = __esm({
  "node_modules/rxjs/_esm5/internal/operators/auditTime.js"() {
    init_async();
    init_audit();
    init_timer();
  }
});

// node_modules/rxjs/_esm5/internal/operators/buffer.js
function buffer(closingNotifier) {
  return function bufferOperatorFunction(source) {
    return source.lift(new BufferOperator(closingNotifier));
  };
}
var BufferOperator, BufferSubscriber;
var init_buffer = __esm({
  "node_modules/rxjs/_esm5/internal/operators/buffer.js"() {
    init_tslib_es6();
    init_innerSubscribe();
    BufferOperator = function() {
      function BufferOperator2(closingNotifier) {
        this.closingNotifier = closingNotifier;
      }
      BufferOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));
      };
      return BufferOperator2;
    }();
    BufferSubscriber = function(_super) {
      __extends(BufferSubscriber2, _super);
      function BufferSubscriber2(destination, closingNotifier) {
        var _this = _super.call(this, destination) || this;
        _this.buffer = [];
        _this.add(innerSubscribe(closingNotifier, new SimpleInnerSubscriber(_this)));
        return _this;
      }
      BufferSubscriber2.prototype._next = function(value2) {
        this.buffer.push(value2);
      };
      BufferSubscriber2.prototype.notifyNext = function() {
        var buffer2 = this.buffer;
        this.buffer = [];
        this.destination.next(buffer2);
      };
      return BufferSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/bufferCount.js
function bufferCount(bufferSize, startBufferEvery) {
  if (startBufferEvery === void 0) {
    startBufferEvery = null;
  }
  return function bufferCountOperatorFunction(source) {
    return source.lift(new BufferCountOperator(bufferSize, startBufferEvery));
  };
}
var BufferCountOperator, BufferCountSubscriber, BufferSkipCountSubscriber;
var init_bufferCount = __esm({
  "node_modules/rxjs/_esm5/internal/operators/bufferCount.js"() {
    init_tslib_es6();
    init_Subscriber();
    BufferCountOperator = function() {
      function BufferCountOperator2(bufferSize, startBufferEvery) {
        this.bufferSize = bufferSize;
        this.startBufferEvery = startBufferEvery;
        if (!startBufferEvery || bufferSize === startBufferEvery) {
          this.subscriberClass = BufferCountSubscriber;
        } else {
          this.subscriberClass = BufferSkipCountSubscriber;
        }
      }
      BufferCountOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));
      };
      return BufferCountOperator2;
    }();
    BufferCountSubscriber = function(_super) {
      __extends(BufferCountSubscriber2, _super);
      function BufferCountSubscriber2(destination, bufferSize) {
        var _this = _super.call(this, destination) || this;
        _this.bufferSize = bufferSize;
        _this.buffer = [];
        return _this;
      }
      BufferCountSubscriber2.prototype._next = function(value2) {
        var buffer2 = this.buffer;
        buffer2.push(value2);
        if (buffer2.length == this.bufferSize) {
          this.destination.next(buffer2);
          this.buffer = [];
        }
      };
      BufferCountSubscriber2.prototype._complete = function() {
        var buffer2 = this.buffer;
        if (buffer2.length > 0) {
          this.destination.next(buffer2);
        }
        _super.prototype._complete.call(this);
      };
      return BufferCountSubscriber2;
    }(Subscriber);
    BufferSkipCountSubscriber = function(_super) {
      __extends(BufferSkipCountSubscriber2, _super);
      function BufferSkipCountSubscriber2(destination, bufferSize, startBufferEvery) {
        var _this = _super.call(this, destination) || this;
        _this.bufferSize = bufferSize;
        _this.startBufferEvery = startBufferEvery;
        _this.buffers = [];
        _this.count = 0;
        return _this;
      }
      BufferSkipCountSubscriber2.prototype._next = function(value2) {
        var _a2 = this, bufferSize = _a2.bufferSize, startBufferEvery = _a2.startBufferEvery, buffers = _a2.buffers, count2 = _a2.count;
        this.count++;
        if (count2 % startBufferEvery === 0) {
          buffers.push([]);
        }
        for (var i6 = buffers.length; i6--; ) {
          var buffer2 = buffers[i6];
          buffer2.push(value2);
          if (buffer2.length === bufferSize) {
            buffers.splice(i6, 1);
            this.destination.next(buffer2);
          }
        }
      };
      BufferSkipCountSubscriber2.prototype._complete = function() {
        var _a2 = this, buffers = _a2.buffers, destination = _a2.destination;
        while (buffers.length > 0) {
          var buffer2 = buffers.shift();
          if (buffer2.length > 0) {
            destination.next(buffer2);
          }
        }
        _super.prototype._complete.call(this);
      };
      return BufferSkipCountSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/bufferTime.js
function bufferTime(bufferTimeSpan) {
  var length = arguments.length;
  var scheduler = async;
  if (isScheduler(arguments[arguments.length - 1])) {
    scheduler = arguments[arguments.length - 1];
    length--;
  }
  var bufferCreationInterval = null;
  if (length >= 2) {
    bufferCreationInterval = arguments[1];
  }
  var maxBufferSize = Number.POSITIVE_INFINITY;
  if (length >= 3) {
    maxBufferSize = arguments[2];
  }
  return function bufferTimeOperatorFunction(source) {
    return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));
  };
}
function dispatchBufferTimeSpanOnly(state) {
  var subscriber = state.subscriber;
  var prevContext = state.context;
  if (prevContext) {
    subscriber.closeContext(prevContext);
  }
  if (!subscriber.closed) {
    state.context = subscriber.openContext();
    state.context.closeAction = this.schedule(state, state.bufferTimeSpan);
  }
}
function dispatchBufferCreation(state) {
  var bufferCreationInterval = state.bufferCreationInterval, bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler;
  var context = subscriber.openContext();
  var action = this;
  if (!subscriber.closed) {
    subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber, context }));
    action.schedule(state, bufferCreationInterval);
  }
}
function dispatchBufferClose(arg) {
  var subscriber = arg.subscriber, context = arg.context;
  subscriber.closeContext(context);
}
var BufferTimeOperator, Context2, BufferTimeSubscriber;
var init_bufferTime = __esm({
  "node_modules/rxjs/_esm5/internal/operators/bufferTime.js"() {
    init_tslib_es6();
    init_async();
    init_Subscriber();
    init_isScheduler();
    BufferTimeOperator = function() {
      function BufferTimeOperator2(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        this.bufferTimeSpan = bufferTimeSpan;
        this.bufferCreationInterval = bufferCreationInterval;
        this.maxBufferSize = maxBufferSize;
        this.scheduler = scheduler;
      }
      BufferTimeOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));
      };
      return BufferTimeOperator2;
    }();
    Context2 = function() {
      function Context3() {
        this.buffer = [];
      }
      return Context3;
    }();
    BufferTimeSubscriber = function(_super) {
      __extends(BufferTimeSubscriber2, _super);
      function BufferTimeSubscriber2(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.bufferTimeSpan = bufferTimeSpan;
        _this.bufferCreationInterval = bufferCreationInterval;
        _this.maxBufferSize = maxBufferSize;
        _this.scheduler = scheduler;
        _this.contexts = [];
        var context = _this.openContext();
        _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;
        if (_this.timespanOnly) {
          var timeSpanOnlyState = { subscriber: _this, context, bufferTimeSpan };
          _this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        } else {
          var closeState = { subscriber: _this, context };
          var creationState = { bufferTimeSpan, bufferCreationInterval, subscriber: _this, scheduler };
          _this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));
          _this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
        }
        return _this;
      }
      BufferTimeSubscriber2.prototype._next = function(value2) {
        var contexts = this.contexts;
        var len = contexts.length;
        var filledBufferContext;
        for (var i6 = 0; i6 < len; i6++) {
          var context_1 = contexts[i6];
          var buffer2 = context_1.buffer;
          buffer2.push(value2);
          if (buffer2.length == this.maxBufferSize) {
            filledBufferContext = context_1;
          }
        }
        if (filledBufferContext) {
          this.onBufferFull(filledBufferContext);
        }
      };
      BufferTimeSubscriber2.prototype._error = function(err) {
        this.contexts.length = 0;
        _super.prototype._error.call(this, err);
      };
      BufferTimeSubscriber2.prototype._complete = function() {
        var _a2 = this, contexts = _a2.contexts, destination = _a2.destination;
        while (contexts.length > 0) {
          var context_2 = contexts.shift();
          destination.next(context_2.buffer);
        }
        _super.prototype._complete.call(this);
      };
      BufferTimeSubscriber2.prototype._unsubscribe = function() {
        this.contexts = null;
      };
      BufferTimeSubscriber2.prototype.onBufferFull = function(context) {
        this.closeContext(context);
        var closeAction = context.closeAction;
        closeAction.unsubscribe();
        this.remove(closeAction);
        if (!this.closed && this.timespanOnly) {
          context = this.openContext();
          var bufferTimeSpan = this.bufferTimeSpan;
          var timeSpanOnlyState = { subscriber: this, context, bufferTimeSpan };
          this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        }
      };
      BufferTimeSubscriber2.prototype.openContext = function() {
        var context = new Context2();
        this.contexts.push(context);
        return context;
      };
      BufferTimeSubscriber2.prototype.closeContext = function(context) {
        this.destination.next(context.buffer);
        var contexts = this.contexts;
        var spliceIndex = contexts ? contexts.indexOf(context) : -1;
        if (spliceIndex >= 0) {
          contexts.splice(contexts.indexOf(context), 1);
        }
      };
      return BufferTimeSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/bufferToggle.js
function bufferToggle(openings, closingSelector) {
  return function bufferToggleOperatorFunction(source) {
    return source.lift(new BufferToggleOperator(openings, closingSelector));
  };
}
var BufferToggleOperator, BufferToggleSubscriber;
var init_bufferToggle = __esm({
  "node_modules/rxjs/_esm5/internal/operators/bufferToggle.js"() {
    init_tslib_es6();
    init_Subscription();
    init_subscribeToResult();
    init_OuterSubscriber();
    BufferToggleOperator = function() {
      function BufferToggleOperator2(openings, closingSelector) {
        this.openings = openings;
        this.closingSelector = closingSelector;
      }
      BufferToggleOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));
      };
      return BufferToggleOperator2;
    }();
    BufferToggleSubscriber = function(_super) {
      __extends(BufferToggleSubscriber2, _super);
      function BufferToggleSubscriber2(destination, openings, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.closingSelector = closingSelector;
        _this.contexts = [];
        _this.add(subscribeToResult(_this, openings));
        return _this;
      }
      BufferToggleSubscriber2.prototype._next = function(value2) {
        var contexts = this.contexts;
        var len = contexts.length;
        for (var i6 = 0; i6 < len; i6++) {
          contexts[i6].buffer.push(value2);
        }
      };
      BufferToggleSubscriber2.prototype._error = function(err) {
        var contexts = this.contexts;
        while (contexts.length > 0) {
          var context_1 = contexts.shift();
          context_1.subscription.unsubscribe();
          context_1.buffer = null;
          context_1.subscription = null;
        }
        this.contexts = null;
        _super.prototype._error.call(this, err);
      };
      BufferToggleSubscriber2.prototype._complete = function() {
        var contexts = this.contexts;
        while (contexts.length > 0) {
          var context_2 = contexts.shift();
          this.destination.next(context_2.buffer);
          context_2.subscription.unsubscribe();
          context_2.buffer = null;
          context_2.subscription = null;
        }
        this.contexts = null;
        _super.prototype._complete.call(this);
      };
      BufferToggleSubscriber2.prototype.notifyNext = function(outerValue, innerValue) {
        outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
      };
      BufferToggleSubscriber2.prototype.notifyComplete = function(innerSub) {
        this.closeBuffer(innerSub.context);
      };
      BufferToggleSubscriber2.prototype.openBuffer = function(value2) {
        try {
          var closingSelector = this.closingSelector;
          var closingNotifier = closingSelector.call(this, value2);
          if (closingNotifier) {
            this.trySubscribe(closingNotifier);
          }
        } catch (err) {
          this._error(err);
        }
      };
      BufferToggleSubscriber2.prototype.closeBuffer = function(context) {
        var contexts = this.contexts;
        if (contexts && context) {
          var buffer2 = context.buffer, subscription = context.subscription;
          this.destination.next(buffer2);
          contexts.splice(contexts.indexOf(context), 1);
          this.remove(subscription);
          subscription.unsubscribe();
        }
      };
      BufferToggleSubscriber2.prototype.trySubscribe = function(closingNotifier) {
        var contexts = this.contexts;
        var buffer2 = [];
        var subscription = new Subscription();
        var context = { buffer: buffer2, subscription };
        contexts.push(context);
        var innerSubscription = subscribeToResult(this, closingNotifier, context);
        if (!innerSubscription || innerSubscription.closed) {
          this.closeBuffer(context);
        } else {
          innerSubscription.context = context;
          this.add(innerSubscription);
          subscription.add(innerSubscription);
        }
      };
      return BufferToggleSubscriber2;
    }(OuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/bufferWhen.js
function bufferWhen(closingSelector) {
  return function(source) {
    return source.lift(new BufferWhenOperator(closingSelector));
  };
}
var BufferWhenOperator, BufferWhenSubscriber;
var init_bufferWhen = __esm({
  "node_modules/rxjs/_esm5/internal/operators/bufferWhen.js"() {
    init_tslib_es6();
    init_Subscription();
    init_innerSubscribe();
    BufferWhenOperator = function() {
      function BufferWhenOperator2(closingSelector) {
        this.closingSelector = closingSelector;
      }
      BufferWhenOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));
      };
      return BufferWhenOperator2;
    }();
    BufferWhenSubscriber = function(_super) {
      __extends(BufferWhenSubscriber2, _super);
      function BufferWhenSubscriber2(destination, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.closingSelector = closingSelector;
        _this.subscribing = false;
        _this.openBuffer();
        return _this;
      }
      BufferWhenSubscriber2.prototype._next = function(value2) {
        this.buffer.push(value2);
      };
      BufferWhenSubscriber2.prototype._complete = function() {
        var buffer2 = this.buffer;
        if (buffer2) {
          this.destination.next(buffer2);
        }
        _super.prototype._complete.call(this);
      };
      BufferWhenSubscriber2.prototype._unsubscribe = function() {
        this.buffer = void 0;
        this.subscribing = false;
      };
      BufferWhenSubscriber2.prototype.notifyNext = function() {
        this.openBuffer();
      };
      BufferWhenSubscriber2.prototype.notifyComplete = function() {
        if (this.subscribing) {
          this.complete();
        } else {
          this.openBuffer();
        }
      };
      BufferWhenSubscriber2.prototype.openBuffer = function() {
        var closingSubscription = this.closingSubscription;
        if (closingSubscription) {
          this.remove(closingSubscription);
          closingSubscription.unsubscribe();
        }
        var buffer2 = this.buffer;
        if (this.buffer) {
          this.destination.next(buffer2);
        }
        this.buffer = [];
        var closingNotifier;
        try {
          var closingSelector = this.closingSelector;
          closingNotifier = closingSelector();
        } catch (err) {
          return this.error(err);
        }
        closingSubscription = new Subscription();
        this.closingSubscription = closingSubscription;
        this.add(closingSubscription);
        this.subscribing = true;
        closingSubscription.add(innerSubscribe(closingNotifier, new SimpleInnerSubscriber(this)));
        this.subscribing = false;
      };
      return BufferWhenSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/catchError.js
function catchError(selector) {
  return function catchErrorOperatorFunction(source) {
    var operator = new CatchOperator(selector);
    var caught = source.lift(operator);
    return operator.caught = caught;
  };
}
var CatchOperator, CatchSubscriber;
var init_catchError = __esm({
  "node_modules/rxjs/_esm5/internal/operators/catchError.js"() {
    init_tslib_es6();
    init_innerSubscribe();
    CatchOperator = function() {
      function CatchOperator2(selector) {
        this.selector = selector;
      }
      CatchOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
      };
      return CatchOperator2;
    }();
    CatchSubscriber = function(_super) {
      __extends(CatchSubscriber2, _super);
      function CatchSubscriber2(destination, selector, caught) {
        var _this = _super.call(this, destination) || this;
        _this.selector = selector;
        _this.caught = caught;
        return _this;
      }
      CatchSubscriber2.prototype.error = function(err) {
        if (!this.isStopped) {
          var result = void 0;
          try {
            result = this.selector(err, this.caught);
          } catch (err2) {
            _super.prototype.error.call(this, err2);
            return;
          }
          this._unsubscribeAndRecycle();
          var innerSubscriber = new SimpleInnerSubscriber(this);
          this.add(innerSubscriber);
          var innerSubscription = innerSubscribe(result, innerSubscriber);
          if (innerSubscription !== innerSubscriber) {
            this.add(innerSubscription);
          }
        }
      };
      return CatchSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/combineAll.js
function combineAll(project) {
  return function(source) {
    return source.lift(new CombineLatestOperator(project));
  };
}
var init_combineAll = __esm({
  "node_modules/rxjs/_esm5/internal/operators/combineAll.js"() {
    init_combineLatest();
  }
});

// node_modules/rxjs/_esm5/internal/operators/combineLatest.js
function combineLatest2() {
  var observables = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    observables[_i2] = arguments[_i2];
  }
  var project = null;
  if (typeof observables[observables.length - 1] === "function") {
    project = observables.pop();
  }
  if (observables.length === 1 && isArray(observables[0])) {
    observables = observables[0].slice();
  }
  return function(source) {
    return source.lift.call(from([source].concat(observables)), new CombineLatestOperator(project));
  };
}
var init_combineLatest2 = __esm({
  "node_modules/rxjs/_esm5/internal/operators/combineLatest.js"() {
    init_isArray();
    init_combineLatest();
    init_from();
  }
});

// node_modules/rxjs/_esm5/internal/operators/concat.js
function concat3() {
  var observables = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    observables[_i2] = arguments[_i2];
  }
  return function(source) {
    return source.lift.call(concat2.apply(void 0, [source].concat(observables)));
  };
}
var init_concat2 = __esm({
  "node_modules/rxjs/_esm5/internal/operators/concat.js"() {
    init_concat();
  }
});

// node_modules/rxjs/_esm5/internal/operators/concatMap.js
function concatMap(project, resultSelector) {
  return mergeMap(project, resultSelector, 1);
}
var init_concatMap = __esm({
  "node_modules/rxjs/_esm5/internal/operators/concatMap.js"() {
    init_mergeMap();
  }
});

// node_modules/rxjs/_esm5/internal/operators/concatMapTo.js
function concatMapTo(innerObservable, resultSelector) {
  return concatMap(function() {
    return innerObservable;
  }, resultSelector);
}
var init_concatMapTo = __esm({
  "node_modules/rxjs/_esm5/internal/operators/concatMapTo.js"() {
    init_concatMap();
  }
});

// node_modules/rxjs/_esm5/internal/operators/count.js
function count(predicate) {
  return function(source) {
    return source.lift(new CountOperator(predicate, source));
  };
}
var CountOperator, CountSubscriber;
var init_count = __esm({
  "node_modules/rxjs/_esm5/internal/operators/count.js"() {
    init_tslib_es6();
    init_Subscriber();
    CountOperator = function() {
      function CountOperator2(predicate, source) {
        this.predicate = predicate;
        this.source = source;
      }
      CountOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));
      };
      return CountOperator2;
    }();
    CountSubscriber = function(_super) {
      __extends(CountSubscriber2, _super);
      function CountSubscriber2(destination, predicate, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.count = 0;
        _this.index = 0;
        return _this;
      }
      CountSubscriber2.prototype._next = function(value2) {
        if (this.predicate) {
          this._tryPredicate(value2);
        } else {
          this.count++;
        }
      };
      CountSubscriber2.prototype._tryPredicate = function(value2) {
        var result;
        try {
          result = this.predicate(value2, this.index++, this.source);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        if (result) {
          this.count++;
        }
      };
      CountSubscriber2.prototype._complete = function() {
        this.destination.next(this.count);
        this.destination.complete();
      };
      return CountSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/debounce.js
function debounce(durationSelector) {
  return function(source) {
    return source.lift(new DebounceOperator(durationSelector));
  };
}
var DebounceOperator, DebounceSubscriber;
var init_debounce = __esm({
  "node_modules/rxjs/_esm5/internal/operators/debounce.js"() {
    init_tslib_es6();
    init_innerSubscribe();
    DebounceOperator = function() {
      function DebounceOperator2(durationSelector) {
        this.durationSelector = durationSelector;
      }
      DebounceOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));
      };
      return DebounceOperator2;
    }();
    DebounceSubscriber = function(_super) {
      __extends(DebounceSubscriber2, _super);
      function DebounceSubscriber2(destination, durationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.durationSelector = durationSelector;
        _this.hasValue = false;
        return _this;
      }
      DebounceSubscriber2.prototype._next = function(value2) {
        try {
          var result = this.durationSelector.call(this, value2);
          if (result) {
            this._tryNext(value2, result);
          }
        } catch (err) {
          this.destination.error(err);
        }
      };
      DebounceSubscriber2.prototype._complete = function() {
        this.emitValue();
        this.destination.complete();
      };
      DebounceSubscriber2.prototype._tryNext = function(value2, duration) {
        var subscription = this.durationSubscription;
        this.value = value2;
        this.hasValue = true;
        if (subscription) {
          subscription.unsubscribe();
          this.remove(subscription);
        }
        subscription = innerSubscribe(duration, new SimpleInnerSubscriber(this));
        if (subscription && !subscription.closed) {
          this.add(this.durationSubscription = subscription);
        }
      };
      DebounceSubscriber2.prototype.notifyNext = function() {
        this.emitValue();
      };
      DebounceSubscriber2.prototype.notifyComplete = function() {
        this.emitValue();
      };
      DebounceSubscriber2.prototype.emitValue = function() {
        if (this.hasValue) {
          var value2 = this.value;
          var subscription = this.durationSubscription;
          if (subscription) {
            this.durationSubscription = void 0;
            subscription.unsubscribe();
            this.remove(subscription);
          }
          this.value = void 0;
          this.hasValue = false;
          _super.prototype._next.call(this, value2);
        }
      };
      return DebounceSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/debounceTime.js
function debounceTime(dueTime, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return function(source) {
    return source.lift(new DebounceTimeOperator(dueTime, scheduler));
  };
}
function dispatchNext3(subscriber) {
  subscriber.debouncedNext();
}
var DebounceTimeOperator, DebounceTimeSubscriber;
var init_debounceTime = __esm({
  "node_modules/rxjs/_esm5/internal/operators/debounceTime.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_async();
    DebounceTimeOperator = function() {
      function DebounceTimeOperator2(dueTime, scheduler) {
        this.dueTime = dueTime;
        this.scheduler = scheduler;
      }
      DebounceTimeOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
      };
      return DebounceTimeOperator2;
    }();
    DebounceTimeSubscriber = function(_super) {
      __extends(DebounceTimeSubscriber2, _super);
      function DebounceTimeSubscriber2(destination, dueTime, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.dueTime = dueTime;
        _this.scheduler = scheduler;
        _this.debouncedSubscription = null;
        _this.lastValue = null;
        _this.hasValue = false;
        return _this;
      }
      DebounceTimeSubscriber2.prototype._next = function(value2) {
        this.clearDebounce();
        this.lastValue = value2;
        this.hasValue = true;
        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext3, this.dueTime, this));
      };
      DebounceTimeSubscriber2.prototype._complete = function() {
        this.debouncedNext();
        this.destination.complete();
      };
      DebounceTimeSubscriber2.prototype.debouncedNext = function() {
        this.clearDebounce();
        if (this.hasValue) {
          var lastValue = this.lastValue;
          this.lastValue = null;
          this.hasValue = false;
          this.destination.next(lastValue);
        }
      };
      DebounceTimeSubscriber2.prototype.clearDebounce = function() {
        var debouncedSubscription = this.debouncedSubscription;
        if (debouncedSubscription !== null) {
          this.remove(debouncedSubscription);
          debouncedSubscription.unsubscribe();
          this.debouncedSubscription = null;
        }
      };
      return DebounceTimeSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/defaultIfEmpty.js
function defaultIfEmpty(defaultValue) {
  if (defaultValue === void 0) {
    defaultValue = null;
  }
  return function(source) {
    return source.lift(new DefaultIfEmptyOperator(defaultValue));
  };
}
var DefaultIfEmptyOperator, DefaultIfEmptySubscriber;
var init_defaultIfEmpty = __esm({
  "node_modules/rxjs/_esm5/internal/operators/defaultIfEmpty.js"() {
    init_tslib_es6();
    init_Subscriber();
    DefaultIfEmptyOperator = function() {
      function DefaultIfEmptyOperator2(defaultValue) {
        this.defaultValue = defaultValue;
      }
      DefaultIfEmptyOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
      };
      return DefaultIfEmptyOperator2;
    }();
    DefaultIfEmptySubscriber = function(_super) {
      __extends(DefaultIfEmptySubscriber2, _super);
      function DefaultIfEmptySubscriber2(destination, defaultValue) {
        var _this = _super.call(this, destination) || this;
        _this.defaultValue = defaultValue;
        _this.isEmpty = true;
        return _this;
      }
      DefaultIfEmptySubscriber2.prototype._next = function(value2) {
        this.isEmpty = false;
        this.destination.next(value2);
      };
      DefaultIfEmptySubscriber2.prototype._complete = function() {
        if (this.isEmpty) {
          this.destination.next(this.defaultValue);
        }
        this.destination.complete();
      };
      return DefaultIfEmptySubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/util/isDate.js
function isDate(value2) {
  return value2 instanceof Date && !isNaN(+value2);
}
var init_isDate = __esm({
  "node_modules/rxjs/_esm5/internal/util/isDate.js"() {
  }
});

// node_modules/rxjs/_esm5/internal/operators/delay.js
function delay(delay2, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  var absoluteDelay = isDate(delay2);
  var delayFor = absoluteDelay ? +delay2 - scheduler.now() : Math.abs(delay2);
  return function(source) {
    return source.lift(new DelayOperator(delayFor, scheduler));
  };
}
var DelayOperator, DelaySubscriber, DelayMessage;
var init_delay = __esm({
  "node_modules/rxjs/_esm5/internal/operators/delay.js"() {
    init_tslib_es6();
    init_async();
    init_isDate();
    init_Subscriber();
    init_Notification();
    DelayOperator = function() {
      function DelayOperator2(delay2, scheduler) {
        this.delay = delay2;
        this.scheduler = scheduler;
      }
      DelayOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
      };
      return DelayOperator2;
    }();
    DelaySubscriber = function(_super) {
      __extends(DelaySubscriber2, _super);
      function DelaySubscriber2(destination, delay2, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.delay = delay2;
        _this.scheduler = scheduler;
        _this.queue = [];
        _this.active = false;
        _this.errored = false;
        return _this;
      }
      DelaySubscriber2.dispatch = function(state) {
        var source = state.source;
        var queue2 = source.queue;
        var scheduler = state.scheduler;
        var destination = state.destination;
        while (queue2.length > 0 && queue2[0].time - scheduler.now() <= 0) {
          queue2.shift().notification.observe(destination);
        }
        if (queue2.length > 0) {
          var delay_1 = Math.max(0, queue2[0].time - scheduler.now());
          this.schedule(state, delay_1);
        } else {
          this.unsubscribe();
          source.active = false;
        }
      };
      DelaySubscriber2.prototype._schedule = function(scheduler) {
        this.active = true;
        var destination = this.destination;
        destination.add(scheduler.schedule(DelaySubscriber2.dispatch, this.delay, {
          source: this,
          destination: this.destination,
          scheduler
        }));
      };
      DelaySubscriber2.prototype.scheduleNotification = function(notification) {
        if (this.errored === true) {
          return;
        }
        var scheduler = this.scheduler;
        var message = new DelayMessage(scheduler.now() + this.delay, notification);
        this.queue.push(message);
        if (this.active === false) {
          this._schedule(scheduler);
        }
      };
      DelaySubscriber2.prototype._next = function(value2) {
        this.scheduleNotification(Notification.createNext(value2));
      };
      DelaySubscriber2.prototype._error = function(err) {
        this.errored = true;
        this.queue = [];
        this.destination.error(err);
        this.unsubscribe();
      };
      DelaySubscriber2.prototype._complete = function() {
        this.scheduleNotification(Notification.createComplete());
        this.unsubscribe();
      };
      return DelaySubscriber2;
    }(Subscriber);
    DelayMessage = function() {
      function DelayMessage2(time, notification) {
        this.time = time;
        this.notification = notification;
      }
      return DelayMessage2;
    }();
  }
});

// node_modules/rxjs/_esm5/internal/operators/delayWhen.js
function delayWhen(delayDurationSelector, subscriptionDelay) {
  if (subscriptionDelay) {
    return function(source) {
      return new SubscriptionDelayObservable(source, subscriptionDelay).lift(new DelayWhenOperator(delayDurationSelector));
    };
  }
  return function(source) {
    return source.lift(new DelayWhenOperator(delayDurationSelector));
  };
}
var DelayWhenOperator, DelayWhenSubscriber, SubscriptionDelayObservable, SubscriptionDelaySubscriber;
var init_delayWhen = __esm({
  "node_modules/rxjs/_esm5/internal/operators/delayWhen.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_Observable();
    init_OuterSubscriber();
    init_subscribeToResult();
    DelayWhenOperator = function() {
      function DelayWhenOperator2(delayDurationSelector) {
        this.delayDurationSelector = delayDurationSelector;
      }
      DelayWhenOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));
      };
      return DelayWhenOperator2;
    }();
    DelayWhenSubscriber = function(_super) {
      __extends(DelayWhenSubscriber2, _super);
      function DelayWhenSubscriber2(destination, delayDurationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.delayDurationSelector = delayDurationSelector;
        _this.completed = false;
        _this.delayNotifierSubscriptions = [];
        _this.index = 0;
        return _this;
      }
      DelayWhenSubscriber2.prototype.notifyNext = function(outerValue, _innerValue, _outerIndex, _innerIndex, innerSub) {
        this.destination.next(outerValue);
        this.removeSubscription(innerSub);
        this.tryComplete();
      };
      DelayWhenSubscriber2.prototype.notifyError = function(error, innerSub) {
        this._error(error);
      };
      DelayWhenSubscriber2.prototype.notifyComplete = function(innerSub) {
        var value2 = this.removeSubscription(innerSub);
        if (value2) {
          this.destination.next(value2);
        }
        this.tryComplete();
      };
      DelayWhenSubscriber2.prototype._next = function(value2) {
        var index = this.index++;
        try {
          var delayNotifier = this.delayDurationSelector(value2, index);
          if (delayNotifier) {
            this.tryDelay(delayNotifier, value2);
          }
        } catch (err) {
          this.destination.error(err);
        }
      };
      DelayWhenSubscriber2.prototype._complete = function() {
        this.completed = true;
        this.tryComplete();
        this.unsubscribe();
      };
      DelayWhenSubscriber2.prototype.removeSubscription = function(subscription) {
        subscription.unsubscribe();
        var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);
        if (subscriptionIdx !== -1) {
          this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
        }
        return subscription.outerValue;
      };
      DelayWhenSubscriber2.prototype.tryDelay = function(delayNotifier, value2) {
        var notifierSubscription = subscribeToResult(this, delayNotifier, value2);
        if (notifierSubscription && !notifierSubscription.closed) {
          var destination = this.destination;
          destination.add(notifierSubscription);
          this.delayNotifierSubscriptions.push(notifierSubscription);
        }
      };
      DelayWhenSubscriber2.prototype.tryComplete = function() {
        if (this.completed && this.delayNotifierSubscriptions.length === 0) {
          this.destination.complete();
        }
      };
      return DelayWhenSubscriber2;
    }(OuterSubscriber);
    SubscriptionDelayObservable = function(_super) {
      __extends(SubscriptionDelayObservable2, _super);
      function SubscriptionDelayObservable2(source, subscriptionDelay) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subscriptionDelay = subscriptionDelay;
        return _this;
      }
      SubscriptionDelayObservable2.prototype._subscribe = function(subscriber) {
        this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
      };
      return SubscriptionDelayObservable2;
    }(Observable);
    SubscriptionDelaySubscriber = function(_super) {
      __extends(SubscriptionDelaySubscriber2, _super);
      function SubscriptionDelaySubscriber2(parent, source) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.source = source;
        _this.sourceSubscribed = false;
        return _this;
      }
      SubscriptionDelaySubscriber2.prototype._next = function(unused) {
        this.subscribeToSource();
      };
      SubscriptionDelaySubscriber2.prototype._error = function(err) {
        this.unsubscribe();
        this.parent.error(err);
      };
      SubscriptionDelaySubscriber2.prototype._complete = function() {
        this.unsubscribe();
        this.subscribeToSource();
      };
      SubscriptionDelaySubscriber2.prototype.subscribeToSource = function() {
        if (!this.sourceSubscribed) {
          this.sourceSubscribed = true;
          this.unsubscribe();
          this.source.subscribe(this.parent);
        }
      };
      return SubscriptionDelaySubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/dematerialize.js
function dematerialize() {
  return function dematerializeOperatorFunction(source) {
    return source.lift(new DeMaterializeOperator());
  };
}
var DeMaterializeOperator, DeMaterializeSubscriber;
var init_dematerialize = __esm({
  "node_modules/rxjs/_esm5/internal/operators/dematerialize.js"() {
    init_tslib_es6();
    init_Subscriber();
    DeMaterializeOperator = function() {
      function DeMaterializeOperator2() {
      }
      DeMaterializeOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new DeMaterializeSubscriber(subscriber));
      };
      return DeMaterializeOperator2;
    }();
    DeMaterializeSubscriber = function(_super) {
      __extends(DeMaterializeSubscriber2, _super);
      function DeMaterializeSubscriber2(destination) {
        return _super.call(this, destination) || this;
      }
      DeMaterializeSubscriber2.prototype._next = function(value2) {
        value2.observe(this.destination);
      };
      return DeMaterializeSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/distinct.js
function distinct(keySelector, flushes) {
  return function(source) {
    return source.lift(new DistinctOperator(keySelector, flushes));
  };
}
var DistinctOperator, DistinctSubscriber;
var init_distinct = __esm({
  "node_modules/rxjs/_esm5/internal/operators/distinct.js"() {
    init_tslib_es6();
    init_innerSubscribe();
    DistinctOperator = function() {
      function DistinctOperator2(keySelector, flushes) {
        this.keySelector = keySelector;
        this.flushes = flushes;
      }
      DistinctOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));
      };
      return DistinctOperator2;
    }();
    DistinctSubscriber = function(_super) {
      __extends(DistinctSubscriber2, _super);
      function DistinctSubscriber2(destination, keySelector, flushes) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.values = /* @__PURE__ */ new Set();
        if (flushes) {
          _this.add(innerSubscribe(flushes, new SimpleInnerSubscriber(_this)));
        }
        return _this;
      }
      DistinctSubscriber2.prototype.notifyNext = function() {
        this.values.clear();
      };
      DistinctSubscriber2.prototype.notifyError = function(error) {
        this._error(error);
      };
      DistinctSubscriber2.prototype._next = function(value2) {
        if (this.keySelector) {
          this._useKeySelector(value2);
        } else {
          this._finalizeNext(value2, value2);
        }
      };
      DistinctSubscriber2.prototype._useKeySelector = function(value2) {
        var key2;
        var destination = this.destination;
        try {
          key2 = this.keySelector(value2);
        } catch (err) {
          destination.error(err);
          return;
        }
        this._finalizeNext(key2, value2);
      };
      DistinctSubscriber2.prototype._finalizeNext = function(key2, value2) {
        var values = this.values;
        if (!values.has(key2)) {
          values.add(key2);
          this.destination.next(value2);
        }
      };
      return DistinctSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/distinctUntilChanged.js
function distinctUntilChanged(compare, keySelector) {
  return function(source) {
    return source.lift(new DistinctUntilChangedOperator(compare, keySelector));
  };
}
var DistinctUntilChangedOperator, DistinctUntilChangedSubscriber;
var init_distinctUntilChanged = __esm({
  "node_modules/rxjs/_esm5/internal/operators/distinctUntilChanged.js"() {
    init_tslib_es6();
    init_Subscriber();
    DistinctUntilChangedOperator = function() {
      function DistinctUntilChangedOperator2(compare, keySelector) {
        this.compare = compare;
        this.keySelector = keySelector;
      }
      DistinctUntilChangedOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
      };
      return DistinctUntilChangedOperator2;
    }();
    DistinctUntilChangedSubscriber = function(_super) {
      __extends(DistinctUntilChangedSubscriber2, _super);
      function DistinctUntilChangedSubscriber2(destination, compare, keySelector) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.hasKey = false;
        if (typeof compare === "function") {
          _this.compare = compare;
        }
        return _this;
      }
      DistinctUntilChangedSubscriber2.prototype.compare = function(x6, y5) {
        return x6 === y5;
      };
      DistinctUntilChangedSubscriber2.prototype._next = function(value2) {
        var key2;
        try {
          var keySelector = this.keySelector;
          key2 = keySelector ? keySelector(value2) : value2;
        } catch (err) {
          return this.destination.error(err);
        }
        var result = false;
        if (this.hasKey) {
          try {
            var compare = this.compare;
            result = compare(this.key, key2);
          } catch (err) {
            return this.destination.error(err);
          }
        } else {
          this.hasKey = true;
        }
        if (!result) {
          this.key = key2;
          this.destination.next(value2);
        }
      };
      return DistinctUntilChangedSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/distinctUntilKeyChanged.js
function distinctUntilKeyChanged(key2, compare) {
  return distinctUntilChanged(function(x6, y5) {
    return compare ? compare(x6[key2], y5[key2]) : x6[key2] === y5[key2];
  });
}
var init_distinctUntilKeyChanged = __esm({
  "node_modules/rxjs/_esm5/internal/operators/distinctUntilKeyChanged.js"() {
    init_distinctUntilChanged();
  }
});

// node_modules/rxjs/_esm5/internal/operators/throwIfEmpty.js
function throwIfEmpty(errorFactory) {
  if (errorFactory === void 0) {
    errorFactory = defaultErrorFactory;
  }
  return function(source) {
    return source.lift(new ThrowIfEmptyOperator(errorFactory));
  };
}
function defaultErrorFactory() {
  return new EmptyError();
}
var ThrowIfEmptyOperator, ThrowIfEmptySubscriber;
var init_throwIfEmpty = __esm({
  "node_modules/rxjs/_esm5/internal/operators/throwIfEmpty.js"() {
    init_tslib_es6();
    init_EmptyError();
    init_Subscriber();
    ThrowIfEmptyOperator = function() {
      function ThrowIfEmptyOperator2(errorFactory) {
        this.errorFactory = errorFactory;
      }
      ThrowIfEmptyOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new ThrowIfEmptySubscriber(subscriber, this.errorFactory));
      };
      return ThrowIfEmptyOperator2;
    }();
    ThrowIfEmptySubscriber = function(_super) {
      __extends(ThrowIfEmptySubscriber2, _super);
      function ThrowIfEmptySubscriber2(destination, errorFactory) {
        var _this = _super.call(this, destination) || this;
        _this.errorFactory = errorFactory;
        _this.hasValue = false;
        return _this;
      }
      ThrowIfEmptySubscriber2.prototype._next = function(value2) {
        this.hasValue = true;
        this.destination.next(value2);
      };
      ThrowIfEmptySubscriber2.prototype._complete = function() {
        if (!this.hasValue) {
          var err = void 0;
          try {
            err = this.errorFactory();
          } catch (e6) {
            err = e6;
          }
          this.destination.error(err);
        } else {
          return this.destination.complete();
        }
      };
      return ThrowIfEmptySubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/take.js
function take(count2) {
  return function(source) {
    if (count2 === 0) {
      return empty2();
    } else {
      return source.lift(new TakeOperator(count2));
    }
  };
}
var TakeOperator, TakeSubscriber;
var init_take = __esm({
  "node_modules/rxjs/_esm5/internal/operators/take.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_ArgumentOutOfRangeError();
    init_empty();
    TakeOperator = function() {
      function TakeOperator2(total) {
        this.total = total;
        if (this.total < 0) {
          throw new ArgumentOutOfRangeError();
        }
      }
      TakeOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new TakeSubscriber(subscriber, this.total));
      };
      return TakeOperator2;
    }();
    TakeSubscriber = function(_super) {
      __extends(TakeSubscriber2, _super);
      function TakeSubscriber2(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.count = 0;
        return _this;
      }
      TakeSubscriber2.prototype._next = function(value2) {
        var total = this.total;
        var count2 = ++this.count;
        if (count2 <= total) {
          this.destination.next(value2);
          if (count2 === total) {
            this.destination.complete();
            this.unsubscribe();
          }
        }
      };
      return TakeSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/elementAt.js
function elementAt(index, defaultValue) {
  if (index < 0) {
    throw new ArgumentOutOfRangeError();
  }
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(filter(function(v9, i6) {
      return i6 === index;
    }), take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new ArgumentOutOfRangeError();
    }));
  };
}
var init_elementAt = __esm({
  "node_modules/rxjs/_esm5/internal/operators/elementAt.js"() {
    init_ArgumentOutOfRangeError();
    init_filter();
    init_throwIfEmpty();
    init_defaultIfEmpty();
    init_take();
  }
});

// node_modules/rxjs/_esm5/internal/operators/endWith.js
function endWith() {
  var array = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    array[_i2] = arguments[_i2];
  }
  return function(source) {
    return concat2(source, of.apply(void 0, array));
  };
}
var init_endWith = __esm({
  "node_modules/rxjs/_esm5/internal/operators/endWith.js"() {
    init_concat();
    init_of();
  }
});

// node_modules/rxjs/_esm5/internal/operators/every.js
function every(predicate, thisArg) {
  return function(source) {
    return source.lift(new EveryOperator(predicate, thisArg, source));
  };
}
var EveryOperator, EverySubscriber;
var init_every = __esm({
  "node_modules/rxjs/_esm5/internal/operators/every.js"() {
    init_tslib_es6();
    init_Subscriber();
    EveryOperator = function() {
      function EveryOperator2(predicate, thisArg, source) {
        this.predicate = predicate;
        this.thisArg = thisArg;
        this.source = source;
      }
      EveryOperator2.prototype.call = function(observer, source) {
        return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));
      };
      return EveryOperator2;
    }();
    EverySubscriber = function(_super) {
      __extends(EverySubscriber2, _super);
      function EverySubscriber2(destination, predicate, thisArg, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.thisArg = thisArg;
        _this.source = source;
        _this.index = 0;
        _this.thisArg = thisArg || _this;
        return _this;
      }
      EverySubscriber2.prototype.notifyComplete = function(everyValueMatch) {
        this.destination.next(everyValueMatch);
        this.destination.complete();
      };
      EverySubscriber2.prototype._next = function(value2) {
        var result = false;
        try {
          result = this.predicate.call(this.thisArg, value2, this.index++, this.source);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        if (!result) {
          this.notifyComplete(false);
        }
      };
      EverySubscriber2.prototype._complete = function() {
        this.notifyComplete(true);
      };
      return EverySubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/exhaust.js
function exhaust() {
  return function(source) {
    return source.lift(new SwitchFirstOperator());
  };
}
var SwitchFirstOperator, SwitchFirstSubscriber;
var init_exhaust = __esm({
  "node_modules/rxjs/_esm5/internal/operators/exhaust.js"() {
    init_tslib_es6();
    init_innerSubscribe();
    SwitchFirstOperator = function() {
      function SwitchFirstOperator2() {
      }
      SwitchFirstOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new SwitchFirstSubscriber(subscriber));
      };
      return SwitchFirstOperator2;
    }();
    SwitchFirstSubscriber = function(_super) {
      __extends(SwitchFirstSubscriber2, _super);
      function SwitchFirstSubscriber2(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasCompleted = false;
        _this.hasSubscription = false;
        return _this;
      }
      SwitchFirstSubscriber2.prototype._next = function(value2) {
        if (!this.hasSubscription) {
          this.hasSubscription = true;
          this.add(innerSubscribe(value2, new SimpleInnerSubscriber(this)));
        }
      };
      SwitchFirstSubscriber2.prototype._complete = function() {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
          this.destination.complete();
        }
      };
      SwitchFirstSubscriber2.prototype.notifyComplete = function() {
        this.hasSubscription = false;
        if (this.hasCompleted) {
          this.destination.complete();
        }
      };
      return SwitchFirstSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/exhaustMap.js
function exhaustMap(project, resultSelector) {
  if (resultSelector) {
    return function(source) {
      return source.pipe(exhaustMap(function(a5, i6) {
        return from(project(a5, i6)).pipe(map(function(b4, ii3) {
          return resultSelector(a5, b4, i6, ii3);
        }));
      }));
    };
  }
  return function(source) {
    return source.lift(new ExhaustMapOperator(project));
  };
}
var ExhaustMapOperator, ExhaustMapSubscriber;
var init_exhaustMap = __esm({
  "node_modules/rxjs/_esm5/internal/operators/exhaustMap.js"() {
    init_tslib_es6();
    init_map();
    init_from();
    init_innerSubscribe();
    ExhaustMapOperator = function() {
      function ExhaustMapOperator2(project) {
        this.project = project;
      }
      ExhaustMapOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new ExhaustMapSubscriber(subscriber, this.project));
      };
      return ExhaustMapOperator2;
    }();
    ExhaustMapSubscriber = function(_super) {
      __extends(ExhaustMapSubscriber2, _super);
      function ExhaustMapSubscriber2(destination, project) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.hasSubscription = false;
        _this.hasCompleted = false;
        _this.index = 0;
        return _this;
      }
      ExhaustMapSubscriber2.prototype._next = function(value2) {
        if (!this.hasSubscription) {
          this.tryNext(value2);
        }
      };
      ExhaustMapSubscriber2.prototype.tryNext = function(value2) {
        var result;
        var index = this.index++;
        try {
          result = this.project(value2, index);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        this.hasSubscription = true;
        this._innerSub(result);
      };
      ExhaustMapSubscriber2.prototype._innerSub = function(result) {
        var innerSubscriber = new SimpleInnerSubscriber(this);
        var destination = this.destination;
        destination.add(innerSubscriber);
        var innerSubscription = innerSubscribe(result, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
          destination.add(innerSubscription);
        }
      };
      ExhaustMapSubscriber2.prototype._complete = function() {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
          this.destination.complete();
        }
        this.unsubscribe();
      };
      ExhaustMapSubscriber2.prototype.notifyNext = function(innerValue) {
        this.destination.next(innerValue);
      };
      ExhaustMapSubscriber2.prototype.notifyError = function(err) {
        this.destination.error(err);
      };
      ExhaustMapSubscriber2.prototype.notifyComplete = function() {
        this.hasSubscription = false;
        if (this.hasCompleted) {
          this.destination.complete();
        }
      };
      return ExhaustMapSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/expand.js
function expand(project, concurrent, scheduler) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;
  return function(source) {
    return source.lift(new ExpandOperator(project, concurrent, scheduler));
  };
}
var ExpandOperator, ExpandSubscriber;
var init_expand = __esm({
  "node_modules/rxjs/_esm5/internal/operators/expand.js"() {
    init_tslib_es6();
    init_innerSubscribe();
    ExpandOperator = function() {
      function ExpandOperator2(project, concurrent, scheduler) {
        this.project = project;
        this.concurrent = concurrent;
        this.scheduler = scheduler;
      }
      ExpandOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));
      };
      return ExpandOperator2;
    }();
    ExpandSubscriber = function(_super) {
      __extends(ExpandSubscriber2, _super);
      function ExpandSubscriber2(destination, project, concurrent, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.concurrent = concurrent;
        _this.scheduler = scheduler;
        _this.index = 0;
        _this.active = 0;
        _this.hasCompleted = false;
        if (concurrent < Number.POSITIVE_INFINITY) {
          _this.buffer = [];
        }
        return _this;
      }
      ExpandSubscriber2.dispatch = function(arg) {
        var subscriber = arg.subscriber, result = arg.result, value2 = arg.value, index = arg.index;
        subscriber.subscribeToProjection(result, value2, index);
      };
      ExpandSubscriber2.prototype._next = function(value2) {
        var destination = this.destination;
        if (destination.closed) {
          this._complete();
          return;
        }
        var index = this.index++;
        if (this.active < this.concurrent) {
          destination.next(value2);
          try {
            var project = this.project;
            var result = project(value2, index);
            if (!this.scheduler) {
              this.subscribeToProjection(result, value2, index);
            } else {
              var state = { subscriber: this, result, value: value2, index };
              var destination_1 = this.destination;
              destination_1.add(this.scheduler.schedule(ExpandSubscriber2.dispatch, 0, state));
            }
          } catch (e6) {
            destination.error(e6);
          }
        } else {
          this.buffer.push(value2);
        }
      };
      ExpandSubscriber2.prototype.subscribeToProjection = function(result, value2, index) {
        this.active++;
        var destination = this.destination;
        destination.add(innerSubscribe(result, new SimpleInnerSubscriber(this)));
      };
      ExpandSubscriber2.prototype._complete = function() {
        this.hasCompleted = true;
        if (this.hasCompleted && this.active === 0) {
          this.destination.complete();
        }
        this.unsubscribe();
      };
      ExpandSubscriber2.prototype.notifyNext = function(innerValue) {
        this._next(innerValue);
      };
      ExpandSubscriber2.prototype.notifyComplete = function() {
        var buffer2 = this.buffer;
        this.active--;
        if (buffer2 && buffer2.length > 0) {
          this._next(buffer2.shift());
        }
        if (this.hasCompleted && this.active === 0) {
          this.destination.complete();
        }
      };
      return ExpandSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/finalize.js
function finalize(callback) {
  return function(source) {
    return source.lift(new FinallyOperator(callback));
  };
}
var FinallyOperator, FinallySubscriber;
var init_finalize = __esm({
  "node_modules/rxjs/_esm5/internal/operators/finalize.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_Subscription();
    FinallyOperator = function() {
      function FinallyOperator2(callback) {
        this.callback = callback;
      }
      FinallyOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new FinallySubscriber(subscriber, this.callback));
      };
      return FinallyOperator2;
    }();
    FinallySubscriber = function(_super) {
      __extends(FinallySubscriber2, _super);
      function FinallySubscriber2(destination, callback) {
        var _this = _super.call(this, destination) || this;
        _this.add(new Subscription(callback));
        return _this;
      }
      return FinallySubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/find.js
function find(predicate, thisArg) {
  if (typeof predicate !== "function") {
    throw new TypeError("predicate is not a function");
  }
  return function(source) {
    return source.lift(new FindValueOperator(predicate, source, false, thisArg));
  };
}
var FindValueOperator, FindValueSubscriber;
var init_find = __esm({
  "node_modules/rxjs/_esm5/internal/operators/find.js"() {
    init_tslib_es6();
    init_Subscriber();
    FindValueOperator = function() {
      function FindValueOperator2(predicate, source, yieldIndex, thisArg) {
        this.predicate = predicate;
        this.source = source;
        this.yieldIndex = yieldIndex;
        this.thisArg = thisArg;
      }
      FindValueOperator2.prototype.call = function(observer, source) {
        return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));
      };
      return FindValueOperator2;
    }();
    FindValueSubscriber = function(_super) {
      __extends(FindValueSubscriber2, _super);
      function FindValueSubscriber2(destination, predicate, source, yieldIndex, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.yieldIndex = yieldIndex;
        _this.thisArg = thisArg;
        _this.index = 0;
        return _this;
      }
      FindValueSubscriber2.prototype.notifyComplete = function(value2) {
        var destination = this.destination;
        destination.next(value2);
        destination.complete();
        this.unsubscribe();
      };
      FindValueSubscriber2.prototype._next = function(value2) {
        var _a2 = this, predicate = _a2.predicate, thisArg = _a2.thisArg;
        var index = this.index++;
        try {
          var result = predicate.call(thisArg || this, value2, index, this.source);
          if (result) {
            this.notifyComplete(this.yieldIndex ? index : value2);
          }
        } catch (err) {
          this.destination.error(err);
        }
      };
      FindValueSubscriber2.prototype._complete = function() {
        this.notifyComplete(this.yieldIndex ? -1 : void 0);
      };
      return FindValueSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/findIndex.js
function findIndex(predicate, thisArg) {
  return function(source) {
    return source.lift(new FindValueOperator(predicate, source, true, thisArg));
  };
}
var init_findIndex = __esm({
  "node_modules/rxjs/_esm5/internal/operators/findIndex.js"() {
    init_find();
  }
});

// node_modules/rxjs/_esm5/internal/operators/first.js
function first(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(predicate ? filter(function(v9, i6) {
      return predicate(v9, i6, source);
    }) : identity, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
var init_first = __esm({
  "node_modules/rxjs/_esm5/internal/operators/first.js"() {
    init_EmptyError();
    init_filter();
    init_take();
    init_defaultIfEmpty();
    init_throwIfEmpty();
    init_identity();
  }
});

// node_modules/rxjs/_esm5/internal/operators/ignoreElements.js
function ignoreElements() {
  return function ignoreElementsOperatorFunction(source) {
    return source.lift(new IgnoreElementsOperator());
  };
}
var IgnoreElementsOperator, IgnoreElementsSubscriber;
var init_ignoreElements = __esm({
  "node_modules/rxjs/_esm5/internal/operators/ignoreElements.js"() {
    init_tslib_es6();
    init_Subscriber();
    IgnoreElementsOperator = function() {
      function IgnoreElementsOperator2() {
      }
      IgnoreElementsOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new IgnoreElementsSubscriber(subscriber));
      };
      return IgnoreElementsOperator2;
    }();
    IgnoreElementsSubscriber = function(_super) {
      __extends(IgnoreElementsSubscriber2, _super);
      function IgnoreElementsSubscriber2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      IgnoreElementsSubscriber2.prototype._next = function(unused) {
      };
      return IgnoreElementsSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/isEmpty.js
function isEmpty() {
  return function(source) {
    return source.lift(new IsEmptyOperator());
  };
}
var IsEmptyOperator, IsEmptySubscriber;
var init_isEmpty = __esm({
  "node_modules/rxjs/_esm5/internal/operators/isEmpty.js"() {
    init_tslib_es6();
    init_Subscriber();
    IsEmptyOperator = function() {
      function IsEmptyOperator2() {
      }
      IsEmptyOperator2.prototype.call = function(observer, source) {
        return source.subscribe(new IsEmptySubscriber(observer));
      };
      return IsEmptyOperator2;
    }();
    IsEmptySubscriber = function(_super) {
      __extends(IsEmptySubscriber2, _super);
      function IsEmptySubscriber2(destination) {
        return _super.call(this, destination) || this;
      }
      IsEmptySubscriber2.prototype.notifyComplete = function(isEmpty2) {
        var destination = this.destination;
        destination.next(isEmpty2);
        destination.complete();
      };
      IsEmptySubscriber2.prototype._next = function(value2) {
        this.notifyComplete(false);
      };
      IsEmptySubscriber2.prototype._complete = function() {
        this.notifyComplete(true);
      };
      return IsEmptySubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/takeLast.js
function takeLast(count2) {
  return function takeLastOperatorFunction(source) {
    if (count2 === 0) {
      return empty2();
    } else {
      return source.lift(new TakeLastOperator(count2));
    }
  };
}
var TakeLastOperator, TakeLastSubscriber;
var init_takeLast = __esm({
  "node_modules/rxjs/_esm5/internal/operators/takeLast.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_ArgumentOutOfRangeError();
    init_empty();
    TakeLastOperator = function() {
      function TakeLastOperator2(total) {
        this.total = total;
        if (this.total < 0) {
          throw new ArgumentOutOfRangeError();
        }
      }
      TakeLastOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new TakeLastSubscriber(subscriber, this.total));
      };
      return TakeLastOperator2;
    }();
    TakeLastSubscriber = function(_super) {
      __extends(TakeLastSubscriber2, _super);
      function TakeLastSubscriber2(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.ring = new Array();
        _this.count = 0;
        return _this;
      }
      TakeLastSubscriber2.prototype._next = function(value2) {
        var ring = this.ring;
        var total = this.total;
        var count2 = this.count++;
        if (ring.length < total) {
          ring.push(value2);
        } else {
          var index = count2 % total;
          ring[index] = value2;
        }
      };
      TakeLastSubscriber2.prototype._complete = function() {
        var destination = this.destination;
        var count2 = this.count;
        if (count2 > 0) {
          var total = this.count >= this.total ? this.total : this.count;
          var ring = this.ring;
          for (var i6 = 0; i6 < total; i6++) {
            var idx = count2++ % total;
            destination.next(ring[idx]);
          }
        }
        destination.complete();
      };
      return TakeLastSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/last.js
function last(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(predicate ? filter(function(v9, i6) {
      return predicate(v9, i6, source);
    }) : identity, takeLast(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
var init_last = __esm({
  "node_modules/rxjs/_esm5/internal/operators/last.js"() {
    init_EmptyError();
    init_filter();
    init_takeLast();
    init_throwIfEmpty();
    init_defaultIfEmpty();
    init_identity();
  }
});

// node_modules/rxjs/_esm5/internal/operators/mapTo.js
function mapTo(value2) {
  return function(source) {
    return source.lift(new MapToOperator(value2));
  };
}
var MapToOperator, MapToSubscriber;
var init_mapTo = __esm({
  "node_modules/rxjs/_esm5/internal/operators/mapTo.js"() {
    init_tslib_es6();
    init_Subscriber();
    MapToOperator = function() {
      function MapToOperator2(value2) {
        this.value = value2;
      }
      MapToOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new MapToSubscriber(subscriber, this.value));
      };
      return MapToOperator2;
    }();
    MapToSubscriber = function(_super) {
      __extends(MapToSubscriber2, _super);
      function MapToSubscriber2(destination, value2) {
        var _this = _super.call(this, destination) || this;
        _this.value = value2;
        return _this;
      }
      MapToSubscriber2.prototype._next = function(x6) {
        this.destination.next(this.value);
      };
      return MapToSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/materialize.js
function materialize() {
  return function materializeOperatorFunction(source) {
    return source.lift(new MaterializeOperator());
  };
}
var MaterializeOperator, MaterializeSubscriber;
var init_materialize = __esm({
  "node_modules/rxjs/_esm5/internal/operators/materialize.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_Notification();
    MaterializeOperator = function() {
      function MaterializeOperator2() {
      }
      MaterializeOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new MaterializeSubscriber(subscriber));
      };
      return MaterializeOperator2;
    }();
    MaterializeSubscriber = function(_super) {
      __extends(MaterializeSubscriber2, _super);
      function MaterializeSubscriber2(destination) {
        return _super.call(this, destination) || this;
      }
      MaterializeSubscriber2.prototype._next = function(value2) {
        this.destination.next(Notification.createNext(value2));
      };
      MaterializeSubscriber2.prototype._error = function(err) {
        var destination = this.destination;
        destination.next(Notification.createError(err));
        destination.complete();
      };
      MaterializeSubscriber2.prototype._complete = function() {
        var destination = this.destination;
        destination.next(Notification.createComplete());
        destination.complete();
      };
      return MaterializeSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/scan.js
function scan(accumulator, seed) {
  var hasSeed = false;
  if (arguments.length >= 2) {
    hasSeed = true;
  }
  return function scanOperatorFunction(source) {
    return source.lift(new ScanOperator(accumulator, seed, hasSeed));
  };
}
var ScanOperator, ScanSubscriber;
var init_scan = __esm({
  "node_modules/rxjs/_esm5/internal/operators/scan.js"() {
    init_tslib_es6();
    init_Subscriber();
    ScanOperator = function() {
      function ScanOperator2(accumulator, seed, hasSeed) {
        if (hasSeed === void 0) {
          hasSeed = false;
        }
        this.accumulator = accumulator;
        this.seed = seed;
        this.hasSeed = hasSeed;
      }
      ScanOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
      };
      return ScanOperator2;
    }();
    ScanSubscriber = function(_super) {
      __extends(ScanSubscriber2, _super);
      function ScanSubscriber2(destination, accumulator, _seed, hasSeed) {
        var _this = _super.call(this, destination) || this;
        _this.accumulator = accumulator;
        _this._seed = _seed;
        _this.hasSeed = hasSeed;
        _this.index = 0;
        return _this;
      }
      Object.defineProperty(ScanSubscriber2.prototype, "seed", {
        get: function() {
          return this._seed;
        },
        set: function(value2) {
          this.hasSeed = true;
          this._seed = value2;
        },
        enumerable: true,
        configurable: true
      });
      ScanSubscriber2.prototype._next = function(value2) {
        if (!this.hasSeed) {
          this.seed = value2;
          this.destination.next(value2);
        } else {
          return this._tryNext(value2);
        }
      };
      ScanSubscriber2.prototype._tryNext = function(value2) {
        var index = this.index++;
        var result;
        try {
          result = this.accumulator(this.seed, value2, index);
        } catch (err) {
          this.destination.error(err);
        }
        this.seed = result;
        this.destination.next(result);
      };
      return ScanSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/reduce.js
function reduce(accumulator, seed) {
  if (arguments.length >= 2) {
    return function reduceOperatorFunctionWithSeed(source) {
      return pipe(scan(accumulator, seed), takeLast(1), defaultIfEmpty(seed))(source);
    };
  }
  return function reduceOperatorFunction(source) {
    return pipe(scan(function(acc, value2, index) {
      return accumulator(acc, value2, index + 1);
    }), takeLast(1))(source);
  };
}
var init_reduce = __esm({
  "node_modules/rxjs/_esm5/internal/operators/reduce.js"() {
    init_scan();
    init_takeLast();
    init_defaultIfEmpty();
    init_pipe();
  }
});

// node_modules/rxjs/_esm5/internal/operators/max.js
function max(comparer) {
  var max2 = typeof comparer === "function" ? function(x6, y5) {
    return comparer(x6, y5) > 0 ? x6 : y5;
  } : function(x6, y5) {
    return x6 > y5 ? x6 : y5;
  };
  return reduce(max2);
}
var init_max = __esm({
  "node_modules/rxjs/_esm5/internal/operators/max.js"() {
    init_reduce();
  }
});

// node_modules/rxjs/_esm5/internal/operators/merge.js
function merge2() {
  var observables = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    observables[_i2] = arguments[_i2];
  }
  return function(source) {
    return source.lift.call(merge.apply(void 0, [source].concat(observables)));
  };
}
var init_merge2 = __esm({
  "node_modules/rxjs/_esm5/internal/operators/merge.js"() {
    init_merge();
  }
});

// node_modules/rxjs/_esm5/internal/operators/mergeMapTo.js
function mergeMapTo(innerObservable, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  if (typeof resultSelector === "function") {
    return mergeMap(function() {
      return innerObservable;
    }, resultSelector, concurrent);
  }
  if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return mergeMap(function() {
    return innerObservable;
  }, concurrent);
}
var init_mergeMapTo = __esm({
  "node_modules/rxjs/_esm5/internal/operators/mergeMapTo.js"() {
    init_mergeMap();
  }
});

// node_modules/rxjs/_esm5/internal/operators/mergeScan.js
function mergeScan(accumulator, seed, concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  return function(source) {
    return source.lift(new MergeScanOperator(accumulator, seed, concurrent));
  };
}
var MergeScanOperator, MergeScanSubscriber;
var init_mergeScan = __esm({
  "node_modules/rxjs/_esm5/internal/operators/mergeScan.js"() {
    init_tslib_es6();
    init_innerSubscribe();
    MergeScanOperator = function() {
      function MergeScanOperator2(accumulator, seed, concurrent) {
        this.accumulator = accumulator;
        this.seed = seed;
        this.concurrent = concurrent;
      }
      MergeScanOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));
      };
      return MergeScanOperator2;
    }();
    MergeScanSubscriber = function(_super) {
      __extends(MergeScanSubscriber2, _super);
      function MergeScanSubscriber2(destination, accumulator, acc, concurrent) {
        var _this = _super.call(this, destination) || this;
        _this.accumulator = accumulator;
        _this.acc = acc;
        _this.concurrent = concurrent;
        _this.hasValue = false;
        _this.hasCompleted = false;
        _this.buffer = [];
        _this.active = 0;
        _this.index = 0;
        return _this;
      }
      MergeScanSubscriber2.prototype._next = function(value2) {
        if (this.active < this.concurrent) {
          var index = this.index++;
          var destination = this.destination;
          var ish = void 0;
          try {
            var accumulator = this.accumulator;
            ish = accumulator(this.acc, value2, index);
          } catch (e6) {
            return destination.error(e6);
          }
          this.active++;
          this._innerSub(ish);
        } else {
          this.buffer.push(value2);
        }
      };
      MergeScanSubscriber2.prototype._innerSub = function(ish) {
        var innerSubscriber = new SimpleInnerSubscriber(this);
        var destination = this.destination;
        destination.add(innerSubscriber);
        var innerSubscription = innerSubscribe(ish, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
          destination.add(innerSubscription);
        }
      };
      MergeScanSubscriber2.prototype._complete = function() {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
          if (this.hasValue === false) {
            this.destination.next(this.acc);
          }
          this.destination.complete();
        }
        this.unsubscribe();
      };
      MergeScanSubscriber2.prototype.notifyNext = function(innerValue) {
        var destination = this.destination;
        this.acc = innerValue;
        this.hasValue = true;
        destination.next(innerValue);
      };
      MergeScanSubscriber2.prototype.notifyComplete = function() {
        var buffer2 = this.buffer;
        this.active--;
        if (buffer2.length > 0) {
          this._next(buffer2.shift());
        } else if (this.active === 0 && this.hasCompleted) {
          if (this.hasValue === false) {
            this.destination.next(this.acc);
          }
          this.destination.complete();
        }
      };
      return MergeScanSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/min.js
function min(comparer) {
  var min2 = typeof comparer === "function" ? function(x6, y5) {
    return comparer(x6, y5) < 0 ? x6 : y5;
  } : function(x6, y5) {
    return x6 < y5 ? x6 : y5;
  };
  return reduce(min2);
}
var init_min = __esm({
  "node_modules/rxjs/_esm5/internal/operators/min.js"() {
    init_reduce();
  }
});

// node_modules/rxjs/_esm5/internal/operators/multicast.js
function multicast(subjectOrSubjectFactory, selector) {
  return function multicastOperatorFunction(source) {
    var subjectFactory;
    if (typeof subjectOrSubjectFactory === "function") {
      subjectFactory = subjectOrSubjectFactory;
    } else {
      subjectFactory = function subjectFactory2() {
        return subjectOrSubjectFactory;
      };
    }
    if (typeof selector === "function") {
      return source.lift(new MulticastOperator(subjectFactory, selector));
    }
    var connectable = Object.create(source, connectableObservableDescriptor);
    connectable.source = source;
    connectable.subjectFactory = subjectFactory;
    return connectable;
  };
}
var MulticastOperator;
var init_multicast = __esm({
  "node_modules/rxjs/_esm5/internal/operators/multicast.js"() {
    init_ConnectableObservable();
    MulticastOperator = function() {
      function MulticastOperator2(subjectFactory, selector) {
        this.subjectFactory = subjectFactory;
        this.selector = selector;
      }
      MulticastOperator2.prototype.call = function(subscriber, source) {
        var selector = this.selector;
        var subject = this.subjectFactory();
        var subscription = selector(subject).subscribe(subscriber);
        subscription.add(source.subscribe(subject));
        return subscription;
      };
      return MulticastOperator2;
    }();
  }
});

// node_modules/rxjs/_esm5/internal/operators/onErrorResumeNext.js
function onErrorResumeNext2() {
  var nextSources = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    nextSources[_i2] = arguments[_i2];
  }
  if (nextSources.length === 1 && isArray(nextSources[0])) {
    nextSources = nextSources[0];
  }
  return function(source) {
    return source.lift(new OnErrorResumeNextOperator(nextSources));
  };
}
var OnErrorResumeNextOperator, OnErrorResumeNextSubscriber;
var init_onErrorResumeNext2 = __esm({
  "node_modules/rxjs/_esm5/internal/operators/onErrorResumeNext.js"() {
    init_tslib_es6();
    init_from();
    init_isArray();
    init_innerSubscribe();
    OnErrorResumeNextOperator = function() {
      function OnErrorResumeNextOperator2(nextSources) {
        this.nextSources = nextSources;
      }
      OnErrorResumeNextOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));
      };
      return OnErrorResumeNextOperator2;
    }();
    OnErrorResumeNextSubscriber = function(_super) {
      __extends(OnErrorResumeNextSubscriber2, _super);
      function OnErrorResumeNextSubscriber2(destination, nextSources) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.nextSources = nextSources;
        return _this;
      }
      OnErrorResumeNextSubscriber2.prototype.notifyError = function() {
        this.subscribeToNextSource();
      };
      OnErrorResumeNextSubscriber2.prototype.notifyComplete = function() {
        this.subscribeToNextSource();
      };
      OnErrorResumeNextSubscriber2.prototype._error = function(err) {
        this.subscribeToNextSource();
        this.unsubscribe();
      };
      OnErrorResumeNextSubscriber2.prototype._complete = function() {
        this.subscribeToNextSource();
        this.unsubscribe();
      };
      OnErrorResumeNextSubscriber2.prototype.subscribeToNextSource = function() {
        var next = this.nextSources.shift();
        if (!!next) {
          var innerSubscriber = new SimpleInnerSubscriber(this);
          var destination = this.destination;
          destination.add(innerSubscriber);
          var innerSubscription = innerSubscribe(next, innerSubscriber);
          if (innerSubscription !== innerSubscriber) {
            destination.add(innerSubscription);
          }
        } else {
          this.destination.complete();
        }
      };
      return OnErrorResumeNextSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/pairwise.js
function pairwise() {
  return function(source) {
    return source.lift(new PairwiseOperator());
  };
}
var PairwiseOperator, PairwiseSubscriber;
var init_pairwise = __esm({
  "node_modules/rxjs/_esm5/internal/operators/pairwise.js"() {
    init_tslib_es6();
    init_Subscriber();
    PairwiseOperator = function() {
      function PairwiseOperator2() {
      }
      PairwiseOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new PairwiseSubscriber(subscriber));
      };
      return PairwiseOperator2;
    }();
    PairwiseSubscriber = function(_super) {
      __extends(PairwiseSubscriber2, _super);
      function PairwiseSubscriber2(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasPrev = false;
        return _this;
      }
      PairwiseSubscriber2.prototype._next = function(value2) {
        var pair;
        if (this.hasPrev) {
          pair = [this.prev, value2];
        } else {
          this.hasPrev = true;
        }
        this.prev = value2;
        if (pair) {
          this.destination.next(pair);
        }
      };
      return PairwiseSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/partition.js
function partition2(predicate, thisArg) {
  return function(source) {
    return [
      filter(predicate, thisArg)(source),
      filter(not(predicate, thisArg))(source)
    ];
  };
}
var init_partition2 = __esm({
  "node_modules/rxjs/_esm5/internal/operators/partition.js"() {
    init_not();
    init_filter();
  }
});

// node_modules/rxjs/_esm5/internal/operators/pluck.js
function pluck() {
  var properties = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    properties[_i2] = arguments[_i2];
  }
  var length = properties.length;
  if (length === 0) {
    throw new Error("list of properties cannot be empty.");
  }
  return function(source) {
    return map(plucker(properties, length))(source);
  };
}
function plucker(props, length) {
  var mapper = function(x6) {
    var currentProp = x6;
    for (var i6 = 0; i6 < length; i6++) {
      var p7 = currentProp != null ? currentProp[props[i6]] : void 0;
      if (p7 !== void 0) {
        currentProp = p7;
      } else {
        return void 0;
      }
    }
    return currentProp;
  };
  return mapper;
}
var init_pluck = __esm({
  "node_modules/rxjs/_esm5/internal/operators/pluck.js"() {
    init_map();
  }
});

// node_modules/rxjs/_esm5/internal/operators/publish.js
function publish(selector) {
  return selector ? multicast(function() {
    return new Subject();
  }, selector) : multicast(new Subject());
}
var init_publish = __esm({
  "node_modules/rxjs/_esm5/internal/operators/publish.js"() {
    init_Subject();
    init_multicast();
  }
});

// node_modules/rxjs/_esm5/internal/operators/publishBehavior.js
function publishBehavior(value2) {
  return function(source) {
    return multicast(new BehaviorSubject(value2))(source);
  };
}
var init_publishBehavior = __esm({
  "node_modules/rxjs/_esm5/internal/operators/publishBehavior.js"() {
    init_BehaviorSubject();
    init_multicast();
  }
});

// node_modules/rxjs/_esm5/internal/operators/publishLast.js
function publishLast() {
  return function(source) {
    return multicast(new AsyncSubject())(source);
  };
}
var init_publishLast = __esm({
  "node_modules/rxjs/_esm5/internal/operators/publishLast.js"() {
    init_AsyncSubject();
    init_multicast();
  }
});

// node_modules/rxjs/_esm5/internal/operators/publishReplay.js
function publishReplay(bufferSize, windowTime2, selectorOrScheduler, scheduler) {
  if (selectorOrScheduler && typeof selectorOrScheduler !== "function") {
    scheduler = selectorOrScheduler;
  }
  var selector = typeof selectorOrScheduler === "function" ? selectorOrScheduler : void 0;
  var subject = new ReplaySubject(bufferSize, windowTime2, scheduler);
  return function(source) {
    return multicast(function() {
      return subject;
    }, selector)(source);
  };
}
var init_publishReplay = __esm({
  "node_modules/rxjs/_esm5/internal/operators/publishReplay.js"() {
    init_ReplaySubject();
    init_multicast();
  }
});

// node_modules/rxjs/_esm5/internal/operators/race.js
function race2() {
  var observables = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    observables[_i2] = arguments[_i2];
  }
  return function raceOperatorFunction(source) {
    if (observables.length === 1 && isArray(observables[0])) {
      observables = observables[0];
    }
    return source.lift.call(race.apply(void 0, [source].concat(observables)));
  };
}
var init_race2 = __esm({
  "node_modules/rxjs/_esm5/internal/operators/race.js"() {
    init_isArray();
    init_race();
  }
});

// node_modules/rxjs/_esm5/internal/operators/repeat.js
function repeat(count2) {
  if (count2 === void 0) {
    count2 = -1;
  }
  return function(source) {
    if (count2 === 0) {
      return empty2();
    } else if (count2 < 0) {
      return source.lift(new RepeatOperator(-1, source));
    } else {
      return source.lift(new RepeatOperator(count2 - 1, source));
    }
  };
}
var RepeatOperator, RepeatSubscriber;
var init_repeat = __esm({
  "node_modules/rxjs/_esm5/internal/operators/repeat.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_empty();
    RepeatOperator = function() {
      function RepeatOperator2(count2, source) {
        this.count = count2;
        this.source = source;
      }
      RepeatOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));
      };
      return RepeatOperator2;
    }();
    RepeatSubscriber = function(_super) {
      __extends(RepeatSubscriber2, _super);
      function RepeatSubscriber2(destination, count2, source) {
        var _this = _super.call(this, destination) || this;
        _this.count = count2;
        _this.source = source;
        return _this;
      }
      RepeatSubscriber2.prototype.complete = function() {
        if (!this.isStopped) {
          var _a2 = this, source = _a2.source, count2 = _a2.count;
          if (count2 === 0) {
            return _super.prototype.complete.call(this);
          } else if (count2 > -1) {
            this.count = count2 - 1;
          }
          source.subscribe(this._unsubscribeAndRecycle());
        }
      };
      return RepeatSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/repeatWhen.js
function repeatWhen(notifier) {
  return function(source) {
    return source.lift(new RepeatWhenOperator(notifier));
  };
}
var RepeatWhenOperator, RepeatWhenSubscriber;
var init_repeatWhen = __esm({
  "node_modules/rxjs/_esm5/internal/operators/repeatWhen.js"() {
    init_tslib_es6();
    init_Subject();
    init_innerSubscribe();
    RepeatWhenOperator = function() {
      function RepeatWhenOperator2(notifier) {
        this.notifier = notifier;
      }
      RepeatWhenOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));
      };
      return RepeatWhenOperator2;
    }();
    RepeatWhenSubscriber = function(_super) {
      __extends(RepeatWhenSubscriber2, _super);
      function RepeatWhenSubscriber2(destination, notifier, source) {
        var _this = _super.call(this, destination) || this;
        _this.notifier = notifier;
        _this.source = source;
        _this.sourceIsBeingSubscribedTo = true;
        return _this;
      }
      RepeatWhenSubscriber2.prototype.notifyNext = function() {
        this.sourceIsBeingSubscribedTo = true;
        this.source.subscribe(this);
      };
      RepeatWhenSubscriber2.prototype.notifyComplete = function() {
        if (this.sourceIsBeingSubscribedTo === false) {
          return _super.prototype.complete.call(this);
        }
      };
      RepeatWhenSubscriber2.prototype.complete = function() {
        this.sourceIsBeingSubscribedTo = false;
        if (!this.isStopped) {
          if (!this.retries) {
            this.subscribeToRetries();
          }
          if (!this.retriesSubscription || this.retriesSubscription.closed) {
            return _super.prototype.complete.call(this);
          }
          this._unsubscribeAndRecycle();
          this.notifications.next(void 0);
        }
      };
      RepeatWhenSubscriber2.prototype._unsubscribe = function() {
        var _a2 = this, notifications = _a2.notifications, retriesSubscription = _a2.retriesSubscription;
        if (notifications) {
          notifications.unsubscribe();
          this.notifications = void 0;
        }
        if (retriesSubscription) {
          retriesSubscription.unsubscribe();
          this.retriesSubscription = void 0;
        }
        this.retries = void 0;
      };
      RepeatWhenSubscriber2.prototype._unsubscribeAndRecycle = function() {
        var _unsubscribe = this._unsubscribe;
        this._unsubscribe = null;
        _super.prototype._unsubscribeAndRecycle.call(this);
        this._unsubscribe = _unsubscribe;
        return this;
      };
      RepeatWhenSubscriber2.prototype.subscribeToRetries = function() {
        this.notifications = new Subject();
        var retries;
        try {
          var notifier = this.notifier;
          retries = notifier(this.notifications);
        } catch (e6) {
          return _super.prototype.complete.call(this);
        }
        this.retries = retries;
        this.retriesSubscription = innerSubscribe(retries, new SimpleInnerSubscriber(this));
      };
      return RepeatWhenSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/retry.js
function retry(count2) {
  if (count2 === void 0) {
    count2 = -1;
  }
  return function(source) {
    return source.lift(new RetryOperator(count2, source));
  };
}
var RetryOperator, RetrySubscriber;
var init_retry = __esm({
  "node_modules/rxjs/_esm5/internal/operators/retry.js"() {
    init_tslib_es6();
    init_Subscriber();
    RetryOperator = function() {
      function RetryOperator2(count2, source) {
        this.count = count2;
        this.source = source;
      }
      RetryOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));
      };
      return RetryOperator2;
    }();
    RetrySubscriber = function(_super) {
      __extends(RetrySubscriber2, _super);
      function RetrySubscriber2(destination, count2, source) {
        var _this = _super.call(this, destination) || this;
        _this.count = count2;
        _this.source = source;
        return _this;
      }
      RetrySubscriber2.prototype.error = function(err) {
        if (!this.isStopped) {
          var _a2 = this, source = _a2.source, count2 = _a2.count;
          if (count2 === 0) {
            return _super.prototype.error.call(this, err);
          } else if (count2 > -1) {
            this.count = count2 - 1;
          }
          source.subscribe(this._unsubscribeAndRecycle());
        }
      };
      return RetrySubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/retryWhen.js
function retryWhen(notifier) {
  return function(source) {
    return source.lift(new RetryWhenOperator(notifier, source));
  };
}
var RetryWhenOperator, RetryWhenSubscriber;
var init_retryWhen = __esm({
  "node_modules/rxjs/_esm5/internal/operators/retryWhen.js"() {
    init_tslib_es6();
    init_Subject();
    init_innerSubscribe();
    RetryWhenOperator = function() {
      function RetryWhenOperator2(notifier, source) {
        this.notifier = notifier;
        this.source = source;
      }
      RetryWhenOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));
      };
      return RetryWhenOperator2;
    }();
    RetryWhenSubscriber = function(_super) {
      __extends(RetryWhenSubscriber2, _super);
      function RetryWhenSubscriber2(destination, notifier, source) {
        var _this = _super.call(this, destination) || this;
        _this.notifier = notifier;
        _this.source = source;
        return _this;
      }
      RetryWhenSubscriber2.prototype.error = function(err) {
        if (!this.isStopped) {
          var errors = this.errors;
          var retries = this.retries;
          var retriesSubscription = this.retriesSubscription;
          if (!retries) {
            errors = new Subject();
            try {
              var notifier = this.notifier;
              retries = notifier(errors);
            } catch (e6) {
              return _super.prototype.error.call(this, e6);
            }
            retriesSubscription = innerSubscribe(retries, new SimpleInnerSubscriber(this));
          } else {
            this.errors = void 0;
            this.retriesSubscription = void 0;
          }
          this._unsubscribeAndRecycle();
          this.errors = errors;
          this.retries = retries;
          this.retriesSubscription = retriesSubscription;
          errors.next(err);
        }
      };
      RetryWhenSubscriber2.prototype._unsubscribe = function() {
        var _a2 = this, errors = _a2.errors, retriesSubscription = _a2.retriesSubscription;
        if (errors) {
          errors.unsubscribe();
          this.errors = void 0;
        }
        if (retriesSubscription) {
          retriesSubscription.unsubscribe();
          this.retriesSubscription = void 0;
        }
        this.retries = void 0;
      };
      RetryWhenSubscriber2.prototype.notifyNext = function() {
        var _unsubscribe = this._unsubscribe;
        this._unsubscribe = null;
        this._unsubscribeAndRecycle();
        this._unsubscribe = _unsubscribe;
        this.source.subscribe(this);
      };
      return RetryWhenSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/sample.js
function sample(notifier) {
  return function(source) {
    return source.lift(new SampleOperator(notifier));
  };
}
var SampleOperator, SampleSubscriber;
var init_sample = __esm({
  "node_modules/rxjs/_esm5/internal/operators/sample.js"() {
    init_tslib_es6();
    init_innerSubscribe();
    SampleOperator = function() {
      function SampleOperator2(notifier) {
        this.notifier = notifier;
      }
      SampleOperator2.prototype.call = function(subscriber, source) {
        var sampleSubscriber = new SampleSubscriber(subscriber);
        var subscription = source.subscribe(sampleSubscriber);
        subscription.add(innerSubscribe(this.notifier, new SimpleInnerSubscriber(sampleSubscriber)));
        return subscription;
      };
      return SampleOperator2;
    }();
    SampleSubscriber = function(_super) {
      __extends(SampleSubscriber2, _super);
      function SampleSubscriber2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.hasValue = false;
        return _this;
      }
      SampleSubscriber2.prototype._next = function(value2) {
        this.value = value2;
        this.hasValue = true;
      };
      SampleSubscriber2.prototype.notifyNext = function() {
        this.emitValue();
      };
      SampleSubscriber2.prototype.notifyComplete = function() {
        this.emitValue();
      };
      SampleSubscriber2.prototype.emitValue = function() {
        if (this.hasValue) {
          this.hasValue = false;
          this.destination.next(this.value);
        }
      };
      return SampleSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/sampleTime.js
function sampleTime(period, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return function(source) {
    return source.lift(new SampleTimeOperator(period, scheduler));
  };
}
function dispatchNotification(state) {
  var subscriber = state.subscriber, period = state.period;
  subscriber.notifyNext();
  this.schedule(state, period);
}
var SampleTimeOperator, SampleTimeSubscriber;
var init_sampleTime = __esm({
  "node_modules/rxjs/_esm5/internal/operators/sampleTime.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_async();
    SampleTimeOperator = function() {
      function SampleTimeOperator2(period, scheduler) {
        this.period = period;
        this.scheduler = scheduler;
      }
      SampleTimeOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));
      };
      return SampleTimeOperator2;
    }();
    SampleTimeSubscriber = function(_super) {
      __extends(SampleTimeSubscriber2, _super);
      function SampleTimeSubscriber2(destination, period, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.period = period;
        _this.scheduler = scheduler;
        _this.hasValue = false;
        _this.add(scheduler.schedule(dispatchNotification, period, { subscriber: _this, period }));
        return _this;
      }
      SampleTimeSubscriber2.prototype._next = function(value2) {
        this.lastValue = value2;
        this.hasValue = true;
      };
      SampleTimeSubscriber2.prototype.notifyNext = function() {
        if (this.hasValue) {
          this.hasValue = false;
          this.destination.next(this.lastValue);
        }
      };
      return SampleTimeSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/sequenceEqual.js
function sequenceEqual(compareTo, comparator) {
  return function(source) {
    return source.lift(new SequenceEqualOperator(compareTo, comparator));
  };
}
var SequenceEqualOperator, SequenceEqualSubscriber, SequenceEqualCompareToSubscriber;
var init_sequenceEqual = __esm({
  "node_modules/rxjs/_esm5/internal/operators/sequenceEqual.js"() {
    init_tslib_es6();
    init_Subscriber();
    SequenceEqualOperator = function() {
      function SequenceEqualOperator2(compareTo, comparator) {
        this.compareTo = compareTo;
        this.comparator = comparator;
      }
      SequenceEqualOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparator));
      };
      return SequenceEqualOperator2;
    }();
    SequenceEqualSubscriber = function(_super) {
      __extends(SequenceEqualSubscriber2, _super);
      function SequenceEqualSubscriber2(destination, compareTo, comparator) {
        var _this = _super.call(this, destination) || this;
        _this.compareTo = compareTo;
        _this.comparator = comparator;
        _this._a = [];
        _this._b = [];
        _this._oneComplete = false;
        _this.destination.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, _this)));
        return _this;
      }
      SequenceEqualSubscriber2.prototype._next = function(value2) {
        if (this._oneComplete && this._b.length === 0) {
          this.emit(false);
        } else {
          this._a.push(value2);
          this.checkValues();
        }
      };
      SequenceEqualSubscriber2.prototype._complete = function() {
        if (this._oneComplete) {
          this.emit(this._a.length === 0 && this._b.length === 0);
        } else {
          this._oneComplete = true;
        }
        this.unsubscribe();
      };
      SequenceEqualSubscriber2.prototype.checkValues = function() {
        var _c = this, _a2 = _c._a, _b = _c._b, comparator = _c.comparator;
        while (_a2.length > 0 && _b.length > 0) {
          var a5 = _a2.shift();
          var b4 = _b.shift();
          var areEqual = false;
          try {
            areEqual = comparator ? comparator(a5, b4) : a5 === b4;
          } catch (e6) {
            this.destination.error(e6);
          }
          if (!areEqual) {
            this.emit(false);
          }
        }
      };
      SequenceEqualSubscriber2.prototype.emit = function(value2) {
        var destination = this.destination;
        destination.next(value2);
        destination.complete();
      };
      SequenceEqualSubscriber2.prototype.nextB = function(value2) {
        if (this._oneComplete && this._a.length === 0) {
          this.emit(false);
        } else {
          this._b.push(value2);
          this.checkValues();
        }
      };
      SequenceEqualSubscriber2.prototype.completeB = function() {
        if (this._oneComplete) {
          this.emit(this._a.length === 0 && this._b.length === 0);
        } else {
          this._oneComplete = true;
        }
      };
      return SequenceEqualSubscriber2;
    }(Subscriber);
    SequenceEqualCompareToSubscriber = function(_super) {
      __extends(SequenceEqualCompareToSubscriber2, _super);
      function SequenceEqualCompareToSubscriber2(destination, parent) {
        var _this = _super.call(this, destination) || this;
        _this.parent = parent;
        return _this;
      }
      SequenceEqualCompareToSubscriber2.prototype._next = function(value2) {
        this.parent.nextB(value2);
      };
      SequenceEqualCompareToSubscriber2.prototype._error = function(err) {
        this.parent.error(err);
        this.unsubscribe();
      };
      SequenceEqualCompareToSubscriber2.prototype._complete = function() {
        this.parent.completeB();
        this.unsubscribe();
      };
      return SequenceEqualCompareToSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/share.js
function shareSubjectFactory() {
  return new Subject();
}
function share() {
  return function(source) {
    return refCount()(multicast(shareSubjectFactory)(source));
  };
}
var init_share = __esm({
  "node_modules/rxjs/_esm5/internal/operators/share.js"() {
    init_multicast();
    init_refCount();
    init_Subject();
  }
});

// node_modules/rxjs/_esm5/internal/operators/shareReplay.js
function shareReplay(configOrBufferSize, windowTime2, scheduler) {
  var config2;
  if (configOrBufferSize && typeof configOrBufferSize === "object") {
    config2 = configOrBufferSize;
  } else {
    config2 = {
      bufferSize: configOrBufferSize,
      windowTime: windowTime2,
      refCount: false,
      scheduler
    };
  }
  return function(source) {
    return source.lift(shareReplayOperator(config2));
  };
}
function shareReplayOperator(_a2) {
  var _b = _a2.bufferSize, bufferSize = _b === void 0 ? Number.POSITIVE_INFINITY : _b, _c = _a2.windowTime, windowTime2 = _c === void 0 ? Number.POSITIVE_INFINITY : _c, useRefCount = _a2.refCount, scheduler = _a2.scheduler;
  var subject;
  var refCount2 = 0;
  var subscription;
  var hasError = false;
  var isComplete = false;
  return function shareReplayOperation(source) {
    refCount2++;
    var innerSub;
    if (!subject || hasError) {
      hasError = false;
      subject = new ReplaySubject(bufferSize, windowTime2, scheduler);
      innerSub = subject.subscribe(this);
      subscription = source.subscribe({
        next: function(value2) {
          subject.next(value2);
        },
        error: function(err) {
          hasError = true;
          subject.error(err);
        },
        complete: function() {
          isComplete = true;
          subscription = void 0;
          subject.complete();
        }
      });
      if (isComplete) {
        subscription = void 0;
      }
    } else {
      innerSub = subject.subscribe(this);
    }
    this.add(function() {
      refCount2--;
      innerSub.unsubscribe();
      innerSub = void 0;
      if (subscription && !isComplete && useRefCount && refCount2 === 0) {
        subscription.unsubscribe();
        subscription = void 0;
        subject = void 0;
      }
    });
  };
}
var init_shareReplay = __esm({
  "node_modules/rxjs/_esm5/internal/operators/shareReplay.js"() {
    init_ReplaySubject();
  }
});

// node_modules/rxjs/_esm5/internal/operators/single.js
function single(predicate) {
  return function(source) {
    return source.lift(new SingleOperator(predicate, source));
  };
}
var SingleOperator, SingleSubscriber;
var init_single = __esm({
  "node_modules/rxjs/_esm5/internal/operators/single.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_EmptyError();
    SingleOperator = function() {
      function SingleOperator2(predicate, source) {
        this.predicate = predicate;
        this.source = source;
      }
      SingleOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));
      };
      return SingleOperator2;
    }();
    SingleSubscriber = function(_super) {
      __extends(SingleSubscriber2, _super);
      function SingleSubscriber2(destination, predicate, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.seenValue = false;
        _this.index = 0;
        return _this;
      }
      SingleSubscriber2.prototype.applySingleValue = function(value2) {
        if (this.seenValue) {
          this.destination.error("Sequence contains more than one element");
        } else {
          this.seenValue = true;
          this.singleValue = value2;
        }
      };
      SingleSubscriber2.prototype._next = function(value2) {
        var index = this.index++;
        if (this.predicate) {
          this.tryNext(value2, index);
        } else {
          this.applySingleValue(value2);
        }
      };
      SingleSubscriber2.prototype.tryNext = function(value2, index) {
        try {
          if (this.predicate(value2, index, this.source)) {
            this.applySingleValue(value2);
          }
        } catch (err) {
          this.destination.error(err);
        }
      };
      SingleSubscriber2.prototype._complete = function() {
        var destination = this.destination;
        if (this.index > 0) {
          destination.next(this.seenValue ? this.singleValue : void 0);
          destination.complete();
        } else {
          destination.error(new EmptyError());
        }
      };
      return SingleSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/skip.js
function skip(count2) {
  return function(source) {
    return source.lift(new SkipOperator(count2));
  };
}
var SkipOperator, SkipSubscriber;
var init_skip = __esm({
  "node_modules/rxjs/_esm5/internal/operators/skip.js"() {
    init_tslib_es6();
    init_Subscriber();
    SkipOperator = function() {
      function SkipOperator2(total) {
        this.total = total;
      }
      SkipOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new SkipSubscriber(subscriber, this.total));
      };
      return SkipOperator2;
    }();
    SkipSubscriber = function(_super) {
      __extends(SkipSubscriber2, _super);
      function SkipSubscriber2(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.count = 0;
        return _this;
      }
      SkipSubscriber2.prototype._next = function(x6) {
        if (++this.count > this.total) {
          this.destination.next(x6);
        }
      };
      return SkipSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/skipLast.js
function skipLast(count2) {
  return function(source) {
    return source.lift(new SkipLastOperator(count2));
  };
}
var SkipLastOperator, SkipLastSubscriber;
var init_skipLast = __esm({
  "node_modules/rxjs/_esm5/internal/operators/skipLast.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_ArgumentOutOfRangeError();
    SkipLastOperator = function() {
      function SkipLastOperator2(_skipCount) {
        this._skipCount = _skipCount;
        if (this._skipCount < 0) {
          throw new ArgumentOutOfRangeError();
        }
      }
      SkipLastOperator2.prototype.call = function(subscriber, source) {
        if (this._skipCount === 0) {
          return source.subscribe(new Subscriber(subscriber));
        } else {
          return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));
        }
      };
      return SkipLastOperator2;
    }();
    SkipLastSubscriber = function(_super) {
      __extends(SkipLastSubscriber2, _super);
      function SkipLastSubscriber2(destination, _skipCount) {
        var _this = _super.call(this, destination) || this;
        _this._skipCount = _skipCount;
        _this._count = 0;
        _this._ring = new Array(_skipCount);
        return _this;
      }
      SkipLastSubscriber2.prototype._next = function(value2) {
        var skipCount = this._skipCount;
        var count2 = this._count++;
        if (count2 < skipCount) {
          this._ring[count2] = value2;
        } else {
          var currentIndex = count2 % skipCount;
          var ring = this._ring;
          var oldValue = ring[currentIndex];
          ring[currentIndex] = value2;
          this.destination.next(oldValue);
        }
      };
      return SkipLastSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/skipUntil.js
function skipUntil(notifier) {
  return function(source) {
    return source.lift(new SkipUntilOperator(notifier));
  };
}
var SkipUntilOperator, SkipUntilSubscriber;
var init_skipUntil = __esm({
  "node_modules/rxjs/_esm5/internal/operators/skipUntil.js"() {
    init_tslib_es6();
    init_innerSubscribe();
    SkipUntilOperator = function() {
      function SkipUntilOperator2(notifier) {
        this.notifier = notifier;
      }
      SkipUntilOperator2.prototype.call = function(destination, source) {
        return source.subscribe(new SkipUntilSubscriber(destination, this.notifier));
      };
      return SkipUntilOperator2;
    }();
    SkipUntilSubscriber = function(_super) {
      __extends(SkipUntilSubscriber2, _super);
      function SkipUntilSubscriber2(destination, notifier) {
        var _this = _super.call(this, destination) || this;
        _this.hasValue = false;
        var innerSubscriber = new SimpleInnerSubscriber(_this);
        _this.add(innerSubscriber);
        _this.innerSubscription = innerSubscriber;
        var innerSubscription = innerSubscribe(notifier, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
          _this.add(innerSubscription);
          _this.innerSubscription = innerSubscription;
        }
        return _this;
      }
      SkipUntilSubscriber2.prototype._next = function(value2) {
        if (this.hasValue) {
          _super.prototype._next.call(this, value2);
        }
      };
      SkipUntilSubscriber2.prototype.notifyNext = function() {
        this.hasValue = true;
        if (this.innerSubscription) {
          this.innerSubscription.unsubscribe();
        }
      };
      SkipUntilSubscriber2.prototype.notifyComplete = function() {
      };
      return SkipUntilSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/skipWhile.js
function skipWhile(predicate) {
  return function(source) {
    return source.lift(new SkipWhileOperator(predicate));
  };
}
var SkipWhileOperator, SkipWhileSubscriber;
var init_skipWhile = __esm({
  "node_modules/rxjs/_esm5/internal/operators/skipWhile.js"() {
    init_tslib_es6();
    init_Subscriber();
    SkipWhileOperator = function() {
      function SkipWhileOperator2(predicate) {
        this.predicate = predicate;
      }
      SkipWhileOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
      };
      return SkipWhileOperator2;
    }();
    SkipWhileSubscriber = function(_super) {
      __extends(SkipWhileSubscriber2, _super);
      function SkipWhileSubscriber2(destination, predicate) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.skipping = true;
        _this.index = 0;
        return _this;
      }
      SkipWhileSubscriber2.prototype._next = function(value2) {
        var destination = this.destination;
        if (this.skipping) {
          this.tryCallPredicate(value2);
        }
        if (!this.skipping) {
          destination.next(value2);
        }
      };
      SkipWhileSubscriber2.prototype.tryCallPredicate = function(value2) {
        try {
          var result = this.predicate(value2, this.index++);
          this.skipping = Boolean(result);
        } catch (err) {
          this.destination.error(err);
        }
      };
      return SkipWhileSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/startWith.js
function startWith() {
  var array = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    array[_i2] = arguments[_i2];
  }
  var scheduler = array[array.length - 1];
  if (isScheduler(scheduler)) {
    array.pop();
    return function(source) {
      return concat2(array, source, scheduler);
    };
  } else {
    return function(source) {
      return concat2(array, source);
    };
  }
}
var init_startWith = __esm({
  "node_modules/rxjs/_esm5/internal/operators/startWith.js"() {
    init_concat();
    init_isScheduler();
  }
});

// node_modules/rxjs/_esm5/internal/observable/SubscribeOnObservable.js
var SubscribeOnObservable;
var init_SubscribeOnObservable = __esm({
  "node_modules/rxjs/_esm5/internal/observable/SubscribeOnObservable.js"() {
    init_tslib_es6();
    init_Observable();
    init_asap();
    init_isNumeric();
    SubscribeOnObservable = function(_super) {
      __extends(SubscribeOnObservable2, _super);
      function SubscribeOnObservable2(source, delayTime, scheduler) {
        if (delayTime === void 0) {
          delayTime = 0;
        }
        if (scheduler === void 0) {
          scheduler = asap;
        }
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.delayTime = delayTime;
        _this.scheduler = scheduler;
        if (!isNumeric(delayTime) || delayTime < 0) {
          _this.delayTime = 0;
        }
        if (!scheduler || typeof scheduler.schedule !== "function") {
          _this.scheduler = asap;
        }
        return _this;
      }
      SubscribeOnObservable2.create = function(source, delay2, scheduler) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (scheduler === void 0) {
          scheduler = asap;
        }
        return new SubscribeOnObservable2(source, delay2, scheduler);
      };
      SubscribeOnObservable2.dispatch = function(arg) {
        var source = arg.source, subscriber = arg.subscriber;
        return this.add(source.subscribe(subscriber));
      };
      SubscribeOnObservable2.prototype._subscribe = function(subscriber) {
        var delay2 = this.delayTime;
        var source = this.source;
        var scheduler = this.scheduler;
        return scheduler.schedule(SubscribeOnObservable2.dispatch, delay2, {
          source,
          subscriber
        });
      };
      return SubscribeOnObservable2;
    }(Observable);
  }
});

// node_modules/rxjs/_esm5/internal/operators/subscribeOn.js
function subscribeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return function subscribeOnOperatorFunction(source) {
    return source.lift(new SubscribeOnOperator(scheduler, delay2));
  };
}
var SubscribeOnOperator;
var init_subscribeOn = __esm({
  "node_modules/rxjs/_esm5/internal/operators/subscribeOn.js"() {
    init_SubscribeOnObservable();
    SubscribeOnOperator = function() {
      function SubscribeOnOperator2(scheduler, delay2) {
        this.scheduler = scheduler;
        this.delay = delay2;
      }
      SubscribeOnOperator2.prototype.call = function(subscriber, source) {
        return new SubscribeOnObservable(source, this.delay, this.scheduler).subscribe(subscriber);
      };
      return SubscribeOnOperator2;
    }();
  }
});

// node_modules/rxjs/_esm5/internal/operators/switchMap.js
function switchMap(project, resultSelector) {
  if (typeof resultSelector === "function") {
    return function(source) {
      return source.pipe(switchMap(function(a5, i6) {
        return from(project(a5, i6)).pipe(map(function(b4, ii3) {
          return resultSelector(a5, b4, i6, ii3);
        }));
      }));
    };
  }
  return function(source) {
    return source.lift(new SwitchMapOperator(project));
  };
}
var SwitchMapOperator, SwitchMapSubscriber;
var init_switchMap = __esm({
  "node_modules/rxjs/_esm5/internal/operators/switchMap.js"() {
    init_tslib_es6();
    init_map();
    init_from();
    init_innerSubscribe();
    SwitchMapOperator = function() {
      function SwitchMapOperator2(project) {
        this.project = project;
      }
      SwitchMapOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));
      };
      return SwitchMapOperator2;
    }();
    SwitchMapSubscriber = function(_super) {
      __extends(SwitchMapSubscriber2, _super);
      function SwitchMapSubscriber2(destination, project) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.index = 0;
        return _this;
      }
      SwitchMapSubscriber2.prototype._next = function(value2) {
        var result;
        var index = this.index++;
        try {
          result = this.project(value2, index);
        } catch (error) {
          this.destination.error(error);
          return;
        }
        this._innerSub(result);
      };
      SwitchMapSubscriber2.prototype._innerSub = function(result) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
          innerSubscription.unsubscribe();
        }
        var innerSubscriber = new SimpleInnerSubscriber(this);
        var destination = this.destination;
        destination.add(innerSubscriber);
        this.innerSubscription = innerSubscribe(result, innerSubscriber);
        if (this.innerSubscription !== innerSubscriber) {
          destination.add(this.innerSubscription);
        }
      };
      SwitchMapSubscriber2.prototype._complete = function() {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
          _super.prototype._complete.call(this);
        }
        this.unsubscribe();
      };
      SwitchMapSubscriber2.prototype._unsubscribe = function() {
        this.innerSubscription = void 0;
      };
      SwitchMapSubscriber2.prototype.notifyComplete = function() {
        this.innerSubscription = void 0;
        if (this.isStopped) {
          _super.prototype._complete.call(this);
        }
      };
      SwitchMapSubscriber2.prototype.notifyNext = function(innerValue) {
        this.destination.next(innerValue);
      };
      return SwitchMapSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/switchAll.js
function switchAll() {
  return switchMap(identity);
}
var init_switchAll = __esm({
  "node_modules/rxjs/_esm5/internal/operators/switchAll.js"() {
    init_switchMap();
    init_identity();
  }
});

// node_modules/rxjs/_esm5/internal/operators/switchMapTo.js
function switchMapTo(innerObservable, resultSelector) {
  return resultSelector ? switchMap(function() {
    return innerObservable;
  }, resultSelector) : switchMap(function() {
    return innerObservable;
  });
}
var init_switchMapTo = __esm({
  "node_modules/rxjs/_esm5/internal/operators/switchMapTo.js"() {
    init_switchMap();
  }
});

// node_modules/rxjs/_esm5/internal/operators/takeUntil.js
function takeUntil(notifier) {
  return function(source) {
    return source.lift(new TakeUntilOperator(notifier));
  };
}
var TakeUntilOperator, TakeUntilSubscriber;
var init_takeUntil = __esm({
  "node_modules/rxjs/_esm5/internal/operators/takeUntil.js"() {
    init_tslib_es6();
    init_innerSubscribe();
    TakeUntilOperator = function() {
      function TakeUntilOperator2(notifier) {
        this.notifier = notifier;
      }
      TakeUntilOperator2.prototype.call = function(subscriber, source) {
        var takeUntilSubscriber = new TakeUntilSubscriber(subscriber);
        var notifierSubscription = innerSubscribe(this.notifier, new SimpleInnerSubscriber(takeUntilSubscriber));
        if (notifierSubscription && !takeUntilSubscriber.seenValue) {
          takeUntilSubscriber.add(notifierSubscription);
          return source.subscribe(takeUntilSubscriber);
        }
        return takeUntilSubscriber;
      };
      return TakeUntilOperator2;
    }();
    TakeUntilSubscriber = function(_super) {
      __extends(TakeUntilSubscriber2, _super);
      function TakeUntilSubscriber2(destination) {
        var _this = _super.call(this, destination) || this;
        _this.seenValue = false;
        return _this;
      }
      TakeUntilSubscriber2.prototype.notifyNext = function() {
        this.seenValue = true;
        this.complete();
      };
      TakeUntilSubscriber2.prototype.notifyComplete = function() {
      };
      return TakeUntilSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/takeWhile.js
function takeWhile(predicate, inclusive) {
  if (inclusive === void 0) {
    inclusive = false;
  }
  return function(source) {
    return source.lift(new TakeWhileOperator(predicate, inclusive));
  };
}
var TakeWhileOperator, TakeWhileSubscriber;
var init_takeWhile = __esm({
  "node_modules/rxjs/_esm5/internal/operators/takeWhile.js"() {
    init_tslib_es6();
    init_Subscriber();
    TakeWhileOperator = function() {
      function TakeWhileOperator2(predicate, inclusive) {
        this.predicate = predicate;
        this.inclusive = inclusive;
      }
      TakeWhileOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate, this.inclusive));
      };
      return TakeWhileOperator2;
    }();
    TakeWhileSubscriber = function(_super) {
      __extends(TakeWhileSubscriber2, _super);
      function TakeWhileSubscriber2(destination, predicate, inclusive) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.inclusive = inclusive;
        _this.index = 0;
        return _this;
      }
      TakeWhileSubscriber2.prototype._next = function(value2) {
        var destination = this.destination;
        var result;
        try {
          result = this.predicate(value2, this.index++);
        } catch (err) {
          destination.error(err);
          return;
        }
        this.nextOrComplete(value2, result);
      };
      TakeWhileSubscriber2.prototype.nextOrComplete = function(value2, predicateResult) {
        var destination = this.destination;
        if (Boolean(predicateResult)) {
          destination.next(value2);
        } else {
          if (this.inclusive) {
            destination.next(value2);
          }
          destination.complete();
        }
      };
      return TakeWhileSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/tap.js
function tap(nextOrObserver, error, complete) {
  return function tapOperatorFunction(source) {
    return source.lift(new DoOperator(nextOrObserver, error, complete));
  };
}
var DoOperator, TapSubscriber;
var init_tap = __esm({
  "node_modules/rxjs/_esm5/internal/operators/tap.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_noop();
    init_isFunction();
    DoOperator = function() {
      function DoOperator2(nextOrObserver, error, complete) {
        this.nextOrObserver = nextOrObserver;
        this.error = error;
        this.complete = complete;
      }
      DoOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
      };
      return DoOperator2;
    }();
    TapSubscriber = function(_super) {
      __extends(TapSubscriber2, _super);
      function TapSubscriber2(destination, observerOrNext, error, complete) {
        var _this = _super.call(this, destination) || this;
        _this._tapNext = noop2;
        _this._tapError = noop2;
        _this._tapComplete = noop2;
        _this._tapError = error || noop2;
        _this._tapComplete = complete || noop2;
        if (isFunction(observerOrNext)) {
          _this._context = _this;
          _this._tapNext = observerOrNext;
        } else if (observerOrNext) {
          _this._context = observerOrNext;
          _this._tapNext = observerOrNext.next || noop2;
          _this._tapError = observerOrNext.error || noop2;
          _this._tapComplete = observerOrNext.complete || noop2;
        }
        return _this;
      }
      TapSubscriber2.prototype._next = function(value2) {
        try {
          this._tapNext.call(this._context, value2);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        this.destination.next(value2);
      };
      TapSubscriber2.prototype._error = function(err) {
        try {
          this._tapError.call(this._context, err);
        } catch (err2) {
          this.destination.error(err2);
          return;
        }
        this.destination.error(err);
      };
      TapSubscriber2.prototype._complete = function() {
        try {
          this._tapComplete.call(this._context);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        return this.destination.complete();
      };
      return TapSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/throttle.js
function throttle(durationSelector, config2) {
  if (config2 === void 0) {
    config2 = defaultThrottleConfig;
  }
  return function(source) {
    return source.lift(new ThrottleOperator(durationSelector, !!config2.leading, !!config2.trailing));
  };
}
var defaultThrottleConfig, ThrottleOperator, ThrottleSubscriber;
var init_throttle = __esm({
  "node_modules/rxjs/_esm5/internal/operators/throttle.js"() {
    init_tslib_es6();
    init_innerSubscribe();
    defaultThrottleConfig = {
      leading: true,
      trailing: false
    };
    ThrottleOperator = function() {
      function ThrottleOperator2(durationSelector, leading, trailing) {
        this.durationSelector = durationSelector;
        this.leading = leading;
        this.trailing = trailing;
      }
      ThrottleOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));
      };
      return ThrottleOperator2;
    }();
    ThrottleSubscriber = function(_super) {
      __extends(ThrottleSubscriber2, _super);
      function ThrottleSubscriber2(destination, durationSelector, _leading, _trailing) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.durationSelector = durationSelector;
        _this._leading = _leading;
        _this._trailing = _trailing;
        _this._hasValue = false;
        return _this;
      }
      ThrottleSubscriber2.prototype._next = function(value2) {
        this._hasValue = true;
        this._sendValue = value2;
        if (!this._throttled) {
          if (this._leading) {
            this.send();
          } else {
            this.throttle(value2);
          }
        }
      };
      ThrottleSubscriber2.prototype.send = function() {
        var _a2 = this, _hasValue = _a2._hasValue, _sendValue = _a2._sendValue;
        if (_hasValue) {
          this.destination.next(_sendValue);
          this.throttle(_sendValue);
        }
        this._hasValue = false;
        this._sendValue = void 0;
      };
      ThrottleSubscriber2.prototype.throttle = function(value2) {
        var duration = this.tryDurationSelector(value2);
        if (!!duration) {
          this.add(this._throttled = innerSubscribe(duration, new SimpleInnerSubscriber(this)));
        }
      };
      ThrottleSubscriber2.prototype.tryDurationSelector = function(value2) {
        try {
          return this.durationSelector(value2);
        } catch (err) {
          this.destination.error(err);
          return null;
        }
      };
      ThrottleSubscriber2.prototype.throttlingDone = function() {
        var _a2 = this, _throttled = _a2._throttled, _trailing = _a2._trailing;
        if (_throttled) {
          _throttled.unsubscribe();
        }
        this._throttled = void 0;
        if (_trailing) {
          this.send();
        }
      };
      ThrottleSubscriber2.prototype.notifyNext = function() {
        this.throttlingDone();
      };
      ThrottleSubscriber2.prototype.notifyComplete = function() {
        this.throttlingDone();
      };
      return ThrottleSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/throttleTime.js
function throttleTime(duration, scheduler, config2) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  if (config2 === void 0) {
    config2 = defaultThrottleConfig;
  }
  return function(source) {
    return source.lift(new ThrottleTimeOperator(duration, scheduler, config2.leading, config2.trailing));
  };
}
function dispatchNext4(arg) {
  var subscriber = arg.subscriber;
  subscriber.clearThrottle();
}
var ThrottleTimeOperator, ThrottleTimeSubscriber;
var init_throttleTime = __esm({
  "node_modules/rxjs/_esm5/internal/operators/throttleTime.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_async();
    init_throttle();
    ThrottleTimeOperator = function() {
      function ThrottleTimeOperator2(duration, scheduler, leading, trailing) {
        this.duration = duration;
        this.scheduler = scheduler;
        this.leading = leading;
        this.trailing = trailing;
      }
      ThrottleTimeOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));
      };
      return ThrottleTimeOperator2;
    }();
    ThrottleTimeSubscriber = function(_super) {
      __extends(ThrottleTimeSubscriber2, _super);
      function ThrottleTimeSubscriber2(destination, duration, scheduler, leading, trailing) {
        var _this = _super.call(this, destination) || this;
        _this.duration = duration;
        _this.scheduler = scheduler;
        _this.leading = leading;
        _this.trailing = trailing;
        _this._hasTrailingValue = false;
        _this._trailingValue = null;
        return _this;
      }
      ThrottleTimeSubscriber2.prototype._next = function(value2) {
        if (this.throttled) {
          if (this.trailing) {
            this._trailingValue = value2;
            this._hasTrailingValue = true;
          }
        } else {
          this.add(this.throttled = this.scheduler.schedule(dispatchNext4, this.duration, { subscriber: this }));
          if (this.leading) {
            this.destination.next(value2);
          } else if (this.trailing) {
            this._trailingValue = value2;
            this._hasTrailingValue = true;
          }
        }
      };
      ThrottleTimeSubscriber2.prototype._complete = function() {
        if (this._hasTrailingValue) {
          this.destination.next(this._trailingValue);
          this.destination.complete();
        } else {
          this.destination.complete();
        }
      };
      ThrottleTimeSubscriber2.prototype.clearThrottle = function() {
        var throttled = this.throttled;
        if (throttled) {
          if (this.trailing && this._hasTrailingValue) {
            this.destination.next(this._trailingValue);
            this._trailingValue = null;
            this._hasTrailingValue = false;
          }
          throttled.unsubscribe();
          this.remove(throttled);
          this.throttled = null;
        }
      };
      return ThrottleTimeSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/timeInterval.js
function timeInterval(scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return function(source) {
    return defer(function() {
      return source.pipe(scan(function(_a2, value2) {
        var current = _a2.current;
        return { value: value2, current: scheduler.now(), last: current };
      }, { current: scheduler.now(), value: void 0, last: void 0 }), map(function(_a2) {
        var current = _a2.current, last2 = _a2.last, value2 = _a2.value;
        return new TimeInterval(value2, current - last2);
      }));
    });
  };
}
var TimeInterval;
var init_timeInterval = __esm({
  "node_modules/rxjs/_esm5/internal/operators/timeInterval.js"() {
    init_async();
    init_scan();
    init_defer();
    init_map();
    TimeInterval = function() {
      function TimeInterval2(value2, interval2) {
        this.value = value2;
        this.interval = interval2;
      }
      return TimeInterval2;
    }();
  }
});

// node_modules/rxjs/_esm5/internal/operators/timeoutWith.js
function timeoutWith(due, withObservable, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return function(source) {
    var absoluteTimeout = isDate(due);
    var waitFor = absoluteTimeout ? +due - scheduler.now() : Math.abs(due);
    return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));
  };
}
var TimeoutWithOperator, TimeoutWithSubscriber;
var init_timeoutWith = __esm({
  "node_modules/rxjs/_esm5/internal/operators/timeoutWith.js"() {
    init_tslib_es6();
    init_async();
    init_isDate();
    init_innerSubscribe();
    TimeoutWithOperator = function() {
      function TimeoutWithOperator2(waitFor, absoluteTimeout, withObservable, scheduler) {
        this.waitFor = waitFor;
        this.absoluteTimeout = absoluteTimeout;
        this.withObservable = withObservable;
        this.scheduler = scheduler;
      }
      TimeoutWithOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
      };
      return TimeoutWithOperator2;
    }();
    TimeoutWithSubscriber = function(_super) {
      __extends(TimeoutWithSubscriber2, _super);
      function TimeoutWithSubscriber2(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.absoluteTimeout = absoluteTimeout;
        _this.waitFor = waitFor;
        _this.withObservable = withObservable;
        _this.scheduler = scheduler;
        _this.scheduleTimeout();
        return _this;
      }
      TimeoutWithSubscriber2.dispatchTimeout = function(subscriber) {
        var withObservable = subscriber.withObservable;
        subscriber._unsubscribeAndRecycle();
        subscriber.add(innerSubscribe(withObservable, new SimpleInnerSubscriber(subscriber)));
      };
      TimeoutWithSubscriber2.prototype.scheduleTimeout = function() {
        var action = this.action;
        if (action) {
          this.action = action.schedule(this, this.waitFor);
        } else {
          this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber2.dispatchTimeout, this.waitFor, this));
        }
      };
      TimeoutWithSubscriber2.prototype._next = function(value2) {
        if (!this.absoluteTimeout) {
          this.scheduleTimeout();
        }
        _super.prototype._next.call(this, value2);
      };
      TimeoutWithSubscriber2.prototype._unsubscribe = function() {
        this.action = void 0;
        this.scheduler = null;
        this.withObservable = null;
      };
      return TimeoutWithSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/timeout.js
function timeout(due, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return timeoutWith(due, throwError(new TimeoutError()), scheduler);
}
var init_timeout = __esm({
  "node_modules/rxjs/_esm5/internal/operators/timeout.js"() {
    init_async();
    init_TimeoutError();
    init_timeoutWith();
    init_throwError();
  }
});

// node_modules/rxjs/_esm5/internal/operators/timestamp.js
function timestamp(scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return map(function(value2) {
    return new Timestamp(value2, scheduler.now());
  });
}
var Timestamp;
var init_timestamp = __esm({
  "node_modules/rxjs/_esm5/internal/operators/timestamp.js"() {
    init_async();
    init_map();
    Timestamp = function() {
      function Timestamp2(value2, timestamp2) {
        this.value = value2;
        this.timestamp = timestamp2;
      }
      return Timestamp2;
    }();
  }
});

// node_modules/rxjs/_esm5/internal/operators/toArray.js
function toArrayReducer(arr, item, index) {
  if (index === 0) {
    return [item];
  }
  arr.push(item);
  return arr;
}
function toArray() {
  return reduce(toArrayReducer, []);
}
var init_toArray = __esm({
  "node_modules/rxjs/_esm5/internal/operators/toArray.js"() {
    init_reduce();
  }
});

// node_modules/rxjs/_esm5/internal/operators/window.js
function window2(windowBoundaries) {
  return function windowOperatorFunction(source) {
    return source.lift(new WindowOperator(windowBoundaries));
  };
}
var WindowOperator, WindowSubscriber;
var init_window = __esm({
  "node_modules/rxjs/_esm5/internal/operators/window.js"() {
    init_tslib_es6();
    init_Subject();
    init_innerSubscribe();
    WindowOperator = function() {
      function WindowOperator3(windowBoundaries) {
        this.windowBoundaries = windowBoundaries;
      }
      WindowOperator3.prototype.call = function(subscriber, source) {
        var windowSubscriber = new WindowSubscriber(subscriber);
        var sourceSubscription = source.subscribe(windowSubscriber);
        if (!sourceSubscription.closed) {
          windowSubscriber.add(innerSubscribe(this.windowBoundaries, new SimpleInnerSubscriber(windowSubscriber)));
        }
        return sourceSubscription;
      };
      return WindowOperator3;
    }();
    WindowSubscriber = function(_super) {
      __extends(WindowSubscriber3, _super);
      function WindowSubscriber3(destination) {
        var _this = _super.call(this, destination) || this;
        _this.window = new Subject();
        destination.next(_this.window);
        return _this;
      }
      WindowSubscriber3.prototype.notifyNext = function() {
        this.openWindow();
      };
      WindowSubscriber3.prototype.notifyError = function(error) {
        this._error(error);
      };
      WindowSubscriber3.prototype.notifyComplete = function() {
        this._complete();
      };
      WindowSubscriber3.prototype._next = function(value2) {
        this.window.next(value2);
      };
      WindowSubscriber3.prototype._error = function(err) {
        this.window.error(err);
        this.destination.error(err);
      };
      WindowSubscriber3.prototype._complete = function() {
        this.window.complete();
        this.destination.complete();
      };
      WindowSubscriber3.prototype._unsubscribe = function() {
        this.window = null;
      };
      WindowSubscriber3.prototype.openWindow = function() {
        var prevWindow = this.window;
        if (prevWindow) {
          prevWindow.complete();
        }
        var destination = this.destination;
        var newWindow = this.window = new Subject();
        destination.next(newWindow);
      };
      return WindowSubscriber3;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/windowCount.js
function windowCount(windowSize, startWindowEvery) {
  if (startWindowEvery === void 0) {
    startWindowEvery = 0;
  }
  return function windowCountOperatorFunction(source) {
    return source.lift(new WindowCountOperator(windowSize, startWindowEvery));
  };
}
var WindowCountOperator, WindowCountSubscriber;
var init_windowCount = __esm({
  "node_modules/rxjs/_esm5/internal/operators/windowCount.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_Subject();
    WindowCountOperator = function() {
      function WindowCountOperator2(windowSize, startWindowEvery) {
        this.windowSize = windowSize;
        this.startWindowEvery = startWindowEvery;
      }
      WindowCountOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));
      };
      return WindowCountOperator2;
    }();
    WindowCountSubscriber = function(_super) {
      __extends(WindowCountSubscriber2, _super);
      function WindowCountSubscriber2(destination, windowSize, startWindowEvery) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.windowSize = windowSize;
        _this.startWindowEvery = startWindowEvery;
        _this.windows = [new Subject()];
        _this.count = 0;
        destination.next(_this.windows[0]);
        return _this;
      }
      WindowCountSubscriber2.prototype._next = function(value2) {
        var startWindowEvery = this.startWindowEvery > 0 ? this.startWindowEvery : this.windowSize;
        var destination = this.destination;
        var windowSize = this.windowSize;
        var windows = this.windows;
        var len = windows.length;
        for (var i6 = 0; i6 < len && !this.closed; i6++) {
          windows[i6].next(value2);
        }
        var c5 = this.count - windowSize + 1;
        if (c5 >= 0 && c5 % startWindowEvery === 0 && !this.closed) {
          windows.shift().complete();
        }
        if (++this.count % startWindowEvery === 0 && !this.closed) {
          var window_1 = new Subject();
          windows.push(window_1);
          destination.next(window_1);
        }
      };
      WindowCountSubscriber2.prototype._error = function(err) {
        var windows = this.windows;
        if (windows) {
          while (windows.length > 0 && !this.closed) {
            windows.shift().error(err);
          }
        }
        this.destination.error(err);
      };
      WindowCountSubscriber2.prototype._complete = function() {
        var windows = this.windows;
        if (windows) {
          while (windows.length > 0 && !this.closed) {
            windows.shift().complete();
          }
        }
        this.destination.complete();
      };
      WindowCountSubscriber2.prototype._unsubscribe = function() {
        this.count = 0;
        this.windows = null;
      };
      return WindowCountSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/windowTime.js
function windowTime(windowTimeSpan) {
  var scheduler = async;
  var windowCreationInterval = null;
  var maxWindowSize = Number.POSITIVE_INFINITY;
  if (isScheduler(arguments[3])) {
    scheduler = arguments[3];
  }
  if (isScheduler(arguments[2])) {
    scheduler = arguments[2];
  } else if (isNumeric(arguments[2])) {
    maxWindowSize = Number(arguments[2]);
  }
  if (isScheduler(arguments[1])) {
    scheduler = arguments[1];
  } else if (isNumeric(arguments[1])) {
    windowCreationInterval = Number(arguments[1]);
  }
  return function windowTimeOperatorFunction(source) {
    return source.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));
  };
}
function dispatchWindowTimeSpanOnly(state) {
  var subscriber = state.subscriber, windowTimeSpan = state.windowTimeSpan, window3 = state.window;
  if (window3) {
    subscriber.closeWindow(window3);
  }
  state.window = subscriber.openWindow();
  this.schedule(state, windowTimeSpan);
}
function dispatchWindowCreation(state) {
  var windowTimeSpan = state.windowTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler, windowCreationInterval = state.windowCreationInterval;
  var window3 = subscriber.openWindow();
  var action = this;
  var context = { action, subscription: null };
  var timeSpanState = { subscriber, window: window3, context };
  context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
  action.add(context.subscription);
  action.schedule(state, windowCreationInterval);
}
function dispatchWindowClose(state) {
  var subscriber = state.subscriber, window3 = state.window, context = state.context;
  if (context && context.action && context.subscription) {
    context.action.remove(context.subscription);
  }
  subscriber.closeWindow(window3);
}
var WindowTimeOperator, CountedSubject, WindowTimeSubscriber;
var init_windowTime = __esm({
  "node_modules/rxjs/_esm5/internal/operators/windowTime.js"() {
    init_tslib_es6();
    init_Subject();
    init_async();
    init_Subscriber();
    init_isNumeric();
    init_isScheduler();
    WindowTimeOperator = function() {
      function WindowTimeOperator2(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        this.windowTimeSpan = windowTimeSpan;
        this.windowCreationInterval = windowCreationInterval;
        this.maxWindowSize = maxWindowSize;
        this.scheduler = scheduler;
      }
      WindowTimeOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));
      };
      return WindowTimeOperator2;
    }();
    CountedSubject = function(_super) {
      __extends(CountedSubject2, _super);
      function CountedSubject2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._numberOfNextedValues = 0;
        return _this;
      }
      CountedSubject2.prototype.next = function(value2) {
        this._numberOfNextedValues++;
        _super.prototype.next.call(this, value2);
      };
      Object.defineProperty(CountedSubject2.prototype, "numberOfNextedValues", {
        get: function() {
          return this._numberOfNextedValues;
        },
        enumerable: true,
        configurable: true
      });
      return CountedSubject2;
    }(Subject);
    WindowTimeSubscriber = function(_super) {
      __extends(WindowTimeSubscriber2, _super);
      function WindowTimeSubscriber2(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.windowTimeSpan = windowTimeSpan;
        _this.windowCreationInterval = windowCreationInterval;
        _this.maxWindowSize = maxWindowSize;
        _this.scheduler = scheduler;
        _this.windows = [];
        var window3 = _this.openWindow();
        if (windowCreationInterval !== null && windowCreationInterval >= 0) {
          var closeState = { subscriber: _this, window: window3, context: null };
          var creationState = { windowTimeSpan, windowCreationInterval, subscriber: _this, scheduler };
          _this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));
          _this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
        } else {
          var timeSpanOnlyState = { subscriber: _this, window: window3, windowTimeSpan };
          _this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
        }
        return _this;
      }
      WindowTimeSubscriber2.prototype._next = function(value2) {
        var windows = this.windows;
        var len = windows.length;
        for (var i6 = 0; i6 < len; i6++) {
          var window_1 = windows[i6];
          if (!window_1.closed) {
            window_1.next(value2);
            if (window_1.numberOfNextedValues >= this.maxWindowSize) {
              this.closeWindow(window_1);
            }
          }
        }
      };
      WindowTimeSubscriber2.prototype._error = function(err) {
        var windows = this.windows;
        while (windows.length > 0) {
          windows.shift().error(err);
        }
        this.destination.error(err);
      };
      WindowTimeSubscriber2.prototype._complete = function() {
        var windows = this.windows;
        while (windows.length > 0) {
          var window_2 = windows.shift();
          if (!window_2.closed) {
            window_2.complete();
          }
        }
        this.destination.complete();
      };
      WindowTimeSubscriber2.prototype.openWindow = function() {
        var window3 = new CountedSubject();
        this.windows.push(window3);
        var destination = this.destination;
        destination.next(window3);
        return window3;
      };
      WindowTimeSubscriber2.prototype.closeWindow = function(window3) {
        window3.complete();
        var windows = this.windows;
        windows.splice(windows.indexOf(window3), 1);
      };
      return WindowTimeSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/windowToggle.js
function windowToggle(openings, closingSelector) {
  return function(source) {
    return source.lift(new WindowToggleOperator(openings, closingSelector));
  };
}
var WindowToggleOperator, WindowToggleSubscriber;
var init_windowToggle = __esm({
  "node_modules/rxjs/_esm5/internal/operators/windowToggle.js"() {
    init_tslib_es6();
    init_Subject();
    init_Subscription();
    init_OuterSubscriber();
    init_subscribeToResult();
    WindowToggleOperator = function() {
      function WindowToggleOperator2(openings, closingSelector) {
        this.openings = openings;
        this.closingSelector = closingSelector;
      }
      WindowToggleOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));
      };
      return WindowToggleOperator2;
    }();
    WindowToggleSubscriber = function(_super) {
      __extends(WindowToggleSubscriber2, _super);
      function WindowToggleSubscriber2(destination, openings, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.openings = openings;
        _this.closingSelector = closingSelector;
        _this.contexts = [];
        _this.add(_this.openSubscription = subscribeToResult(_this, openings, openings));
        return _this;
      }
      WindowToggleSubscriber2.prototype._next = function(value2) {
        var contexts = this.contexts;
        if (contexts) {
          var len = contexts.length;
          for (var i6 = 0; i6 < len; i6++) {
            contexts[i6].window.next(value2);
          }
        }
      };
      WindowToggleSubscriber2.prototype._error = function(err) {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
          var len = contexts.length;
          var index = -1;
          while (++index < len) {
            var context_1 = contexts[index];
            context_1.window.error(err);
            context_1.subscription.unsubscribe();
          }
        }
        _super.prototype._error.call(this, err);
      };
      WindowToggleSubscriber2.prototype._complete = function() {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
          var len = contexts.length;
          var index = -1;
          while (++index < len) {
            var context_2 = contexts[index];
            context_2.window.complete();
            context_2.subscription.unsubscribe();
          }
        }
        _super.prototype._complete.call(this);
      };
      WindowToggleSubscriber2.prototype._unsubscribe = function() {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
          var len = contexts.length;
          var index = -1;
          while (++index < len) {
            var context_3 = contexts[index];
            context_3.window.unsubscribe();
            context_3.subscription.unsubscribe();
          }
        }
      };
      WindowToggleSubscriber2.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (outerValue === this.openings) {
          var closingNotifier = void 0;
          try {
            var closingSelector = this.closingSelector;
            closingNotifier = closingSelector(innerValue);
          } catch (e6) {
            return this.error(e6);
          }
          var window_1 = new Subject();
          var subscription = new Subscription();
          var context_4 = { window: window_1, subscription };
          this.contexts.push(context_4);
          var innerSubscription = subscribeToResult(this, closingNotifier, context_4);
          if (innerSubscription.closed) {
            this.closeWindow(this.contexts.length - 1);
          } else {
            innerSubscription.context = context_4;
            subscription.add(innerSubscription);
          }
          this.destination.next(window_1);
        } else {
          this.closeWindow(this.contexts.indexOf(outerValue));
        }
      };
      WindowToggleSubscriber2.prototype.notifyError = function(err) {
        this.error(err);
      };
      WindowToggleSubscriber2.prototype.notifyComplete = function(inner) {
        if (inner !== this.openSubscription) {
          this.closeWindow(this.contexts.indexOf(inner.context));
        }
      };
      WindowToggleSubscriber2.prototype.closeWindow = function(index) {
        if (index === -1) {
          return;
        }
        var contexts = this.contexts;
        var context = contexts[index];
        var window3 = context.window, subscription = context.subscription;
        contexts.splice(index, 1);
        window3.complete();
        subscription.unsubscribe();
      };
      return WindowToggleSubscriber2;
    }(OuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/windowWhen.js
function windowWhen(closingSelector) {
  return function windowWhenOperatorFunction(source) {
    return source.lift(new WindowOperator2(closingSelector));
  };
}
var WindowOperator2, WindowSubscriber2;
var init_windowWhen = __esm({
  "node_modules/rxjs/_esm5/internal/operators/windowWhen.js"() {
    init_tslib_es6();
    init_Subject();
    init_OuterSubscriber();
    init_subscribeToResult();
    WindowOperator2 = function() {
      function WindowOperator3(closingSelector) {
        this.closingSelector = closingSelector;
      }
      WindowOperator3.prototype.call = function(subscriber, source) {
        return source.subscribe(new WindowSubscriber2(subscriber, this.closingSelector));
      };
      return WindowOperator3;
    }();
    WindowSubscriber2 = function(_super) {
      __extends(WindowSubscriber3, _super);
      function WindowSubscriber3(destination, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.closingSelector = closingSelector;
        _this.openWindow();
        return _this;
      }
      WindowSubscriber3.prototype.notifyNext = function(_outerValue, _innerValue, _outerIndex, _innerIndex, innerSub) {
        this.openWindow(innerSub);
      };
      WindowSubscriber3.prototype.notifyError = function(error) {
        this._error(error);
      };
      WindowSubscriber3.prototype.notifyComplete = function(innerSub) {
        this.openWindow(innerSub);
      };
      WindowSubscriber3.prototype._next = function(value2) {
        this.window.next(value2);
      };
      WindowSubscriber3.prototype._error = function(err) {
        this.window.error(err);
        this.destination.error(err);
        this.unsubscribeClosingNotification();
      };
      WindowSubscriber3.prototype._complete = function() {
        this.window.complete();
        this.destination.complete();
        this.unsubscribeClosingNotification();
      };
      WindowSubscriber3.prototype.unsubscribeClosingNotification = function() {
        if (this.closingNotification) {
          this.closingNotification.unsubscribe();
        }
      };
      WindowSubscriber3.prototype.openWindow = function(innerSub) {
        if (innerSub === void 0) {
          innerSub = null;
        }
        if (innerSub) {
          this.remove(innerSub);
          innerSub.unsubscribe();
        }
        var prevWindow = this.window;
        if (prevWindow) {
          prevWindow.complete();
        }
        var window3 = this.window = new Subject();
        this.destination.next(window3);
        var closingNotifier;
        try {
          var closingSelector = this.closingSelector;
          closingNotifier = closingSelector();
        } catch (e6) {
          this.destination.error(e6);
          this.window.error(e6);
          return;
        }
        this.add(this.closingNotification = subscribeToResult(this, closingNotifier));
      };
      return WindowSubscriber3;
    }(OuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/withLatestFrom.js
function withLatestFrom() {
  var args = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    args[_i2] = arguments[_i2];
  }
  return function(source) {
    var project;
    if (typeof args[args.length - 1] === "function") {
      project = args.pop();
    }
    var observables = args;
    return source.lift(new WithLatestFromOperator(observables, project));
  };
}
var WithLatestFromOperator, WithLatestFromSubscriber;
var init_withLatestFrom = __esm({
  "node_modules/rxjs/_esm5/internal/operators/withLatestFrom.js"() {
    init_tslib_es6();
    init_OuterSubscriber();
    init_subscribeToResult();
    WithLatestFromOperator = function() {
      function WithLatestFromOperator2(observables, project) {
        this.observables = observables;
        this.project = project;
      }
      WithLatestFromOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
      };
      return WithLatestFromOperator2;
    }();
    WithLatestFromSubscriber = function(_super) {
      __extends(WithLatestFromSubscriber2, _super);
      function WithLatestFromSubscriber2(destination, observables, project) {
        var _this = _super.call(this, destination) || this;
        _this.observables = observables;
        _this.project = project;
        _this.toRespond = [];
        var len = observables.length;
        _this.values = new Array(len);
        for (var i6 = 0; i6 < len; i6++) {
          _this.toRespond.push(i6);
        }
        for (var i6 = 0; i6 < len; i6++) {
          var observable2 = observables[i6];
          _this.add(subscribeToResult(_this, observable2, void 0, i6));
        }
        return _this;
      }
      WithLatestFromSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
        this.values[outerIndex] = innerValue;
        var toRespond = this.toRespond;
        if (toRespond.length > 0) {
          var found = toRespond.indexOf(outerIndex);
          if (found !== -1) {
            toRespond.splice(found, 1);
          }
        }
      };
      WithLatestFromSubscriber2.prototype.notifyComplete = function() {
      };
      WithLatestFromSubscriber2.prototype._next = function(value2) {
        if (this.toRespond.length === 0) {
          var args = [value2].concat(this.values);
          if (this.project) {
            this._tryProject(args);
          } else {
            this.destination.next(args);
          }
        }
      };
      WithLatestFromSubscriber2.prototype._tryProject = function(args) {
        var result;
        try {
          result = this.project.apply(this, args);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        this.destination.next(result);
      };
      return WithLatestFromSubscriber2;
    }(OuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/zip.js
function zip2() {
  var observables = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    observables[_i2] = arguments[_i2];
  }
  return function zipOperatorFunction(source) {
    return source.lift.call(zip.apply(void 0, [source].concat(observables)));
  };
}
var init_zip2 = __esm({
  "node_modules/rxjs/_esm5/internal/operators/zip.js"() {
    init_zip();
  }
});

// node_modules/rxjs/_esm5/internal/operators/zipAll.js
function zipAll(project) {
  return function(source) {
    return source.lift(new ZipOperator(project));
  };
}
var init_zipAll = __esm({
  "node_modules/rxjs/_esm5/internal/operators/zipAll.js"() {
    init_zip();
  }
});

// node_modules/rxjs/_esm5/operators/index.js
var operators_exports = {};
__export(operators_exports, {
  audit: () => audit,
  auditTime: () => auditTime,
  buffer: () => buffer,
  bufferCount: () => bufferCount,
  bufferTime: () => bufferTime,
  bufferToggle: () => bufferToggle,
  bufferWhen: () => bufferWhen,
  catchError: () => catchError,
  combineAll: () => combineAll,
  combineLatest: () => combineLatest2,
  concat: () => concat3,
  concatAll: () => concatAll,
  concatMap: () => concatMap,
  concatMapTo: () => concatMapTo,
  count: () => count,
  debounce: () => debounce,
  debounceTime: () => debounceTime,
  defaultIfEmpty: () => defaultIfEmpty,
  delay: () => delay,
  delayWhen: () => delayWhen,
  dematerialize: () => dematerialize,
  distinct: () => distinct,
  distinctUntilChanged: () => distinctUntilChanged,
  distinctUntilKeyChanged: () => distinctUntilKeyChanged,
  elementAt: () => elementAt,
  endWith: () => endWith,
  every: () => every,
  exhaust: () => exhaust,
  exhaustMap: () => exhaustMap,
  expand: () => expand,
  filter: () => filter,
  finalize: () => finalize,
  find: () => find,
  findIndex: () => findIndex,
  first: () => first,
  flatMap: () => flatMap,
  groupBy: () => groupBy,
  ignoreElements: () => ignoreElements,
  isEmpty: () => isEmpty,
  last: () => last,
  map: () => map,
  mapTo: () => mapTo,
  materialize: () => materialize,
  max: () => max,
  merge: () => merge2,
  mergeAll: () => mergeAll,
  mergeMap: () => mergeMap,
  mergeMapTo: () => mergeMapTo,
  mergeScan: () => mergeScan,
  min: () => min,
  multicast: () => multicast,
  observeOn: () => observeOn,
  onErrorResumeNext: () => onErrorResumeNext2,
  pairwise: () => pairwise,
  partition: () => partition2,
  pluck: () => pluck,
  publish: () => publish,
  publishBehavior: () => publishBehavior,
  publishLast: () => publishLast,
  publishReplay: () => publishReplay,
  race: () => race2,
  reduce: () => reduce,
  refCount: () => refCount,
  repeat: () => repeat,
  repeatWhen: () => repeatWhen,
  retry: () => retry,
  retryWhen: () => retryWhen,
  sample: () => sample,
  sampleTime: () => sampleTime,
  scan: () => scan,
  sequenceEqual: () => sequenceEqual,
  share: () => share,
  shareReplay: () => shareReplay,
  single: () => single,
  skip: () => skip,
  skipLast: () => skipLast,
  skipUntil: () => skipUntil,
  skipWhile: () => skipWhile,
  startWith: () => startWith,
  subscribeOn: () => subscribeOn,
  switchAll: () => switchAll,
  switchMap: () => switchMap,
  switchMapTo: () => switchMapTo,
  take: () => take,
  takeLast: () => takeLast,
  takeUntil: () => takeUntil,
  takeWhile: () => takeWhile,
  tap: () => tap,
  throttle: () => throttle,
  throttleTime: () => throttleTime,
  throwIfEmpty: () => throwIfEmpty,
  timeInterval: () => timeInterval,
  timeout: () => timeout,
  timeoutWith: () => timeoutWith,
  timestamp: () => timestamp,
  toArray: () => toArray,
  window: () => window2,
  windowCount: () => windowCount,
  windowTime: () => windowTime,
  windowToggle: () => windowToggle,
  windowWhen: () => windowWhen,
  withLatestFrom: () => withLatestFrom,
  zip: () => zip2,
  zipAll: () => zipAll
});
var init_operators = __esm({
  "node_modules/rxjs/_esm5/operators/index.js"() {
    init_audit();
    init_auditTime();
    init_buffer();
    init_bufferCount();
    init_bufferTime();
    init_bufferToggle();
    init_bufferWhen();
    init_catchError();
    init_combineAll();
    init_combineLatest2();
    init_concat2();
    init_concatAll();
    init_concatMap();
    init_concatMapTo();
    init_count();
    init_debounce();
    init_debounceTime();
    init_defaultIfEmpty();
    init_delay();
    init_delayWhen();
    init_dematerialize();
    init_distinct();
    init_distinctUntilChanged();
    init_distinctUntilKeyChanged();
    init_elementAt();
    init_endWith();
    init_every();
    init_exhaust();
    init_exhaustMap();
    init_expand();
    init_filter();
    init_finalize();
    init_find();
    init_findIndex();
    init_first();
    init_groupBy();
    init_ignoreElements();
    init_isEmpty();
    init_last();
    init_map();
    init_mapTo();
    init_materialize();
    init_max();
    init_merge2();
    init_mergeAll();
    init_mergeMap();
    init_mergeMapTo();
    init_mergeScan();
    init_min();
    init_multicast();
    init_observeOn();
    init_onErrorResumeNext2();
    init_pairwise();
    init_partition2();
    init_pluck();
    init_publish();
    init_publishBehavior();
    init_publishLast();
    init_publishReplay();
    init_race2();
    init_reduce();
    init_repeat();
    init_repeatWhen();
    init_retry();
    init_retryWhen();
    init_refCount();
    init_sample();
    init_sampleTime();
    init_scan();
    init_sequenceEqual();
    init_share();
    init_shareReplay();
    init_single();
    init_skip();
    init_skipLast();
    init_skipUntil();
    init_skipWhile();
    init_startWith();
    init_subscribeOn();
    init_switchAll();
    init_switchMap();
    init_switchMapTo();
    init_take();
    init_takeLast();
    init_takeUntil();
    init_takeWhile();
    init_tap();
    init_throttle();
    init_throttleTime();
    init_throwIfEmpty();
    init_timeInterval();
    init_timeout();
    init_timeoutWith();
    init_timestamp();
    init_toArray();
    init_window();
    init_windowCount();
    init_windowTime();
    init_windowToggle();
    init_windowWhen();
    init_withLatestFrom();
    init_zip2();
    init_zipAll();
  }
});

// node_modules/qs/lib/formats.js
var require_formats = __commonJS({
  "node_modules/qs/lib/formats.js"(exports2, module2) {
    "use strict";
    var replace = String.prototype.replace;
    var percentTwenties = /%20/g;
    var Format = {
      RFC1738: "RFC1738",
      RFC3986: "RFC3986"
    };
    module2.exports = {
      "default": Format.RFC3986,
      formatters: {
        RFC1738: function(value2) {
          return replace.call(value2, percentTwenties, "+");
        },
        RFC3986: function(value2) {
          return String(value2);
        }
      },
      RFC1738: Format.RFC1738,
      RFC3986: Format.RFC3986
    };
  }
});

// node_modules/qs/lib/utils.js
var require_utils4 = __commonJS({
  "node_modules/qs/lib/utils.js"(exports2, module2) {
    "use strict";
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var isArray2 = Array.isArray;
    var hexTable = function() {
      var array = [];
      for (var i6 = 0; i6 < 256; ++i6) {
        array.push("%" + ((i6 < 16 ? "0" : "") + i6.toString(16)).toUpperCase());
      }
      return array;
    }();
    var compactQueue = function compactQueue2(queue2) {
      while (queue2.length > 1) {
        var item = queue2.pop();
        var obj = item.obj[item.prop];
        if (isArray2(obj)) {
          var compacted = [];
          for (var j8 = 0; j8 < obj.length; ++j8) {
            if (typeof obj[j8] !== "undefined") {
              compacted.push(obj[j8]);
            }
          }
          item.obj[item.prop] = compacted;
        }
      }
    };
    var arrayToObject = function arrayToObject2(source, options) {
      var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      for (var i6 = 0; i6 < source.length; ++i6) {
        if (typeof source[i6] !== "undefined") {
          obj[i6] = source[i6];
        }
      }
      return obj;
    };
    var merge3 = function merge4(target, source, options) {
      if (!source) {
        return target;
      }
      if (typeof source !== "object") {
        if (isArray2(target)) {
          target.push(source);
        } else if (target && typeof target === "object") {
          if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
            target[source] = true;
          }
        } else {
          return [target, source];
        }
        return target;
      }
      if (!target || typeof target !== "object") {
        return [target].concat(source);
      }
      var mergeTarget = target;
      if (isArray2(target) && !isArray2(source)) {
        mergeTarget = arrayToObject(target, options);
      }
      if (isArray2(target) && isArray2(source)) {
        source.forEach(function(item, i6) {
          if (has.call(target, i6)) {
            var targetItem = target[i6];
            if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
              target[i6] = merge4(targetItem, item, options);
            } else {
              target.push(item);
            }
          } else {
            target[i6] = item;
          }
        });
        return target;
      }
      return Object.keys(source).reduce(function(acc, key2) {
        var value2 = source[key2];
        if (has.call(acc, key2)) {
          acc[key2] = merge4(acc[key2], value2, options);
        } else {
          acc[key2] = value2;
        }
        return acc;
      }, mergeTarget);
    };
    var assign = function assignSingleSource(target, source) {
      return Object.keys(source).reduce(function(acc, key2) {
        acc[key2] = source[key2];
        return acc;
      }, target);
    };
    var decode3 = function(str, decoder, charset) {
      var strWithoutPlus = str.replace(/\+/g, " ");
      if (charset === "iso-8859-1") {
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
      }
      try {
        return decodeURIComponent(strWithoutPlus);
      } catch (e6) {
        return strWithoutPlus;
      }
    };
    var encode4 = function encode5(str, defaultEncoder, charset, kind, format) {
      if (str.length === 0) {
        return str;
      }
      var string = str;
      if (typeof str === "symbol") {
        string = Symbol.prototype.toString.call(str);
      } else if (typeof str !== "string") {
        string = String(str);
      }
      if (charset === "iso-8859-1") {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function($02) {
          return "%26%23" + parseInt($02.slice(2), 16) + "%3B";
        });
      }
      var out = "";
      for (var i6 = 0; i6 < string.length; ++i6) {
        var c5 = string.charCodeAt(i6);
        if (c5 === 45 || c5 === 46 || c5 === 95 || c5 === 126 || c5 >= 48 && c5 <= 57 || c5 >= 65 && c5 <= 90 || c5 >= 97 && c5 <= 122 || format === formats.RFC1738 && (c5 === 40 || c5 === 41)) {
          out += string.charAt(i6);
          continue;
        }
        if (c5 < 128) {
          out = out + hexTable[c5];
          continue;
        }
        if (c5 < 2048) {
          out = out + (hexTable[192 | c5 >> 6] + hexTable[128 | c5 & 63]);
          continue;
        }
        if (c5 < 55296 || c5 >= 57344) {
          out = out + (hexTable[224 | c5 >> 12] + hexTable[128 | c5 >> 6 & 63] + hexTable[128 | c5 & 63]);
          continue;
        }
        i6 += 1;
        c5 = 65536 + ((c5 & 1023) << 10 | string.charCodeAt(i6) & 1023);
        out += hexTable[240 | c5 >> 18] + hexTable[128 | c5 >> 12 & 63] + hexTable[128 | c5 >> 6 & 63] + hexTable[128 | c5 & 63];
      }
      return out;
    };
    var compact = function compact2(value2) {
      var queue2 = [{ obj: { o: value2 }, prop: "o" }];
      var refs = [];
      for (var i6 = 0; i6 < queue2.length; ++i6) {
        var item = queue2[i6];
        var obj = item.obj[item.prop];
        var keys = Object.keys(obj);
        for (var j8 = 0; j8 < keys.length; ++j8) {
          var key2 = keys[j8];
          var val = obj[key2];
          if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
            queue2.push({ obj, prop: key2 });
            refs.push(val);
          }
        }
      }
      compactQueue(queue2);
      return value2;
    };
    var isRegExp = function isRegExp2(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    };
    var isBuffer2 = function isBuffer3(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    };
    var combine = function combine2(a5, b4) {
      return [].concat(a5, b4);
    };
    var maybeMap = function maybeMap2(val, fn2) {
      if (isArray2(val)) {
        var mapped = [];
        for (var i6 = 0; i6 < val.length; i6 += 1) {
          mapped.push(fn2(val[i6]));
        }
        return mapped;
      }
      return fn2(val);
    };
    module2.exports = {
      arrayToObject,
      assign,
      combine,
      compact,
      decode: decode3,
      encode: encode4,
      isBuffer: isBuffer2,
      isRegExp,
      maybeMap,
      merge: merge3
    };
  }
});

// node_modules/qs/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/qs/lib/stringify.js"(exports2, module2) {
    "use strict";
    var getSideChannel = require_side_channel();
    var utils = require_utils4();
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var arrayPrefixGenerators = {
      brackets: function brackets(prefix2) {
        return prefix2 + "[]";
      },
      comma: "comma",
      indices: function indices(prefix2, key2) {
        return prefix2 + "[" + key2 + "]";
      },
      repeat: function repeat2(prefix2) {
        return prefix2;
      }
    };
    var isArray2 = Array.isArray;
    var split = String.prototype.split;
    var push = Array.prototype.push;
    var pushToArray = function(arr, valueOrArray) {
      push.apply(arr, isArray2(valueOrArray) ? valueOrArray : [valueOrArray]);
    };
    var toISO = Date.prototype.toISOString;
    var defaultFormat = formats["default"];
    var defaults = {
      addQueryPrefix: false,
      allowDots: false,
      charset: "utf-8",
      charsetSentinel: false,
      delimiter: "&",
      encode: true,
      encoder: utils.encode,
      encodeValuesOnly: false,
      format: defaultFormat,
      formatter: formats.formatters[defaultFormat],
      indices: false,
      serializeDate: function serializeDate(date) {
        return toISO.call(date);
      },
      skipNulls: false,
      strictNullHandling: false
    };
    var isNonNullishPrimitive = function isNonNullishPrimitive2(v9) {
      return typeof v9 === "string" || typeof v9 === "number" || typeof v9 === "boolean" || typeof v9 === "symbol" || typeof v9 === "bigint";
    };
    var sentinel = {};
    var stringify3 = function stringify4(object, prefix2, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter2, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
      var obj = object;
      var tmpSc = sideChannel;
      var step = 0;
      var findFlag = false;
      while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== "undefined") {
          if (pos === step) {
            throw new RangeError("Cyclic object value");
          } else {
            findFlag = true;
          }
        }
        if (typeof tmpSc.get(sentinel) === "undefined") {
          step = 0;
        }
      }
      if (typeof filter2 === "function") {
        obj = filter2(prefix2, obj);
      } else if (obj instanceof Date) {
        obj = serializeDate(obj);
      } else if (generateArrayPrefix === "comma" && isArray2(obj)) {
        obj = utils.maybeMap(obj, function(value3) {
          if (value3 instanceof Date) {
            return serializeDate(value3);
          }
          return value3;
        });
      }
      if (obj === null) {
        if (strictNullHandling) {
          return encoder && !encodeValuesOnly ? encoder(prefix2, defaults.encoder, charset, "key", format) : prefix2;
        }
        obj = "";
      }
      if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
          var keyValue = encodeValuesOnly ? prefix2 : encoder(prefix2, defaults.encoder, charset, "key", format);
          if (generateArrayPrefix === "comma" && encodeValuesOnly) {
            var valuesArray = split.call(String(obj), ",");
            var valuesJoined = "";
            for (var i6 = 0; i6 < valuesArray.length; ++i6) {
              valuesJoined += (i6 === 0 ? "" : ",") + formatter(encoder(valuesArray[i6], defaults.encoder, charset, "value", format));
            }
            return [formatter(keyValue) + "=" + valuesJoined];
          }
          return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder, charset, "value", format))];
        }
        return [formatter(prefix2) + "=" + formatter(String(obj))];
      }
      var values = [];
      if (typeof obj === "undefined") {
        return values;
      }
      var objKeys;
      if (generateArrayPrefix === "comma" && isArray2(obj)) {
        objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
      } else if (isArray2(filter2)) {
        objKeys = filter2;
      } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
      }
      for (var j8 = 0; j8 < objKeys.length; ++j8) {
        var key2 = objKeys[j8];
        var value2 = typeof key2 === "object" && typeof key2.value !== "undefined" ? key2.value : obj[key2];
        if (skipNulls && value2 === null) {
          continue;
        }
        var keyPrefix = isArray2(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(prefix2, key2) : prefix2 : prefix2 + (allowDots ? "." + key2 : "[" + key2 + "]");
        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify4(
          value2,
          keyPrefix,
          generateArrayPrefix,
          strictNullHandling,
          skipNulls,
          encoder,
          filter2,
          sort,
          allowDots,
          serializeDate,
          format,
          formatter,
          encodeValuesOnly,
          charset,
          valueSideChannel
        ));
      }
      return values;
    };
    var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
        throw new TypeError("Encoder has to be a function.");
      }
      var charset = opts.charset || defaults.charset;
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var format = formats["default"];
      if (typeof opts.format !== "undefined") {
        if (!has.call(formats.formatters, opts.format)) {
          throw new TypeError("Unknown format option provided.");
        }
        format = opts.format;
      }
      var formatter = formats.formatters[format];
      var filter2 = defaults.filter;
      if (typeof opts.filter === "function" || isArray2(opts.filter)) {
        filter2 = opts.filter;
      }
      return {
        addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
        encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter2,
        format,
        formatter,
        serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === "function" ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module2.exports = function(object, opts) {
      var obj = object;
      var options = normalizeStringifyOptions(opts);
      var objKeys;
      var filter2;
      if (typeof options.filter === "function") {
        filter2 = options.filter;
        obj = filter2("", obj);
      } else if (isArray2(options.filter)) {
        filter2 = options.filter;
        objKeys = filter2;
      }
      var keys = [];
      if (typeof obj !== "object" || obj === null) {
        return "";
      }
      var arrayFormat;
      if (opts && opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
      } else if (opts && "indices" in opts) {
        arrayFormat = opts.indices ? "indices" : "repeat";
      } else {
        arrayFormat = "indices";
      }
      var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
      if (!objKeys) {
        objKeys = Object.keys(obj);
      }
      if (options.sort) {
        objKeys.sort(options.sort);
      }
      var sideChannel = getSideChannel();
      for (var i6 = 0; i6 < objKeys.length; ++i6) {
        var key2 = objKeys[i6];
        if (options.skipNulls && obj[key2] === null) {
          continue;
        }
        pushToArray(keys, stringify3(
          obj[key2],
          key2,
          generateArrayPrefix,
          options.strictNullHandling,
          options.skipNulls,
          options.encode ? options.encoder : null,
          options.filter,
          options.sort,
          options.allowDots,
          options.serializeDate,
          options.format,
          options.formatter,
          options.encodeValuesOnly,
          options.charset,
          sideChannel
        ));
      }
      var joined = keys.join(options.delimiter);
      var prefix2 = options.addQueryPrefix === true ? "?" : "";
      if (options.charsetSentinel) {
        if (options.charset === "iso-8859-1") {
          prefix2 += "utf8=%26%2310003%3B&";
        } else {
          prefix2 += "utf8=%E2%9C%93&";
        }
      }
      return joined.length > 0 ? prefix2 + joined : "";
    };
  }
});

// node_modules/qs/lib/parse.js
var require_parse = __commonJS({
  "node_modules/qs/lib/parse.js"(exports2, module2) {
    "use strict";
    var utils = require_utils4();
    var has = Object.prototype.hasOwnProperty;
    var isArray2 = Array.isArray;
    var defaults = {
      allowDots: false,
      allowPrototypes: false,
      allowSparse: false,
      arrayLimit: 20,
      charset: "utf-8",
      charsetSentinel: false,
      comma: false,
      decoder: utils.decode,
      delimiter: "&",
      depth: 5,
      ignoreQueryPrefix: false,
      interpretNumericEntities: false,
      parameterLimit: 1e3,
      parseArrays: true,
      plainObjects: false,
      strictNullHandling: false
    };
    var interpretNumericEntities = function(str) {
      return str.replace(/&#(\d+);/g, function($02, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
      });
    };
    var parseArrayValue = function(val, options) {
      if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
        return val.split(",");
      }
      return val;
    };
    var isoSentinel = "utf8=%26%2310003%3B";
    var charsetSentinel = "utf8=%E2%9C%93";
    var parseValues = function parseQueryStringValues(str, options) {
      var obj = {};
      var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
      var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
      var parts = cleanStr.split(options.delimiter, limit);
      var skipIndex = -1;
      var i6;
      var charset = options.charset;
      if (options.charsetSentinel) {
        for (i6 = 0; i6 < parts.length; ++i6) {
          if (parts[i6].indexOf("utf8=") === 0) {
            if (parts[i6] === charsetSentinel) {
              charset = "utf-8";
            } else if (parts[i6] === isoSentinel) {
              charset = "iso-8859-1";
            }
            skipIndex = i6;
            i6 = parts.length;
          }
        }
      }
      for (i6 = 0; i6 < parts.length; ++i6) {
        if (i6 === skipIndex) {
          continue;
        }
        var part = parts[i6];
        var bracketEqualsPos = part.indexOf("]=");
        var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
        var key2, val;
        if (pos === -1) {
          key2 = options.decoder(part, defaults.decoder, charset, "key");
          val = options.strictNullHandling ? null : "";
        } else {
          key2 = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
          val = utils.maybeMap(
            parseArrayValue(part.slice(pos + 1), options),
            function(encodedVal) {
              return options.decoder(encodedVal, defaults.decoder, charset, "value");
            }
          );
        }
        if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
          val = interpretNumericEntities(val);
        }
        if (part.indexOf("[]=") > -1) {
          val = isArray2(val) ? [val] : val;
        }
        if (has.call(obj, key2)) {
          obj[key2] = utils.combine(obj[key2], val);
        } else {
          obj[key2] = val;
        }
      }
      return obj;
    };
    var parseObject = function(chain2, val, options, valuesParsed) {
      var leaf = valuesParsed ? val : parseArrayValue(val, options);
      for (var i6 = chain2.length - 1; i6 >= 0; --i6) {
        var obj;
        var root2 = chain2[i6];
        if (root2 === "[]" && options.parseArrays) {
          obj = [].concat(leaf);
        } else {
          obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
          var cleanRoot = root2.charAt(0) === "[" && root2.charAt(root2.length - 1) === "]" ? root2.slice(1, -1) : root2;
          var index = parseInt(cleanRoot, 10);
          if (!options.parseArrays && cleanRoot === "") {
            obj = { 0: leaf };
          } else if (!isNaN(index) && root2 !== cleanRoot && String(index) === cleanRoot && index >= 0 && (options.parseArrays && index <= options.arrayLimit)) {
            obj = [];
            obj[index] = leaf;
          } else if (cleanRoot !== "__proto__") {
            obj[cleanRoot] = leaf;
          }
        }
        leaf = obj;
      }
      return leaf;
    };
    var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
      if (!givenKey) {
        return;
      }
      var key2 = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
      var brackets = /(\[[^[\]]*])/;
      var child = /(\[[^[\]]*])/g;
      var segment = options.depth > 0 && brackets.exec(key2);
      var parent = segment ? key2.slice(0, segment.index) : key2;
      var keys = [];
      if (parent) {
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(parent);
      }
      var i6 = 0;
      while (options.depth > 0 && (segment = child.exec(key2)) !== null && i6 < options.depth) {
        i6 += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(segment[1]);
      }
      if (segment) {
        keys.push("[" + key2.slice(segment.index) + "]");
      }
      return parseObject(keys, val, options, valuesParsed);
    };
    var normalizeParseOptions = function normalizeParseOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (opts.decoder !== null && opts.decoder !== void 0 && typeof opts.decoder !== "function") {
        throw new TypeError("Decoder has to be a function.");
      }
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
      return {
        allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
        allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
        decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module2.exports = function(str, opts) {
      var options = normalizeParseOptions(opts);
      if (str === "" || str === null || typeof str === "undefined") {
        return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      }
      var tempObj = typeof str === "string" ? parseValues(str, options) : str;
      var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var keys = Object.keys(tempObj);
      for (var i6 = 0; i6 < keys.length; ++i6) {
        var key2 = keys[i6];
        var newObj = parseKeys(key2, tempObj[key2], options, typeof str === "string");
        obj = utils.merge(obj, newObj, options);
      }
      if (options.allowSparse === true) {
        return obj;
      }
      return utils.compact(obj);
    };
  }
});

// node_modules/qs/lib/index.js
var require_lib = __commonJS({
  "node_modules/qs/lib/index.js"(exports2, module2) {
    "use strict";
    var stringify3 = require_stringify();
    var parse4 = require_parse();
    var formats = require_formats();
    module2.exports = {
      formats,
      parse: parse4,
      stringify: stringify3
    };
  }
});

// node_modules/@coinbase/wallet-sdk/dist/types.js
var require_types2 = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RegExpString = exports2.IntNumber = exports2.BigIntString = exports2.AddressString = exports2.HexString = exports2.OpaqueType = void 0;
    function OpaqueType() {
      return (value2) => value2;
    }
    exports2.OpaqueType = OpaqueType;
    exports2.HexString = OpaqueType();
    exports2.AddressString = OpaqueType();
    exports2.BigIntString = OpaqueType();
    function IntNumber(num) {
      return Math.floor(num);
    }
    exports2.IntNumber = IntNumber;
    exports2.RegExpString = OpaqueType();
  }
});

// node_modules/@coinbase/wallet-sdk/dist/util.js
var require_util3 = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/util.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createQrUrl = exports2.getFavicon = exports2.range = exports2.isBigNumber = exports2.ensureParsedJSONObject = exports2.ensureBN = exports2.ensureRegExpString = exports2.ensureIntNumber = exports2.ensureBuffer = exports2.ensureAddressString = exports2.ensureEvenLengthHexString = exports2.ensureHexString = exports2.isHexString = exports2.prepend0x = exports2.strip0x = exports2.has0xPrefix = exports2.hexStringFromIntNumber = exports2.intNumberFromHexString = exports2.bigIntStringFromBN = exports2.hexStringFromBuffer = exports2.hexStringToUint8Array = exports2.uint8ArrayToHex = exports2.randomBytesHex = void 0;
    var bn_js_1 = __importDefault(require_bn3());
    var qs_1 = require_lib();
    var types_1 = require_types2();
    var INT_STRING_REGEX = /^[0-9]*$/;
    var HEXADECIMAL_STRING_REGEX = /^[a-f0-9]*$/;
    function randomBytesHex(length) {
      return uint8ArrayToHex(crypto.getRandomValues(new Uint8Array(length)));
    }
    exports2.randomBytesHex = randomBytesHex;
    function uint8ArrayToHex(value2) {
      return [...value2].map((b4) => b4.toString(16).padStart(2, "0")).join("");
    }
    exports2.uint8ArrayToHex = uint8ArrayToHex;
    function hexStringToUint8Array(hexString) {
      return new Uint8Array(hexString.match(/.{1,2}/g).map((byte) => parseInt(byte, 16)));
    }
    exports2.hexStringToUint8Array = hexStringToUint8Array;
    function hexStringFromBuffer(buf, includePrefix = false) {
      const hex = buf.toString("hex");
      return (0, types_1.HexString)(includePrefix ? "0x" + hex : hex);
    }
    exports2.hexStringFromBuffer = hexStringFromBuffer;
    function bigIntStringFromBN(bn2) {
      return (0, types_1.BigIntString)(bn2.toString(10));
    }
    exports2.bigIntStringFromBN = bigIntStringFromBN;
    function intNumberFromHexString(hex) {
      return (0, types_1.IntNumber)(new bn_js_1.default(ensureEvenLengthHexString(hex, false), 16).toNumber());
    }
    exports2.intNumberFromHexString = intNumberFromHexString;
    function hexStringFromIntNumber(num) {
      return (0, types_1.HexString)("0x" + new bn_js_1.default(num).toString(16));
    }
    exports2.hexStringFromIntNumber = hexStringFromIntNumber;
    function has0xPrefix(str) {
      return str.startsWith("0x") || str.startsWith("0X");
    }
    exports2.has0xPrefix = has0xPrefix;
    function strip0x(hex) {
      if (has0xPrefix(hex)) {
        return hex.slice(2);
      }
      return hex;
    }
    exports2.strip0x = strip0x;
    function prepend0x(hex) {
      if (has0xPrefix(hex)) {
        return "0x" + hex.slice(2);
      }
      return "0x" + hex;
    }
    exports2.prepend0x = prepend0x;
    function isHexString4(hex) {
      if (typeof hex !== "string") {
        return false;
      }
      const s6 = strip0x(hex).toLowerCase();
      return HEXADECIMAL_STRING_REGEX.test(s6);
    }
    exports2.isHexString = isHexString4;
    function ensureHexString(hex, includePrefix = false) {
      if (typeof hex === "string") {
        const s6 = strip0x(hex).toLowerCase();
        if (HEXADECIMAL_STRING_REGEX.test(s6)) {
          return (0, types_1.HexString)(includePrefix ? "0x" + s6 : s6);
        }
      }
      throw new Error(`"${String(hex)}" is not a hexadecimal string`);
    }
    exports2.ensureHexString = ensureHexString;
    function ensureEvenLengthHexString(hex, includePrefix = false) {
      let h6 = ensureHexString(hex, false);
      if (h6.length % 2 === 1) {
        h6 = (0, types_1.HexString)("0" + h6);
      }
      return includePrefix ? (0, types_1.HexString)("0x" + h6) : h6;
    }
    exports2.ensureEvenLengthHexString = ensureEvenLengthHexString;
    function ensureAddressString(str) {
      if (typeof str === "string") {
        const s6 = strip0x(str).toLowerCase();
        if (isHexString4(s6) && s6.length === 40) {
          return (0, types_1.AddressString)(prepend0x(s6));
        }
      }
      throw new Error(`Invalid Ethereum address: ${String(str)}`);
    }
    exports2.ensureAddressString = ensureAddressString;
    function ensureBuffer(str) {
      if (Buffer.isBuffer(str)) {
        return str;
      }
      if (typeof str === "string") {
        if (isHexString4(str)) {
          const s6 = ensureEvenLengthHexString(str, false);
          return Buffer.from(s6, "hex");
        } else {
          return Buffer.from(str, "utf8");
        }
      }
      throw new Error(`Not binary data: ${String(str)}`);
    }
    exports2.ensureBuffer = ensureBuffer;
    function ensureIntNumber(num) {
      if (typeof num === "number" && Number.isInteger(num)) {
        return (0, types_1.IntNumber)(num);
      }
      if (typeof num === "string") {
        if (INT_STRING_REGEX.test(num)) {
          return (0, types_1.IntNumber)(Number(num));
        }
        if (isHexString4(num)) {
          return (0, types_1.IntNumber)(new bn_js_1.default(ensureEvenLengthHexString(num, false), 16).toNumber());
        }
      }
      throw new Error(`Not an integer: ${String(num)}`);
    }
    exports2.ensureIntNumber = ensureIntNumber;
    function ensureRegExpString(regExp) {
      if (regExp instanceof RegExp) {
        return (0, types_1.RegExpString)(regExp.toString());
      }
      throw new Error(`Not a RegExp: ${String(regExp)}`);
    }
    exports2.ensureRegExpString = ensureRegExpString;
    function ensureBN(val) {
      if (val !== null && (bn_js_1.default.isBN(val) || isBigNumber(val))) {
        return new bn_js_1.default(val.toString(10), 10);
      }
      if (typeof val === "number") {
        return new bn_js_1.default(ensureIntNumber(val));
      }
      if (typeof val === "string") {
        if (INT_STRING_REGEX.test(val)) {
          return new bn_js_1.default(val, 10);
        }
        if (isHexString4(val)) {
          return new bn_js_1.default(ensureEvenLengthHexString(val, false), 16);
        }
      }
      throw new Error(`Not an integer: ${String(val)}`);
    }
    exports2.ensureBN = ensureBN;
    function ensureParsedJSONObject(val) {
      if (typeof val === "string") {
        return JSON.parse(val);
      }
      if (typeof val === "object") {
        return val;
      }
      throw new Error(`Not a JSON string or an object: ${String(val)}`);
    }
    exports2.ensureParsedJSONObject = ensureParsedJSONObject;
    function isBigNumber(val) {
      if (val == null || typeof val.constructor !== "function") {
        return false;
      }
      const { constructor } = val;
      return typeof constructor.config === "function" && typeof constructor.EUCLID === "number";
    }
    exports2.isBigNumber = isBigNumber;
    function range2(start, stop) {
      return Array.from({ length: stop - start }, (_8, i6) => start + i6);
    }
    exports2.range = range2;
    function getFavicon() {
      const el = document.querySelector('link[sizes="192x192"]') || document.querySelector('link[sizes="180x180"]') || document.querySelector('link[rel="icon"]') || document.querySelector('link[rel="shortcut icon"]');
      const { protocol, host } = document.location;
      const href = el ? el.getAttribute("href") : null;
      if (!href || href.startsWith("javascript:")) {
        return null;
      }
      if (href.startsWith("http://") || href.startsWith("https://") || href.startsWith("data:")) {
        return href;
      }
      if (href.startsWith("//")) {
        return protocol + href;
      }
      return `${protocol}//${host}${href}`;
    }
    exports2.getFavicon = getFavicon;
    function createQrUrl(sessionId, sessionSecret, serverUrl, isParentConnection) {
      const sessionIdKey = isParentConnection ? "parent-id" : "id";
      const query = (0, qs_1.stringify)({
        [sessionIdKey]: sessionId,
        secret: sessionSecret,
        server: serverUrl,
        v: "1"
      });
      const qrUrl = `${serverUrl}/#/link?${query}`;
      return qrUrl;
    }
    exports2.createQrUrl = createQrUrl;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/relay/Session.js
var require_Session = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/relay/Session.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Session = void 0;
    var js_sha256_1 = require_sha2562();
    var rxjs_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var operators_1 = (init_operators(), __toCommonJS(operators_exports));
    var util_1 = require_util3();
    var STORAGE_KEY_SESSION_ID = "session:id";
    var STORAGE_KEY_SESSION_SECRET = "session:secret";
    var STORAGE_KEY_SESSION_LINKED = "session:linked";
    var Session = class {
      constructor(storage, id2, secret, linked) {
        this._storage = storage;
        this._id = id2 || (0, util_1.randomBytesHex)(16);
        this._secret = secret || (0, util_1.randomBytesHex)(32);
        const hash3 = js_sha256_1.sha256.create();
        hash3.update(`${this._id}, ${this._secret} WalletLink`);
        this._key = hash3.hex();
        this._linked = !!linked;
      }
      static load(storage) {
        const id2 = storage.getItem(STORAGE_KEY_SESSION_ID);
        const linked = storage.getItem(STORAGE_KEY_SESSION_LINKED);
        const secret = storage.getItem(STORAGE_KEY_SESSION_SECRET);
        if (id2 && secret) {
          return new Session(storage, id2, secret, linked === "1");
        }
        return null;
      }
      static get persistedSessionIdChange$() {
        return (0, rxjs_1.fromEvent)(window, "storage").pipe((0, operators_1.filter)((evt) => evt.key === STORAGE_KEY_SESSION_ID), (0, operators_1.map)((evt) => ({
          oldValue: evt.oldValue || null,
          newValue: evt.newValue || null
        })));
      }
      static hash(sessionId) {
        const hash3 = js_sha256_1.sha256.create();
        return hash3.update(sessionId).hex();
      }
      get id() {
        return this._id;
      }
      get secret() {
        return this._secret;
      }
      get key() {
        return this._key;
      }
      get linked() {
        return this._linked;
      }
      set linked(val) {
        this._linked = val;
        this.persistLinked();
      }
      save() {
        this._storage.setItem(STORAGE_KEY_SESSION_ID, this._id);
        this._storage.setItem(STORAGE_KEY_SESSION_SECRET, this._secret);
        this.persistLinked();
        return this;
      }
      persistLinked() {
        this._storage.setItem(STORAGE_KEY_SESSION_LINKED, this._linked ? "1" : "0");
      }
    };
    exports2.Session = Session;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/relay/WalletSDKRelayAbstract.js
var require_WalletSDKRelayAbstract = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/relay/WalletSDKRelayAbstract.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WalletSDKRelayAbstract = exports2.APP_VERSION_KEY = exports2.LOCAL_STORAGE_ADDRESSES_KEY = exports2.WALLET_USER_NAME_KEY = void 0;
    var eth_rpc_errors_1 = require_dist2();
    exports2.WALLET_USER_NAME_KEY = "walletUsername";
    exports2.LOCAL_STORAGE_ADDRESSES_KEY = "Addresses";
    exports2.APP_VERSION_KEY = "AppVersion";
    var WalletSDKRelayAbstract = class {
      async makeEthereumJSONRPCRequest(request, jsonRpcUrl) {
        if (!jsonRpcUrl)
          throw new Error("Error: No jsonRpcUrl provided");
        return window.fetch(jsonRpcUrl, {
          method: "POST",
          body: JSON.stringify(request),
          mode: "cors",
          headers: { "Content-Type": "application/json" }
        }).then((res) => res.json()).then((json) => {
          if (!json) {
            throw eth_rpc_errors_1.ethErrors.rpc.parse({});
          }
          const response = json;
          const { error } = response;
          if (error) {
            throw (0, eth_rpc_errors_1.serializeError)(error);
          }
          return response;
        });
      }
    };
    exports2.WalletSDKRelayAbstract = WalletSDKRelayAbstract;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/util.js
var require_util4 = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/util.js"(exports2, module2) {
    var createKeccakHash = require_js();
    var BN4 = require_bn3();
    function zeros2(bytes) {
      return Buffer.allocUnsafe(bytes).fill(0);
    }
    function setLength(msg, length, right) {
      const buf = zeros2(length);
      msg = toBuffer(msg);
      if (right) {
        if (msg.length < length) {
          msg.copy(buf);
          return buf;
        }
        return msg.slice(0, length);
      } else {
        if (msg.length < length) {
          msg.copy(buf, length - msg.length);
          return buf;
        }
        return msg.slice(-length);
      }
    }
    function setLengthRight(msg, length) {
      return setLength(msg, length, true);
    }
    function toBuffer(v9) {
      if (!Buffer.isBuffer(v9)) {
        if (Array.isArray(v9)) {
          v9 = Buffer.from(v9);
        } else if (typeof v9 === "string") {
          if (isHexString4(v9)) {
            v9 = Buffer.from(padToEven(stripHexPrefix(v9)), "hex");
          } else {
            v9 = Buffer.from(v9);
          }
        } else if (typeof v9 === "number") {
          v9 = intToBuffer(v9);
        } else if (v9 === null || v9 === void 0) {
          v9 = Buffer.allocUnsafe(0);
        } else if (BN4.isBN(v9)) {
          v9 = v9.toArrayLike(Buffer);
        } else if (v9.toArray) {
          v9 = Buffer.from(v9.toArray());
        } else {
          throw new Error("invalid type");
        }
      }
      return v9;
    }
    function bufferToHex2(buf) {
      buf = toBuffer(buf);
      return "0x" + buf.toString("hex");
    }
    function keccak(a5, bits) {
      a5 = toBuffer(a5);
      if (!bits)
        bits = 256;
      return createKeccakHash("keccak" + bits).update(a5).digest();
    }
    function padToEven(str) {
      return str.length % 2 ? "0" + str : str;
    }
    function isHexString4(str) {
      return typeof str === "string" && str.match(/^0x[0-9A-Fa-f]*$/);
    }
    function stripHexPrefix(str) {
      if (typeof str === "string" && str.startsWith("0x")) {
        return str.slice(2);
      }
      return str;
    }
    module2.exports = {
      zeros: zeros2,
      setLength,
      setLengthRight,
      isHexString: isHexString4,
      stripHexPrefix,
      toBuffer,
      bufferToHex: bufferToHex2,
      keccak
    };
  }
});

// node_modules/@coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/abi.js
var require_abi = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/abi.js"(exports2, module2) {
    var util2 = require_util4();
    var BN4 = require_bn3();
    function elementaryName(name2) {
      if (name2.startsWith("int[")) {
        return "int256" + name2.slice(3);
      } else if (name2 === "int") {
        return "int256";
      } else if (name2.startsWith("uint[")) {
        return "uint256" + name2.slice(4);
      } else if (name2 === "uint") {
        return "uint256";
      } else if (name2.startsWith("fixed[")) {
        return "fixed128x128" + name2.slice(5);
      } else if (name2 === "fixed") {
        return "fixed128x128";
      } else if (name2.startsWith("ufixed[")) {
        return "ufixed128x128" + name2.slice(6);
      } else if (name2 === "ufixed") {
        return "ufixed128x128";
      }
      return name2;
    }
    function parseTypeN(type) {
      return parseInt(/^\D+(\d+)$/.exec(type)[1], 10);
    }
    function parseTypeNxM(type) {
      var tmp = /^\D+(\d+)x(\d+)$/.exec(type);
      return [parseInt(tmp[1], 10), parseInt(tmp[2], 10)];
    }
    function parseTypeArray(type) {
      var tmp = type.match(/(.*)\[(.*?)\]$/);
      if (tmp) {
        return tmp[2] === "" ? "dynamic" : parseInt(tmp[2], 10);
      }
      return null;
    }
    function parseNumber(arg) {
      var type = typeof arg;
      if (type === "string") {
        if (util2.isHexString(arg)) {
          return new BN4(util2.stripHexPrefix(arg), 16);
        } else {
          return new BN4(arg, 10);
        }
      } else if (type === "number") {
        return new BN4(arg);
      } else if (arg.toArray) {
        return arg;
      } else {
        throw new Error("Argument is not a number");
      }
    }
    function encodeSingle(type, arg) {
      var size, num, ret, i6;
      if (type === "address") {
        return encodeSingle("uint160", parseNumber(arg));
      } else if (type === "bool") {
        return encodeSingle("uint8", arg ? 1 : 0);
      } else if (type === "string") {
        return encodeSingle("bytes", new Buffer(arg, "utf8"));
      } else if (isArray2(type)) {
        if (typeof arg.length === "undefined") {
          throw new Error("Not an array?");
        }
        size = parseTypeArray(type);
        if (size !== "dynamic" && size !== 0 && arg.length > size) {
          throw new Error("Elements exceed array size: " + size);
        }
        ret = [];
        type = type.slice(0, type.lastIndexOf("["));
        if (typeof arg === "string") {
          arg = JSON.parse(arg);
        }
        for (i6 in arg) {
          ret.push(encodeSingle(type, arg[i6]));
        }
        if (size === "dynamic") {
          var length = encodeSingle("uint256", arg.length);
          ret.unshift(length);
        }
        return Buffer.concat(ret);
      } else if (type === "bytes") {
        arg = new Buffer(arg);
        ret = Buffer.concat([encodeSingle("uint256", arg.length), arg]);
        if (arg.length % 32 !== 0) {
          ret = Buffer.concat([ret, util2.zeros(32 - arg.length % 32)]);
        }
        return ret;
      } else if (type.startsWith("bytes")) {
        size = parseTypeN(type);
        if (size < 1 || size > 32) {
          throw new Error("Invalid bytes<N> width: " + size);
        }
        return util2.setLengthRight(arg, 32);
      } else if (type.startsWith("uint")) {
        size = parseTypeN(type);
        if (size % 8 || size < 8 || size > 256) {
          throw new Error("Invalid uint<N> width: " + size);
        }
        num = parseNumber(arg);
        if (num.bitLength() > size) {
          throw new Error("Supplied uint exceeds width: " + size + " vs " + num.bitLength());
        }
        if (num < 0) {
          throw new Error("Supplied uint is negative");
        }
        return num.toArrayLike(Buffer, "be", 32);
      } else if (type.startsWith("int")) {
        size = parseTypeN(type);
        if (size % 8 || size < 8 || size > 256) {
          throw new Error("Invalid int<N> width: " + size);
        }
        num = parseNumber(arg);
        if (num.bitLength() > size) {
          throw new Error("Supplied int exceeds width: " + size + " vs " + num.bitLength());
        }
        return num.toTwos(256).toArrayLike(Buffer, "be", 32);
      } else if (type.startsWith("ufixed")) {
        size = parseTypeNxM(type);
        num = parseNumber(arg);
        if (num < 0) {
          throw new Error("Supplied ufixed is negative");
        }
        return encodeSingle("uint256", num.mul(new BN4(2).pow(new BN4(size[1]))));
      } else if (type.startsWith("fixed")) {
        size = parseTypeNxM(type);
        return encodeSingle("int256", parseNumber(arg).mul(new BN4(2).pow(new BN4(size[1]))));
      }
      throw new Error("Unsupported or invalid type: " + type);
    }
    function isDynamic(type) {
      return type === "string" || type === "bytes" || parseTypeArray(type) === "dynamic";
    }
    function isArray2(type) {
      return type.lastIndexOf("]") === type.length - 1;
    }
    function rawEncode(types, values) {
      var output = [];
      var data = [];
      var headLength = 32 * types.length;
      for (var i6 in types) {
        var type = elementaryName(types[i6]);
        var value2 = values[i6];
        var cur = encodeSingle(type, value2);
        if (isDynamic(type)) {
          output.push(encodeSingle("uint256", headLength));
          data.push(cur);
          headLength += cur.length;
        } else {
          output.push(cur);
        }
      }
      return Buffer.concat(output.concat(data));
    }
    function solidityPack(types, values) {
      if (types.length !== values.length) {
        throw new Error("Number of types are not matching the values");
      }
      var size, num;
      var ret = [];
      for (var i6 = 0; i6 < types.length; i6++) {
        var type = elementaryName(types[i6]);
        var value2 = values[i6];
        if (type === "bytes") {
          ret.push(value2);
        } else if (type === "string") {
          ret.push(new Buffer(value2, "utf8"));
        } else if (type === "bool") {
          ret.push(new Buffer(value2 ? "01" : "00", "hex"));
        } else if (type === "address") {
          ret.push(util2.setLength(value2, 20));
        } else if (type.startsWith("bytes")) {
          size = parseTypeN(type);
          if (size < 1 || size > 32) {
            throw new Error("Invalid bytes<N> width: " + size);
          }
          ret.push(util2.setLengthRight(value2, size));
        } else if (type.startsWith("uint")) {
          size = parseTypeN(type);
          if (size % 8 || size < 8 || size > 256) {
            throw new Error("Invalid uint<N> width: " + size);
          }
          num = parseNumber(value2);
          if (num.bitLength() > size) {
            throw new Error("Supplied uint exceeds width: " + size + " vs " + num.bitLength());
          }
          ret.push(num.toArrayLike(Buffer, "be", size / 8));
        } else if (type.startsWith("int")) {
          size = parseTypeN(type);
          if (size % 8 || size < 8 || size > 256) {
            throw new Error("Invalid int<N> width: " + size);
          }
          num = parseNumber(value2);
          if (num.bitLength() > size) {
            throw new Error("Supplied int exceeds width: " + size + " vs " + num.bitLength());
          }
          ret.push(num.toTwos(size).toArrayLike(Buffer, "be", size / 8));
        } else {
          throw new Error("Unsupported or invalid type: " + type);
        }
      }
      return Buffer.concat(ret);
    }
    function soliditySHA3(types, values) {
      return util2.keccak(solidityPack(types, values));
    }
    module2.exports = {
      rawEncode,
      solidityPack,
      soliditySHA3
    };
  }
});

// node_modules/@coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/index.js
var require_eth_eip712_util = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/index.js"(exports2, module2) {
    var util2 = require_util4();
    var abi = require_abi();
    var TYPED_MESSAGE_SCHEMA = {
      type: "object",
      properties: {
        types: {
          type: "object",
          additionalProperties: {
            type: "array",
            items: {
              type: "object",
              properties: {
                name: { type: "string" },
                type: { type: "string" }
              },
              required: ["name", "type"]
            }
          }
        },
        primaryType: { type: "string" },
        domain: { type: "object" },
        message: { type: "object" }
      },
      required: ["types", "primaryType", "domain", "message"]
    };
    var TypedDataUtils = {
      encodeData(primaryType, data, types, useV4 = true) {
        const encodedTypes = ["bytes32"];
        const encodedValues = [this.hashType(primaryType, types)];
        if (useV4) {
          const encodeField = (name2, type, value2) => {
            if (types[type] !== void 0) {
              return ["bytes32", value2 == null ? "0x0000000000000000000000000000000000000000000000000000000000000000" : util2.keccak(this.encodeData(type, value2, types, useV4))];
            }
            if (value2 === void 0)
              throw new Error(`missing value for field ${name2} of type ${type}`);
            if (type === "bytes") {
              return ["bytes32", util2.keccak(value2)];
            }
            if (type === "string") {
              if (typeof value2 === "string") {
                value2 = Buffer.from(value2, "utf8");
              }
              return ["bytes32", util2.keccak(value2)];
            }
            if (type.lastIndexOf("]") === type.length - 1) {
              const parsedType = type.slice(0, type.lastIndexOf("["));
              const typeValuePairs = value2.map((item) => encodeField(name2, parsedType, item));
              return ["bytes32", util2.keccak(abi.rawEncode(
                typeValuePairs.map(([type2]) => type2),
                typeValuePairs.map(([, value3]) => value3)
              ))];
            }
            return [type, value2];
          };
          for (const field of types[primaryType]) {
            const [type, value2] = encodeField(field.name, field.type, data[field.name]);
            encodedTypes.push(type);
            encodedValues.push(value2);
          }
        } else {
          for (const field of types[primaryType]) {
            let value2 = data[field.name];
            if (value2 !== void 0) {
              if (field.type === "bytes") {
                encodedTypes.push("bytes32");
                value2 = util2.keccak(value2);
                encodedValues.push(value2);
              } else if (field.type === "string") {
                encodedTypes.push("bytes32");
                if (typeof value2 === "string") {
                  value2 = Buffer.from(value2, "utf8");
                }
                value2 = util2.keccak(value2);
                encodedValues.push(value2);
              } else if (types[field.type] !== void 0) {
                encodedTypes.push("bytes32");
                value2 = util2.keccak(this.encodeData(field.type, value2, types, useV4));
                encodedValues.push(value2);
              } else if (field.type.lastIndexOf("]") === field.type.length - 1) {
                throw new Error("Arrays currently unimplemented in encodeData");
              } else {
                encodedTypes.push(field.type);
                encodedValues.push(value2);
              }
            }
          }
        }
        return abi.rawEncode(encodedTypes, encodedValues);
      },
      encodeType(primaryType, types) {
        let result = "";
        let deps = this.findTypeDependencies(primaryType, types).filter((dep) => dep !== primaryType);
        deps = [primaryType].concat(deps.sort());
        for (const type of deps) {
          const children = types[type];
          if (!children) {
            throw new Error("No type definition specified: " + type);
          }
          result += type + "(" + types[type].map(({ name: name2, type: type2 }) => type2 + " " + name2).join(",") + ")";
        }
        return result;
      },
      findTypeDependencies(primaryType, types, results2 = []) {
        primaryType = primaryType.match(/^\w*/)[0];
        if (results2.includes(primaryType) || types[primaryType] === void 0) {
          return results2;
        }
        results2.push(primaryType);
        for (const field of types[primaryType]) {
          for (const dep of this.findTypeDependencies(field.type, types, results2)) {
            !results2.includes(dep) && results2.push(dep);
          }
        }
        return results2;
      },
      hashStruct(primaryType, data, types, useV4 = true) {
        return util2.keccak(this.encodeData(primaryType, data, types, useV4));
      },
      hashType(primaryType, types) {
        return util2.keccak(this.encodeType(primaryType, types));
      },
      sanitizeData(data) {
        const sanitizedData = {};
        for (const key2 in TYPED_MESSAGE_SCHEMA.properties) {
          data[key2] && (sanitizedData[key2] = data[key2]);
        }
        if (sanitizedData.types) {
          sanitizedData.types = Object.assign({ EIP712Domain: [] }, sanitizedData.types);
        }
        return sanitizedData;
      },
      hash(typedData, useV4 = true) {
        const sanitizedData = this.sanitizeData(typedData);
        const parts = [Buffer.from("1901", "hex")];
        parts.push(this.hashStruct("EIP712Domain", sanitizedData.domain, sanitizedData.types, useV4));
        if (sanitizedData.primaryType !== "EIP712Domain") {
          parts.push(this.hashStruct(sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, useV4));
        }
        return util2.keccak(Buffer.concat(parts));
      }
    };
    module2.exports = {
      TYPED_MESSAGE_SCHEMA,
      TypedDataUtils,
      hashForSignTypedDataLegacy: function(msgParams) {
        return typedSignatureHashLegacy(msgParams.data);
      },
      hashForSignTypedData_v3: function(msgParams) {
        return TypedDataUtils.hash(msgParams.data, false);
      },
      hashForSignTypedData_v4: function(msgParams) {
        return TypedDataUtils.hash(msgParams.data);
      }
    };
    function typedSignatureHashLegacy(typedData) {
      const error = new Error("Expect argument to be non-empty array");
      if (typeof typedData !== "object" || !typedData.length)
        throw error;
      const data = typedData.map(function(e6) {
        return e6.type === "bytes" ? util2.toBuffer(e6.value) : e6.value;
      });
      const types = typedData.map(function(e6) {
        return e6.type;
      });
      const schema = typedData.map(function(e6) {
        if (!e6.name)
          throw error;
        return e6.type + " " + e6.name;
      });
      return abi.soliditySHA3(
        ["bytes32", "bytes32"],
        [
          abi.soliditySHA3(new Array(typedData.length).fill("string"), schema),
          abi.soliditySHA3(types, data)
        ]
      );
    }
  }
});

// node_modules/@coinbase/wallet-sdk/dist/provider/FilterPolyfill.js
var require_FilterPolyfill = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/provider/FilterPolyfill.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.filterFromParam = exports2.FilterPolyfill = void 0;
    var types_1 = require_types2();
    var util_1 = require_util3();
    var TIMEOUT = 5 * 60 * 1e3;
    var JSONRPC_TEMPLATE = {
      jsonrpc: "2.0",
      id: 0
    };
    var FilterPolyfill = class {
      constructor(provider) {
        this.logFilters = /* @__PURE__ */ new Map();
        this.blockFilters = /* @__PURE__ */ new Set();
        this.pendingTransactionFilters = /* @__PURE__ */ new Set();
        this.cursors = /* @__PURE__ */ new Map();
        this.timeouts = /* @__PURE__ */ new Map();
        this.nextFilterId = (0, types_1.IntNumber)(1);
        this.provider = provider;
      }
      async newFilter(param) {
        const filter2 = filterFromParam(param);
        const id2 = this.makeFilterId();
        const cursor = await this.setInitialCursorPosition(id2, filter2.fromBlock);
        console.log(`Installing new log filter(${id2}):`, filter2, "initial cursor position:", cursor);
        this.logFilters.set(id2, filter2);
        this.setFilterTimeout(id2);
        return (0, util_1.hexStringFromIntNumber)(id2);
      }
      async newBlockFilter() {
        const id2 = this.makeFilterId();
        const cursor = await this.setInitialCursorPosition(id2, "latest");
        console.log(`Installing new block filter (${id2}) with initial cursor position:`, cursor);
        this.blockFilters.add(id2);
        this.setFilterTimeout(id2);
        return (0, util_1.hexStringFromIntNumber)(id2);
      }
      async newPendingTransactionFilter() {
        const id2 = this.makeFilterId();
        const cursor = await this.setInitialCursorPosition(id2, "latest");
        console.log(`Installing new block filter (${id2}) with initial cursor position:`, cursor);
        this.pendingTransactionFilters.add(id2);
        this.setFilterTimeout(id2);
        return (0, util_1.hexStringFromIntNumber)(id2);
      }
      uninstallFilter(filterId) {
        const id2 = (0, util_1.intNumberFromHexString)(filterId);
        console.log(`Uninstalling filter (${id2})`);
        this.deleteFilter(id2);
        return true;
      }
      getFilterChanges(filterId) {
        const id2 = (0, util_1.intNumberFromHexString)(filterId);
        if (this.timeouts.has(id2)) {
          this.setFilterTimeout(id2);
        }
        if (this.logFilters.has(id2)) {
          return this.getLogFilterChanges(id2);
        } else if (this.blockFilters.has(id2)) {
          return this.getBlockFilterChanges(id2);
        } else if (this.pendingTransactionFilters.has(id2)) {
          return this.getPendingTransactionFilterChanges(id2);
        }
        return Promise.resolve(filterNotFoundError());
      }
      async getFilterLogs(filterId) {
        const id2 = (0, util_1.intNumberFromHexString)(filterId);
        const filter2 = this.logFilters.get(id2);
        if (!filter2) {
          return filterNotFoundError();
        }
        return this.sendAsyncPromise(Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { method: "eth_getLogs", params: [paramFromFilter(filter2)] }));
      }
      makeFilterId() {
        return (0, types_1.IntNumber)(++this.nextFilterId);
      }
      sendAsyncPromise(request) {
        return new Promise((resolve, reject) => {
          this.provider.sendAsync(request, (err, response) => {
            if (err) {
              return reject(err);
            }
            if (Array.isArray(response) || response == null) {
              return reject(new Error(`unexpected response received: ${JSON.stringify(response)}`));
            }
            resolve(response);
          });
        });
      }
      deleteFilter(id2) {
        console.log(`Deleting filter (${id2})`);
        this.logFilters.delete(id2);
        this.blockFilters.delete(id2);
        this.pendingTransactionFilters.delete(id2);
        this.cursors.delete(id2);
        this.timeouts.delete(id2);
      }
      async getLogFilterChanges(id2) {
        const filter2 = this.logFilters.get(id2);
        const cursorPosition = this.cursors.get(id2);
        if (!cursorPosition || !filter2) {
          return filterNotFoundError();
        }
        const currentBlockHeight = await this.getCurrentBlockHeight();
        const toBlock = filter2.toBlock === "latest" ? currentBlockHeight : filter2.toBlock;
        if (cursorPosition > currentBlockHeight) {
          return emptyResult();
        }
        if (cursorPosition > filter2.toBlock) {
          return emptyResult();
        }
        console.log(`Fetching logs from ${cursorPosition} to ${toBlock} for filter ${id2}`);
        const response = await this.sendAsyncPromise(Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { method: "eth_getLogs", params: [
          paramFromFilter(Object.assign(Object.assign({}, filter2), { fromBlock: cursorPosition, toBlock }))
        ] }));
        if (Array.isArray(response.result)) {
          const blocks2 = response.result.map((log) => (0, util_1.intNumberFromHexString)(log.blockNumber || "0x0"));
          const highestBlock = Math.max(...blocks2);
          if (highestBlock && highestBlock > cursorPosition) {
            const newCursorPosition = (0, types_1.IntNumber)(highestBlock + 1);
            console.log(`Moving cursor position for filter (${id2}) from ${cursorPosition} to ${newCursorPosition}`);
            this.cursors.set(id2, newCursorPosition);
          }
        }
        return response;
      }
      async getBlockFilterChanges(id2) {
        const cursorPosition = this.cursors.get(id2);
        if (!cursorPosition) {
          return filterNotFoundError();
        }
        const currentBlockHeight = await this.getCurrentBlockHeight();
        if (cursorPosition > currentBlockHeight) {
          return emptyResult();
        }
        console.log(`Fetching blocks from ${cursorPosition} to ${currentBlockHeight} for filter (${id2})`);
        const blocks2 = (await Promise.all(
          (0, util_1.range)(cursorPosition, currentBlockHeight + 1).map((i6) => this.getBlockHashByNumber((0, types_1.IntNumber)(i6)))
        )).filter((hash3) => !!hash3);
        const newCursorPosition = (0, types_1.IntNumber)(cursorPosition + blocks2.length);
        console.log(`Moving cursor position for filter (${id2}) from ${cursorPosition} to ${newCursorPosition}`);
        this.cursors.set(id2, newCursorPosition);
        return Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { result: blocks2 });
      }
      async getPendingTransactionFilterChanges(_id) {
        return Promise.resolve(emptyResult());
      }
      async setInitialCursorPosition(id2, startBlock) {
        const currentBlockHeight = await this.getCurrentBlockHeight();
        const initialCursorPosition = typeof startBlock === "number" && startBlock > currentBlockHeight ? startBlock : currentBlockHeight;
        this.cursors.set(id2, initialCursorPosition);
        return initialCursorPosition;
      }
      setFilterTimeout(id2) {
        const existing = this.timeouts.get(id2);
        if (existing) {
          window.clearTimeout(existing);
        }
        const timeout2 = window.setTimeout(() => {
          console.log(`Filter (${id2}) timed out`);
          this.deleteFilter(id2);
        }, TIMEOUT);
        this.timeouts.set(id2, timeout2);
      }
      async getCurrentBlockHeight() {
        const { result } = await this.sendAsyncPromise(Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { method: "eth_blockNumber", params: [] }));
        return (0, util_1.intNumberFromHexString)((0, util_1.ensureHexString)(result));
      }
      async getBlockHashByNumber(blockNumber) {
        const response = await this.sendAsyncPromise(Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { method: "eth_getBlockByNumber", params: [(0, util_1.hexStringFromIntNumber)(blockNumber), false] }));
        if (response.result && typeof response.result.hash === "string") {
          return (0, util_1.ensureHexString)(response.result.hash);
        }
        return null;
      }
    };
    exports2.FilterPolyfill = FilterPolyfill;
    function filterFromParam(param) {
      return {
        fromBlock: intBlockHeightFromHexBlockHeight(param.fromBlock),
        toBlock: intBlockHeightFromHexBlockHeight(param.toBlock),
        addresses: param.address === void 0 ? null : Array.isArray(param.address) ? param.address : [param.address],
        topics: param.topics || []
      };
    }
    exports2.filterFromParam = filterFromParam;
    function paramFromFilter(filter2) {
      const param = {
        fromBlock: hexBlockHeightFromIntBlockHeight(filter2.fromBlock),
        toBlock: hexBlockHeightFromIntBlockHeight(filter2.toBlock),
        topics: filter2.topics
      };
      if (filter2.addresses !== null) {
        param.address = filter2.addresses;
      }
      return param;
    }
    function intBlockHeightFromHexBlockHeight(value2) {
      if (value2 === void 0 || value2 === "latest" || value2 === "pending") {
        return "latest";
      } else if (value2 === "earliest") {
        return (0, types_1.IntNumber)(0);
      } else if ((0, util_1.isHexString)(value2)) {
        return (0, util_1.intNumberFromHexString)(value2);
      }
      throw new Error(`Invalid block option: ${String(value2)}`);
    }
    function hexBlockHeightFromIntBlockHeight(value2) {
      if (value2 === "latest") {
        return value2;
      }
      return (0, util_1.hexStringFromIntNumber)(value2);
    }
    function filterNotFoundError() {
      return Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { error: { code: -32e3, message: "filter not found" } });
    }
    function emptyResult() {
      return Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { result: [] });
    }
  }
});

// node_modules/@coinbase/wallet-sdk/dist/provider/JSONRPC.js
var require_JSONRPC = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/provider/JSONRPC.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.JSONRPCMethod = void 0;
    var JSONRPCMethod;
    (function(JSONRPCMethod2) {
      JSONRPCMethod2["eth_accounts"] = "eth_accounts";
      JSONRPCMethod2["eth_coinbase"] = "eth_coinbase";
      JSONRPCMethod2["net_version"] = "net_version";
      JSONRPCMethod2["eth_chainId"] = "eth_chainId";
      JSONRPCMethod2["eth_uninstallFilter"] = "eth_uninstallFilter";
      JSONRPCMethod2["eth_requestAccounts"] = "eth_requestAccounts";
      JSONRPCMethod2["eth_sign"] = "eth_sign";
      JSONRPCMethod2["eth_ecRecover"] = "eth_ecRecover";
      JSONRPCMethod2["personal_sign"] = "personal_sign";
      JSONRPCMethod2["personal_ecRecover"] = "personal_ecRecover";
      JSONRPCMethod2["eth_signTransaction"] = "eth_signTransaction";
      JSONRPCMethod2["eth_sendRawTransaction"] = "eth_sendRawTransaction";
      JSONRPCMethod2["eth_sendTransaction"] = "eth_sendTransaction";
      JSONRPCMethod2["eth_signTypedData_v1"] = "eth_signTypedData_v1";
      JSONRPCMethod2["eth_signTypedData_v2"] = "eth_signTypedData_v2";
      JSONRPCMethod2["eth_signTypedData_v3"] = "eth_signTypedData_v3";
      JSONRPCMethod2["eth_signTypedData_v4"] = "eth_signTypedData_v4";
      JSONRPCMethod2["eth_signTypedData"] = "eth_signTypedData";
      JSONRPCMethod2["cbWallet_arbitrary"] = "walletlink_arbitrary";
      JSONRPCMethod2["wallet_addEthereumChain"] = "wallet_addEthereumChain";
      JSONRPCMethod2["wallet_switchEthereumChain"] = "wallet_switchEthereumChain";
      JSONRPCMethod2["wallet_watchAsset"] = "wallet_watchAsset";
      JSONRPCMethod2["eth_subscribe"] = "eth_subscribe";
      JSONRPCMethod2["eth_unsubscribe"] = "eth_unsubscribe";
      JSONRPCMethod2["eth_newFilter"] = "eth_newFilter";
      JSONRPCMethod2["eth_newBlockFilter"] = "eth_newBlockFilter";
      JSONRPCMethod2["eth_newPendingTransactionFilter"] = "eth_newPendingTransactionFilter";
      JSONRPCMethod2["eth_getFilterChanges"] = "eth_getFilterChanges";
      JSONRPCMethod2["eth_getFilterLogs"] = "eth_getFilterLogs";
    })(JSONRPCMethod = exports2.JSONRPCMethod || (exports2.JSONRPCMethod = {}));
  }
});

// node_modules/pify/index.js
var require_pify = __commonJS({
  "node_modules/pify/index.js"(exports2, module2) {
    "use strict";
    var processFn = (fn2, opts) => function() {
      const P5 = opts.promiseModule;
      const args = new Array(arguments.length);
      for (let i6 = 0; i6 < arguments.length; i6++) {
        args[i6] = arguments[i6];
      }
      return new P5((resolve, reject) => {
        if (opts.errorFirst) {
          args.push(function(err, result) {
            if (opts.multiArgs) {
              const results2 = new Array(arguments.length - 1);
              for (let i6 = 1; i6 < arguments.length; i6++) {
                results2[i6 - 1] = arguments[i6];
              }
              if (err) {
                results2.unshift(err);
                reject(results2);
              } else {
                resolve(results2);
              }
            } else if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          });
        } else {
          args.push(function(result) {
            if (opts.multiArgs) {
              const results2 = new Array(arguments.length - 1);
              for (let i6 = 0; i6 < arguments.length; i6++) {
                results2[i6] = arguments[i6];
              }
              resolve(results2);
            } else {
              resolve(result);
            }
          });
        }
        fn2.apply(this, args);
      });
    };
    module2.exports = (obj, opts) => {
      opts = Object.assign({
        exclude: [/.+(Sync|Stream)$/],
        errorFirst: true,
        promiseModule: Promise
      }, opts);
      const filter2 = (key2) => {
        const match = (pattern) => typeof pattern === "string" ? key2 === pattern : pattern.test(key2);
        return opts.include ? opts.include.some(match) : !opts.exclude.some(match);
      };
      let ret;
      if (typeof obj === "function") {
        ret = function() {
          if (opts.excludeMain) {
            return obj.apply(this, arguments);
          }
          return processFn(obj, opts).apply(this, arguments);
        };
      } else {
        ret = Object.create(Object.getPrototypeOf(obj));
      }
      for (const key2 in obj) {
        const x6 = obj[key2];
        ret[key2] = typeof x6 === "function" && filter2(key2) ? processFn(x6, opts) : x6;
      }
      return ret;
    };
  }
});

// node_modules/xtend/immutable.js
var require_immutable = __commonJS({
  "node_modules/xtend/immutable.js"(exports2, module2) {
    module2.exports = extend;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function extend() {
      var target = {};
      for (var i6 = 0; i6 < arguments.length; i6++) {
        var source = arguments[i6];
        for (var key2 in source) {
          if (hasOwnProperty.call(source, key2)) {
            target[key2] = source[key2];
          }
        }
      }
      return target;
    }
  }
});

// node_modules/json-rpc-random-id/index.js
var require_json_rpc_random_id = __commonJS({
  "node_modules/json-rpc-random-id/index.js"(exports2, module2) {
    module2.exports = IdIterator;
    function IdIterator(opts) {
      opts = opts || {};
      var max2 = opts.max || Number.MAX_SAFE_INTEGER;
      var idCounter = typeof opts.start !== "undefined" ? opts.start : Math.floor(Math.random() * max2);
      return function createRandomId() {
        idCounter = idCounter % max2;
        return idCounter++;
      };
    }
  }
});

// node_modules/eth-query/index.js
var require_eth_query = __commonJS({
  "node_modules/eth-query/index.js"(exports2, module2) {
    var extend = require_immutable();
    var createRandomId = require_json_rpc_random_id()();
    module2.exports = EthQuery;
    function EthQuery(provider) {
      const self2 = this;
      self2.currentProvider = provider;
    }
    EthQuery.prototype.getBalance = generateFnWithDefaultBlockFor(2, "eth_getBalance");
    EthQuery.prototype.getCode = generateFnWithDefaultBlockFor(2, "eth_getCode");
    EthQuery.prototype.getTransactionCount = generateFnWithDefaultBlockFor(2, "eth_getTransactionCount");
    EthQuery.prototype.getStorageAt = generateFnWithDefaultBlockFor(3, "eth_getStorageAt");
    EthQuery.prototype.call = generateFnWithDefaultBlockFor(2, "eth_call");
    EthQuery.prototype.protocolVersion = generateFnFor("eth_protocolVersion");
    EthQuery.prototype.syncing = generateFnFor("eth_syncing");
    EthQuery.prototype.coinbase = generateFnFor("eth_coinbase");
    EthQuery.prototype.mining = generateFnFor("eth_mining");
    EthQuery.prototype.hashrate = generateFnFor("eth_hashrate");
    EthQuery.prototype.gasPrice = generateFnFor("eth_gasPrice");
    EthQuery.prototype.accounts = generateFnFor("eth_accounts");
    EthQuery.prototype.blockNumber = generateFnFor("eth_blockNumber");
    EthQuery.prototype.getBlockTransactionCountByHash = generateFnFor("eth_getBlockTransactionCountByHash");
    EthQuery.prototype.getBlockTransactionCountByNumber = generateFnFor("eth_getBlockTransactionCountByNumber");
    EthQuery.prototype.getUncleCountByBlockHash = generateFnFor("eth_getUncleCountByBlockHash");
    EthQuery.prototype.getUncleCountByBlockNumber = generateFnFor("eth_getUncleCountByBlockNumber");
    EthQuery.prototype.sign = generateFnFor("eth_sign");
    EthQuery.prototype.sendTransaction = generateFnFor("eth_sendTransaction");
    EthQuery.prototype.sendRawTransaction = generateFnFor("eth_sendRawTransaction");
    EthQuery.prototype.estimateGas = generateFnFor("eth_estimateGas");
    EthQuery.prototype.getBlockByHash = generateFnFor("eth_getBlockByHash");
    EthQuery.prototype.getBlockByNumber = generateFnFor("eth_getBlockByNumber");
    EthQuery.prototype.getTransactionByHash = generateFnFor("eth_getTransactionByHash");
    EthQuery.prototype.getTransactionByBlockHashAndIndex = generateFnFor("eth_getTransactionByBlockHashAndIndex");
    EthQuery.prototype.getTransactionByBlockNumberAndIndex = generateFnFor("eth_getTransactionByBlockNumberAndIndex");
    EthQuery.prototype.getTransactionReceipt = generateFnFor("eth_getTransactionReceipt");
    EthQuery.prototype.getUncleByBlockHashAndIndex = generateFnFor("eth_getUncleByBlockHashAndIndex");
    EthQuery.prototype.getUncleByBlockNumberAndIndex = generateFnFor("eth_getUncleByBlockNumberAndIndex");
    EthQuery.prototype.getCompilers = generateFnFor("eth_getCompilers");
    EthQuery.prototype.compileLLL = generateFnFor("eth_compileLLL");
    EthQuery.prototype.compileSolidity = generateFnFor("eth_compileSolidity");
    EthQuery.prototype.compileSerpent = generateFnFor("eth_compileSerpent");
    EthQuery.prototype.newFilter = generateFnFor("eth_newFilter");
    EthQuery.prototype.newBlockFilter = generateFnFor("eth_newBlockFilter");
    EthQuery.prototype.newPendingTransactionFilter = generateFnFor("eth_newPendingTransactionFilter");
    EthQuery.prototype.uninstallFilter = generateFnFor("eth_uninstallFilter");
    EthQuery.prototype.getFilterChanges = generateFnFor("eth_getFilterChanges");
    EthQuery.prototype.getFilterLogs = generateFnFor("eth_getFilterLogs");
    EthQuery.prototype.getLogs = generateFnFor("eth_getLogs");
    EthQuery.prototype.getWork = generateFnFor("eth_getWork");
    EthQuery.prototype.submitWork = generateFnFor("eth_submitWork");
    EthQuery.prototype.submitHashrate = generateFnFor("eth_submitHashrate");
    EthQuery.prototype.sendAsync = function(opts, cb) {
      const self2 = this;
      self2.currentProvider.sendAsync(createPayload(opts), function(err, response) {
        if (!err && response.error)
          err = new Error("EthQuery - RPC Error - " + response.error.message);
        if (err)
          return cb(err);
        cb(null, response.result);
      });
    };
    function generateFnFor(methodName) {
      return function() {
        const self2 = this;
        var args = [].slice.call(arguments);
        var cb = args.pop();
        self2.sendAsync({
          method: methodName,
          params: args
        }, cb);
      };
    }
    function generateFnWithDefaultBlockFor(argCount, methodName) {
      return function() {
        const self2 = this;
        var args = [].slice.call(arguments);
        var cb = args.pop();
        if (args.length < argCount)
          args.push("latest");
        self2.sendAsync({
          method: methodName,
          params: args
        }, cb);
      };
    }
    function createPayload(data) {
      return extend({
        id: createRandomId(),
        jsonrpc: "2.0",
        params: []
      }, data);
    }
  }
});

// node_modules/safe-event-emitter/index.js
var require_safe_event_emitter2 = __commonJS({
  "node_modules/safe-event-emitter/index.js"(exports2, module2) {
    var util2 = require_util();
    var EventEmitter6 = require_events();
    var R4 = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R4 && typeof R4.apply === "function" ? R4.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    module2.exports = SafeEventEmitter;
    function SafeEventEmitter() {
      EventEmitter6.call(this);
    }
    util2.inherits(SafeEventEmitter, EventEmitter6);
    SafeEventEmitter.prototype.emit = function(type) {
      var args = [];
      for (var i6 = 1; i6 < arguments.length; i6++)
        args.push(arguments[i6]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er2;
        if (args.length > 0)
          er2 = args[0];
        if (er2 instanceof Error) {
          throw er2;
        }
        var err = new Error("Unhandled error." + (er2 ? " (" + er2.message + ")" : ""));
        err.context = er2;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        safeApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i6 = 0; i6 < len; ++i6)
          safeApply(listeners[i6], this, args);
      }
      return true;
    };
    function safeApply(handler, context, args) {
      try {
        ReflectApply(handler, context, args);
      } catch (err) {
        setTimeout(() => {
          throw err;
        });
      }
    }
    function arrayClone(arr, n4) {
      var copy = new Array(n4);
      for (var i6 = 0; i6 < n4; ++i6)
        copy[i6] = arr[i6];
      return copy;
    }
  }
});

// node_modules/eth-block-tracker/src/base.js
var require_base = __commonJS({
  "node_modules/eth-block-tracker/src/base.js"(exports2, module2) {
    var EthQuery = require_eth_query();
    var pify = require_pify();
    var SafeEventEmitter = require_safe_event_emitter2();
    var sec = 1e3;
    var calculateSum = (accumulator, currentValue) => accumulator + currentValue;
    var blockTrackerEvents = ["sync", "latest"];
    var BaseBlockTracker = class extends SafeEventEmitter {
      constructor(opts = {}) {
        super();
        this._blockResetDuration = opts.blockResetDuration || 20 * sec;
        this._blockResetTimeout;
        this._currentBlock = null;
        this._isRunning = false;
        this._onNewListener = this._onNewListener.bind(this);
        this._onRemoveListener = this._onRemoveListener.bind(this);
        this._resetCurrentBlock = this._resetCurrentBlock.bind(this);
        this._setupInternalEvents();
      }
      isRunning() {
        return this._isRunning;
      }
      getCurrentBlock() {
        return this._currentBlock;
      }
      async getLatestBlock() {
        if (this._currentBlock)
          return this._currentBlock;
        const latestBlock = await new Promise((resolve) => this.once("latest", resolve));
        return latestBlock;
      }
      removeAllListeners(eventName) {
        if (eventName) {
          super.removeAllListeners(eventName);
        } else {
          super.removeAllListeners();
        }
        this._setupInternalEvents();
        this._onRemoveListener();
      }
      _start() {
      }
      _end() {
      }
      _setupInternalEvents() {
        this.removeListener("newListener", this._onNewListener);
        this.removeListener("removeListener", this._onRemoveListener);
        this.on("newListener", this._onNewListener);
        this.on("removeListener", this._onRemoveListener);
      }
      _onNewListener(eventName, handler) {
        if (!blockTrackerEvents.includes(eventName))
          return;
        this._maybeStart();
      }
      _onRemoveListener(eventName, handler) {
        if (this._getBlockTrackerEventCount() > 0)
          return;
        this._maybeEnd();
      }
      _maybeStart() {
        if (this._isRunning)
          return;
        this._isRunning = true;
        this._cancelBlockResetTimeout();
        this._start();
      }
      _maybeEnd() {
        if (!this._isRunning)
          return;
        this._isRunning = false;
        this._setupBlockResetTimeout();
        this._end();
      }
      _getBlockTrackerEventCount() {
        return blockTrackerEvents.map((eventName) => this.listenerCount(eventName)).reduce(calculateSum);
      }
      _newPotentialLatest(newBlock) {
        const currentBlock = this._currentBlock;
        if (currentBlock && hexToInt(newBlock) <= hexToInt(currentBlock))
          return;
        this._setCurrentBlock(newBlock);
      }
      _setCurrentBlock(newBlock) {
        const oldBlock = this._currentBlock;
        this._currentBlock = newBlock;
        this.emit("latest", newBlock);
        this.emit("sync", { oldBlock, newBlock });
      }
      _setupBlockResetTimeout() {
        this._cancelBlockResetTimeout();
        this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this._blockResetDuration);
        if (this._blockResetTimeout.unref) {
          this._blockResetTimeout.unref();
        }
      }
      _cancelBlockResetTimeout() {
        clearTimeout(this._blockResetTimeout);
      }
      _resetCurrentBlock() {
        this._currentBlock = null;
      }
    };
    module2.exports = BaseBlockTracker;
    function hexToInt(hexInt) {
      return Number.parseInt(hexInt, 16);
    }
  }
});

// node_modules/eth-block-tracker/src/polling.js
var require_polling = __commonJS({
  "node_modules/eth-block-tracker/src/polling.js"(exports2, module2) {
    var pify = require_pify();
    var BaseBlockTracker = require_base();
    var sec = 1e3;
    var PollingBlockTracker = class extends BaseBlockTracker {
      constructor(opts = {}) {
        if (!opts.provider)
          throw new Error("PollingBlockTracker - no provider specified.");
        const pollingInterval = opts.pollingInterval || 20 * sec;
        const retryTimeout = opts.retryTimeout || pollingInterval / 10;
        const keepEventLoopActive = opts.keepEventLoopActive !== void 0 ? opts.keepEventLoopActive : true;
        const setSkipCacheFlag = opts.setSkipCacheFlag || false;
        super(Object.assign({
          blockResetDuration: pollingInterval
        }, opts));
        this._provider = opts.provider;
        this._pollingInterval = pollingInterval;
        this._retryTimeout = retryTimeout;
        this._keepEventLoopActive = keepEventLoopActive;
        this._setSkipCacheFlag = setSkipCacheFlag;
      }
      async checkForLatestBlock() {
        await this._updateLatestBlock();
        return await this.getLatestBlock();
      }
      _start() {
        this._performSync().catch((err) => this.emit("error", err));
      }
      async _performSync() {
        while (this._isRunning) {
          try {
            await this._updateLatestBlock();
            await timeout2(this._pollingInterval, !this._keepEventLoopActive);
          } catch (err) {
            const newErr = new Error(`PollingBlockTracker - encountered an error while attempting to update latest block:
${err.stack}`);
            try {
              this.emit("error", newErr);
            } catch (emitErr) {
              console.error(newErr);
            }
            await timeout2(this._retryTimeout, !this._keepEventLoopActive);
          }
        }
      }
      async _updateLatestBlock() {
        const latestBlock = await this._fetchLatestBlock();
        this._newPotentialLatest(latestBlock);
      }
      async _fetchLatestBlock() {
        const req = { jsonrpc: "2.0", id: 1, method: "eth_blockNumber", params: [] };
        if (this._setSkipCacheFlag)
          req.skipCache = true;
        const res = await pify((cb) => this._provider.sendAsync(req, cb))();
        if (res.error)
          throw new Error(`PollingBlockTracker - encountered error fetching block:
${res.error}`);
        return res.result;
      }
    };
    module2.exports = PollingBlockTracker;
    function timeout2(duration, unref) {
      return new Promise((resolve) => {
        const timoutRef = setTimeout(resolve, duration);
        if (timoutRef.unref && unref) {
          timoutRef.unref();
        }
      });
    }
  }
});

// node_modules/eth-json-rpc-middleware/node_modules/json-rpc-engine/src/createScaffoldMiddleware.js
var require_createScaffoldMiddleware = __commonJS({
  "node_modules/eth-json-rpc-middleware/node_modules/json-rpc-engine/src/createScaffoldMiddleware.js"(exports2, module2) {
    module2.exports = function createScaffoldMiddleware(handlers) {
      return (req, res, next, end) => {
        const handler = handlers[req.method];
        if (handler === void 0) {
          return next();
        }
        if (typeof handler === "function") {
          return handler(req, res, next, end);
        }
        res.result = handler;
        return end();
      };
    };
  }
});

// node_modules/eth-json-rpc-middleware/scaffold.js
var require_scaffold = __commonJS({
  "node_modules/eth-json-rpc-middleware/scaffold.js"(exports2, module2) {
    module2.exports = require_createScaffoldMiddleware();
  }
});

// node_modules/json-rpc-engine/dist/getUniqueId.js
var require_getUniqueId = __commonJS({
  "node_modules/json-rpc-engine/dist/getUniqueId.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getUniqueId = void 0;
    var MAX = 4294967295;
    var idCounter = Math.floor(Math.random() * MAX);
    function getUniqueId() {
      idCounter = (idCounter + 1) % MAX;
      return idCounter;
    }
    exports2.getUniqueId = getUniqueId;
  }
});

// node_modules/json-rpc-engine/dist/idRemapMiddleware.js
var require_idRemapMiddleware = __commonJS({
  "node_modules/json-rpc-engine/dist/idRemapMiddleware.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createIdRemapMiddleware = void 0;
    var getUniqueId_1 = require_getUniqueId();
    function createIdRemapMiddleware() {
      return (req, res, next, _end) => {
        const originalId = req.id;
        const newId = getUniqueId_1.getUniqueId();
        req.id = newId;
        res.id = newId;
        next((done) => {
          req.id = originalId;
          res.id = originalId;
          done();
        });
      };
    }
    exports2.createIdRemapMiddleware = createIdRemapMiddleware;
  }
});

// node_modules/json-rpc-engine/dist/createAsyncMiddleware.js
var require_createAsyncMiddleware = __commonJS({
  "node_modules/json-rpc-engine/dist/createAsyncMiddleware.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createAsyncMiddleware = void 0;
    function createAsyncMiddleware(asyncMiddleware) {
      return async (req, res, next, end) => {
        let resolveNextPromise;
        const nextPromise = new Promise((resolve) => {
          resolveNextPromise = resolve;
        });
        let returnHandlerCallback = null;
        let nextWasCalled = false;
        const asyncNext = async () => {
          nextWasCalled = true;
          next((runReturnHandlersCallback) => {
            returnHandlerCallback = runReturnHandlersCallback;
            resolveNextPromise();
          });
          await nextPromise;
        };
        try {
          await asyncMiddleware(req, res, asyncNext);
          if (nextWasCalled) {
            await nextPromise;
            returnHandlerCallback(null);
          } else {
            end(null);
          }
        } catch (error) {
          if (returnHandlerCallback) {
            returnHandlerCallback(error);
          } else {
            end(error);
          }
        }
      };
    }
    exports2.createAsyncMiddleware = createAsyncMiddleware;
  }
});

// node_modules/json-rpc-engine/dist/createScaffoldMiddleware.js
var require_createScaffoldMiddleware2 = __commonJS({
  "node_modules/json-rpc-engine/dist/createScaffoldMiddleware.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createScaffoldMiddleware = void 0;
    function createScaffoldMiddleware(handlers) {
      return (req, res, next, end) => {
        const handler = handlers[req.method];
        if (handler === void 0) {
          return next();
        }
        if (typeof handler === "function") {
          return handler(req, res, next, end);
        }
        res.result = handler;
        return end();
      };
    }
    exports2.createScaffoldMiddleware = createScaffoldMiddleware;
  }
});

// node_modules/json-rpc-engine/dist/JsonRpcEngine.js
var require_JsonRpcEngine = __commonJS({
  "node_modules/json-rpc-engine/dist/JsonRpcEngine.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.JsonRpcEngine = void 0;
    var safe_event_emitter_1 = __importDefault(require_safe_event_emitter());
    var eth_rpc_errors_1 = require_dist2();
    var JsonRpcEngine = class extends safe_event_emitter_1.default {
      constructor() {
        super();
        this._middleware = [];
      }
      push(middleware) {
        this._middleware.push(middleware);
      }
      handle(req, cb) {
        if (cb && typeof cb !== "function") {
          throw new Error('"callback" must be a function if provided.');
        }
        if (Array.isArray(req)) {
          if (cb) {
            return this._handleBatch(req, cb);
          }
          return this._handleBatch(req);
        }
        if (cb) {
          return this._handle(req, cb);
        }
        return this._promiseHandle(req);
      }
      asMiddleware() {
        return async (req, res, next, end) => {
          try {
            const [middlewareError, isComplete, returnHandlers] = await JsonRpcEngine._runAllMiddleware(req, res, this._middleware);
            if (isComplete) {
              await JsonRpcEngine._runReturnHandlers(returnHandlers);
              return end(middlewareError);
            }
            return next(async (handlerCallback) => {
              try {
                await JsonRpcEngine._runReturnHandlers(returnHandlers);
              } catch (error) {
                return handlerCallback(error);
              }
              return handlerCallback();
            });
          } catch (error) {
            return end(error);
          }
        };
      }
      async _handleBatch(reqs, cb) {
        try {
          const responses = await Promise.all(
            reqs.map(this._promiseHandle.bind(this))
          );
          if (cb) {
            return cb(null, responses);
          }
          return responses;
        } catch (error) {
          if (cb) {
            return cb(error);
          }
          throw error;
        }
      }
      _promiseHandle(req) {
        return new Promise((resolve) => {
          this._handle(req, (_err, res) => {
            resolve(res);
          });
        });
      }
      async _handle(callerReq, cb) {
        if (!callerReq || Array.isArray(callerReq) || typeof callerReq !== "object") {
          const error2 = new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.invalidRequest, `Requests must be plain objects. Received: ${typeof callerReq}`, { request: callerReq });
          return cb(error2, { id: void 0, jsonrpc: "2.0", error: error2 });
        }
        if (typeof callerReq.method !== "string") {
          const error2 = new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.invalidRequest, `Must specify a string method. Received: ${typeof callerReq.method}`, { request: callerReq });
          return cb(error2, { id: callerReq.id, jsonrpc: "2.0", error: error2 });
        }
        const req = Object.assign({}, callerReq);
        const res = {
          id: req.id,
          jsonrpc: req.jsonrpc
        };
        let error = null;
        try {
          await this._processRequest(req, res);
        } catch (_error) {
          error = _error;
        }
        if (error) {
          delete res.result;
          if (!res.error) {
            res.error = eth_rpc_errors_1.serializeError(error);
          }
        }
        return cb(error, res);
      }
      async _processRequest(req, res) {
        const [error, isComplete, returnHandlers] = await JsonRpcEngine._runAllMiddleware(req, res, this._middleware);
        JsonRpcEngine._checkForCompletion(req, res, isComplete);
        await JsonRpcEngine._runReturnHandlers(returnHandlers);
        if (error) {
          throw error;
        }
      }
      static async _runAllMiddleware(req, res, middlewareStack) {
        const returnHandlers = [];
        let error = null;
        let isComplete = false;
        for (const middleware of middlewareStack) {
          [error, isComplete] = await JsonRpcEngine._runMiddleware(req, res, middleware, returnHandlers);
          if (isComplete) {
            break;
          }
        }
        return [error, isComplete, returnHandlers.reverse()];
      }
      static _runMiddleware(req, res, middleware, returnHandlers) {
        return new Promise((resolve) => {
          const end = (err) => {
            const error = err || res.error;
            if (error) {
              res.error = eth_rpc_errors_1.serializeError(error);
            }
            resolve([error, true]);
          };
          const next = (returnHandler) => {
            if (res.error) {
              end(res.error);
            } else {
              if (returnHandler) {
                if (typeof returnHandler !== "function") {
                  end(new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: "next" return handlers must be functions. Received "${typeof returnHandler}" for request:
${jsonify(req)}`, { request: req }));
                }
                returnHandlers.push(returnHandler);
              }
              resolve([null, false]);
            }
          };
          try {
            middleware(req, res, next, end);
          } catch (error) {
            end(error);
          }
        });
      }
      static async _runReturnHandlers(handlers) {
        for (const handler of handlers) {
          await new Promise((resolve, reject) => {
            handler((err) => err ? reject(err) : resolve());
          });
        }
      }
      static _checkForCompletion(req, res, isComplete) {
        if (!("result" in res) && !("error" in res)) {
          throw new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: Response has no error or result for request:
${jsonify(req)}`, { request: req });
        }
        if (!isComplete) {
          throw new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: Nothing ended request:
${jsonify(req)}`, { request: req });
        }
      }
    };
    exports2.JsonRpcEngine = JsonRpcEngine;
    function jsonify(request) {
      return JSON.stringify(request, null, 2);
    }
  }
});

// node_modules/json-rpc-engine/dist/mergeMiddleware.js
var require_mergeMiddleware = __commonJS({
  "node_modules/json-rpc-engine/dist/mergeMiddleware.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeMiddleware = void 0;
    var JsonRpcEngine_1 = require_JsonRpcEngine();
    function mergeMiddleware(middlewareStack) {
      const engine = new JsonRpcEngine_1.JsonRpcEngine();
      middlewareStack.forEach((middleware) => engine.push(middleware));
      return engine.asMiddleware();
    }
    exports2.mergeMiddleware = mergeMiddleware;
  }
});

// node_modules/json-rpc-engine/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/json-rpc-engine/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o6, m6, k8, k22) {
      if (k22 === void 0)
        k22 = k8;
      Object.defineProperty(o6, k22, { enumerable: true, get: function() {
        return m6[k8];
      } });
    } : function(o6, m6, k8, k22) {
      if (k22 === void 0)
        k22 = k8;
      o6[k22] = m6[k8];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m6, exports3) {
      for (var p7 in m6)
        if (p7 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p7))
          __createBinding(exports3, m6, p7);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_idRemapMiddleware(), exports2);
    __exportStar(require_createAsyncMiddleware(), exports2);
    __exportStar(require_createScaffoldMiddleware2(), exports2);
    __exportStar(require_getUniqueId(), exports2);
    __exportStar(require_JsonRpcEngine(), exports2);
    __exportStar(require_mergeMiddleware(), exports2);
  }
});

// node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "node_modules/tslib/tslib.js"(exports2, module2) {
    var __extends2;
    var __assign;
    var __rest;
    var __decorate;
    var __param;
    var __metadata;
    var __awaiter17;
    var __generator;
    var __exportStar;
    var __values;
    var __read;
    var __spread;
    var __spreadArrays2;
    var __spreadArray2;
    var __await;
    var __asyncGenerator;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet;
    var __classPrivateFieldSet;
    var __classPrivateFieldIn;
    var __createBinding;
    (function(factory) {
      var root2 = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports3) {
          factory(createExporter(root2, createExporter(exports3)));
        });
      } else if (typeof module2 === "object" && typeof module2.exports === "object") {
        factory(createExporter(root2, createExporter(module2.exports)));
      } else {
        factory(createExporter(root2));
      }
      function createExporter(exports3, previous) {
        if (exports3 !== root2) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports3, "__esModule", { value: true });
          } else {
            exports3.__esModule = true;
          }
        }
        return function(id2, v9) {
          return exports3[id2] = previous ? previous(id2, v9) : v9;
        };
      }
    })(function(exporter) {
      var extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d6, b4) {
        d6.__proto__ = b4;
      } || function(d6, b4) {
        for (var p7 in b4)
          if (Object.prototype.hasOwnProperty.call(b4, p7))
            d6[p7] = b4[p7];
      };
      __extends2 = function(d6, b4) {
        if (typeof b4 !== "function" && b4 !== null)
          throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
        extendStatics2(d6, b4);
        function __() {
          this.constructor = d6;
        }
        d6.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
      };
      __assign = Object.assign || function(t6) {
        for (var s6, i6 = 1, n4 = arguments.length; i6 < n4; i6++) {
          s6 = arguments[i6];
          for (var p7 in s6)
            if (Object.prototype.hasOwnProperty.call(s6, p7))
              t6[p7] = s6[p7];
        }
        return t6;
      };
      __rest = function(s6, e6) {
        var t6 = {};
        for (var p7 in s6)
          if (Object.prototype.hasOwnProperty.call(s6, p7) && e6.indexOf(p7) < 0)
            t6[p7] = s6[p7];
        if (s6 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i6 = 0, p7 = Object.getOwnPropertySymbols(s6); i6 < p7.length; i6++) {
            if (e6.indexOf(p7[i6]) < 0 && Object.prototype.propertyIsEnumerable.call(s6, p7[i6]))
              t6[p7[i6]] = s6[p7[i6]];
          }
        return t6;
      };
      __decorate = function(decorators, target, key2, desc) {
        var c5 = arguments.length, r6 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d6;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r6 = Reflect.decorate(decorators, target, key2, desc);
        else
          for (var i6 = decorators.length - 1; i6 >= 0; i6--)
            if (d6 = decorators[i6])
              r6 = (c5 < 3 ? d6(r6) : c5 > 3 ? d6(target, key2, r6) : d6(target, key2)) || r6;
        return c5 > 3 && r6 && Object.defineProperty(target, key2, r6), r6;
      };
      __param = function(paramIndex, decorator) {
        return function(target, key2) {
          decorator(target, key2, paramIndex);
        };
      };
      __metadata = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter17 = function(thisArg, _arguments, P5, generator) {
        function adopt(value2) {
          return value2 instanceof P5 ? value2 : new P5(function(resolve) {
            resolve(value2);
          });
        }
        return new (P5 || (P5 = Promise))(function(resolve, reject) {
          function fulfilled(value2) {
            try {
              step(generator.next(value2));
            } catch (e6) {
              reject(e6);
            }
          }
          function rejected(value2) {
            try {
              step(generator["throw"](value2));
            } catch (e6) {
              reject(e6);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator = function(thisArg, body) {
        var _8 = { label: 0, sent: function() {
          if (t6[0] & 1)
            throw t6[1];
          return t6[1];
        }, trys: [], ops: [] }, f7, y5, t6, g7;
        return g7 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g7[Symbol.iterator] = function() {
          return this;
        }), g7;
        function verb(n4) {
          return function(v9) {
            return step([n4, v9]);
          };
        }
        function step(op) {
          if (f7)
            throw new TypeError("Generator is already executing.");
          while (_8)
            try {
              if (f7 = 1, y5 && (t6 = op[0] & 2 ? y5["return"] : op[0] ? y5["throw"] || ((t6 = y5["return"]) && t6.call(y5), 0) : y5.next) && !(t6 = t6.call(y5, op[1])).done)
                return t6;
              if (y5 = 0, t6)
                op = [op[0] & 2, t6.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t6 = op;
                  break;
                case 4:
                  _8.label++;
                  return { value: op[1], done: false };
                case 5:
                  _8.label++;
                  y5 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _8.ops.pop();
                  _8.trys.pop();
                  continue;
                default:
                  if (!(t6 = _8.trys, t6 = t6.length > 0 && t6[t6.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _8 = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t6 || op[1] > t6[0] && op[1] < t6[3])) {
                    _8.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _8.label < t6[1]) {
                    _8.label = t6[1];
                    t6 = op;
                    break;
                  }
                  if (t6 && _8.label < t6[2]) {
                    _8.label = t6[2];
                    _8.ops.push(op);
                    break;
                  }
                  if (t6[2])
                    _8.ops.pop();
                  _8.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _8);
            } catch (e6) {
              op = [6, e6];
              y5 = 0;
            } finally {
              f7 = t6 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __exportStar = function(m6, o6) {
        for (var p7 in m6)
          if (p7 !== "default" && !Object.prototype.hasOwnProperty.call(o6, p7))
            __createBinding(o6, m6, p7);
      };
      __createBinding = Object.create ? function(o6, m6, k8, k22) {
        if (k22 === void 0)
          k22 = k8;
        var desc = Object.getOwnPropertyDescriptor(m6, k8);
        if (!desc || ("get" in desc ? !m6.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m6[k8];
          } };
        }
        Object.defineProperty(o6, k22, desc);
      } : function(o6, m6, k8, k22) {
        if (k22 === void 0)
          k22 = k8;
        o6[k22] = m6[k8];
      };
      __values = function(o6) {
        var s6 = typeof Symbol === "function" && Symbol.iterator, m6 = s6 && o6[s6], i6 = 0;
        if (m6)
          return m6.call(o6);
        if (o6 && typeof o6.length === "number")
          return {
            next: function() {
              if (o6 && i6 >= o6.length)
                o6 = void 0;
              return { value: o6 && o6[i6++], done: !o6 };
            }
          };
        throw new TypeError(s6 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read = function(o6, n4) {
        var m6 = typeof Symbol === "function" && o6[Symbol.iterator];
        if (!m6)
          return o6;
        var i6 = m6.call(o6), r6, ar3 = [], e6;
        try {
          while ((n4 === void 0 || n4-- > 0) && !(r6 = i6.next()).done)
            ar3.push(r6.value);
        } catch (error) {
          e6 = { error };
        } finally {
          try {
            if (r6 && !r6.done && (m6 = i6["return"]))
              m6.call(i6);
          } finally {
            if (e6)
              throw e6.error;
          }
        }
        return ar3;
      };
      __spread = function() {
        for (var ar3 = [], i6 = 0; i6 < arguments.length; i6++)
          ar3 = ar3.concat(__read(arguments[i6]));
        return ar3;
      };
      __spreadArrays2 = function() {
        for (var s6 = 0, i6 = 0, il = arguments.length; i6 < il; i6++)
          s6 += arguments[i6].length;
        for (var r6 = Array(s6), k8 = 0, i6 = 0; i6 < il; i6++)
          for (var a5 = arguments[i6], j8 = 0, jl = a5.length; j8 < jl; j8++, k8++)
            r6[k8] = a5[j8];
        return r6;
      };
      __spreadArray2 = function(to2, from2, pack3) {
        if (pack3 || arguments.length === 2)
          for (var i6 = 0, l6 = from2.length, ar3; i6 < l6; i6++) {
            if (ar3 || !(i6 in from2)) {
              if (!ar3)
                ar3 = Array.prototype.slice.call(from2, 0, i6);
              ar3[i6] = from2[i6];
            }
          }
        return to2.concat(ar3 || Array.prototype.slice.call(from2));
      };
      __await = function(v9) {
        return this instanceof __await ? (this.v = v9, this) : new __await(v9);
      };
      __asyncGenerator = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g7 = generator.apply(thisArg, _arguments || []), i6, q8 = [];
        return i6 = {}, verb("next"), verb("throw"), verb("return"), i6[Symbol.asyncIterator] = function() {
          return this;
        }, i6;
        function verb(n4) {
          if (g7[n4])
            i6[n4] = function(v9) {
              return new Promise(function(a5, b4) {
                q8.push([n4, v9, a5, b4]) > 1 || resume(n4, v9);
              });
            };
        }
        function resume(n4, v9) {
          try {
            step(g7[n4](v9));
          } catch (e6) {
            settle(q8[0][3], e6);
          }
        }
        function step(r6) {
          r6.value instanceof __await ? Promise.resolve(r6.value.v).then(fulfill, reject) : settle(q8[0][2], r6);
        }
        function fulfill(value2) {
          resume("next", value2);
        }
        function reject(value2) {
          resume("throw", value2);
        }
        function settle(f7, v9) {
          if (f7(v9), q8.shift(), q8.length)
            resume(q8[0][0], q8[0][1]);
        }
      };
      __asyncDelegator = function(o6) {
        var i6, p7;
        return i6 = {}, verb("next"), verb("throw", function(e6) {
          throw e6;
        }), verb("return"), i6[Symbol.iterator] = function() {
          return this;
        }, i6;
        function verb(n4, f7) {
          i6[n4] = o6[n4] ? function(v9) {
            return (p7 = !p7) ? { value: __await(o6[n4](v9)), done: n4 === "return" } : f7 ? f7(v9) : v9;
          } : f7;
        }
      };
      __asyncValues = function(o6) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m6 = o6[Symbol.asyncIterator], i6;
        return m6 ? m6.call(o6) : (o6 = typeof __values === "function" ? __values(o6) : o6[Symbol.iterator](), i6 = {}, verb("next"), verb("throw"), verb("return"), i6[Symbol.asyncIterator] = function() {
          return this;
        }, i6);
        function verb(n4) {
          i6[n4] = o6[n4] && function(v9) {
            return new Promise(function(resolve, reject) {
              v9 = o6[n4](v9), settle(resolve, reject, v9.done, v9.value);
            });
          };
        }
        function settle(resolve, reject, d6, v9) {
          Promise.resolve(v9).then(function(v10) {
            resolve({ value: v10, done: d6 });
          }, reject);
        }
      };
      __makeTemplateObject = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      var __setModuleDefault = Object.create ? function(o6, v9) {
        Object.defineProperty(o6, "default", { enumerable: true, value: v9 });
      } : function(o6, v9) {
        o6["default"] = v9;
      };
      __importStar = function(mod2) {
        if (mod2 && mod2.__esModule)
          return mod2;
        var result = {};
        if (mod2 != null) {
          for (var k8 in mod2)
            if (k8 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k8))
              __createBinding(result, mod2, k8);
        }
        __setModuleDefault(result, mod2);
        return result;
      };
      __importDefault = function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
      };
      __classPrivateFieldGet = function(receiver, state, kind, f7) {
        if (kind === "a" && !f7)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f7 : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f7 : kind === "a" ? f7.call(receiver) : f7 ? f7.value : state.get(receiver);
      };
      __classPrivateFieldSet = function(receiver, state, value2, kind, f7) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f7)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f7 : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f7.call(receiver, value2) : f7 ? f7.value = value2 : state.set(receiver, value2), value2;
      };
      __classPrivateFieldIn = function(state, receiver) {
        if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
          throw new TypeError("Cannot use 'in' operator on non-object");
        return typeof state === "function" ? receiver === state : state.has(receiver);
      };
      exporter("__extends", __extends2);
      exporter("__assign", __assign);
      exporter("__rest", __rest);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter17);
      exporter("__generator", __generator);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays2);
      exporter("__spreadArray", __spreadArray2);
      exporter("__await", __await);
      exporter("__asyncGenerator", __asyncGenerator);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet);
      exporter("__classPrivateFieldIn", __classPrivateFieldIn);
    });
  }
});

// node_modules/async-mutex/lib/Semaphore.js
var require_Semaphore = __commonJS({
  "node_modules/async-mutex/lib/Semaphore.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var Semaphore = function() {
      function Semaphore2(_maxConcurrency) {
        this._maxConcurrency = _maxConcurrency;
        this._queue = [];
        if (_maxConcurrency <= 0) {
          throw new Error("semaphore must be initialized to a positive value");
        }
        this._value = _maxConcurrency;
      }
      Semaphore2.prototype.acquire = function() {
        var _this = this;
        var locked = this.isLocked();
        var ticket = new Promise(function(r6) {
          return _this._queue.push(r6);
        });
        if (!locked)
          this._dispatch();
        return ticket;
      };
      Semaphore2.prototype.runExclusive = function(callback) {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          var _a2, value2, release;
          return tslib_1.__generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, this.acquire()];
              case 1:
                _a2 = _b.sent(), value2 = _a2[0], release = _a2[1];
                _b.label = 2;
              case 2:
                _b.trys.push([2, , 4, 5]);
                return [4, callback(value2)];
              case 3:
                return [2, _b.sent()];
              case 4:
                release();
                return [7];
              case 5:
                return [2];
            }
          });
        });
      };
      Semaphore2.prototype.isLocked = function() {
        return this._value <= 0;
      };
      Semaphore2.prototype.release = function() {
        if (this._maxConcurrency > 1) {
          throw new Error("this method is unavailabel on semaphores with concurrency > 1; use the scoped release returned by acquire instead");
        }
        if (this._currentReleaser) {
          var releaser = this._currentReleaser;
          this._currentReleaser = void 0;
          releaser();
        }
      };
      Semaphore2.prototype._dispatch = function() {
        var _this = this;
        var nextConsumer = this._queue.shift();
        if (!nextConsumer)
          return;
        var released = false;
        this._currentReleaser = function() {
          if (released)
            return;
          released = true;
          _this._value++;
          _this._dispatch();
        };
        nextConsumer([this._value--, this._currentReleaser]);
      };
      return Semaphore2;
    }();
    exports2.default = Semaphore;
  }
});

// node_modules/async-mutex/lib/Mutex.js
var require_Mutex = __commonJS({
  "node_modules/async-mutex/lib/Mutex.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var Semaphore_1 = require_Semaphore();
    var Mutex = function() {
      function Mutex2() {
        this._semaphore = new Semaphore_1.default(1);
      }
      Mutex2.prototype.acquire = function() {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          var _a2, releaser;
          return tslib_1.__generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, this._semaphore.acquire()];
              case 1:
                _a2 = _b.sent(), releaser = _a2[1];
                return [2, releaser];
            }
          });
        });
      };
      Mutex2.prototype.runExclusive = function(callback) {
        return this._semaphore.runExclusive(function() {
          return callback();
        });
      };
      Mutex2.prototype.isLocked = function() {
        return this._semaphore.isLocked();
      };
      Mutex2.prototype.release = function() {
        this._semaphore.release();
      };
      return Mutex2;
    }();
    exports2.default = Mutex;
  }
});

// node_modules/async-mutex/lib/withTimeout.js
var require_withTimeout = __commonJS({
  "node_modules/async-mutex/lib/withTimeout.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.withTimeout = void 0;
    var tslib_1 = require_tslib();
    function withTimeout(sync, timeout2, timeoutError) {
      var _this = this;
      if (timeoutError === void 0) {
        timeoutError = new Error("timeout");
      }
      return {
        acquire: function() {
          return new Promise(function(resolve, reject) {
            return tslib_1.__awaiter(_this, void 0, void 0, function() {
              var isTimeout, ticket, release;
              return tslib_1.__generator(this, function(_a2) {
                switch (_a2.label) {
                  case 0:
                    isTimeout = false;
                    setTimeout(function() {
                      isTimeout = true;
                      reject(timeoutError);
                    }, timeout2);
                    return [4, sync.acquire()];
                  case 1:
                    ticket = _a2.sent();
                    if (isTimeout) {
                      release = Array.isArray(ticket) ? ticket[1] : ticket;
                      release();
                    } else {
                      resolve(ticket);
                    }
                    return [2];
                }
              });
            });
          });
        },
        runExclusive: function(callback) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var release, ticket;
            return tslib_1.__generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  release = function() {
                    return void 0;
                  };
                  _a2.label = 1;
                case 1:
                  _a2.trys.push([1, , 7, 8]);
                  return [4, this.acquire()];
                case 2:
                  ticket = _a2.sent();
                  if (!Array.isArray(ticket))
                    return [3, 4];
                  release = ticket[1];
                  return [4, callback(ticket[0])];
                case 3:
                  return [2, _a2.sent()];
                case 4:
                  release = ticket;
                  return [4, callback()];
                case 5:
                  return [2, _a2.sent()];
                case 6:
                  return [3, 8];
                case 7:
                  release();
                  return [7];
                case 8:
                  return [2];
              }
            });
          });
        },
        release: function() {
          sync.release();
        },
        isLocked: function() {
          return sync.isLocked();
        }
      };
    }
    exports2.withTimeout = withTimeout;
  }
});

// node_modules/async-mutex/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/async-mutex/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.withTimeout = exports2.Semaphore = exports2.Mutex = void 0;
    var Mutex_1 = require_Mutex();
    Object.defineProperty(exports2, "Mutex", { enumerable: true, get: function() {
      return Mutex_1.default;
    } });
    var Semaphore_1 = require_Semaphore();
    Object.defineProperty(exports2, "Semaphore", { enumerable: true, get: function() {
      return Semaphore_1.default;
    } });
    var withTimeout_1 = require_withTimeout();
    Object.defineProperty(exports2, "withTimeout", { enumerable: true, get: function() {
      return withTimeout_1.withTimeout;
    } });
  }
});

// node_modules/eth-json-rpc-filters/node_modules/pify/index.js
var require_pify2 = __commonJS({
  "node_modules/eth-json-rpc-filters/node_modules/pify/index.js"(exports2, module2) {
    "use strict";
    var processFn = (fn2, options, proxy, unwrapped) => function(...arguments_) {
      const P5 = options.promiseModule;
      return new P5((resolve, reject) => {
        if (options.multiArgs) {
          arguments_.push((...result) => {
            if (options.errorFirst) {
              if (result[0]) {
                reject(result);
              } else {
                result.shift();
                resolve(result);
              }
            } else {
              resolve(result);
            }
          });
        } else if (options.errorFirst) {
          arguments_.push((error, result) => {
            if (error) {
              reject(error);
            } else {
              resolve(result);
            }
          });
        } else {
          arguments_.push(resolve);
        }
        const self2 = this === proxy ? unwrapped : this;
        Reflect.apply(fn2, self2, arguments_);
      });
    };
    var filterCache = /* @__PURE__ */ new WeakMap();
    module2.exports = (input, options) => {
      options = {
        exclude: [/.+(?:Sync|Stream)$/],
        errorFirst: true,
        promiseModule: Promise,
        ...options
      };
      const objectType2 = typeof input;
      if (!(input !== null && (objectType2 === "object" || objectType2 === "function"))) {
        throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${input === null ? "null" : objectType2}\``);
      }
      const filter2 = (target, key2) => {
        let cached = filterCache.get(target);
        if (!cached) {
          cached = {};
          filterCache.set(target, cached);
        }
        if (key2 in cached) {
          return cached[key2];
        }
        const match = (pattern) => typeof pattern === "string" || typeof key2 === "symbol" ? key2 === pattern : pattern.test(key2);
        const desc = Reflect.getOwnPropertyDescriptor(target, key2);
        const writableOrConfigurableOwn = desc === void 0 || desc.writable || desc.configurable;
        const included = options.include ? options.include.some(match) : !options.exclude.some(match);
        const shouldFilter = included && writableOrConfigurableOwn;
        cached[key2] = shouldFilter;
        return shouldFilter;
      };
      const cache = /* @__PURE__ */ new WeakMap();
      const proxy = new Proxy(input, {
        apply(target, thisArg, args) {
          const cached = cache.get(target);
          if (cached) {
            return Reflect.apply(cached, thisArg, args);
          }
          const pified = options.excludeMain ? target : processFn(target, options, proxy, target);
          cache.set(target, pified);
          return Reflect.apply(pified, thisArg, args);
        },
        get(target, key2) {
          const property = target[key2];
          if (!filter2(target, key2) || property === Function.prototype[key2]) {
            return property;
          }
          const cached = cache.get(property);
          if (cached) {
            return cached;
          }
          if (typeof property === "function") {
            const pified = processFn(property, options, proxy, target);
            cache.set(property, pified);
            return pified;
          }
          return property;
        }
      });
      return proxy;
    };
  }
});

// node_modules/eth-json-rpc-filters/base-filter.js
var require_base_filter = __commonJS({
  "node_modules/eth-json-rpc-filters/base-filter.js"(exports2, module2) {
    var SafeEventEmitter = require_safe_event_emitter().default;
    var BaseFilter = class extends SafeEventEmitter {
      constructor() {
        super();
        this.updates = [];
      }
      async initialize() {
      }
      async update() {
        throw new Error("BaseFilter - no update method specified");
      }
      addResults(newResults) {
        this.updates = this.updates.concat(newResults);
        newResults.forEach((result) => this.emit("update", result));
      }
      addInitialResults(newResults) {
      }
      getChangesAndClear() {
        const updates = this.updates;
        this.updates = [];
        return updates;
      }
    };
    module2.exports = BaseFilter;
  }
});

// node_modules/eth-json-rpc-filters/base-filter-history.js
var require_base_filter_history = __commonJS({
  "node_modules/eth-json-rpc-filters/base-filter-history.js"(exports2, module2) {
    var BaseFilter = require_base_filter();
    var BaseFilterWithHistory = class extends BaseFilter {
      constructor() {
        super();
        this.allResults = [];
      }
      async update() {
        throw new Error("BaseFilterWithHistory - no update method specified");
      }
      addResults(newResults) {
        this.allResults = this.allResults.concat(newResults);
        super.addResults(newResults);
      }
      addInitialResults(newResults) {
        this.allResults = this.allResults.concat(newResults);
        super.addInitialResults(newResults);
      }
      getAllResults() {
        return this.allResults;
      }
    };
    module2.exports = BaseFilterWithHistory;
  }
});

// node_modules/eth-json-rpc-filters/hexUtils.js
var require_hexUtils = __commonJS({
  "node_modules/eth-json-rpc-filters/hexUtils.js"(exports2, module2) {
    module2.exports = {
      minBlockRef,
      maxBlockRef,
      sortBlockRefs,
      bnToHex,
      blockRefIsNumber,
      hexToInt,
      incrementHexInt,
      intToHex,
      unsafeRandomBytes
    };
    function minBlockRef(...refs) {
      const sortedRefs = sortBlockRefs(refs);
      return sortedRefs[0];
    }
    function maxBlockRef(...refs) {
      const sortedRefs = sortBlockRefs(refs);
      return sortedRefs[sortedRefs.length - 1];
    }
    function sortBlockRefs(refs) {
      return refs.sort((refA, refB) => {
        if (refA === "latest" || refB === "earliest")
          return 1;
        if (refB === "latest" || refA === "earliest")
          return -1;
        return hexToInt(refA) - hexToInt(refB);
      });
    }
    function bnToHex(bn2) {
      return "0x" + bn2.toString(16);
    }
    function blockRefIsNumber(blockRef) {
      return blockRef && !["earliest", "latest", "pending"].includes(blockRef);
    }
    function hexToInt(hexString) {
      if (hexString === void 0 || hexString === null)
        return hexString;
      return Number.parseInt(hexString, 16);
    }
    function incrementHexInt(hexString) {
      if (hexString === void 0 || hexString === null)
        return hexString;
      const value2 = hexToInt(hexString);
      return intToHex(value2 + 1);
    }
    function intToHex(int) {
      if (int === void 0 || int === null)
        return int;
      let hexString = int.toString(16);
      const needsLeftPad = hexString.length % 2;
      if (needsLeftPad)
        hexString = "0" + hexString;
      return "0x" + hexString;
    }
    function unsafeRandomBytes(byteCount) {
      let result = "0x";
      for (let i6 = 0; i6 < byteCount; i6++) {
        result += unsafeRandomNibble();
        result += unsafeRandomNibble();
      }
      return result;
    }
    function unsafeRandomNibble() {
      return Math.floor(Math.random() * 16).toString(16);
    }
  }
});

// node_modules/eth-json-rpc-filters/log-filter.js
var require_log_filter = __commonJS({
  "node_modules/eth-json-rpc-filters/log-filter.js"(exports2, module2) {
    var EthQuery = require_eth_query();
    var pify = require_pify2();
    var BaseFilterWithHistory = require_base_filter_history();
    var { bnToHex, hexToInt, incrementHexInt, minBlockRef, blockRefIsNumber } = require_hexUtils();
    var LogFilter = class extends BaseFilterWithHistory {
      constructor({ provider, params }) {
        super();
        this.type = "log";
        this.ethQuery = new EthQuery(provider);
        this.params = Object.assign({
          fromBlock: "latest",
          toBlock: "latest",
          address: void 0,
          topics: []
        }, params);
        if (this.params.address) {
          if (!Array.isArray(this.params.address)) {
            this.params.address = [this.params.address];
          }
          this.params.address = this.params.address.map((address) => address.toLowerCase());
        }
      }
      async initialize({ currentBlock }) {
        let fromBlock = this.params.fromBlock;
        if (["latest", "pending"].includes(fromBlock))
          fromBlock = currentBlock;
        if ("earliest" === fromBlock)
          fromBlock = "0x0";
        this.params.fromBlock = fromBlock;
        const toBlock = minBlockRef(this.params.toBlock, currentBlock);
        const params = Object.assign({}, this.params, { toBlock });
        const newLogs = await this._fetchLogs(params);
        this.addInitialResults(newLogs);
      }
      async update({ oldBlock, newBlock }) {
        const toBlock = newBlock;
        let fromBlock;
        if (oldBlock) {
          fromBlock = incrementHexInt(oldBlock);
        } else {
          fromBlock = newBlock;
        }
        const params = Object.assign({}, this.params, { fromBlock, toBlock });
        const newLogs = await this._fetchLogs(params);
        const matchingLogs = newLogs.filter((log) => this.matchLog(log));
        this.addResults(matchingLogs);
      }
      async _fetchLogs(params) {
        const newLogs = await pify((cb) => this.ethQuery.getLogs(params, cb))();
        return newLogs;
      }
      matchLog(log) {
        if (hexToInt(this.params.fromBlock) >= hexToInt(log.blockNumber))
          return false;
        if (blockRefIsNumber(this.params.toBlock) && hexToInt(this.params.toBlock) <= hexToInt(log.blockNumber))
          return false;
        const normalizedLogAddress = log.address && log.address.toLowerCase();
        if (this.params.address && normalizedLogAddress && !this.params.address.includes(normalizedLogAddress))
          return false;
        const topicsMatch = this.params.topics.every((topicPattern, index) => {
          let logTopic = log.topics[index];
          if (!logTopic)
            return false;
          logTopic = logTopic.toLowerCase();
          let subtopicsToMatch = Array.isArray(topicPattern) ? topicPattern : [topicPattern];
          const subtopicsIncludeWildcard = subtopicsToMatch.includes(null);
          if (subtopicsIncludeWildcard)
            return true;
          subtopicsToMatch = subtopicsToMatch.map((topic) => topic.toLowerCase());
          const topicDoesMatch = subtopicsToMatch.includes(logTopic);
          return topicDoesMatch;
        });
        return topicsMatch;
      }
    };
    module2.exports = LogFilter;
  }
});

// node_modules/eth-json-rpc-filters/getBlocksForRange.js
var require_getBlocksForRange = __commonJS({
  "node_modules/eth-json-rpc-filters/getBlocksForRange.js"(exports2, module2) {
    module2.exports = getBlocksForRange;
    async function getBlocksForRange({ provider, fromBlock, toBlock }) {
      if (!fromBlock)
        fromBlock = toBlock;
      const fromBlockNumber = hexToInt(fromBlock);
      const toBlockNumber = hexToInt(toBlock);
      const blockCountToQuery = toBlockNumber - fromBlockNumber + 1;
      const missingBlockNumbers = Array(blockCountToQuery).fill().map((_8, index) => fromBlockNumber + index).map(intToHex);
      const blockBodies = await Promise.all(
        missingBlockNumbers.map((blockNum) => query(provider, "eth_getBlockByNumber", [blockNum, false]))
      );
      return blockBodies;
    }
    function hexToInt(hexString) {
      if (hexString === void 0 || hexString === null)
        return hexString;
      return Number.parseInt(hexString, 16);
    }
    function intToHex(int) {
      if (int === void 0 || int === null)
        return int;
      const hexString = int.toString(16);
      return "0x" + hexString;
    }
    function query(provider, method2, params) {
      return new Promise((resolve, reject) => {
        provider.sendAsync({ id: 1, jsonrpc: "2.0", method: method2, params }, (err, res) => {
          if (err)
            return reject(err);
          resolve(res.result);
        });
      });
    }
  }
});

// node_modules/eth-json-rpc-filters/block-filter.js
var require_block_filter = __commonJS({
  "node_modules/eth-json-rpc-filters/block-filter.js"(exports2, module2) {
    var BaseFilter = require_base_filter();
    var getBlocksForRange = require_getBlocksForRange();
    var { incrementHexInt } = require_hexUtils();
    var BlockFilter = class extends BaseFilter {
      constructor({ provider, params }) {
        super();
        this.type = "block";
        this.provider = provider;
      }
      async update({ oldBlock, newBlock }) {
        const toBlock = newBlock;
        const fromBlock = incrementHexInt(oldBlock);
        const blockBodies = await getBlocksForRange({ provider: this.provider, fromBlock, toBlock });
        const blockHashes = blockBodies.map((block) => block.hash);
        this.addResults(blockHashes);
      }
    };
    module2.exports = BlockFilter;
  }
});

// node_modules/eth-json-rpc-filters/tx-filter.js
var require_tx_filter = __commonJS({
  "node_modules/eth-json-rpc-filters/tx-filter.js"(exports2, module2) {
    var BaseFilter = require_base_filter();
    var getBlocksForRange = require_getBlocksForRange();
    var { incrementHexInt } = require_hexUtils();
    var TxFilter = class extends BaseFilter {
      constructor({ provider }) {
        super();
        this.type = "tx";
        this.provider = provider;
      }
      async update({ oldBlock }) {
        const toBlock = oldBlock;
        const fromBlock = incrementHexInt(oldBlock);
        const blocks2 = await getBlocksForRange({ provider: this.provider, fromBlock, toBlock });
        const blockTxHashes = [];
        for (const block of blocks2) {
          blockTxHashes.push(...block.transactions);
        }
        this.addResults(blockTxHashes);
      }
    };
    module2.exports = TxFilter;
  }
});

// node_modules/eth-json-rpc-filters/index.js
var require_eth_json_rpc_filters = __commonJS({
  "node_modules/eth-json-rpc-filters/index.js"(exports2, module2) {
    var Mutex = require_lib2().Mutex;
    var { createAsyncMiddleware } = require_dist3();
    var createJsonRpcMiddleware = require_scaffold();
    var LogFilter = require_log_filter();
    var BlockFilter = require_block_filter();
    var TxFilter = require_tx_filter();
    var { intToHex, hexToInt } = require_hexUtils();
    module2.exports = createEthFilterMiddleware;
    function createEthFilterMiddleware({ blockTracker, provider }) {
      let filterIndex = 0;
      let filters = {};
      const mutex = new Mutex();
      const waitForFree = mutexMiddlewareWrapper({ mutex });
      const middleware = createJsonRpcMiddleware({
        eth_newFilter: waitForFree(toFilterCreationMiddleware(newLogFilter)),
        eth_newBlockFilter: waitForFree(toFilterCreationMiddleware(newBlockFilter)),
        eth_newPendingTransactionFilter: waitForFree(toFilterCreationMiddleware(newPendingTransactionFilter)),
        eth_uninstallFilter: waitForFree(toAsyncRpcMiddleware(uninstallFilterHandler)),
        eth_getFilterChanges: waitForFree(toAsyncRpcMiddleware(getFilterChanges)),
        eth_getFilterLogs: waitForFree(toAsyncRpcMiddleware(getFilterLogs))
      });
      const filterUpdater = async ({ oldBlock, newBlock }) => {
        if (filters.length === 0)
          return;
        const releaseLock = await mutex.acquire();
        try {
          await Promise.all(objValues(filters).map(async (filter2) => {
            try {
              await filter2.update({ oldBlock, newBlock });
            } catch (err) {
              console.error(err);
            }
          }));
        } catch (err) {
          console.error(err);
        }
        releaseLock();
      };
      middleware.newLogFilter = newLogFilter;
      middleware.newBlockFilter = newBlockFilter;
      middleware.newPendingTransactionFilter = newPendingTransactionFilter;
      middleware.uninstallFilter = uninstallFilterHandler;
      middleware.getFilterChanges = getFilterChanges;
      middleware.getFilterLogs = getFilterLogs;
      middleware.destroy = () => {
        uninstallAllFilters();
      };
      return middleware;
      async function newLogFilter(params) {
        const filter2 = new LogFilter({ provider, params });
        const filterIndex2 = await installFilter(filter2);
        return filter2;
      }
      async function newBlockFilter() {
        const filter2 = new BlockFilter({ provider });
        const filterIndex2 = await installFilter(filter2);
        return filter2;
      }
      async function newPendingTransactionFilter() {
        const filter2 = new TxFilter({ provider });
        const filterIndex2 = await installFilter(filter2);
        return filter2;
      }
      async function getFilterChanges(filterIndexHex) {
        const filterIndex2 = hexToInt(filterIndexHex);
        const filter2 = filters[filterIndex2];
        if (!filter2) {
          throw new Error(`No filter for index "${filterIndex2}"`);
        }
        const results2 = filter2.getChangesAndClear();
        return results2;
      }
      async function getFilterLogs(filterIndexHex) {
        const filterIndex2 = hexToInt(filterIndexHex);
        const filter2 = filters[filterIndex2];
        if (!filter2) {
          throw new Error(`No filter for index "${filterIndex2}"`);
        }
        if (filter2.type === "log") {
          results = filter2.getAllResults();
        } else {
          results = [];
        }
        return results;
      }
      async function uninstallFilterHandler(filterIndexHex) {
        const filterIndex2 = hexToInt(filterIndexHex);
        const filter2 = filters[filterIndex2];
        const result = Boolean(filter2);
        if (result) {
          await uninstallFilter(filterIndex2);
        }
        return result;
      }
      async function installFilter(filter2) {
        const prevFilterCount = objValues(filters).length;
        const currentBlock = await blockTracker.getLatestBlock();
        await filter2.initialize({ currentBlock });
        filterIndex++;
        filters[filterIndex] = filter2;
        filter2.id = filterIndex;
        filter2.idHex = intToHex(filterIndex);
        const newFilterCount = objValues(filters).length;
        updateBlockTrackerSubs({ prevFilterCount, newFilterCount });
        return filterIndex;
      }
      async function uninstallFilter(filterIndex2) {
        const prevFilterCount = objValues(filters).length;
        delete filters[filterIndex2];
        const newFilterCount = objValues(filters).length;
        updateBlockTrackerSubs({ prevFilterCount, newFilterCount });
      }
      async function uninstallAllFilters() {
        const prevFilterCount = objValues(filters).length;
        filters = {};
        updateBlockTrackerSubs({ prevFilterCount, newFilterCount: 0 });
      }
      function updateBlockTrackerSubs({ prevFilterCount, newFilterCount }) {
        if (prevFilterCount === 0 && newFilterCount > 0) {
          blockTracker.on("sync", filterUpdater);
          return;
        }
        if (prevFilterCount > 0 && newFilterCount === 0) {
          blockTracker.removeListener("sync", filterUpdater);
          return;
        }
      }
    }
    function toFilterCreationMiddleware(createFilterFn) {
      return toAsyncRpcMiddleware(async (...args) => {
        const filter2 = await createFilterFn(...args);
        const result = intToHex(filter2.id);
        return result;
      });
    }
    function toAsyncRpcMiddleware(asyncFn) {
      return createAsyncMiddleware(async (req, res) => {
        const result = await asyncFn.apply(null, req.params);
        res.result = result;
      });
    }
    function mutexMiddlewareWrapper({ mutex }) {
      return (middleware) => {
        return async (req, res, next, end) => {
          const releaseLock = await mutex.acquire();
          releaseLock();
          middleware(req, res, next, end);
        };
      };
    }
    function objValues(obj, fn2) {
      const values = [];
      for (let key2 in obj) {
        values.push(obj[key2]);
      }
      return values;
    }
  }
});

// node_modules/eth-json-rpc-filters/subscriptionManager.js
var require_subscriptionManager = __commonJS({
  "node_modules/eth-json-rpc-filters/subscriptionManager.js"(exports2, module2) {
    var SafeEventEmitter = require_safe_event_emitter().default;
    var createScaffoldMiddleware = require_scaffold();
    var { createAsyncMiddleware } = require_dist3();
    var createFilterMiddleware = require_eth_json_rpc_filters();
    var { unsafeRandomBytes, incrementHexInt } = require_hexUtils();
    var getBlocksForRange = require_getBlocksForRange();
    module2.exports = createSubscriptionMiddleware;
    function createSubscriptionMiddleware({ blockTracker, provider }) {
      const subscriptions = {};
      const filterManager = createFilterMiddleware({ blockTracker, provider });
      let isDestroyed = false;
      const events = new SafeEventEmitter();
      const middleware = createScaffoldMiddleware({
        eth_subscribe: createAsyncMiddleware(subscribe),
        eth_unsubscribe: createAsyncMiddleware(unsubscribe)
      });
      middleware.destroy = destroy;
      return { events, middleware };
      async function subscribe(req, res) {
        if (isDestroyed)
          throw new Error(
            "SubscriptionManager - attempting to use after destroying"
          );
        const subscriptionType = req.params[0];
        const subId = unsafeRandomBytes(16);
        let sub;
        switch (subscriptionType) {
          case "newHeads":
            sub = createSubNewHeads({ subId });
            break;
          case "logs":
            const filterParams = req.params[1];
            const filter2 = await filterManager.newLogFilter(filterParams);
            sub = createSubFromFilter({ subId, filter: filter2 });
            break;
          default:
            throw new Error(`SubscriptionManager - unsupported subscription type "${subscriptionType}"`);
        }
        subscriptions[subId] = sub;
        res.result = subId;
        return;
        function createSubNewHeads({ subId: subId2 }) {
          const sub2 = {
            type: subscriptionType,
            destroy: async () => {
              blockTracker.removeListener("sync", sub2.update);
            },
            update: async ({ oldBlock, newBlock }) => {
              const toBlock = newBlock;
              const fromBlock = incrementHexInt(oldBlock);
              const rawBlocks = await getBlocksForRange({ provider, fromBlock, toBlock });
              const results2 = rawBlocks.map(normalizeBlock);
              results2.forEach((value2) => {
                _emitSubscriptionResult(subId2, value2);
              });
            }
          };
          blockTracker.on("sync", sub2.update);
          return sub2;
        }
        function createSubFromFilter({ subId: subId2, filter: filter2 }) {
          filter2.on("update", (result) => _emitSubscriptionResult(subId2, result));
          const sub2 = {
            type: subscriptionType,
            destroy: async () => {
              return await filterManager.uninstallFilter(filter2.idHex);
            }
          };
          return sub2;
        }
      }
      async function unsubscribe(req, res) {
        if (isDestroyed)
          throw new Error(
            "SubscriptionManager - attempting to use after destroying"
          );
        const id2 = req.params[0];
        const subscription = subscriptions[id2];
        if (!subscription) {
          res.result = false;
          return;
        }
        delete subscriptions[id2];
        await subscription.destroy();
        res.result = true;
      }
      function _emitSubscriptionResult(filterIdHex, value2) {
        events.emit("notification", {
          jsonrpc: "2.0",
          method: "eth_subscription",
          params: {
            subscription: filterIdHex,
            result: value2
          }
        });
      }
      function destroy() {
        events.removeAllListeners();
        for (const id2 in subscriptions) {
          subscriptions[id2].destroy();
          delete subscriptions[id2];
        }
        isDestroyed = true;
      }
    }
    function normalizeBlock(block) {
      return {
        hash: block.hash,
        parentHash: block.parentHash,
        sha3Uncles: block.sha3Uncles,
        miner: block.miner,
        stateRoot: block.stateRoot,
        transactionsRoot: block.transactionsRoot,
        receiptsRoot: block.receiptsRoot,
        logsBloom: block.logsBloom,
        difficulty: block.difficulty,
        number: block.number,
        gasLimit: block.gasLimit,
        gasUsed: block.gasUsed,
        nonce: block.nonce,
        mixHash: block.mixHash,
        timestamp: block.timestamp,
        extraData: block.extraData
      };
    }
  }
});

// node_modules/@coinbase/wallet-sdk/dist/provider/SubscriptionManager.js
var require_SubscriptionManager = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/provider/SubscriptionManager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SubscriptionManager = void 0;
    var PollingBlockTracker = require_polling();
    var createSubscriptionManager = require_subscriptionManager();
    var noop3 = () => {
    };
    var SubscriptionManager = class {
      constructor(provider) {
        const blockTracker = new PollingBlockTracker({
          provider,
          pollingInterval: 15 * 1e3,
          setSkipCacheFlag: true
        });
        const { events, middleware } = createSubscriptionManager({
          blockTracker,
          provider
        });
        this.events = events;
        this.subscriptionMiddleware = middleware;
      }
      async handleRequest(request) {
        const result = {};
        await this.subscriptionMiddleware(request, result, noop3, noop3);
        return result;
      }
      destroy() {
        this.subscriptionMiddleware.destroy();
      }
    };
    exports2.SubscriptionManager = SubscriptionManager;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/provider/CoinbaseWalletProvider.js
var require_CoinbaseWalletProvider = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/provider/CoinbaseWalletProvider.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CoinbaseWalletProvider = void 0;
    var safe_event_emitter_1 = __importDefault(require_safe_event_emitter());
    var bn_js_1 = __importDefault(require_bn3());
    var eth_rpc_errors_1 = require_dist2();
    var EventListener_1 = require_EventListener();
    var Session_1 = require_Session();
    var WalletSDKRelayAbstract_1 = require_WalletSDKRelayAbstract();
    var util_1 = require_util3();
    var eth_eip712_util_1 = __importDefault(require_eth_eip712_util());
    var FilterPolyfill_1 = require_FilterPolyfill();
    var JSONRPC_1 = require_JSONRPC();
    var SubscriptionManager_1 = require_SubscriptionManager();
    var DEFAULT_CHAIN_ID_KEY = "DefaultChainId";
    var DEFAULT_JSON_RPC_URL = "DefaultJsonRpcUrl";
    var HAS_CHAIN_BEEN_SWITCHED_KEY = "HasChainBeenSwitched";
    var HAS_CHAIN_OVERRIDDEN_FROM_RELAY = "HasChainOverriddenFromRelay";
    var CoinbaseWalletProvider = class extends safe_event_emitter_1.default {
      constructor(options) {
        var _a2, _b;
        super();
        this._filterPolyfill = new FilterPolyfill_1.FilterPolyfill(this);
        this._subscriptionManager = new SubscriptionManager_1.SubscriptionManager(this);
        this._relay = null;
        this._addresses = [];
        this.hasMadeFirstChainChangedEmission = false;
        this._send = this.send.bind(this);
        this._sendAsync = this.sendAsync.bind(this);
        this.setProviderInfo = this.setProviderInfo.bind(this);
        this.updateProviderInfo = this.updateProviderInfo.bind(this);
        this.getChainId = this.getChainId.bind(this);
        this.setAppInfo = this.setAppInfo.bind(this);
        this.enable = this.enable.bind(this);
        this.close = this.close.bind(this);
        this.send = this.send.bind(this);
        this.sendAsync = this.sendAsync.bind(this);
        this.request = this.request.bind(this);
        this._setAddresses = this._setAddresses.bind(this);
        this.scanQRCode = this.scanQRCode.bind(this);
        this.genericRequest = this.genericRequest.bind(this);
        this._jsonRpcUrlFromOpts = options.jsonRpcUrl;
        this._overrideIsMetaMask = options.overrideIsMetaMask;
        this._relayProvider = options.relayProvider;
        this._storage = options.storage;
        this._relayEventManager = options.relayEventManager;
        this._eventListener = options.eventListener;
        this.isCoinbaseWallet = (_a2 = options.overrideIsCoinbaseWallet) !== null && _a2 !== void 0 ? _a2 : true;
        this.isCoinbaseBrowser = (_b = options.overrideIsCoinbaseBrowser) !== null && _b !== void 0 ? _b : false;
        this.qrUrl = options.qrUrl;
        this.supportsAddressSwitching = options.supportsAddressSwitching;
        const chainId = this.getChainId();
        const chainIdStr = (0, util_1.prepend0x)(chainId.toString(16));
        this.emit("connect", { chainIdStr });
        const cachedAddresses = this._storage.getItem(WalletSDKRelayAbstract_1.LOCAL_STORAGE_ADDRESSES_KEY);
        if (cachedAddresses) {
          const addresses = cachedAddresses.split(" ");
          if (addresses[0] !== "") {
            this._addresses = addresses.map((address) => (0, util_1.ensureAddressString)(address));
            this.emit("accountsChanged", addresses);
          }
        }
        this._subscriptionManager.events.on("notification", (notification) => {
          this.emit("message", {
            type: notification.method,
            data: notification.params
          });
        });
        if (this._addresses.length > 0) {
          void this.initializeRelay();
        }
        window.addEventListener("message", (event) => {
          var _a3;
          if (event.data.type !== "walletLinkMessage")
            return;
          if (event.data.data.action === "defaultChainChanged") {
            const _chainId = event.data.data.chainId;
            const jsonRpcUrl = (_a3 = event.data.data.jsonRpcUrl) !== null && _a3 !== void 0 ? _a3 : this.jsonRpcUrl;
            this.updateProviderInfo(jsonRpcUrl, Number(_chainId), true);
          }
        });
      }
      get selectedAddress() {
        return this._addresses[0] || void 0;
      }
      get networkVersion() {
        return this.getChainId().toString(10);
      }
      get chainId() {
        return (0, util_1.prepend0x)(this.getChainId().toString(16));
      }
      get isWalletLink() {
        return true;
      }
      get isMetaMask() {
        return this._overrideIsMetaMask;
      }
      get host() {
        return this.jsonRpcUrl;
      }
      get connected() {
        return true;
      }
      isConnected() {
        return true;
      }
      get jsonRpcUrl() {
        var _a2;
        return (_a2 = this._storage.getItem(DEFAULT_JSON_RPC_URL)) !== null && _a2 !== void 0 ? _a2 : this._jsonRpcUrlFromOpts;
      }
      set jsonRpcUrl(value2) {
        this._storage.setItem(DEFAULT_JSON_RPC_URL, value2);
      }
      get isChainOverridden() {
        return this._storage.getItem(HAS_CHAIN_OVERRIDDEN_FROM_RELAY) === "true";
      }
      set isChainOverridden(value2) {
        this._storage.setItem(HAS_CHAIN_OVERRIDDEN_FROM_RELAY, value2.toString());
      }
      setProviderInfo(jsonRpcUrl, chainId) {
        if (this.isChainOverridden)
          return;
        this.updateProviderInfo(jsonRpcUrl, this.getChainId(), false);
      }
      updateProviderInfo(jsonRpcUrl, chainId, fromRelay) {
        const hasChainSwitched = this._storage.getItem(HAS_CHAIN_BEEN_SWITCHED_KEY) === "true";
        if (hasChainSwitched && fromRelay)
          return;
        if (fromRelay) {
          this.isChainOverridden = true;
        }
        this.jsonRpcUrl = jsonRpcUrl;
        const originalChainId = this.getChainId();
        this._storage.setItem(DEFAULT_CHAIN_ID_KEY, chainId.toString(10));
        const chainChanged = (0, util_1.ensureIntNumber)(chainId) !== originalChainId;
        if (chainChanged || !this.hasMadeFirstChainChangedEmission) {
          this.emit("chainChanged", this.getChainId());
          this.hasMadeFirstChainChangedEmission = true;
        }
      }
      async watchAsset(type, address, symbol, decimals, image, chainId) {
        const relay = await this.initializeRelay();
        const result = await relay.watchAsset(type, address, symbol, decimals, image, chainId === null || chainId === void 0 ? void 0 : chainId.toString()).promise;
        return !!result.result;
      }
      async addEthereumChain(chainId, rpcUrls, blockExplorerUrls, chainName, iconUrls, nativeCurrency) {
        var _a2, _b;
        if ((0, util_1.ensureIntNumber)(chainId) === this.getChainId()) {
          return false;
        }
        const relay = await this.initializeRelay();
        const isWhitelistedNetworkOrStandalone = relay.inlineAddEthereumChain(chainId.toString());
        if (!this._isAuthorized() && !isWhitelistedNetworkOrStandalone) {
          await relay.requestEthereumAccounts().promise;
        }
        const res = await relay.addEthereumChain(chainId.toString(), rpcUrls, iconUrls, blockExplorerUrls, chainName, nativeCurrency).promise;
        if (((_a2 = res.result) === null || _a2 === void 0 ? void 0 : _a2.isApproved) === true) {
          this._storage.setItem(HAS_CHAIN_BEEN_SWITCHED_KEY, "true");
          this.updateProviderInfo(rpcUrls[0], chainId, false);
        }
        return ((_b = res.result) === null || _b === void 0 ? void 0 : _b.isApproved) === true;
      }
      async switchEthereumChain(chainId) {
        if ((0, util_1.ensureIntNumber)(chainId) === this.getChainId()) {
          return;
        }
        const relay = await this.initializeRelay();
        const res = await relay.switchEthereumChain(chainId.toString(10)).promise;
        if (res.errorCode) {
          throw eth_rpc_errors_1.ethErrors.provider.custom({
            code: res.errorCode
          });
        }
        const switchResponse = res.result;
        if (switchResponse.isApproved && switchResponse.rpcUrl.length > 0) {
          this._storage.setItem(HAS_CHAIN_BEEN_SWITCHED_KEY, "true");
          this.updateProviderInfo(switchResponse.rpcUrl, chainId, false);
        }
      }
      setAppInfo(appName, appLogoUrl) {
        void this.initializeRelay().then((relay) => relay.setAppInfo(appName, appLogoUrl));
      }
      async enable() {
        var _a2;
        (_a2 = this._eventListener) === null || _a2 === void 0 ? void 0 : _a2.onEvent(EventListener_1.EVENTS.ETH_ACCOUNTS_STATE, {
          method: "provider::enable",
          addresses_length: this._addresses.length,
          sessionIdHash: this._relay ? Session_1.Session.hash(this._relay.session.id) : null
        });
        if (this._addresses.length > 0) {
          return [...this._addresses];
        }
        return await this._send(JSONRPC_1.JSONRPCMethod.eth_requestAccounts);
      }
      async close() {
        const relay = await this.initializeRelay();
        relay.resetAndReload();
      }
      send(requestOrMethod, callbackOrParams) {
        if (typeof requestOrMethod === "string") {
          const method2 = requestOrMethod;
          const params = Array.isArray(callbackOrParams) ? callbackOrParams : callbackOrParams !== void 0 ? [callbackOrParams] : [];
          const request = {
            jsonrpc: "2.0",
            id: 0,
            method: method2,
            params
          };
          return this._sendRequestAsync(request).then((res) => res.result);
        }
        if (typeof callbackOrParams === "function") {
          const request = requestOrMethod;
          const callback = callbackOrParams;
          return this._sendAsync(request, callback);
        }
        if (Array.isArray(requestOrMethod)) {
          const requests = requestOrMethod;
          return requests.map((r6) => this._sendRequest(r6));
        }
        const req = requestOrMethod;
        return this._sendRequest(req);
      }
      async sendAsync(request, callback) {
        if (typeof callback !== "function") {
          throw new Error("callback is required");
        }
        if (Array.isArray(request)) {
          const arrayCb = callback;
          this._sendMultipleRequestsAsync(request).then((responses) => arrayCb(null, responses)).catch((err) => arrayCb(err, null));
          return;
        }
        const cb = callback;
        return this._sendRequestAsync(request).then((response) => cb(null, response)).catch((err) => cb(err, null));
      }
      async request(args) {
        if (!args || typeof args !== "object" || Array.isArray(args)) {
          throw eth_rpc_errors_1.ethErrors.rpc.invalidRequest({
            message: "Expected a single, non-array, object argument.",
            data: args
          });
        }
        const { method: method2, params } = args;
        if (typeof method2 !== "string" || method2.length === 0) {
          throw eth_rpc_errors_1.ethErrors.rpc.invalidRequest({
            message: "'args.method' must be a non-empty string.",
            data: args
          });
        }
        if (params !== void 0 && !Array.isArray(params) && (typeof params !== "object" || params === null)) {
          throw eth_rpc_errors_1.ethErrors.rpc.invalidRequest({
            message: "'args.params' must be an object or array if provided.",
            data: args
          });
        }
        const newParams = params === void 0 ? [] : params;
        const id2 = this._relayEventManager.makeRequestId();
        const result = await this._sendRequestAsync({
          method: method2,
          params: newParams,
          jsonrpc: "2.0",
          id: id2
        });
        return result.result;
      }
      async scanQRCode(match) {
        const relay = await this.initializeRelay();
        const res = await relay.scanQRCode((0, util_1.ensureRegExpString)(match)).promise;
        if (typeof res.result !== "string") {
          throw new Error("result was not a string");
        }
        return res.result;
      }
      async genericRequest(data, action) {
        const relay = await this.initializeRelay();
        const res = await relay.genericRequest(data, action).promise;
        if (typeof res.result !== "string") {
          throw new Error("result was not a string");
        }
        return res.result;
      }
      supportsSubscriptions() {
        return false;
      }
      subscribe() {
        throw new Error("Subscriptions are not supported");
      }
      unsubscribe() {
        throw new Error("Subscriptions are not supported");
      }
      disconnect() {
        return true;
      }
      _sendRequest(request) {
        const response = {
          jsonrpc: "2.0",
          id: request.id
        };
        const { method: method2 } = request;
        response.result = this._handleSynchronousMethods(request);
        if (response.result === void 0) {
          throw new Error(`Coinbase Wallet does not support calling ${method2} synchronously without a callback. Please provide a callback parameter to call ${method2} asynchronously.`);
        }
        return response;
      }
      _setAddresses(addresses) {
        if (!Array.isArray(addresses)) {
          throw new Error("addresses is not an array");
        }
        const newAddresses = addresses.map((address) => (0, util_1.ensureAddressString)(address));
        if (JSON.stringify(newAddresses) === JSON.stringify(this._addresses)) {
          return;
        }
        if (this._addresses.length > 0 && this.supportsAddressSwitching === false) {
          return;
        }
        this._addresses = newAddresses;
        this.emit("accountsChanged", this._addresses);
        this._storage.setItem(WalletSDKRelayAbstract_1.LOCAL_STORAGE_ADDRESSES_KEY, newAddresses.join(" "));
      }
      _sendRequestAsync(request) {
        return new Promise((resolve, reject) => {
          try {
            const syncResult = this._handleSynchronousMethods(request);
            if (syncResult !== void 0) {
              return resolve({
                jsonrpc: "2.0",
                id: request.id,
                result: syncResult
              });
            }
            const filterPromise = this._handleAsynchronousFilterMethods(request);
            if (filterPromise !== void 0) {
              filterPromise.then((res) => resolve(Object.assign(Object.assign({}, res), { id: request.id }))).catch((err) => reject(err));
              return;
            }
            const subscriptionPromise = this._handleSubscriptionMethods(request);
            if (subscriptionPromise !== void 0) {
              subscriptionPromise.then((res) => resolve({
                jsonrpc: "2.0",
                id: request.id,
                result: res.result
              })).catch((err) => reject(err));
              return;
            }
          } catch (err) {
            return reject(err);
          }
          this._handleAsynchronousMethods(request).then((res) => res && resolve(Object.assign(Object.assign({}, res), { id: request.id }))).catch((err) => reject(err));
        });
      }
      _sendMultipleRequestsAsync(requests) {
        return Promise.all(requests.map((r6) => this._sendRequestAsync(r6)));
      }
      _handleSynchronousMethods(request) {
        const { method: method2 } = request;
        const params = request.params || [];
        switch (method2) {
          case JSONRPC_1.JSONRPCMethod.eth_accounts:
            return this._eth_accounts();
          case JSONRPC_1.JSONRPCMethod.eth_coinbase:
            return this._eth_coinbase();
          case JSONRPC_1.JSONRPCMethod.eth_uninstallFilter:
            return this._eth_uninstallFilter(params);
          case JSONRPC_1.JSONRPCMethod.net_version:
            return this._net_version();
          case JSONRPC_1.JSONRPCMethod.eth_chainId:
            return this._eth_chainId();
          default:
            return void 0;
        }
      }
      async _handleAsynchronousMethods(request) {
        const { method: method2 } = request;
        const params = request.params || [];
        switch (method2) {
          case JSONRPC_1.JSONRPCMethod.eth_requestAccounts:
            return this._eth_requestAccounts();
          case JSONRPC_1.JSONRPCMethod.eth_sign:
            return this._eth_sign(params);
          case JSONRPC_1.JSONRPCMethod.eth_ecRecover:
            return this._eth_ecRecover(params);
          case JSONRPC_1.JSONRPCMethod.personal_sign:
            return this._personal_sign(params);
          case JSONRPC_1.JSONRPCMethod.personal_ecRecover:
            return this._personal_ecRecover(params);
          case JSONRPC_1.JSONRPCMethod.eth_signTransaction:
            return this._eth_signTransaction(params);
          case JSONRPC_1.JSONRPCMethod.eth_sendRawTransaction:
            return this._eth_sendRawTransaction(params);
          case JSONRPC_1.JSONRPCMethod.eth_sendTransaction:
            return this._eth_sendTransaction(params);
          case JSONRPC_1.JSONRPCMethod.eth_signTypedData_v1:
            return this._eth_signTypedData_v1(params);
          case JSONRPC_1.JSONRPCMethod.eth_signTypedData_v2:
            return this._throwUnsupportedMethodError();
          case JSONRPC_1.JSONRPCMethod.eth_signTypedData_v3:
            return this._eth_signTypedData_v3(params);
          case JSONRPC_1.JSONRPCMethod.eth_signTypedData_v4:
          case JSONRPC_1.JSONRPCMethod.eth_signTypedData:
            return this._eth_signTypedData_v4(params);
          case JSONRPC_1.JSONRPCMethod.cbWallet_arbitrary:
            return this._cbwallet_arbitrary(params);
          case JSONRPC_1.JSONRPCMethod.wallet_addEthereumChain:
            return this._wallet_addEthereumChain(params);
          case JSONRPC_1.JSONRPCMethod.wallet_switchEthereumChain:
            return this._wallet_switchEthereumChain(params);
          case JSONRPC_1.JSONRPCMethod.wallet_watchAsset:
            return this._wallet_watchAsset(params);
        }
        const relay = await this.initializeRelay();
        return relay.makeEthereumJSONRPCRequest(request, this.jsonRpcUrl);
      }
      _handleAsynchronousFilterMethods(request) {
        const { method: method2 } = request;
        const params = request.params || [];
        switch (method2) {
          case JSONRPC_1.JSONRPCMethod.eth_newFilter:
            return this._eth_newFilter(params);
          case JSONRPC_1.JSONRPCMethod.eth_newBlockFilter:
            return this._eth_newBlockFilter();
          case JSONRPC_1.JSONRPCMethod.eth_newPendingTransactionFilter:
            return this._eth_newPendingTransactionFilter();
          case JSONRPC_1.JSONRPCMethod.eth_getFilterChanges:
            return this._eth_getFilterChanges(params);
          case JSONRPC_1.JSONRPCMethod.eth_getFilterLogs:
            return this._eth_getFilterLogs(params);
        }
        return void 0;
      }
      _handleSubscriptionMethods(request) {
        switch (request.method) {
          case JSONRPC_1.JSONRPCMethod.eth_subscribe:
          case JSONRPC_1.JSONRPCMethod.eth_unsubscribe:
            return this._subscriptionManager.handleRequest(request);
        }
        return void 0;
      }
      _isKnownAddress(addressString) {
        try {
          const addressStr = (0, util_1.ensureAddressString)(addressString);
          const lowercaseAddresses = this._addresses.map((address) => (0, util_1.ensureAddressString)(address));
          return lowercaseAddresses.includes(addressStr);
        } catch (_a2) {
        }
        return false;
      }
      _ensureKnownAddress(addressString) {
        var _a2;
        if (!this._isKnownAddress(addressString)) {
          (_a2 = this._eventListener) === null || _a2 === void 0 ? void 0 : _a2.onEvent(EventListener_1.EVENTS.UNKNOWN_ADDRESS_ENCOUNTERED);
          throw new Error("Unknown Ethereum address");
        }
      }
      _prepareTransactionParams(tx) {
        const fromAddress = tx.from ? (0, util_1.ensureAddressString)(tx.from) : this.selectedAddress;
        if (!fromAddress) {
          throw new Error("Ethereum address is unavailable");
        }
        this._ensureKnownAddress(fromAddress);
        const toAddress = tx.to ? (0, util_1.ensureAddressString)(tx.to) : null;
        const weiValue = tx.value != null ? (0, util_1.ensureBN)(tx.value) : new bn_js_1.default(0);
        const data = tx.data ? (0, util_1.ensureBuffer)(tx.data) : Buffer.alloc(0);
        const nonce = tx.nonce != null ? (0, util_1.ensureIntNumber)(tx.nonce) : null;
        const gasPriceInWei = tx.gasPrice != null ? (0, util_1.ensureBN)(tx.gasPrice) : null;
        const maxFeePerGas = tx.maxFeePerGas != null ? (0, util_1.ensureBN)(tx.maxFeePerGas) : null;
        const maxPriorityFeePerGas = tx.maxPriorityFeePerGas != null ? (0, util_1.ensureBN)(tx.maxPriorityFeePerGas) : null;
        const gasLimit = tx.gas != null ? (0, util_1.ensureBN)(tx.gas) : null;
        const chainId = this.getChainId();
        return {
          fromAddress,
          toAddress,
          weiValue,
          data,
          nonce,
          gasPriceInWei,
          maxFeePerGas,
          maxPriorityFeePerGas,
          gasLimit,
          chainId
        };
      }
      _isAuthorized() {
        return this._addresses.length > 0;
      }
      _requireAuthorization() {
        if (!this._isAuthorized()) {
          throw eth_rpc_errors_1.ethErrors.provider.unauthorized({});
        }
      }
      _throwUnsupportedMethodError() {
        throw eth_rpc_errors_1.ethErrors.provider.unsupportedMethod({});
      }
      async _signEthereumMessage(message, address, addPrefix, typedDataJson) {
        this._ensureKnownAddress(address);
        try {
          const relay = await this.initializeRelay();
          const res = await relay.signEthereumMessage(message, address, addPrefix, typedDataJson).promise;
          return { jsonrpc: "2.0", id: 0, result: res.result };
        } catch (err) {
          if (typeof err.message === "string" && err.message.match(/(denied|rejected)/i)) {
            throw eth_rpc_errors_1.ethErrors.provider.userRejectedRequest("User denied message signature");
          }
          throw err;
        }
      }
      async _ethereumAddressFromSignedMessage(message, signature2, addPrefix) {
        const relay = await this.initializeRelay();
        const res = await relay.ethereumAddressFromSignedMessage(message, signature2, addPrefix).promise;
        return { jsonrpc: "2.0", id: 0, result: res.result };
      }
      _eth_accounts() {
        return [...this._addresses];
      }
      _eth_coinbase() {
        return this.selectedAddress || null;
      }
      _net_version() {
        return this.getChainId().toString(10);
      }
      _eth_chainId() {
        return (0, util_1.hexStringFromIntNumber)(this.getChainId());
      }
      getChainId() {
        const chainIdStr = this._storage.getItem(DEFAULT_CHAIN_ID_KEY) || "1";
        const chainId = parseInt(chainIdStr, 10);
        return (0, util_1.ensureIntNumber)(chainId);
      }
      async _eth_requestAccounts() {
        var _a2;
        (_a2 = this._eventListener) === null || _a2 === void 0 ? void 0 : _a2.onEvent(EventListener_1.EVENTS.ETH_ACCOUNTS_STATE, {
          method: "provider::_eth_requestAccounts",
          addresses_length: this._addresses.length,
          sessionIdHash: this._relay ? Session_1.Session.hash(this._relay.session.id) : null
        });
        if (this._addresses.length > 0) {
          return Promise.resolve({
            jsonrpc: "2.0",
            id: 0,
            result: this._addresses
          });
        }
        let res;
        try {
          const relay = await this.initializeRelay();
          res = await relay.requestEthereumAccounts().promise;
        } catch (err) {
          if (typeof err.message === "string" && err.message.match(/(denied|rejected)/i)) {
            throw eth_rpc_errors_1.ethErrors.provider.userRejectedRequest("User denied account authorization");
          }
          throw err;
        }
        if (!res.result) {
          throw new Error("accounts received is empty");
        }
        this._setAddresses(res.result);
        return { jsonrpc: "2.0", id: 0, result: this._addresses };
      }
      _eth_sign(params) {
        this._requireAuthorization();
        const address = (0, util_1.ensureAddressString)(params[0]);
        const message = (0, util_1.ensureBuffer)(params[1]);
        return this._signEthereumMessage(message, address, false);
      }
      _eth_ecRecover(params) {
        const message = (0, util_1.ensureBuffer)(params[0]);
        const signature2 = (0, util_1.ensureBuffer)(params[1]);
        return this._ethereumAddressFromSignedMessage(message, signature2, false);
      }
      _personal_sign(params) {
        this._requireAuthorization();
        const message = (0, util_1.ensureBuffer)(params[0]);
        const address = (0, util_1.ensureAddressString)(params[1]);
        return this._signEthereumMessage(message, address, true);
      }
      _personal_ecRecover(params) {
        const message = (0, util_1.ensureBuffer)(params[0]);
        const signature2 = (0, util_1.ensureBuffer)(params[1]);
        return this._ethereumAddressFromSignedMessage(message, signature2, true);
      }
      async _eth_signTransaction(params) {
        this._requireAuthorization();
        const tx = this._prepareTransactionParams(params[0] || {});
        try {
          const relay = await this.initializeRelay();
          const res = await relay.signEthereumTransaction(tx).promise;
          return { jsonrpc: "2.0", id: 0, result: res.result };
        } catch (err) {
          if (typeof err.message === "string" && err.message.match(/(denied|rejected)/i)) {
            throw eth_rpc_errors_1.ethErrors.provider.userRejectedRequest("User denied transaction signature");
          }
          throw err;
        }
      }
      async _eth_sendRawTransaction(params) {
        const signedTransaction = (0, util_1.ensureBuffer)(params[0]);
        const relay = await this.initializeRelay();
        const res = await relay.submitEthereumTransaction(signedTransaction, this.getChainId()).promise;
        return { jsonrpc: "2.0", id: 0, result: res.result };
      }
      async _eth_sendTransaction(params) {
        this._requireAuthorization();
        const tx = this._prepareTransactionParams(params[0] || {});
        try {
          const relay = await this.initializeRelay();
          const res = await relay.signAndSubmitEthereumTransaction(tx).promise;
          return { jsonrpc: "2.0", id: 0, result: res.result };
        } catch (err) {
          if (typeof err.message === "string" && err.message.match(/(denied|rejected)/i)) {
            throw eth_rpc_errors_1.ethErrors.provider.userRejectedRequest("User denied transaction signature");
          }
          throw err;
        }
      }
      async _eth_signTypedData_v1(params) {
        this._requireAuthorization();
        const typedData = (0, util_1.ensureParsedJSONObject)(params[0]);
        const address = (0, util_1.ensureAddressString)(params[1]);
        this._ensureKnownAddress(address);
        const message = eth_eip712_util_1.default.hashForSignTypedDataLegacy({ data: typedData });
        const typedDataJSON = JSON.stringify(typedData, null, 2);
        return this._signEthereumMessage(message, address, false, typedDataJSON);
      }
      async _eth_signTypedData_v3(params) {
        this._requireAuthorization();
        const address = (0, util_1.ensureAddressString)(params[0]);
        const typedData = (0, util_1.ensureParsedJSONObject)(params[1]);
        this._ensureKnownAddress(address);
        const message = eth_eip712_util_1.default.hashForSignTypedData_v3({ data: typedData });
        const typedDataJSON = JSON.stringify(typedData, null, 2);
        return this._signEthereumMessage(message, address, false, typedDataJSON);
      }
      async _eth_signTypedData_v4(params) {
        this._requireAuthorization();
        const address = (0, util_1.ensureAddressString)(params[0]);
        const typedData = (0, util_1.ensureParsedJSONObject)(params[1]);
        this._ensureKnownAddress(address);
        const message = eth_eip712_util_1.default.hashForSignTypedData_v4({ data: typedData });
        const typedDataJSON = JSON.stringify(typedData, null, 2);
        return this._signEthereumMessage(message, address, false, typedDataJSON);
      }
      async _cbwallet_arbitrary(params) {
        const action = params[0];
        const data = params[1];
        if (typeof data !== "string") {
          throw new Error("parameter must be a string");
        }
        if (typeof action !== "object" || action === null) {
          throw new Error("parameter must be an object");
        }
        const result = await this.genericRequest(action, data);
        return { jsonrpc: "2.0", id: 0, result };
      }
      async _wallet_addEthereumChain(params) {
        var _a2, _b, _c, _d;
        const request = params[0];
        if (((_a2 = request.rpcUrls) === null || _a2 === void 0 ? void 0 : _a2.length) === 0) {
          return {
            jsonrpc: "2.0",
            id: 0,
            error: { code: 2, message: `please pass in at least 1 rpcUrl` }
          };
        }
        if (!request.chainName || request.chainName.trim() === "") {
          throw eth_rpc_errors_1.ethErrors.provider.custom({
            code: 0,
            message: "chainName is a required field"
          });
        }
        if (!request.nativeCurrency) {
          throw eth_rpc_errors_1.ethErrors.provider.custom({
            code: 0,
            message: "nativeCurrency is a required field"
          });
        }
        const chainIdNumber = parseInt(request.chainId, 16);
        const success = await this.addEthereumChain(chainIdNumber, (_b = request.rpcUrls) !== null && _b !== void 0 ? _b : [], (_c = request.blockExplorerUrls) !== null && _c !== void 0 ? _c : [], request.chainName, (_d = request.iconUrls) !== null && _d !== void 0 ? _d : [], request.nativeCurrency);
        if (success) {
          return { jsonrpc: "2.0", id: 0, result: null };
        } else {
          return {
            jsonrpc: "2.0",
            id: 0,
            error: { code: 2, message: `unable to add ethereum chain` }
          };
        }
      }
      async _wallet_switchEthereumChain(params) {
        const request = params[0];
        await this.switchEthereumChain(parseInt(request.chainId, 16));
        return { jsonrpc: "2.0", id: 0, result: null };
      }
      async _wallet_watchAsset(params) {
        var _a2;
        const request = Array.isArray(params) ? params[0] : params;
        if (((_a2 = request.type) === null || _a2 === void 0 ? void 0 : _a2.length) === 0) {
          throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
            message: "type is a required field"
          });
        }
        if (request.type !== "ERC20") {
          throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
            message: `Asset of type '${request.type}' not supported`
          });
        }
        if (!(request === null || request === void 0 ? void 0 : request.options)) {
          throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
            message: "options is a required field"
          });
        }
        if (!request.options.address) {
          throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
            message: "option address is a required option"
          });
        }
        const chainId = this.getChainId();
        const { address, symbol, image, decimals } = request.options;
        const res = await this.watchAsset(request.type, address, symbol, decimals, image, chainId);
        return { jsonrpc: "2.0", id: 0, result: res };
      }
      _eth_uninstallFilter(params) {
        const filterId = (0, util_1.ensureHexString)(params[0]);
        return this._filterPolyfill.uninstallFilter(filterId);
      }
      async _eth_newFilter(params) {
        const param = params[0];
        const filterId = await this._filterPolyfill.newFilter(param);
        return { jsonrpc: "2.0", id: 0, result: filterId };
      }
      async _eth_newBlockFilter() {
        const filterId = await this._filterPolyfill.newBlockFilter();
        return { jsonrpc: "2.0", id: 0, result: filterId };
      }
      async _eth_newPendingTransactionFilter() {
        const filterId = await this._filterPolyfill.newPendingTransactionFilter();
        return { jsonrpc: "2.0", id: 0, result: filterId };
      }
      _eth_getFilterChanges(params) {
        const filterId = (0, util_1.ensureHexString)(params[0]);
        return this._filterPolyfill.getFilterChanges(filterId);
      }
      _eth_getFilterLogs(params) {
        const filterId = (0, util_1.ensureHexString)(params[0]);
        return this._filterPolyfill.getFilterLogs(filterId);
      }
      initializeRelay() {
        if (this._relay) {
          return Promise.resolve(this._relay);
        }
        return this._relayProvider().then((relay) => {
          relay.setAccountsCallback((accounts) => this._setAddresses(accounts));
          relay.setChainCallback((chainId, jsonRpcUrl) => {
            this.updateProviderInfo(jsonRpcUrl, parseInt(chainId, 10), true);
          });
          this._relay = relay;
          return relay;
        });
      }
    };
    exports2.CoinbaseWalletProvider = CoinbaseWalletProvider;
  }
});

// node_modules/preact/dist/preact.module.js
var preact_module_exports = {};
__export(preact_module_exports, {
  Component: () => _2,
  Fragment: () => d,
  cloneElement: () => B2,
  createContext: () => D2,
  createElement: () => v2,
  createRef: () => p3,
  h: () => v2,
  hydrate: () => q3,
  isValidElement: () => i2,
  options: () => l2,
  render: () => S2,
  toChildArray: () => A2
});
function a(n4, l6) {
  for (var u7 in l6)
    n4[u7] = l6[u7];
  return n4;
}
function h2(n4) {
  var l6 = n4.parentNode;
  l6 && l6.removeChild(n4);
}
function v2(l6, u7, i6) {
  var t6, o6, r6, f7 = {};
  for (r6 in u7)
    "key" == r6 ? t6 = u7[r6] : "ref" == r6 ? o6 = u7[r6] : f7[r6] = u7[r6];
  if (arguments.length > 2 && (f7.children = arguments.length > 3 ? n2.call(arguments, 2) : i6), "function" == typeof l6 && null != l6.defaultProps)
    for (r6 in l6.defaultProps)
      void 0 === f7[r6] && (f7[r6] = l6.defaultProps[r6]);
  return y(l6, f7, t6, o6, null);
}
function y(n4, i6, t6, o6, r6) {
  var f7 = { type: n4, props: i6, key: t6, ref: o6, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: null == r6 ? ++u2 : r6 };
  return null == r6 && null != l2.vnode && l2.vnode(f7), f7;
}
function p3() {
  return { current: null };
}
function d(n4) {
  return n4.children;
}
function _2(n4, l6) {
  this.props = n4, this.context = l6;
}
function k3(n4, l6) {
  if (null == l6)
    return n4.__ ? k3(n4.__, n4.__.__k.indexOf(n4) + 1) : null;
  for (var u7; l6 < n4.__k.length; l6++)
    if (null != (u7 = n4.__k[l6]) && null != u7.__e)
      return u7.__e;
  return "function" == typeof n4.type ? k3(n4) : null;
}
function b(n4) {
  var l6, u7;
  if (null != (n4 = n4.__) && null != n4.__c) {
    for (n4.__e = n4.__c.base = null, l6 = 0; l6 < n4.__k.length; l6++)
      if (null != (u7 = n4.__k[l6]) && null != u7.__e) {
        n4.__e = n4.__c.base = u7.__e;
        break;
      }
    return b(n4);
  }
}
function m2(n4) {
  (!n4.__d && (n4.__d = true) && t2.push(n4) && !g3.__r++ || r2 !== l2.debounceRendering) && ((r2 = l2.debounceRendering) || o2)(g3);
}
function g3() {
  for (var n4; g3.__r = t2.length; )
    n4 = t2.sort(function(n5, l6) {
      return n5.__v.__b - l6.__v.__b;
    }), t2 = [], n4.some(function(n5) {
      var l6, u7, i6, t6, o6, r6;
      n5.__d && (o6 = (t6 = (l6 = n5).__v).__e, (r6 = l6.__P) && (u7 = [], (i6 = a({}, t6)).__v = t6.__v + 1, j3(r6, t6, i6, l6.__n, void 0 !== r6.ownerSVGElement, null != t6.__h ? [o6] : null, u7, null == o6 ? k3(t6) : o6, t6.__h), z3(u7, t6), t6.__e != o6 && b(t6)));
    });
}
function w2(n4, l6, u7, i6, t6, o6, r6, f7, s6, a5) {
  var h6, v9, p7, _8, b4, m6, g7, w8 = i6 && i6.__k || c, A8 = w8.length;
  for (u7.__k = [], h6 = 0; h6 < l6.length; h6++)
    if (null != (_8 = u7.__k[h6] = null == (_8 = l6[h6]) || "boolean" == typeof _8 ? null : "string" == typeof _8 || "number" == typeof _8 || "bigint" == typeof _8 ? y(null, _8, null, null, _8) : Array.isArray(_8) ? y(d, { children: _8 }, null, null, null) : _8.__b > 0 ? y(_8.type, _8.props, _8.key, null, _8.__v) : _8)) {
      if (_8.__ = u7, _8.__b = u7.__b + 1, null === (p7 = w8[h6]) || p7 && _8.key == p7.key && _8.type === p7.type)
        w8[h6] = void 0;
      else
        for (v9 = 0; v9 < A8; v9++) {
          if ((p7 = w8[v9]) && _8.key == p7.key && _8.type === p7.type) {
            w8[v9] = void 0;
            break;
          }
          p7 = null;
        }
      j3(n4, _8, p7 = p7 || e2, t6, o6, r6, f7, s6, a5), b4 = _8.__e, (v9 = _8.ref) && p7.ref != v9 && (g7 || (g7 = []), p7.ref && g7.push(p7.ref, null, _8), g7.push(v9, _8.__c || b4, _8)), null != b4 ? (null == m6 && (m6 = b4), "function" == typeof _8.type && _8.__k === p7.__k ? _8.__d = s6 = x2(_8, s6, n4) : s6 = P2(n4, _8, p7, w8, b4, s6), "function" == typeof u7.type && (u7.__d = s6)) : s6 && p7.__e == s6 && s6.parentNode != n4 && (s6 = k3(p7));
    }
  for (u7.__e = m6, h6 = A8; h6--; )
    null != w8[h6] && ("function" == typeof u7.type && null != w8[h6].__e && w8[h6].__e == u7.__d && (u7.__d = k3(i6, h6 + 1)), N3(w8[h6], w8[h6]));
  if (g7)
    for (h6 = 0; h6 < g7.length; h6++)
      M2(g7[h6], g7[++h6], g7[++h6]);
}
function x2(n4, l6, u7) {
  for (var i6, t6 = n4.__k, o6 = 0; t6 && o6 < t6.length; o6++)
    (i6 = t6[o6]) && (i6.__ = n4, l6 = "function" == typeof i6.type ? x2(i6, l6, u7) : P2(u7, i6, i6, t6, i6.__e, l6));
  return l6;
}
function A2(n4, l6) {
  return l6 = l6 || [], null == n4 || "boolean" == typeof n4 || (Array.isArray(n4) ? n4.some(function(n5) {
    A2(n5, l6);
  }) : l6.push(n4)), l6;
}
function P2(n4, l6, u7, i6, t6, o6) {
  var r6, f7, e6;
  if (void 0 !== l6.__d)
    r6 = l6.__d, l6.__d = void 0;
  else if (null == u7 || t6 != o6 || null == t6.parentNode)
    n:
      if (null == o6 || o6.parentNode !== n4)
        n4.appendChild(t6), r6 = null;
      else {
        for (f7 = o6, e6 = 0; (f7 = f7.nextSibling) && e6 < i6.length; e6 += 2)
          if (f7 == t6)
            break n;
        n4.insertBefore(t6, o6), r6 = o6;
      }
  return void 0 !== r6 ? r6 : t6.nextSibling;
}
function C(n4, l6, u7, i6, t6) {
  var o6;
  for (o6 in u7)
    "children" === o6 || "key" === o6 || o6 in l6 || H2(n4, o6, null, u7[o6], i6);
  for (o6 in l6)
    t6 && "function" != typeof l6[o6] || "children" === o6 || "key" === o6 || "value" === o6 || "checked" === o6 || u7[o6] === l6[o6] || H2(n4, o6, l6[o6], u7[o6], i6);
}
function $2(n4, l6, u7) {
  "-" === l6[0] ? n4.setProperty(l6, u7) : n4[l6] = null == u7 ? "" : "number" != typeof u7 || s2.test(l6) ? u7 : u7 + "px";
}
function H2(n4, l6, u7, i6, t6) {
  var o6;
  n:
    if ("style" === l6)
      if ("string" == typeof u7)
        n4.style.cssText = u7;
      else {
        if ("string" == typeof i6 && (n4.style.cssText = i6 = ""), i6)
          for (l6 in i6)
            u7 && l6 in u7 || $2(n4.style, l6, "");
        if (u7)
          for (l6 in u7)
            i6 && u7[l6] === i6[l6] || $2(n4.style, l6, u7[l6]);
      }
    else if ("o" === l6[0] && "n" === l6[1])
      o6 = l6 !== (l6 = l6.replace(/Capture$/, "")), l6 = l6.toLowerCase() in n4 ? l6.toLowerCase().slice(2) : l6.slice(2), n4.l || (n4.l = {}), n4.l[l6 + o6] = u7, u7 ? i6 || n4.addEventListener(l6, o6 ? T2 : I2, o6) : n4.removeEventListener(l6, o6 ? T2 : I2, o6);
    else if ("dangerouslySetInnerHTML" !== l6) {
      if (t6)
        l6 = l6.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
      else if ("href" !== l6 && "list" !== l6 && "form" !== l6 && "tabIndex" !== l6 && "download" !== l6 && l6 in n4)
        try {
          n4[l6] = null == u7 ? "" : u7;
          break n;
        } catch (n5) {
        }
      "function" == typeof u7 || (null != u7 && (false !== u7 || "a" === l6[0] && "r" === l6[1]) ? n4.setAttribute(l6, u7) : n4.removeAttribute(l6));
    }
}
function I2(n4) {
  this.l[n4.type + false](l2.event ? l2.event(n4) : n4);
}
function T2(n4) {
  this.l[n4.type + true](l2.event ? l2.event(n4) : n4);
}
function j3(n4, u7, i6, t6, o6, r6, f7, e6, c5) {
  var s6, h6, v9, y5, p7, k8, b4, m6, g7, x6, A8, P5 = u7.type;
  if (void 0 !== u7.constructor)
    return null;
  null != i6.__h && (c5 = i6.__h, e6 = u7.__e = i6.__e, u7.__h = null, r6 = [e6]), (s6 = l2.__b) && s6(u7);
  try {
    n:
      if ("function" == typeof P5) {
        if (m6 = u7.props, g7 = (s6 = P5.contextType) && t6[s6.__c], x6 = s6 ? g7 ? g7.props.value : s6.__ : t6, i6.__c ? b4 = (h6 = u7.__c = i6.__c).__ = h6.__E : ("prototype" in P5 && P5.prototype.render ? u7.__c = h6 = new P5(m6, x6) : (u7.__c = h6 = new _2(m6, x6), h6.constructor = P5, h6.render = O2), g7 && g7.sub(h6), h6.props = m6, h6.state || (h6.state = {}), h6.context = x6, h6.__n = t6, v9 = h6.__d = true, h6.__h = []), null == h6.__s && (h6.__s = h6.state), null != P5.getDerivedStateFromProps && (h6.__s == h6.state && (h6.__s = a({}, h6.__s)), a(h6.__s, P5.getDerivedStateFromProps(m6, h6.__s))), y5 = h6.props, p7 = h6.state, v9)
          null == P5.getDerivedStateFromProps && null != h6.componentWillMount && h6.componentWillMount(), null != h6.componentDidMount && h6.__h.push(h6.componentDidMount);
        else {
          if (null == P5.getDerivedStateFromProps && m6 !== y5 && null != h6.componentWillReceiveProps && h6.componentWillReceiveProps(m6, x6), !h6.__e && null != h6.shouldComponentUpdate && false === h6.shouldComponentUpdate(m6, h6.__s, x6) || u7.__v === i6.__v) {
            h6.props = m6, h6.state = h6.__s, u7.__v !== i6.__v && (h6.__d = false), h6.__v = u7, u7.__e = i6.__e, u7.__k = i6.__k, u7.__k.forEach(function(n5) {
              n5 && (n5.__ = u7);
            }), h6.__h.length && f7.push(h6);
            break n;
          }
          null != h6.componentWillUpdate && h6.componentWillUpdate(m6, h6.__s, x6), null != h6.componentDidUpdate && h6.__h.push(function() {
            h6.componentDidUpdate(y5, p7, k8);
          });
        }
        h6.context = x6, h6.props = m6, h6.state = h6.__s, (s6 = l2.__r) && s6(u7), h6.__d = false, h6.__v = u7, h6.__P = n4, s6 = h6.render(h6.props, h6.state, h6.context), h6.state = h6.__s, null != h6.getChildContext && (t6 = a(a({}, t6), h6.getChildContext())), v9 || null == h6.getSnapshotBeforeUpdate || (k8 = h6.getSnapshotBeforeUpdate(y5, p7)), A8 = null != s6 && s6.type === d && null == s6.key ? s6.props.children : s6, w2(n4, Array.isArray(A8) ? A8 : [A8], u7, i6, t6, o6, r6, f7, e6, c5), h6.base = u7.__e, u7.__h = null, h6.__h.length && f7.push(h6), b4 && (h6.__E = h6.__ = null), h6.__e = false;
      } else
        null == r6 && u7.__v === i6.__v ? (u7.__k = i6.__k, u7.__e = i6.__e) : u7.__e = L2(i6.__e, u7, i6, t6, o6, r6, f7, c5);
    (s6 = l2.diffed) && s6(u7);
  } catch (n5) {
    u7.__v = null, (c5 || null != r6) && (u7.__e = e6, u7.__h = !!c5, r6[r6.indexOf(e6)] = null), l2.__e(n5, u7, i6);
  }
}
function z3(n4, u7) {
  l2.__c && l2.__c(u7, n4), n4.some(function(u8) {
    try {
      n4 = u8.__h, u8.__h = [], n4.some(function(n5) {
        n5.call(u8);
      });
    } catch (n5) {
      l2.__e(n5, u8.__v);
    }
  });
}
function L2(l6, u7, i6, t6, o6, r6, f7, c5) {
  var s6, a5, v9, y5 = i6.props, p7 = u7.props, d6 = u7.type, _8 = 0;
  if ("svg" === d6 && (o6 = true), null != r6) {
    for (; _8 < r6.length; _8++)
      if ((s6 = r6[_8]) && "setAttribute" in s6 == !!d6 && (d6 ? s6.localName === d6 : 3 === s6.nodeType)) {
        l6 = s6, r6[_8] = null;
        break;
      }
  }
  if (null == l6) {
    if (null === d6)
      return document.createTextNode(p7);
    l6 = o6 ? document.createElementNS("http://www.w3.org/2000/svg", d6) : document.createElement(d6, p7.is && p7), r6 = null, c5 = false;
  }
  if (null === d6)
    y5 === p7 || c5 && l6.data === p7 || (l6.data = p7);
  else {
    if (r6 = r6 && n2.call(l6.childNodes), a5 = (y5 = i6.props || e2).dangerouslySetInnerHTML, v9 = p7.dangerouslySetInnerHTML, !c5) {
      if (null != r6)
        for (y5 = {}, _8 = 0; _8 < l6.attributes.length; _8++)
          y5[l6.attributes[_8].name] = l6.attributes[_8].value;
      (v9 || a5) && (v9 && (a5 && v9.__html == a5.__html || v9.__html === l6.innerHTML) || (l6.innerHTML = v9 && v9.__html || ""));
    }
    if (C(l6, p7, y5, o6, c5), v9)
      u7.__k = [];
    else if (_8 = u7.props.children, w2(l6, Array.isArray(_8) ? _8 : [_8], u7, i6, t6, o6 && "foreignObject" !== d6, r6, f7, r6 ? r6[0] : i6.__k && k3(i6, 0), c5), null != r6)
      for (_8 = r6.length; _8--; )
        null != r6[_8] && h2(r6[_8]);
    c5 || ("value" in p7 && void 0 !== (_8 = p7.value) && (_8 !== l6.value || "progress" === d6 && !_8 || "option" === d6 && _8 !== y5.value) && H2(l6, "value", _8, y5.value, false), "checked" in p7 && void 0 !== (_8 = p7.checked) && _8 !== l6.checked && H2(l6, "checked", _8, y5.checked, false));
  }
  return l6;
}
function M2(n4, u7, i6) {
  try {
    "function" == typeof n4 ? n4(u7) : n4.current = u7;
  } catch (n5) {
    l2.__e(n5, i6);
  }
}
function N3(n4, u7, i6) {
  var t6, o6;
  if (l2.unmount && l2.unmount(n4), (t6 = n4.ref) && (t6.current && t6.current !== n4.__e || M2(t6, null, u7)), null != (t6 = n4.__c)) {
    if (t6.componentWillUnmount)
      try {
        t6.componentWillUnmount();
      } catch (n5) {
        l2.__e(n5, u7);
      }
    t6.base = t6.__P = null;
  }
  if (t6 = n4.__k)
    for (o6 = 0; o6 < t6.length; o6++)
      t6[o6] && N3(t6[o6], u7, "function" != typeof n4.type);
  i6 || null == n4.__e || h2(n4.__e), n4.__e = n4.__d = void 0;
}
function O2(n4, l6, u7) {
  return this.constructor(n4, u7);
}
function S2(u7, i6, t6) {
  var o6, r6, f7;
  l2.__ && l2.__(u7, i6), r6 = (o6 = "function" == typeof t6) ? null : t6 && t6.__k || i6.__k, f7 = [], j3(i6, u7 = (!o6 && t6 || i6).__k = v2(d, null, [u7]), r6 || e2, e2, void 0 !== i6.ownerSVGElement, !o6 && t6 ? [t6] : r6 ? null : i6.firstChild ? n2.call(i6.childNodes) : null, f7, !o6 && t6 ? t6 : r6 ? r6.__e : i6.firstChild, o6), z3(f7, u7);
}
function q3(n4, l6) {
  S2(n4, l6, q3);
}
function B2(l6, u7, i6) {
  var t6, o6, r6, f7 = a({}, l6.props);
  for (r6 in u7)
    "key" == r6 ? t6 = u7[r6] : "ref" == r6 ? o6 = u7[r6] : f7[r6] = u7[r6];
  return arguments.length > 2 && (f7.children = arguments.length > 3 ? n2.call(arguments, 2) : i6), y(l6.type, f7, t6 || l6.key, o6 || l6.ref, null);
}
function D2(n4, l6) {
  var u7 = { __c: l6 = "__cC" + f3++, __: n4, Consumer: function(n5, l7) {
    return n5.children(l7);
  }, Provider: function(n5) {
    var u8, i6;
    return this.getChildContext || (u8 = [], (i6 = {})[l6] = this, this.getChildContext = function() {
      return i6;
    }, this.shouldComponentUpdate = function(n6) {
      this.props.value !== n6.value && u8.some(m2);
    }, this.sub = function(n6) {
      u8.push(n6);
      var l7 = n6.componentWillUnmount;
      n6.componentWillUnmount = function() {
        u8.splice(u8.indexOf(n6), 1), l7 && l7.call(n6);
      };
    }), n5.children;
  } };
  return u7.Provider.__ = u7.Consumer.contextType = u7;
}
var n2, l2, u2, i2, t2, o2, r2, f3, e2, c, s2;
var init_preact_module = __esm({
  "node_modules/preact/dist/preact.module.js"() {
    e2 = {};
    c = [];
    s2 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
    n2 = c.slice, l2 = { __e: function(n4, l6, u7, i6) {
      for (var t6, o6, r6; l6 = l6.__; )
        if ((t6 = l6.__c) && !t6.__)
          try {
            if ((o6 = t6.constructor) && null != o6.getDerivedStateFromError && (t6.setState(o6.getDerivedStateFromError(n4)), r6 = t6.__d), null != t6.componentDidCatch && (t6.componentDidCatch(n4, i6 || {}), r6 = t6.__d), r6)
              return t6.__E = t6;
          } catch (l7) {
            n4 = l7;
          }
      throw n4;
    } }, u2 = 0, i2 = function(n4) {
      return null != n4 && void 0 === n4.constructor;
    }, _2.prototype.setState = function(n4, l6) {
      var u7;
      u7 = null != this.__s && this.__s !== this.state ? this.__s : this.__s = a({}, this.state), "function" == typeof n4 && (n4 = n4(a({}, u7), this.props)), n4 && a(u7, n4), null != n4 && this.__v && (l6 && this.__h.push(l6), m2(this));
    }, _2.prototype.forceUpdate = function(n4) {
      this.__v && (this.__e = true, n4 && this.__h.push(n4), m2(this));
    }, _2.prototype.render = d, t2 = [], o2 = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, g3.__r = 0, f3 = 0;
  }
});

// node_modules/clsx/dist/clsx.m.js
var clsx_m_exports = {};
__export(clsx_m_exports, {
  default: () => clsx_m_default
});
function toVal(mix) {
  var k8, y5, str = "";
  if (typeof mix === "string" || typeof mix === "number") {
    str += mix;
  } else if (typeof mix === "object") {
    if (Array.isArray(mix)) {
      for (k8 = 0; k8 < mix.length; k8++) {
        if (mix[k8]) {
          if (y5 = toVal(mix[k8])) {
            str && (str += " ");
            str += y5;
          }
        }
      }
    } else {
      for (k8 in mix) {
        if (mix[k8]) {
          str && (str += " ");
          str += k8;
        }
      }
    }
  }
  return str;
}
function clsx_m_default() {
  var i6 = 0, tmp, x6, str = "";
  while (i6 < arguments.length) {
    if (tmp = arguments[i6++]) {
      if (x6 = toVal(tmp)) {
        str && (str += " ");
        str += x6;
      }
    }
  }
  return str;
}
var init_clsx_m = __esm({
  "node_modules/clsx/dist/clsx.m.js"() {
  }
});

// node_modules/preact/hooks/dist/hooks.module.js
var hooks_module_exports = {};
__export(hooks_module_exports, {
  useCallback: () => A3,
  useContext: () => F,
  useDebugValue: () => T3,
  useEffect: () => y2,
  useErrorBoundary: () => q4,
  useImperativeHandle: () => s3,
  useLayoutEffect: () => d2,
  useMemo: () => _3,
  useReducer: () => p4,
  useRef: () => h3,
  useState: () => m3
});
function l3(t6, r6) {
  l2.__h && l2.__h(u3, t6, o3 || r6), o3 = 0;
  var i6 = u3.__H || (u3.__H = { __: [], __h: [] });
  return t6 >= i6.__.length && i6.__.push({}), i6.__[t6];
}
function m3(n4) {
  return o3 = 1, p4(w3, n4);
}
function p4(n4, r6, o6) {
  var i6 = l3(t3++, 2);
  return i6.t = n4, i6.__c || (i6.__ = [o6 ? o6(r6) : w3(void 0, r6), function(n5) {
    var t6 = i6.t(i6.__[0], n5);
    i6.__[0] !== t6 && (i6.__ = [t6, i6.__[1]], i6.__c.setState({}));
  }], i6.__c = u3), i6.__;
}
function y2(r6, o6) {
  var i6 = l3(t3++, 3);
  !l2.__s && k4(i6.__H, o6) && (i6.__ = r6, i6.__H = o6, u3.__H.__h.push(i6));
}
function d2(r6, o6) {
  var i6 = l3(t3++, 4);
  !l2.__s && k4(i6.__H, o6) && (i6.__ = r6, i6.__H = o6, u3.__h.push(i6));
}
function h3(n4) {
  return o3 = 5, _3(function() {
    return { current: n4 };
  }, []);
}
function s3(n4, t6, u7) {
  o3 = 6, d2(function() {
    return "function" == typeof n4 ? (n4(t6()), function() {
      return n4(null);
    }) : n4 ? (n4.current = t6(), function() {
      return n4.current = null;
    }) : void 0;
  }, null == u7 ? u7 : u7.concat(n4));
}
function _3(n4, u7) {
  var r6 = l3(t3++, 7);
  return k4(r6.__H, u7) && (r6.__ = n4(), r6.__H = u7, r6.__h = n4), r6.__;
}
function A3(n4, t6) {
  return o3 = 8, _3(function() {
    return n4;
  }, t6);
}
function F(n4) {
  var r6 = u3.context[n4.__c], o6 = l3(t3++, 9);
  return o6.c = n4, r6 ? (null == o6.__ && (o6.__ = true, r6.sub(u3)), r6.props.value) : n4.__;
}
function T3(t6, u7) {
  l2.useDebugValue && l2.useDebugValue(u7 ? u7(t6) : t6);
}
function q4(n4) {
  var r6 = l3(t3++, 10), o6 = m3();
  return r6.__ = n4, u3.componentDidCatch || (u3.componentDidCatch = function(n5) {
    r6.__ && r6.__(n5), o6[1](n5);
  }), [o6[0], function() {
    o6[1](void 0);
  }];
}
function x3() {
  for (var t6; t6 = i3.shift(); )
    if (t6.__P)
      try {
        t6.__H.__h.forEach(g4), t6.__H.__h.forEach(j4), t6.__H.__h = [];
      } catch (u7) {
        t6.__H.__h = [], l2.__e(u7, t6.__v);
      }
}
function g4(n4) {
  var t6 = u3, r6 = n4.__c;
  "function" == typeof r6 && (n4.__c = void 0, r6()), u3 = t6;
}
function j4(n4) {
  var t6 = u3;
  n4.__c = n4.__(), u3 = t6;
}
function k4(n4, t6) {
  return !n4 || n4.length !== t6.length || t6.some(function(t7, u7) {
    return t7 !== n4[u7];
  });
}
function w3(n4, t6) {
  return "function" == typeof t6 ? t6(n4) : t6;
}
var t3, u3, r3, o3, i3, c2, f4, e3, a2, v6, b2;
var init_hooks_module = __esm({
  "node_modules/preact/hooks/dist/hooks.module.js"() {
    init_preact_module();
    o3 = 0;
    i3 = [];
    c2 = l2.__b;
    f4 = l2.__r;
    e3 = l2.diffed;
    a2 = l2.__c;
    v6 = l2.unmount;
    l2.__b = function(n4) {
      u3 = null, c2 && c2(n4);
    }, l2.__r = function(n4) {
      f4 && f4(n4), t3 = 0;
      var r6 = (u3 = n4.__c).__H;
      r6 && (r6.__h.forEach(g4), r6.__h.forEach(j4), r6.__h = []);
    }, l2.diffed = function(t6) {
      e3 && e3(t6);
      var o6 = t6.__c;
      o6 && o6.__H && o6.__H.__h.length && (1 !== i3.push(o6) && r3 === l2.requestAnimationFrame || ((r3 = l2.requestAnimationFrame) || function(n4) {
        var t7, u7 = function() {
          clearTimeout(r6), b2 && cancelAnimationFrame(t7), setTimeout(n4);
        }, r6 = setTimeout(u7, 100);
        b2 && (t7 = requestAnimationFrame(u7));
      })(x3)), u3 = null;
    }, l2.__c = function(t6, u7) {
      u7.some(function(t7) {
        try {
          t7.__h.forEach(g4), t7.__h = t7.__h.filter(function(n4) {
            return !n4.__ || j4(n4);
          });
        } catch (r6) {
          u7.some(function(n4) {
            n4.__h && (n4.__h = []);
          }), u7 = [], l2.__e(r6, t7.__v);
        }
      }), a2 && a2(t6, u7);
    }, l2.unmount = function(t6) {
      v6 && v6(t6);
      var u7, r6 = t6.__c;
      r6 && r6.__H && (r6.__H.__.forEach(function(n4) {
        try {
          g4(n4);
        } catch (n5) {
          u7 = n5;
        }
      }), u7 && l2.__e(u7, r6.__v));
    };
    b2 = "function" == typeof requestAnimationFrame;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/version.js
var require_version = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LIB_VERSION = void 0;
    exports2.LIB_VERSION = "3.1.0";
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/icons/globe-icon-svg.js
var require_globe_icon_svg = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/icons/globe-icon-svg.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTggMEMzLjU4IDAgMCAzLjU4IDAgOHMzLjU4IDggOCA4IDgtMy41OCA4LTgtMy41OC04LTgtOFptNS45MSA3aC0xLjk0Yy0uMS0xLjU3LS40Mi0zLS45MS00LjE1IDEuNDguODggMi41NSAyLjM4IDIuODUgNC4xNVpNOCAxNGMtLjQ1IDAtMS43Mi0xLjc3LTEuOTUtNWgzLjljLS4yMyAzLjIzLTEuNSA1LTEuOTUgNVpNNi4wNSA3QzYuMjggMy43NyA3LjU1IDIgOCAyYy40NSAwIDEuNzIgMS43NyAxLjk1IDVoLTMuOVpNNC45NCAyLjg1QzQuNDYgNCA0LjEzIDUuNDMgNC4wMyA3SDIuMDljLjMtMS43NyAxLjM3LTMuMjcgMi44NS00LjE1Wk0yLjA5IDloMS45NGMuMSAxLjU3LjQyIDMgLjkxIDQuMTVBNS45OTggNS45OTggMCAwIDEgMi4wOSA5Wm04Ljk3IDQuMTVjLjQ4LTEuMTUuODEtMi41OC45MS00LjE1aDEuOTRhNS45OTggNS45OTggMCAwIDEtMi44NSA0LjE1WiIgZmlsbD0iIzE2NTJGMCIvPjwvc3ZnPg==`;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/icons/link-icon-svg.js
var require_link_icon_svg = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/icons/link-icon-svg.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTciIGhlaWdodD0iMTciIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTE1LjYzNSAyLjExN2EzLjg4OSAzLjg4OSAwIDAgMC01LjUyMSAwTDYuODkgNS4zMzVBMy44OTQgMy44OTQgMCAwIDAgNS44IDguNzM5Yy4wODMuNTA2LjI2OCAxLjAxMS41NTMgMS40NjYuMTUxLjI1My4zMzYuNDcyLjUzNy42OTFsLjYyMS42MjQgMS4xNDEtMS4xNDYtLjYyLS42MjRhMi4xMDUgMi4xMDUgMCAwIDEtLjQ4Ny0uNzQxIDIuMzQgMi4zNCAwIDAgMSAuNTAzLTIuNTFsMy4yMDYtMy4yMmEyLjI5MyAyLjI5MyAwIDAgMSAzLjIzOSAwYy44OS44OTQuODkgMi4zNDMgMCAzLjI1M2wtMS41MjcgMS41MzNjLjIzNC42NC4zMzUgMS4zMzEuMzAyIDIuMDA1bDIuMzgzLTIuMzkyYzEuNTEtMS41MzQgMS40OTMtNC4wMjgtLjAxNy01LjU2MVoiIGZpbGw9IiMxNjUyRjAiLz48cGF0aCBkPSJNMTEuMjcxIDcuNzQ1YTMuMTMgMy4xMyAwIDAgMC0uNTU0LS42OWwtLjYyLS42MjQtMS4xNDIgMS4xNDYuNjIxLjYyM2MuMjE4LjIyLjM4Ni40ODkuNDg3Ljc1OC4zMzUuODI2LjE2NyAxLjgyLS41MDQgMi40OTRsLTMuMjA1IDMuMjE5YTIuMjkzIDIuMjkzIDAgMCAxLTMuMjQgMCAyLjMxNiAyLjMxNiAwIDAgMSAwLTMuMjUybDEuNTI4LTEuNTM0YTQuODE1IDQuODE1IDAgMCAxLS4yODUtMi4wMDVsLTIuMzgzIDIuMzkzYTMuOTI3IDMuOTI3IDAgMCAwIDAgNS41NDQgMy45MDkgMy45MDkgMCAwIDAgNS41MzggMGwzLjIwNS0zLjIxOWEzLjk1OCAzLjk1OCAwIDAgMCAxLjA5MS0zLjQwNCA0LjIxMSA0LjIxMSAwIDAgMC0uNTM3LTEuNDQ5WiIgZmlsbD0iIzE2NTJGMCIvPjwvc3ZnPg==`;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/icons/lock-icon-svg.js
var require_lock_icon_svg = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/icons/lock-icon-svg.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEgN3Y5aDE0VjdIMVptNy41IDQuMzlWMTRoLTF2LTIuNjFjLS40NC0uMTktLjc1LS42My0uNzUtMS4xNGExLjI1IDEuMjUgMCAwIDEgMi41IDBjMCAuNTEtLjMxLjk1LS43NSAxLjE0Wk01LjY3IDZWNC4zM0M1LjY3IDMuMDUgNi43MSAyIDggMnMyLjMzIDEuMDUgMi4zMyAyLjMzVjZoMlY0LjMzQzEyLjMzIDEuOTQgMTAuMzkgMCA4IDBTMy42NyAxLjk0IDMuNjcgNC4zM1Y2aDJaIiBmaWxsPSIjMTY1MkYwIi8+PC9zdmc+`;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/icons/QRLogo.js
var require_QRLogo = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/icons/QRLogo.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = `<svg width="100" height="100" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
<circle cx="50" cy="50" r="50" fill="white"/>
<circle cx="49.9996" cy="49.9996" r="43.6363" fill="#1B53E4"/>
<circle cx="49.9996" cy="49.9996" r="43.6363" stroke="white"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M19.3379 49.9484C19.3379 66.8508 33.04 80.553 49.9425 80.553C66.8449 80.553 80.5471 66.8508 80.5471 49.9484C80.5471 33.0459 66.8449 19.3438 49.9425 19.3438C33.04 19.3438 19.3379 33.0459 19.3379 49.9484ZM44.0817 40.0799C41.8725 40.0799 40.0817 41.8708 40.0817 44.0799V55.8029C40.0817 58.012 41.8725 59.8029 44.0817 59.8029H55.8046C58.0138 59.8029 59.8046 58.012 59.8046 55.8029V44.0799C59.8046 41.8708 58.0138 40.0799 55.8046 40.0799H44.0817Z" fill="white"/>
</svg>

`;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/vendor-js/qrcode-svg/index.js
var require_qrcode_svg = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/vendor-js/qrcode-svg/index.js"(exports2, module2) {
    function QR8bitByte(data) {
      this.mode = QRMode.MODE_8BIT_BYTE;
      this.data = data;
      this.parsedData = [];
      for (var i7 = 0, l6 = this.data.length; i7 < l6; i7++) {
        var byteArray = [];
        var code = this.data.charCodeAt(i7);
        if (code > 65536) {
          byteArray[0] = 240 | (code & 1835008) >>> 18;
          byteArray[1] = 128 | (code & 258048) >>> 12;
          byteArray[2] = 128 | (code & 4032) >>> 6;
          byteArray[3] = 128 | code & 63;
        } else if (code > 2048) {
          byteArray[0] = 224 | (code & 61440) >>> 12;
          byteArray[1] = 128 | (code & 4032) >>> 6;
          byteArray[2] = 128 | code & 63;
        } else if (code > 128) {
          byteArray[0] = 192 | (code & 1984) >>> 6;
          byteArray[1] = 128 | code & 63;
        } else {
          byteArray[0] = code;
        }
        this.parsedData.push(byteArray);
      }
      this.parsedData = Array.prototype.concat.apply([], this.parsedData);
      if (this.parsedData.length != this.data.length) {
        this.parsedData.unshift(191);
        this.parsedData.unshift(187);
        this.parsedData.unshift(239);
      }
    }
    QR8bitByte.prototype = {
      getLength: function(buffer2) {
        return this.parsedData.length;
      },
      write: function(buffer2) {
        for (var i7 = 0, l6 = this.parsedData.length; i7 < l6; i7++) {
          buffer2.put(this.parsedData[i7], 8);
        }
      }
    };
    function QRCodeModel(typeNumber, errorCorrectLevel) {
      this.typeNumber = typeNumber;
      this.errorCorrectLevel = errorCorrectLevel;
      this.modules = null;
      this.moduleCount = 0;
      this.dataCache = null;
      this.dataList = [];
    }
    QRCodeModel.prototype = { addData: function(data) {
      var newData = new QR8bitByte(data);
      this.dataList.push(newData);
      this.dataCache = null;
    }, isDark: function(row, col) {
      if (row < 0 || this.moduleCount <= row || col < 0 || this.moduleCount <= col) {
        throw new Error(row + "," + col);
      }
      return this.modules[row][col];
    }, getModuleCount: function() {
      return this.moduleCount;
    }, make: function() {
      this.makeImpl(false, this.getBestMaskPattern());
    }, makeImpl: function(test, maskPattern) {
      this.moduleCount = this.typeNumber * 4 + 17;
      this.modules = new Array(this.moduleCount);
      for (var row = 0; row < this.moduleCount; row++) {
        this.modules[row] = new Array(this.moduleCount);
        for (var col = 0; col < this.moduleCount; col++) {
          this.modules[row][col] = null;
        }
      }
      this.setupPositionProbePattern(0, 0);
      this.setupPositionProbePattern(this.moduleCount - 7, 0);
      this.setupPositionProbePattern(0, this.moduleCount - 7);
      this.setupPositionAdjustPattern();
      this.setupTimingPattern();
      this.setupTypeInfo(test, maskPattern);
      if (this.typeNumber >= 7) {
        this.setupTypeNumber(test);
      }
      if (this.dataCache == null) {
        this.dataCache = QRCodeModel.createData(this.typeNumber, this.errorCorrectLevel, this.dataList);
      }
      this.mapData(this.dataCache, maskPattern);
    }, setupPositionProbePattern: function(row, col) {
      for (var r6 = -1; r6 <= 7; r6++) {
        if (row + r6 <= -1 || this.moduleCount <= row + r6)
          continue;
        for (var c5 = -1; c5 <= 7; c5++) {
          if (col + c5 <= -1 || this.moduleCount <= col + c5)
            continue;
          if (0 <= r6 && r6 <= 6 && (c5 == 0 || c5 == 6) || 0 <= c5 && c5 <= 6 && (r6 == 0 || r6 == 6) || 2 <= r6 && r6 <= 4 && 2 <= c5 && c5 <= 4) {
            this.modules[row + r6][col + c5] = true;
          } else {
            this.modules[row + r6][col + c5] = false;
          }
        }
      }
    }, getBestMaskPattern: function() {
      var minLostPoint = 0;
      var pattern = 0;
      for (var i7 = 0; i7 < 8; i7++) {
        this.makeImpl(true, i7);
        var lostPoint = QRUtil.getLostPoint(this);
        if (i7 == 0 || minLostPoint > lostPoint) {
          minLostPoint = lostPoint;
          pattern = i7;
        }
      }
      return pattern;
    }, createMovieClip: function(target_mc, instance_name, depth) {
      var qr_mc = target_mc.createEmptyMovieClip(instance_name, depth);
      var cs2 = 1;
      this.make();
      for (var row = 0; row < this.modules.length; row++) {
        var y5 = row * cs2;
        for (var col = 0; col < this.modules[row].length; col++) {
          var x6 = col * cs2;
          var dark = this.modules[row][col];
          if (dark) {
            qr_mc.beginFill(0, 100);
            qr_mc.moveTo(x6, y5);
            qr_mc.lineTo(x6 + cs2, y5);
            qr_mc.lineTo(x6 + cs2, y5 + cs2);
            qr_mc.lineTo(x6, y5 + cs2);
            qr_mc.endFill();
          }
        }
      }
      return qr_mc;
    }, setupTimingPattern: function() {
      for (var r6 = 8; r6 < this.moduleCount - 8; r6++) {
        if (this.modules[r6][6] != null) {
          continue;
        }
        this.modules[r6][6] = r6 % 2 == 0;
      }
      for (var c5 = 8; c5 < this.moduleCount - 8; c5++) {
        if (this.modules[6][c5] != null) {
          continue;
        }
        this.modules[6][c5] = c5 % 2 == 0;
      }
    }, setupPositionAdjustPattern: function() {
      var pos = QRUtil.getPatternPosition(this.typeNumber);
      for (var i7 = 0; i7 < pos.length; i7++) {
        for (var j8 = 0; j8 < pos.length; j8++) {
          var row = pos[i7];
          var col = pos[j8];
          if (this.modules[row][col] != null) {
            continue;
          }
          for (var r6 = -2; r6 <= 2; r6++) {
            for (var c5 = -2; c5 <= 2; c5++) {
              if (r6 == -2 || r6 == 2 || c5 == -2 || c5 == 2 || r6 == 0 && c5 == 0) {
                this.modules[row + r6][col + c5] = true;
              } else {
                this.modules[row + r6][col + c5] = false;
              }
            }
          }
        }
      }
    }, setupTypeNumber: function(test) {
      var bits = QRUtil.getBCHTypeNumber(this.typeNumber);
      for (var i7 = 0; i7 < 18; i7++) {
        var mod2 = !test && (bits >> i7 & 1) == 1;
        this.modules[Math.floor(i7 / 3)][i7 % 3 + this.moduleCount - 8 - 3] = mod2;
      }
      for (var i7 = 0; i7 < 18; i7++) {
        var mod2 = !test && (bits >> i7 & 1) == 1;
        this.modules[i7 % 3 + this.moduleCount - 8 - 3][Math.floor(i7 / 3)] = mod2;
      }
    }, setupTypeInfo: function(test, maskPattern) {
      var data = this.errorCorrectLevel << 3 | maskPattern;
      var bits = QRUtil.getBCHTypeInfo(data);
      for (var i7 = 0; i7 < 15; i7++) {
        var mod2 = !test && (bits >> i7 & 1) == 1;
        if (i7 < 6) {
          this.modules[i7][8] = mod2;
        } else if (i7 < 8) {
          this.modules[i7 + 1][8] = mod2;
        } else {
          this.modules[this.moduleCount - 15 + i7][8] = mod2;
        }
      }
      for (var i7 = 0; i7 < 15; i7++) {
        var mod2 = !test && (bits >> i7 & 1) == 1;
        if (i7 < 8) {
          this.modules[8][this.moduleCount - i7 - 1] = mod2;
        } else if (i7 < 9) {
          this.modules[8][15 - i7 - 1 + 1] = mod2;
        } else {
          this.modules[8][15 - i7 - 1] = mod2;
        }
      }
      this.modules[this.moduleCount - 8][8] = !test;
    }, mapData: function(data, maskPattern) {
      var inc = -1;
      var row = this.moduleCount - 1;
      var bitIndex = 7;
      var byteIndex = 0;
      for (var col = this.moduleCount - 1; col > 0; col -= 2) {
        if (col == 6)
          col--;
        while (true) {
          for (var c5 = 0; c5 < 2; c5++) {
            if (this.modules[row][col - c5] == null) {
              var dark = false;
              if (byteIndex < data.length) {
                dark = (data[byteIndex] >>> bitIndex & 1) == 1;
              }
              var mask = QRUtil.getMask(maskPattern, row, col - c5);
              if (mask) {
                dark = !dark;
              }
              this.modules[row][col - c5] = dark;
              bitIndex--;
              if (bitIndex == -1) {
                byteIndex++;
                bitIndex = 7;
              }
            }
          }
          row += inc;
          if (row < 0 || this.moduleCount <= row) {
            row -= inc;
            inc = -inc;
            break;
          }
        }
      }
    } };
    QRCodeModel.PAD0 = 236;
    QRCodeModel.PAD1 = 17;
    QRCodeModel.createData = function(typeNumber, errorCorrectLevel, dataList) {
      var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectLevel);
      var buffer2 = new QRBitBuffer();
      for (var i7 = 0; i7 < dataList.length; i7++) {
        var data = dataList[i7];
        buffer2.put(data.mode, 4);
        buffer2.put(data.getLength(), QRUtil.getLengthInBits(data.mode, typeNumber));
        data.write(buffer2);
      }
      var totalDataCount = 0;
      for (var i7 = 0; i7 < rsBlocks.length; i7++) {
        totalDataCount += rsBlocks[i7].dataCount;
      }
      if (buffer2.getLengthInBits() > totalDataCount * 8) {
        throw new Error("code length overflow. (" + buffer2.getLengthInBits() + ">" + totalDataCount * 8 + ")");
      }
      if (buffer2.getLengthInBits() + 4 <= totalDataCount * 8) {
        buffer2.put(0, 4);
      }
      while (buffer2.getLengthInBits() % 8 != 0) {
        buffer2.putBit(false);
      }
      while (true) {
        if (buffer2.getLengthInBits() >= totalDataCount * 8) {
          break;
        }
        buffer2.put(QRCodeModel.PAD0, 8);
        if (buffer2.getLengthInBits() >= totalDataCount * 8) {
          break;
        }
        buffer2.put(QRCodeModel.PAD1, 8);
      }
      return QRCodeModel.createBytes(buffer2, rsBlocks);
    };
    QRCodeModel.createBytes = function(buffer2, rsBlocks) {
      var offset = 0;
      var maxDcCount = 0;
      var maxEcCount = 0;
      var dcdata = new Array(rsBlocks.length);
      var ecdata = new Array(rsBlocks.length);
      for (var r6 = 0; r6 < rsBlocks.length; r6++) {
        var dcCount = rsBlocks[r6].dataCount;
        var ecCount = rsBlocks[r6].totalCount - dcCount;
        maxDcCount = Math.max(maxDcCount, dcCount);
        maxEcCount = Math.max(maxEcCount, ecCount);
        dcdata[r6] = new Array(dcCount);
        for (var i7 = 0; i7 < dcdata[r6].length; i7++) {
          dcdata[r6][i7] = 255 & buffer2.buffer[i7 + offset];
        }
        offset += dcCount;
        var rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);
        var rawPoly = new QRPolynomial(dcdata[r6], rsPoly.getLength() - 1);
        var modPoly = rawPoly.mod(rsPoly);
        ecdata[r6] = new Array(rsPoly.getLength() - 1);
        for (var i7 = 0; i7 < ecdata[r6].length; i7++) {
          var modIndex = i7 + modPoly.getLength() - ecdata[r6].length;
          ecdata[r6][i7] = modIndex >= 0 ? modPoly.get(modIndex) : 0;
        }
      }
      var totalCodeCount = 0;
      for (var i7 = 0; i7 < rsBlocks.length; i7++) {
        totalCodeCount += rsBlocks[i7].totalCount;
      }
      var data = new Array(totalCodeCount);
      var index = 0;
      for (var i7 = 0; i7 < maxDcCount; i7++) {
        for (var r6 = 0; r6 < rsBlocks.length; r6++) {
          if (i7 < dcdata[r6].length) {
            data[index++] = dcdata[r6][i7];
          }
        }
      }
      for (var i7 = 0; i7 < maxEcCount; i7++) {
        for (var r6 = 0; r6 < rsBlocks.length; r6++) {
          if (i7 < ecdata[r6].length) {
            data[index++] = ecdata[r6][i7];
          }
        }
      }
      return data;
    };
    var QRMode = { MODE_NUMBER: 1 << 0, MODE_ALPHA_NUM: 1 << 1, MODE_8BIT_BYTE: 1 << 2, MODE_KANJI: 1 << 3 };
    var QRErrorCorrectLevel = { L: 1, M: 0, Q: 3, H: 2 };
    var QRMaskPattern = { PATTERN000: 0, PATTERN001: 1, PATTERN010: 2, PATTERN011: 3, PATTERN100: 4, PATTERN101: 5, PATTERN110: 6, PATTERN111: 7 };
    var QRUtil = { PATTERN_POSITION_TABLE: [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]], G15: 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0, G18: 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0, G15_MASK: 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1, getBCHTypeInfo: function(data) {
      var d6 = data << 10;
      while (QRUtil.getBCHDigit(d6) - QRUtil.getBCHDigit(QRUtil.G15) >= 0) {
        d6 ^= QRUtil.G15 << QRUtil.getBCHDigit(d6) - QRUtil.getBCHDigit(QRUtil.G15);
      }
      return (data << 10 | d6) ^ QRUtil.G15_MASK;
    }, getBCHTypeNumber: function(data) {
      var d6 = data << 12;
      while (QRUtil.getBCHDigit(d6) - QRUtil.getBCHDigit(QRUtil.G18) >= 0) {
        d6 ^= QRUtil.G18 << QRUtil.getBCHDigit(d6) - QRUtil.getBCHDigit(QRUtil.G18);
      }
      return data << 12 | d6;
    }, getBCHDigit: function(data) {
      var digit = 0;
      while (data != 0) {
        digit++;
        data >>>= 1;
      }
      return digit;
    }, getPatternPosition: function(typeNumber) {
      return QRUtil.PATTERN_POSITION_TABLE[typeNumber - 1];
    }, getMask: function(maskPattern, i7, j8) {
      switch (maskPattern) {
        case QRMaskPattern.PATTERN000:
          return (i7 + j8) % 2 == 0;
        case QRMaskPattern.PATTERN001:
          return i7 % 2 == 0;
        case QRMaskPattern.PATTERN010:
          return j8 % 3 == 0;
        case QRMaskPattern.PATTERN011:
          return (i7 + j8) % 3 == 0;
        case QRMaskPattern.PATTERN100:
          return (Math.floor(i7 / 2) + Math.floor(j8 / 3)) % 2 == 0;
        case QRMaskPattern.PATTERN101:
          return i7 * j8 % 2 + i7 * j8 % 3 == 0;
        case QRMaskPattern.PATTERN110:
          return (i7 * j8 % 2 + i7 * j8 % 3) % 2 == 0;
        case QRMaskPattern.PATTERN111:
          return (i7 * j8 % 3 + (i7 + j8) % 2) % 2 == 0;
        default:
          throw new Error("bad maskPattern:" + maskPattern);
      }
    }, getErrorCorrectPolynomial: function(errorCorrectLength) {
      var a5 = new QRPolynomial([1], 0);
      for (var i7 = 0; i7 < errorCorrectLength; i7++) {
        a5 = a5.multiply(new QRPolynomial([1, QRMath.gexp(i7)], 0));
      }
      return a5;
    }, getLengthInBits: function(mode, type) {
      if (1 <= type && type < 10) {
        switch (mode) {
          case QRMode.MODE_NUMBER:
            return 10;
          case QRMode.MODE_ALPHA_NUM:
            return 9;
          case QRMode.MODE_8BIT_BYTE:
            return 8;
          case QRMode.MODE_KANJI:
            return 8;
          default:
            throw new Error("mode:" + mode);
        }
      } else if (type < 27) {
        switch (mode) {
          case QRMode.MODE_NUMBER:
            return 12;
          case QRMode.MODE_ALPHA_NUM:
            return 11;
          case QRMode.MODE_8BIT_BYTE:
            return 16;
          case QRMode.MODE_KANJI:
            return 10;
          default:
            throw new Error("mode:" + mode);
        }
      } else if (type < 41) {
        switch (mode) {
          case QRMode.MODE_NUMBER:
            return 14;
          case QRMode.MODE_ALPHA_NUM:
            return 13;
          case QRMode.MODE_8BIT_BYTE:
            return 16;
          case QRMode.MODE_KANJI:
            return 12;
          default:
            throw new Error("mode:" + mode);
        }
      } else {
        throw new Error("type:" + type);
      }
    }, getLostPoint: function(qrCode) {
      var moduleCount = qrCode.getModuleCount();
      var lostPoint = 0;
      for (var row = 0; row < moduleCount; row++) {
        for (var col = 0; col < moduleCount; col++) {
          var sameCount = 0;
          var dark = qrCode.isDark(row, col);
          for (var r6 = -1; r6 <= 1; r6++) {
            if (row + r6 < 0 || moduleCount <= row + r6) {
              continue;
            }
            for (var c5 = -1; c5 <= 1; c5++) {
              if (col + c5 < 0 || moduleCount <= col + c5) {
                continue;
              }
              if (r6 == 0 && c5 == 0) {
                continue;
              }
              if (dark == qrCode.isDark(row + r6, col + c5)) {
                sameCount++;
              }
            }
          }
          if (sameCount > 5) {
            lostPoint += 3 + sameCount - 5;
          }
        }
      }
      for (var row = 0; row < moduleCount - 1; row++) {
        for (var col = 0; col < moduleCount - 1; col++) {
          var count2 = 0;
          if (qrCode.isDark(row, col))
            count2++;
          if (qrCode.isDark(row + 1, col))
            count2++;
          if (qrCode.isDark(row, col + 1))
            count2++;
          if (qrCode.isDark(row + 1, col + 1))
            count2++;
          if (count2 == 0 || count2 == 4) {
            lostPoint += 3;
          }
        }
      }
      for (var row = 0; row < moduleCount; row++) {
        for (var col = 0; col < moduleCount - 6; col++) {
          if (qrCode.isDark(row, col) && !qrCode.isDark(row, col + 1) && qrCode.isDark(row, col + 2) && qrCode.isDark(row, col + 3) && qrCode.isDark(row, col + 4) && !qrCode.isDark(row, col + 5) && qrCode.isDark(row, col + 6)) {
            lostPoint += 40;
          }
        }
      }
      for (var col = 0; col < moduleCount; col++) {
        for (var row = 0; row < moduleCount - 6; row++) {
          if (qrCode.isDark(row, col) && !qrCode.isDark(row + 1, col) && qrCode.isDark(row + 2, col) && qrCode.isDark(row + 3, col) && qrCode.isDark(row + 4, col) && !qrCode.isDark(row + 5, col) && qrCode.isDark(row + 6, col)) {
            lostPoint += 40;
          }
        }
      }
      var darkCount = 0;
      for (var col = 0; col < moduleCount; col++) {
        for (var row = 0; row < moduleCount; row++) {
          if (qrCode.isDark(row, col)) {
            darkCount++;
          }
        }
      }
      var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
      lostPoint += ratio * 10;
      return lostPoint;
    } };
    var QRMath = { glog: function(n4) {
      if (n4 < 1) {
        throw new Error("glog(" + n4 + ")");
      }
      return QRMath.LOG_TABLE[n4];
    }, gexp: function(n4) {
      while (n4 < 0) {
        n4 += 255;
      }
      while (n4 >= 256) {
        n4 -= 255;
      }
      return QRMath.EXP_TABLE[n4];
    }, EXP_TABLE: new Array(256), LOG_TABLE: new Array(256) };
    for (i6 = 0; i6 < 8; i6++) {
      QRMath.EXP_TABLE[i6] = 1 << i6;
    }
    var i6;
    for (i6 = 8; i6 < 256; i6++) {
      QRMath.EXP_TABLE[i6] = QRMath.EXP_TABLE[i6 - 4] ^ QRMath.EXP_TABLE[i6 - 5] ^ QRMath.EXP_TABLE[i6 - 6] ^ QRMath.EXP_TABLE[i6 - 8];
    }
    var i6;
    for (i6 = 0; i6 < 255; i6++) {
      QRMath.LOG_TABLE[QRMath.EXP_TABLE[i6]] = i6;
    }
    var i6;
    function QRPolynomial(num, shift) {
      if (num.length == void 0) {
        throw new Error(num.length + "/" + shift);
      }
      var offset = 0;
      while (offset < num.length && num[offset] == 0) {
        offset++;
      }
      this.num = new Array(num.length - offset + shift);
      for (var i7 = 0; i7 < num.length - offset; i7++) {
        this.num[i7] = num[i7 + offset];
      }
    }
    QRPolynomial.prototype = { get: function(index) {
      return this.num[index];
    }, getLength: function() {
      return this.num.length;
    }, multiply: function(e6) {
      var num = new Array(this.getLength() + e6.getLength() - 1);
      for (var i7 = 0; i7 < this.getLength(); i7++) {
        for (var j8 = 0; j8 < e6.getLength(); j8++) {
          num[i7 + j8] ^= QRMath.gexp(QRMath.glog(this.get(i7)) + QRMath.glog(e6.get(j8)));
        }
      }
      return new QRPolynomial(num, 0);
    }, mod: function(e6) {
      if (this.getLength() - e6.getLength() < 0) {
        return this;
      }
      var ratio = QRMath.glog(this.get(0)) - QRMath.glog(e6.get(0));
      var num = new Array(this.getLength());
      for (var i7 = 0; i7 < this.getLength(); i7++) {
        num[i7] = this.get(i7);
      }
      for (var i7 = 0; i7 < e6.getLength(); i7++) {
        num[i7] ^= QRMath.gexp(QRMath.glog(e6.get(i7)) + ratio);
      }
      return new QRPolynomial(num, 0).mod(e6);
    } };
    function QRRSBlock(totalCount, dataCount) {
      this.totalCount = totalCount;
      this.dataCount = dataCount;
    }
    QRRSBlock.RS_BLOCK_TABLE = [[1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9], [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16], [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13], [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9], [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12], [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15], [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14], [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15], [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13], [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16], [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13], [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15], [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12], [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13], [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12], [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16], [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15], [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15], [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14], [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16], [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17], [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13], [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16], [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17], [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16], [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17], [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16], [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16], [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16], [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16], [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16], [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16], [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16], [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17], [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16], [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16], [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16], [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16], [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16], [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]];
    QRRSBlock.getRSBlocks = function(typeNumber, errorCorrectLevel) {
      var rsBlock = QRRSBlock.getRsBlockTable(typeNumber, errorCorrectLevel);
      if (rsBlock == void 0) {
        throw new Error("bad rs block @ typeNumber:" + typeNumber + "/errorCorrectLevel:" + errorCorrectLevel);
      }
      var length = rsBlock.length / 3;
      var list = [];
      for (var i7 = 0; i7 < length; i7++) {
        var count2 = rsBlock[i7 * 3 + 0];
        var totalCount = rsBlock[i7 * 3 + 1];
        var dataCount = rsBlock[i7 * 3 + 2];
        for (var j8 = 0; j8 < count2; j8++) {
          list.push(new QRRSBlock(totalCount, dataCount));
        }
      }
      return list;
    };
    QRRSBlock.getRsBlockTable = function(typeNumber, errorCorrectLevel) {
      switch (errorCorrectLevel) {
        case QRErrorCorrectLevel.L:
          return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
        case QRErrorCorrectLevel.M:
          return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
        case QRErrorCorrectLevel.Q:
          return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
        case QRErrorCorrectLevel.H:
          return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
    function QRBitBuffer() {
      this.buffer = [];
      this.length = 0;
    }
    QRBitBuffer.prototype = { get: function(index) {
      var bufIndex = Math.floor(index / 8);
      return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) == 1;
    }, put: function(num, length) {
      for (var i7 = 0; i7 < length; i7++) {
        this.putBit((num >>> length - i7 - 1 & 1) == 1);
      }
    }, getLengthInBits: function() {
      return this.length;
    }, putBit: function(bit) {
      var bufIndex = Math.floor(this.length / 8);
      if (this.buffer.length <= bufIndex) {
        this.buffer.push(0);
      }
      if (bit) {
        this.buffer[bufIndex] |= 128 >>> this.length % 8;
      }
      this.length++;
    } };
    var QRCodeLimitLength = [[17, 14, 11, 7], [32, 26, 20, 14], [53, 42, 32, 24], [78, 62, 46, 34], [106, 84, 60, 44], [134, 106, 74, 58], [154, 122, 86, 64], [192, 152, 108, 84], [230, 180, 130, 98], [271, 213, 151, 119], [321, 251, 177, 137], [367, 287, 203, 155], [425, 331, 241, 177], [458, 362, 258, 194], [520, 412, 292, 220], [586, 450, 322, 250], [644, 504, 364, 280], [718, 560, 394, 310], [792, 624, 442, 338], [858, 666, 482, 382], [929, 711, 509, 403], [1003, 779, 565, 439], [1091, 857, 611, 461], [1171, 911, 661, 511], [1273, 997, 715, 535], [1367, 1059, 751, 593], [1465, 1125, 805, 625], [1528, 1190, 868, 658], [1628, 1264, 908, 698], [1732, 1370, 982, 742], [1840, 1452, 1030, 790], [1952, 1538, 1112, 842], [2068, 1628, 1168, 898], [2188, 1722, 1228, 958], [2303, 1809, 1283, 983], [2431, 1911, 1351, 1051], [2563, 1989, 1423, 1093], [2699, 2099, 1499, 1139], [2809, 2213, 1579, 1219], [2953, 2331, 1663, 1273]];
    function QRCode(options) {
      var instance = this;
      this.options = {
        padding: 4,
        width: 256,
        height: 256,
        typeNumber: 4,
        color: "#000000",
        background: "#ffffff",
        ecl: "M",
        image: {
          svg: "",
          width: 0,
          height: 0
        }
      };
      if (typeof options === "string") {
        options = {
          content: options
        };
      }
      if (options) {
        for (var i7 in options) {
          this.options[i7] = options[i7];
        }
      }
      if (typeof this.options.content !== "string") {
        throw new Error("Expected 'content' as string!");
      }
      if (this.options.content.length === 0) {
        throw new Error("Expected 'content' to be non-empty!");
      }
      if (!(this.options.padding >= 0)) {
        throw new Error("Expected 'padding' value to be non-negative!");
      }
      if (!(this.options.width > 0) || !(this.options.height > 0)) {
        throw new Error("Expected 'width' or 'height' value to be higher than zero!");
      }
      function _getErrorCorrectLevel(ecl2) {
        switch (ecl2) {
          case "L":
            return QRErrorCorrectLevel.L;
          case "M":
            return QRErrorCorrectLevel.M;
          case "Q":
            return QRErrorCorrectLevel.Q;
          case "H":
            return QRErrorCorrectLevel.H;
          default:
            throw new Error("Unknwon error correction level: " + ecl2);
        }
      }
      function _getTypeNumber(content2, ecl2) {
        var length = _getUTF8Length(content2);
        var type2 = 1;
        var limit = 0;
        for (var i8 = 0, len = QRCodeLimitLength.length; i8 <= len; i8++) {
          var table = QRCodeLimitLength[i8];
          if (!table) {
            throw new Error("Content too long: expected " + limit + " but got " + length);
          }
          switch (ecl2) {
            case "L":
              limit = table[0];
              break;
            case "M":
              limit = table[1];
              break;
            case "Q":
              limit = table[2];
              break;
            case "H":
              limit = table[3];
              break;
            default:
              throw new Error("Unknwon error correction level: " + ecl2);
          }
          if (length <= limit) {
            break;
          }
          type2++;
        }
        if (type2 > QRCodeLimitLength.length) {
          throw new Error("Content too long");
        }
        return type2;
      }
      function _getUTF8Length(content2) {
        var result = encodeURI(content2).toString().replace(/\%[0-9a-fA-F]{2}/g, "a");
        return result.length + (result.length != content2 ? 3 : 0);
      }
      var content = this.options.content;
      var type = _getTypeNumber(content, this.options.ecl);
      var ecl = _getErrorCorrectLevel(this.options.ecl);
      this.qrcode = new QRCodeModel(type, ecl);
      this.qrcode.addData(content);
      this.qrcode.make();
    }
    QRCode.prototype.svg = function(opt) {
      var options = this.options || {};
      var modules = this.qrcode.modules;
      if (typeof opt == "undefined") {
        opt = { container: options.container || "svg" };
      }
      var pretty = typeof options.pretty != "undefined" ? !!options.pretty : true;
      var indent = pretty ? "  " : "";
      var EOL = pretty ? "\r\n" : "";
      var width = options.width;
      var height = options.height;
      var length = modules.length;
      var xsize = width / (length + 2 * options.padding);
      var ysize = height / (length + 2 * options.padding);
      var join = typeof options.join != "undefined" ? !!options.join : false;
      var swap = typeof options.swap != "undefined" ? !!options.swap : false;
      var xmlDeclaration = typeof options.xmlDeclaration != "undefined" ? !!options.xmlDeclaration : true;
      var predefined = typeof options.predefined != "undefined" ? !!options.predefined : false;
      var defs = predefined ? indent + '<defs><path id="qrmodule" d="M0 0 h' + ysize + " v" + xsize + ' H0 z" style="fill:' + options.color + ';shape-rendering:crispEdges;" /></defs>' + EOL : "";
      var bgrect = indent + '<rect x="0" y="0" width="' + width + '" height="' + height + '" style="fill:' + options.background + ';shape-rendering:crispEdges;"/>' + EOL;
      var modrect = "";
      var pathdata = "";
      for (var y5 = 0; y5 < length; y5++) {
        for (var x6 = 0; x6 < length; x6++) {
          var module3 = modules[x6][y5];
          if (module3) {
            var px = x6 * xsize + options.padding * xsize;
            var py = y5 * ysize + options.padding * ysize;
            if (swap) {
              var t6 = px;
              px = py;
              py = t6;
            }
            if (join) {
              var w8 = xsize + px;
              var h6 = ysize + py;
              px = Number.isInteger(px) ? Number(px) : px.toFixed(2);
              py = Number.isInteger(py) ? Number(py) : py.toFixed(2);
              w8 = Number.isInteger(w8) ? Number(w8) : w8.toFixed(2);
              h6 = Number.isInteger(h6) ? Number(h6) : h6.toFixed(2);
              pathdata += "M" + px + "," + py + " V" + h6 + " H" + w8 + " V" + py + " H" + px + " Z ";
            } else if (predefined) {
              modrect += indent + '<use x="' + px.toString() + '" y="' + py.toString() + '" href="#qrmodule" />' + EOL;
            } else {
              modrect += indent + '<rect x="' + px.toString() + '" y="' + py.toString() + '" width="' + xsize + '" height="' + ysize + '" style="fill:' + options.color + ';shape-rendering:crispEdges;"/>' + EOL;
            }
          }
        }
      }
      if (join) {
        modrect = indent + '<path x="0" y="0" style="fill:' + options.color + ';shape-rendering:crispEdges;" d="' + pathdata + '" />';
      }
      let imgSvg = "";
      if (this.options.image !== void 0 && this.options.image.svg) {
        const imgWidth = width * this.options.image.width / 100;
        const imgHeight = height * this.options.image.height / 100;
        const imgX = width / 2 - imgWidth / 2;
        const imgY = height / 2 - imgHeight / 2;
        imgSvg += `<svg x="${imgX}" y="${imgY}" width="${imgWidth}" height="${imgHeight}" viewBox="0 0 100 100" preserveAspectRatio="xMinYMin meet">`;
        imgSvg += this.options.image.svg + EOL;
        imgSvg += "</svg>";
      }
      var svg = "";
      switch (opt.container) {
        case "svg":
          if (xmlDeclaration) {
            svg += '<?xml version="1.0" standalone="yes"?>' + EOL;
          }
          svg += '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="' + width + '" height="' + height + '">' + EOL;
          svg += defs + bgrect + modrect;
          svg += imgSvg;
          svg += "</svg>";
          break;
        case "svg-viewbox":
          if (xmlDeclaration) {
            svg += '<?xml version="1.0" standalone="yes"?>' + EOL;
          }
          svg += '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 ' + width + " " + height + '">' + EOL;
          svg += defs + bgrect + modrect;
          svg += imgSvg;
          svg += "</svg>";
          break;
        case "g":
          svg += '<g width="' + width + '" height="' + height + '">' + EOL;
          svg += defs + bgrect + modrect;
          svg += imgSvg;
          svg += "</g>";
          break;
        default:
          svg += (defs + bgrect + modrect + imgSvg).replace(/^\s+/, "");
          break;
      }
      return svg;
    };
    module2.exports = QRCode;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/QRCode.js
var require_QRCode = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/QRCode.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QRCode = void 0;
    var preact_1 = (init_preact_module(), __toCommonJS(preact_module_exports));
    var hooks_1 = (init_hooks_module(), __toCommonJS(hooks_module_exports));
    var qrcode_svg_1 = __importDefault(require_qrcode_svg());
    var QRCode = (props) => {
      const [svg, setSvg] = (0, hooks_1.useState)("");
      (0, hooks_1.useEffect)(() => {
        var _a2, _b;
        const qrcode = new qrcode_svg_1.default({
          content: props.content,
          background: props.bgColor || "#ffffff",
          color: props.fgColor || "#000000",
          container: "svg",
          ecl: "M",
          width: (_a2 = props.width) !== null && _a2 !== void 0 ? _a2 : 256,
          height: (_b = props.height) !== null && _b !== void 0 ? _b : 256,
          padding: 0,
          image: props.image
        });
        const base64 = Buffer.from(qrcode.svg(), "utf8").toString("base64");
        setSvg(`data:image/svg+xml;base64,${base64}`);
      });
      return svg ? (0, preact_1.h)("img", { src: svg, alt: "QR Code" }) : null;
    };
    exports2.QRCode = QRCode;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/Spinner-css.js
var require_Spinner_css = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/Spinner-css.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = `.-cbwsdk-css-reset .-cbwsdk-spinner{display:inline-block}.-cbwsdk-css-reset .-cbwsdk-spinner svg{display:inline-block;animation:2s linear infinite -cbwsdk-spinner-svg}.-cbwsdk-css-reset .-cbwsdk-spinner svg circle{animation:1.9s ease-in-out infinite both -cbwsdk-spinner-circle;display:block;fill:rgba(0,0,0,0);stroke-dasharray:283;stroke-dashoffset:280;stroke-linecap:round;stroke-width:10px;transform-origin:50% 50%}@keyframes -cbwsdk-spinner-svg{0%{transform:rotateZ(0deg)}100%{transform:rotateZ(360deg)}}@keyframes -cbwsdk-spinner-circle{0%,25%{stroke-dashoffset:280;transform:rotate(0)}50%,75%{stroke-dashoffset:75;transform:rotate(45deg)}100%{stroke-dashoffset:280;transform:rotate(360deg)}}`;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/Spinner.js
var require_Spinner = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/Spinner.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Spinner = void 0;
    var preact_1 = (init_preact_module(), __toCommonJS(preact_module_exports));
    var Spinner_css_1 = __importDefault(require_Spinner_css());
    var Spinner = (props) => {
      var _a2;
      const size = (_a2 = props.size) !== null && _a2 !== void 0 ? _a2 : 64;
      const color = props.color || "#000";
      return (0, preact_1.h)(
        "div",
        { class: "-cbwsdk-spinner" },
        (0, preact_1.h)("style", null, Spinner_css_1.default),
        (0, preact_1.h)(
          "svg",
          { viewBox: "0 0 100 100", xmlns: "http://www.w3.org/2000/svg", style: { width: size, height: size } },
          (0, preact_1.h)("circle", { style: { cx: 50, cy: 50, r: 45, stroke: color } })
        )
      );
    };
    exports2.Spinner = Spinner;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/TryExtensionLinkDialog-css.js
var require_TryExtensionLinkDialog_css = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/TryExtensionLinkDialog-css.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = `.-cbwsdk-css-reset .-cbwsdk-extension-dialog{z-index:2147483647;position:fixed;top:0;left:0;right:0;bottom:0;display:flex;align-items:center;justify-content:center}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-backdrop{z-index:2147483647;position:fixed;top:0;left:0;right:0;bottom:0;background-color:rgba(0,0,0,.5);transition:opacity .25s}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-backdrop-hidden{opacity:0}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box{display:flex;position:relative;max-width:500px;flex-direction:column;transform:scale(1);transition:opacity .25s,transform .25s}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-hidden{opacity:0;transform:scale(0.85)}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-top{display:flex;flex-direction:row;background-color:#fff;border-radius:8px;overflow:hidden;min-height:300px}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-top-subtext{margin-top:15px;font-size:12px;line-height:1.5}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-top-install-region{display:flex;flex-basis:50%;flex-direction:column;justify-content:center;padding:32px}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-top-install-region button{display:block;border-radius:8px;background-color:#1652f0;color:#fff;width:90%;min-width:fit-content;height:44px;margin-top:16px;font-size:16px;padding-left:16px;padding-right:16px;cursor:pointer;font-weight:500;text-align:center}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-top-info-region{display:flex;flex-basis:50%;flex-direction:column;justify-content:center;background-color:#fafbfc}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-top-description{display:flex;flex-direction:row;align-items:center;padding-top:14px;padding-bottom:14px;padding-left:24px;padding-right:32px}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-top-description-icon-wrapper{display:block;position:relative;width:40px;height:40px;flex-shrink:0;flex-grow:0;border-radius:20px;background-color:#fff;box-shadow:0px 0px 8px rgba(0,0,0,.04),0px 16px 24px rgba(0,0,0,.06)}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-top-description-icon-wrapper img{position:absolute;top:0;bottom:0;left:0;right:0;margin:auto}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-top-description-text{margin-left:16px;flex-grow:1;font-size:13px;line-height:19px;color:#000;align-self:center}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-bottom{display:flex;flex-direction:row;overflow:hidden;border-radius:8px;background-color:#fff;margin-top:8px}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-bottom-description-region{display:flex;flex-direction:column;justify-content:center;padding:32px;flex-grow:1}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-bottom-description{font-size:13px;line-height:19px;margin-top:12px;color:#aaa}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-bottom-description a{font-size:inherit;line-height:inherit;color:#1652f0;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-bottom-qr-region{position:relative;flex-shrink:0;display:flex;flex-direction:column;justify-content:center;padding-left:24px;padding-right:24px;padding-top:16px;padding-bottom:16px}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-bottom-qr-wrapper{position:relative;display:block;padding:8px;border-radius:8px;box-shadow:0px 4px 12px rgba(0,0,0,.1)}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-bottom-qr-wrapper img{display:block}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-bottom-qr-connecting{position:absolute;top:0;bottom:0;left:0;right:0;display:flex;flex-direction:column;align-items:center;justify-content:center;background-color:rgba(255,255,255,.95)}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-bottom-qr-connecting>p{font-size:12px;font-weight:bold;color:#000;margin-top:16px}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-cancel{position:absolute;-webkit-appearance:none;display:flex;align-items:center;justify-content:center;top:16px;right:16px;width:24px;height:24px;border-radius:12px;background-color:#fafbfc;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-cancel-x{position:relative;display:block;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-cancel-x::before,.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-cancel-x::after{content:"";position:absolute;display:block;top:-1px;left:-7px;width:14px;height:1px;background-color:#000;transition:background-color .2s}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-cancel-x::before{transform:rotate(45deg)}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-cancel-x::after{transform:rotate(135deg)}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-cancel:hover .-cbwsdk-link-dialog-box-cancel-x-a,.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-cancel:hover .-cbwsdk-link-dialog-box-cancel-x-b{background-color:#000}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-container{display:block}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-container-hidden{display:none}.-cbwsdk-css-reset .-cbwsdk-extension-dialog h2{display:block;text-align:left;font-size:22px;font-weight:600;line-height:28px;color:#000}`;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/TryExtensionLinkDialog.js
var require_TryExtensionLinkDialog = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/TryExtensionLinkDialog.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TryExtensionLinkDialog = void 0;
    var clsx_1 = __importDefault((init_clsx_m(), __toCommonJS(clsx_m_exports)));
    var preact_1 = (init_preact_module(), __toCommonJS(preact_module_exports));
    var hooks_1 = (init_hooks_module(), __toCommonJS(hooks_module_exports));
    var util_1 = require_util3();
    var version_1 = require_version();
    var globe_icon_svg_1 = __importDefault(require_globe_icon_svg());
    var link_icon_svg_1 = __importDefault(require_link_icon_svg());
    var lock_icon_svg_1 = __importDefault(require_lock_icon_svg());
    var QRLogo_1 = __importDefault(require_QRLogo());
    var QRCode_1 = require_QRCode();
    var Spinner_1 = require_Spinner();
    var TryExtensionLinkDialog_css_1 = __importDefault(require_TryExtensionLinkDialog_css());
    var TryExtensionLinkDialog = (props) => {
      const [isContainerHidden, setContainerHidden] = (0, hooks_1.useState)(!props.isOpen);
      const [isDialogHidden, setDialogHidden] = (0, hooks_1.useState)(!props.isOpen);
      (0, hooks_1.useEffect)(() => {
        const { isOpen } = props;
        const timers = [
          window.setTimeout(() => {
            setDialogHidden(!isOpen);
          }, 10)
        ];
        if (isOpen) {
          setContainerHidden(false);
        } else {
          timers.push(window.setTimeout(() => {
            setContainerHidden(true);
          }, 360));
        }
        return () => {
          timers.forEach(window.clearTimeout);
        };
      }, [props.isOpen]);
      return (0, preact_1.h)(
        "div",
        { class: (0, clsx_1.default)("-cbwsdk-extension-dialog-container", isContainerHidden && "-cbwsdk-extension-dialog-container-hidden") },
        (0, preact_1.h)("style", null, TryExtensionLinkDialog_css_1.default),
        (0, preact_1.h)("div", { class: (0, clsx_1.default)("-cbwsdk-extension-dialog-backdrop", isDialogHidden && "-cbwsdk-extension-dialog-backdrop-hidden") }),
        (0, preact_1.h)(
          "div",
          { class: "-cbwsdk-extension-dialog" },
          (0, preact_1.h)(
            "div",
            { class: (0, clsx_1.default)("-cbwsdk-extension-dialog-box", isDialogHidden && "-cbwsdk-extension-dialog-box-hidden") },
            (0, preact_1.h)(TryExtensionBox, { onInstallClick: () => {
              window.open("https://api.wallet.coinbase.com/rpc/v2/desktop/chrome", "_blank");
            } }),
            !props.connectDisabled ? (0, preact_1.h)(ScanQRBox, { darkMode: props.darkMode, version: props.version, sessionId: props.sessionId, sessionSecret: props.sessionSecret, linkAPIUrl: props.linkAPIUrl, isConnected: props.isConnected, isParentConnection: props.isParentConnection }) : null,
            props.onCancel && (0, preact_1.h)(CancelButton, { onClick: props.onCancel })
          )
        )
      );
    };
    exports2.TryExtensionLinkDialog = TryExtensionLinkDialog;
    var TryExtensionBox = ({ onInstallClick }) => {
      const [isClicked, setIsClicked] = (0, hooks_1.useState)(false);
      const clickHandler = (0, hooks_1.useCallback)(() => {
        if (isClicked) {
          window.location.reload();
        } else {
          onInstallClick();
          setIsClicked(true);
        }
      }, [onInstallClick, isClicked]);
      return (0, preact_1.h)(
        "div",
        { class: "-cbwsdk-extension-dialog-box-top" },
        (0, preact_1.h)(
          "div",
          { class: "-cbwsdk-extension-dialog-box-top-install-region" },
          (0, preact_1.h)("h2", null, "Try the Coinbase Wallet extension"),
          isClicked && (0, preact_1.h)("div", { class: "-cbwsdk-extension-dialog-box-top-subtext" }, "After installing Coinbase Wallet, refresh the page and connect again."),
          (0, preact_1.h)("button", { type: "button", onClick: clickHandler }, isClicked ? "Refresh" : "Install")
        ),
        (0, preact_1.h)(
          "div",
          { class: "-cbwsdk-extension-dialog-box-top-info-region" },
          (0, preact_1.h)(DescriptionItem, { icon: link_icon_svg_1.default, text: "Connect to crypto apps with one click" }),
          (0, preact_1.h)(DescriptionItem, { icon: lock_icon_svg_1.default, text: "Your private key is stored securely" }),
          (0, preact_1.h)(DescriptionItem, { icon: globe_icon_svg_1.default, text: "Works with Ethereum, Polygon, and more" })
        )
      );
    };
    var ScanQRBox = (props) => {
      const qrUrl = (0, util_1.createQrUrl)(props.sessionId, props.sessionSecret, props.linkAPIUrl, props.isParentConnection);
      return (0, preact_1.h)(
        "div",
        { "data-testid": "scan-qr-box", class: "-cbwsdk-extension-dialog-box-bottom" },
        (0, preact_1.h)(
          "div",
          { class: "-cbwsdk-extension-dialog-box-bottom-description-region" },
          (0, preact_1.h)("h2", null, "Or scan to connect"),
          (0, preact_1.h)(
            "body",
            { class: "-cbwsdk-extension-dialog-box-bottom-description" },
            "Open",
            " ",
            (0, preact_1.h)("a", { href: "https://wallet.coinbase.com/", target: "_blank", rel: "noopener noreferrer" }, "Coinbase Wallet"),
            " ",
            "on your mobile phone and scan"
          )
        ),
        (0, preact_1.h)(
          "div",
          { class: "-cbwsdk-extension-dialog-box-bottom-qr-region" },
          (0, preact_1.h)(
            "div",
            { class: "-cbwsdk-extension-dialog-box-bottom-qr-wrapper" },
            (0, preact_1.h)(QRCode_1.QRCode, { content: qrUrl, width: 150, height: 150, fgColor: "#000", bgColor: "transparent", image: {
              svg: QRLogo_1.default,
              width: 34,
              height: 34
            } })
          ),
          (0, preact_1.h)("input", { type: "hidden", name: "cbwsdk-version", value: version_1.LIB_VERSION }),
          (0, preact_1.h)("input", { type: "hidden", value: qrUrl }),
          !props.isConnected && (0, preact_1.h)(
            "div",
            { "data-testid": "connecting-spinner", class: "-cbwsdk-extension-dialog-box-bottom-qr-connecting" },
            (0, preact_1.h)(Spinner_1.Spinner, { size: 36, color: "#000" }),
            (0, preact_1.h)("p", null, "Connecting...")
          )
        )
      );
    };
    var DescriptionItem = (props) => {
      return (0, preact_1.h)(
        "div",
        { class: "-cbwsdk-extension-dialog-box-top-description" },
        (0, preact_1.h)(
          "div",
          { class: "-cbwsdk-extension-dialog-box-top-description-icon-wrapper" },
          (0, preact_1.h)("img", { src: props.icon })
        ),
        (0, preact_1.h)("body", { class: "-cbwsdk-extension-dialog-box-top-description-text" }, props.text)
      );
    };
    var CancelButton = (props) => (0, preact_1.h)(
      "button",
      { type: "button", class: "-cbwsdk-extension-dialog-box-cancel", onClick: props.onClick },
      (0, preact_1.h)("div", { class: "-cbwsdk-extension-dialog-box-cancel-x" })
    );
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/LinkFlow.js
var require_LinkFlow = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/LinkFlow.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LinkFlow = void 0;
    var preact_1 = (init_preact_module(), __toCommonJS(preact_module_exports));
    var rxjs_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var TryExtensionLinkDialog_1 = require_TryExtensionLinkDialog();
    var LinkFlow = class {
      constructor(options) {
        this.extensionUI$ = new rxjs_1.BehaviorSubject({});
        this.subscriptions = new rxjs_1.Subscription();
        this.isConnected = false;
        this.isOpen = false;
        this.onCancel = null;
        this.root = null;
        this.connectDisabled = false;
        this.darkMode = options.darkMode;
        this.version = options.version;
        this.sessionId = options.sessionId;
        this.sessionSecret = options.sessionSecret;
        this.linkAPIUrl = options.linkAPIUrl;
        this.isParentConnection = options.isParentConnection;
        this.connected$ = options.connected$;
      }
      attach(el) {
        this.root = document.createElement("div");
        this.root.className = "-cbwsdk-link-flow-root";
        el.appendChild(this.root);
        this.render();
        this.subscriptions.add(this.connected$.subscribe((v9) => {
          if (this.isConnected !== v9) {
            this.isConnected = v9;
            this.render();
          }
        }));
      }
      detach() {
        var _a2;
        if (!this.root) {
          return;
        }
        this.subscriptions.unsubscribe();
        (0, preact_1.render)(null, this.root);
        (_a2 = this.root.parentElement) === null || _a2 === void 0 ? void 0 : _a2.removeChild(this.root);
      }
      setConnectDisabled(connectDisabled) {
        this.connectDisabled = connectDisabled;
      }
      open(options) {
        this.isOpen = true;
        this.onCancel = options.onCancel;
        this.render();
      }
      close() {
        this.isOpen = false;
        this.onCancel = null;
        this.render();
      }
      render() {
        if (!this.root) {
          return;
        }
        const subscription = this.extensionUI$.subscribe(() => {
          if (!this.root) {
            return;
          }
          (0, preact_1.render)((0, preact_1.h)(TryExtensionLinkDialog_1.TryExtensionLinkDialog, { darkMode: this.darkMode, version: this.version, sessionId: this.sessionId, sessionSecret: this.sessionSecret, linkAPIUrl: this.linkAPIUrl, isOpen: this.isOpen, isConnected: this.isConnected, isParentConnection: this.isParentConnection, onCancel: this.onCancel, connectDisabled: this.connectDisabled }), this.root);
        });
        this.subscriptions.add(subscription);
      }
    };
    exports2.LinkFlow = LinkFlow;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/Snackbar-css.js
var require_Snackbar_css = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/Snackbar-css.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = `.-cbwsdk-css-reset .-gear-container{margin-left:16px !important;margin-right:9px !important;display:flex;align-items:center;justify-content:center;width:24px;height:24px;transition:opacity .25s}.-cbwsdk-css-reset .-gear-container *{user-select:none}.-cbwsdk-css-reset .-gear-container svg{opacity:0;position:absolute}.-cbwsdk-css-reset .-gear-icon{height:12px;width:12px;z-index:10000}.-cbwsdk-css-reset .-cbwsdk-snackbar{align-items:flex-end;display:flex;flex-direction:column;position:fixed;right:0;top:0;z-index:2147483647}.-cbwsdk-css-reset .-cbwsdk-snackbar *{user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance{display:flex;flex-direction:column;margin:8px 16px 0 16px;overflow:visible;text-align:left;transform:translateX(0);transition:opacity .25s,transform .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header:hover .-gear-container svg{opacity:1}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header{display:flex;align-items:center;background:#fff;overflow:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-cblogo{margin:8px 8px 8px 8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-message{color:#000;font-size:13px;line-height:1.5;user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu{background:#fff;transition:opacity .25s ease-in-out,transform .25s linear,visibility 0s;visibility:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;opacity:0;flex-direction:column;padding-left:8px;padding-right:8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:last-child{margin-bottom:8px !important}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover{background:#f5f7f8;border-radius:6px;transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover span{color:#050f19;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover svg path{fill:#000;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item{visibility:inherit;height:35px;margin-top:8px;margin-bottom:0;display:flex;flex-direction:row;align-items:center;padding:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item *{visibility:inherit;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover{background:rgba(223,95,103,.2);transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover svg path{fill:#df5f67;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover span{color:#df5f67;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-info{color:#aaa;font-size:13px;margin:0 8px 0 32px;position:absolute}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-hidden{opacity:0;text-align:left;transform:translateX(25%);transition:opacity .5s linear}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-expanded .-cbwsdk-snackbar-instance-menu{opacity:1;display:flex;transform:translateY(8px);visibility:visible}`;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/Snackbar.js
var require_Snackbar = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/Snackbar.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SnackbarInstance = exports2.SnackbarContainer = exports2.Snackbar = void 0;
    var clsx_1 = __importDefault((init_clsx_m(), __toCommonJS(clsx_m_exports)));
    var preact_1 = (init_preact_module(), __toCommonJS(preact_module_exports));
    var hooks_1 = (init_hooks_module(), __toCommonJS(hooks_module_exports));
    var Snackbar_css_1 = __importDefault(require_Snackbar_css());
    var cblogo = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEuNDkyIDEwLjQxOWE4LjkzIDguOTMgMCAwMTguOTMtOC45M2gxMS4xNjNhOC45MyA4LjkzIDAgMDE4LjkzIDguOTN2MTEuMTYzYTguOTMgOC45MyAwIDAxLTguOTMgOC45M0gxMC40MjJhOC45MyA4LjkzIDAgMDEtOC45My04LjkzVjEwLjQxOXoiIGZpbGw9IiMxNjUyRjAiLz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEwLjQxOSAwSDIxLjU4QzI3LjMzNSAwIDMyIDQuNjY1IDMyIDEwLjQxOVYyMS41OEMzMiAyNy4zMzUgMjcuMzM1IDMyIDIxLjU4MSAzMkgxMC40MkM0LjY2NSAzMiAwIDI3LjMzNSAwIDIxLjU4MVYxMC40MkMwIDQuNjY1IDQuNjY1IDAgMTAuNDE5IDB6bTAgMS40ODhhOC45MyA4LjkzIDAgMDAtOC45MyA4LjkzdjExLjE2M2E4LjkzIDguOTMgMCAwMDguOTMgOC45M0gyMS41OGE4LjkzIDguOTMgMCAwMDguOTMtOC45M1YxMC40MmE4LjkzIDguOTMgMCAwMC04LjkzLTguOTNIMTAuNDJ6IiBmaWxsPSIjZmZmIi8+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNS45OTggMjYuMDQ5Yy01LjU0OSAwLTEwLjA0Ny00LjQ5OC0xMC4wNDctMTAuMDQ3IDAtNS41NDggNC40OTgtMTAuMDQ2IDEwLjA0Ny0xMC4wNDYgNS41NDggMCAxMC4wNDYgNC40OTggMTAuMDQ2IDEwLjA0NiAwIDUuNTQ5LTQuNDk4IDEwLjA0Ny0xMC4wNDYgMTAuMDQ3eiIgZmlsbD0iI2ZmZiIvPjxwYXRoIGQ9Ik0xMi43NjIgMTQuMjU0YzAtLjgyMi42NjctMS40ODkgMS40ODktMS40ODloMy40OTdjLjgyMiAwIDEuNDg4LjY2NiAxLjQ4OCAxLjQ4OXYzLjQ5N2MwIC44MjItLjY2NiAxLjQ4OC0xLjQ4OCAxLjQ4OGgtMy40OTdhMS40ODggMS40ODggMCAwMS0xLjQ4OS0xLjQ4OHYtMy40OTh6IiBmaWxsPSIjMTY1MkYwIi8+PC9zdmc+`;
    var gearIcon = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDYuNzV2LTEuNWwtMS43Mi0uNTdjLS4wOC0uMjctLjE5LS41Mi0uMzItLjc3bC44MS0xLjYyLTEuMDYtMS4wNi0xLjYyLjgxYy0uMjQtLjEzLS41LS4yNC0uNzctLjMyTDYuNzUgMGgtMS41bC0uNTcgMS43MmMtLjI3LjA4LS41My4xOS0uNzcuMzJsLTEuNjItLjgxLTEuMDYgMS4wNi44MSAxLjYyYy0uMTMuMjQtLjI0LjUtLjMyLjc3TDAgNS4yNXYxLjVsMS43Mi41N2MuMDguMjcuMTkuNTMuMzIuNzdsLS44MSAxLjYyIDEuMDYgMS4wNiAxLjYyLS44MWMuMjQuMTMuNS4yMy43Ny4zMkw1LjI1IDEyaDEuNWwuNTctMS43MmMuMjctLjA4LjUyLS4xOS43Ny0uMzJsMS42Mi44MSAxLjA2LTEuMDYtLjgxLTEuNjJjLjEzLS4yNC4yMy0uNS4zMi0uNzdMMTIgNi43NXpNNiA4LjVhMi41IDIuNSAwIDAxMC01IDIuNSAyLjUgMCAwMTAgNXoiIGZpbGw9IiMwNTBGMTkiLz48L3N2Zz4=`;
    var Snackbar = class {
      constructor(options) {
        this.items = /* @__PURE__ */ new Map();
        this.nextItemKey = 0;
        this.root = null;
        this.darkMode = options.darkMode;
      }
      attach(el) {
        this.root = document.createElement("div");
        this.root.className = "-cbwsdk-snackbar-root";
        el.appendChild(this.root);
        this.render();
      }
      presentItem(itemProps) {
        const key2 = this.nextItemKey++;
        this.items.set(key2, itemProps);
        this.render();
        return () => {
          this.items.delete(key2);
          this.render();
        };
      }
      clear() {
        this.items.clear();
        this.render();
      }
      render() {
        if (!this.root) {
          return;
        }
        (0, preact_1.render)((0, preact_1.h)(
          "div",
          null,
          (0, preact_1.h)(exports2.SnackbarContainer, { darkMode: this.darkMode }, Array.from(this.items.entries()).map(([key2, itemProps]) => (0, preact_1.h)(exports2.SnackbarInstance, Object.assign({}, itemProps, { key: key2 }))))
        ), this.root);
      }
    };
    exports2.Snackbar = Snackbar;
    var SnackbarContainer = (props) => (0, preact_1.h)(
      "div",
      { class: (0, clsx_1.default)("-cbwsdk-snackbar-container") },
      (0, preact_1.h)("style", null, Snackbar_css_1.default),
      (0, preact_1.h)("div", { class: "-cbwsdk-snackbar" }, props.children)
    );
    exports2.SnackbarContainer = SnackbarContainer;
    var SnackbarInstance = ({ autoExpand, message, menuItems }) => {
      const [hidden, setHidden] = (0, hooks_1.useState)(true);
      const [expanded, setExpanded] = (0, hooks_1.useState)(autoExpand !== null && autoExpand !== void 0 ? autoExpand : false);
      (0, hooks_1.useEffect)(() => {
        const timers = [
          window.setTimeout(() => {
            setHidden(false);
          }, 1),
          window.setTimeout(() => {
            setExpanded(true);
          }, 1e4)
        ];
        return () => {
          timers.forEach(window.clearTimeout);
        };
      });
      const toggleExpanded = () => {
        setExpanded(!expanded);
      };
      return (0, preact_1.h)(
        "div",
        { class: (0, clsx_1.default)("-cbwsdk-snackbar-instance", hidden && "-cbwsdk-snackbar-instance-hidden", expanded && "-cbwsdk-snackbar-instance-expanded") },
        (0, preact_1.h)(
          "div",
          { class: "-cbwsdk-snackbar-instance-header", onClick: toggleExpanded },
          (0, preact_1.h)("img", { src: cblogo, class: "-cbwsdk-snackbar-instance-header-cblogo" }),
          (0, preact_1.h)("div", { class: "-cbwsdk-snackbar-instance-header-message" }, message),
          (0, preact_1.h)(
            "div",
            { class: "-gear-container" },
            !expanded && (0, preact_1.h)(
              "svg",
              { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
              (0, preact_1.h)("circle", { cx: "12", cy: "12", r: "12", fill: "#F5F7F8" })
            ),
            (0, preact_1.h)("img", { src: gearIcon, class: "-gear-icon", title: "Expand" })
          )
        ),
        menuItems && menuItems.length > 0 && (0, preact_1.h)("div", { class: "-cbwsdk-snackbar-instance-menu" }, menuItems.map((action, i6) => (0, preact_1.h)(
          "div",
          { class: (0, clsx_1.default)("-cbwsdk-snackbar-instance-menu-item", action.isRed && "-cbwsdk-snackbar-instance-menu-item-is-red"), onClick: action.onClick, key: i6 },
          (0, preact_1.h)(
            "svg",
            { width: action.svgWidth, height: action.svgHeight, viewBox: "0 0 10 11", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
            (0, preact_1.h)("path", { "fill-rule": action.defaultFillRule, "clip-rule": action.defaultClipRule, d: action.path, fill: "#AAAAAA" })
          ),
          (0, preact_1.h)("span", { class: (0, clsx_1.default)("-cbwsdk-snackbar-instance-menu-item-info", action.isRed && "-cbwsdk-snackbar-instance-menu-item-info-is-red") }, action.info)
        )))
      );
    };
    exports2.SnackbarInstance = SnackbarInstance;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/lib/cssReset-css.js
var require_cssReset_css = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/lib/cssReset-css.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = `@namespace svg "http://www.w3.org/2000/svg";.-cbwsdk-css-reset,.-cbwsdk-css-reset *{animation:none;animation-delay:0;animation-direction:normal;animation-duration:0;animation-fill-mode:none;animation-iteration-count:1;animation-name:none;animation-play-state:running;animation-timing-function:ease;backface-visibility:visible;background:0;background-attachment:scroll;background-clip:border-box;background-color:rgba(0,0,0,0);background-image:none;background-origin:padding-box;background-position:0 0;background-position-x:0;background-position-y:0;background-repeat:repeat;background-size:auto auto;border:0;border-style:none;border-width:medium;border-color:inherit;border-bottom:0;border-bottom-color:inherit;border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom-style:none;border-bottom-width:medium;border-collapse:separate;border-image:none;border-left:0;border-left-color:inherit;border-left-style:none;border-left-width:medium;border-radius:0;border-right:0;border-right-color:inherit;border-right-style:none;border-right-width:medium;border-spacing:0;border-top:0;border-top-color:inherit;border-top-left-radius:0;border-top-right-radius:0;border-top-style:none;border-top-width:medium;bottom:auto;box-shadow:none;box-sizing:border-box;caption-side:top;clear:none;clip:auto;color:inherit;columns:auto;column-count:auto;column-fill:balance;column-gap:normal;column-rule:medium none currentColor;column-rule-color:currentColor;column-rule-style:none;column-rule-width:none;column-span:1;column-width:auto;content:normal;counter-increment:none;counter-reset:none;cursor:auto;direction:ltr;display:block;empty-cells:show;float:none;font:normal;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;font-size:medium;font-style:normal;font-variant:normal;font-weight:normal;height:auto;hyphens:none;left:auto;letter-spacing:normal;line-height:normal;list-style:none;list-style-image:none;list-style-position:outside;list-style-type:disc;margin:0;margin-bottom:0;margin-left:0;margin-right:0;margin-top:0;max-height:none;max-width:none;min-height:0;min-width:0;opacity:1;orphans:0;outline:0;outline-color:invert;outline-style:none;outline-width:medium;overflow:visible;overflow-x:visible;overflow-y:visible;padding:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;page-break-after:auto;page-break-before:auto;page-break-inside:auto;perspective:none;perspective-origin:50% 50%;pointer-events:auto;position:static;quotes:"\\201C" "\\201D" "\\2018" "\\2019";right:auto;tab-size:8;table-layout:auto;text-align:inherit;text-align-last:auto;text-decoration:none;text-decoration-color:inherit;text-decoration-line:none;text-decoration-style:solid;text-indent:0;text-shadow:none;text-transform:none;top:auto;transform:none;transform-style:flat;transition:none;transition-delay:0s;transition-duration:0s;transition-property:none;transition-timing-function:ease;unicode-bidi:normal;vertical-align:baseline;visibility:visible;white-space:normal;widows:0;width:auto;word-spacing:normal;z-index:auto}.-cbwsdk-css-reset *{box-sizing:border-box;display:initial;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;line-height:1}.-cbwsdk-css-reset [class*=container]{margin:0;padding:0}.-cbwsdk-css-reset style{display:none}`;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/lib/cssReset.js
var require_cssReset = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/lib/cssReset.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.injectCssReset = void 0;
    var cssReset_css_1 = __importDefault(require_cssReset_css());
    function injectCssReset() {
      const styleEl = document.createElement("style");
      styleEl.type = "text/css";
      styleEl.appendChild(document.createTextNode(cssReset_css_1.default));
      document.documentElement.appendChild(styleEl);
    }
    exports2.injectCssReset = injectCssReset;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/provider/WalletSDKUI.js
var require_WalletSDKUI = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/provider/WalletSDKUI.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WalletSDKUI = void 0;
    var LinkFlow_1 = require_LinkFlow();
    var Snackbar_1 = require_Snackbar();
    var cssReset_1 = require_cssReset();
    var WalletSDKUI = class {
      constructor(options) {
        this.attached = false;
        this.snackbar = new Snackbar_1.Snackbar({
          darkMode: options.darkMode
        });
        this.linkFlow = new LinkFlow_1.LinkFlow({
          darkMode: options.darkMode,
          version: options.version,
          sessionId: options.session.id,
          sessionSecret: options.session.secret,
          linkAPIUrl: options.linkAPIUrl,
          connected$: options.connected$,
          isParentConnection: false
        });
      }
      attach() {
        if (this.attached) {
          throw new Error("Coinbase Wallet SDK UI is already attached");
        }
        const el = document.documentElement;
        const container = document.createElement("div");
        container.className = "-cbwsdk-css-reset";
        el.appendChild(container);
        this.linkFlow.attach(container);
        this.snackbar.attach(container);
        this.attached = true;
        (0, cssReset_1.injectCssReset)();
      }
      setConnectDisabled(connectDisabled) {
        this.linkFlow.setConnectDisabled(connectDisabled);
      }
      addEthereumChain(_options) {
      }
      watchAsset(_options) {
      }
      switchEthereumChain(_options) {
      }
      requestEthereumAccounts(options) {
        this.linkFlow.open({ onCancel: options.onCancel });
      }
      hideRequestEthereumAccounts() {
        this.linkFlow.close();
      }
      signEthereumMessage(_8) {
      }
      signEthereumTransaction(_8) {
      }
      submitEthereumTransaction(_8) {
      }
      ethereumAddressFromSignedMessage(_8) {
      }
      showConnecting(options) {
        let snackbarProps;
        if (options.isUnlinkedErrorState) {
          snackbarProps = {
            autoExpand: true,
            message: "Connection lost",
            menuItems: [
              {
                isRed: false,
                info: "Reset connection",
                svgWidth: "10",
                svgHeight: "11",
                path: "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z",
                defaultFillRule: "evenodd",
                defaultClipRule: "evenodd",
                onClick: options.onResetConnection
              }
            ]
          };
        } else {
          snackbarProps = {
            message: "Confirm on phone",
            menuItems: [
              {
                isRed: true,
                info: "Cancel transaction",
                svgWidth: "11",
                svgHeight: "11",
                path: "M10.3711 1.52346L9.21775 0.370117L5.37109 4.21022L1.52444 0.370117L0.371094 1.52346L4.2112 5.37012L0.371094 9.21677L1.52444 10.3701L5.37109 6.53001L9.21775 10.3701L10.3711 9.21677L6.53099 5.37012L10.3711 1.52346Z",
                defaultFillRule: "inherit",
                defaultClipRule: "inherit",
                onClick: options.onCancel
              },
              {
                isRed: false,
                info: "Reset connection",
                svgWidth: "10",
                svgHeight: "11",
                path: "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z",
                defaultFillRule: "evenodd",
                defaultClipRule: "evenodd",
                onClick: options.onResetConnection
              }
            ]
          };
        }
        return this.snackbar.presentItem(snackbarProps);
      }
      reloadUI() {
        document.location.reload();
      }
      inlineAccountsResponse() {
        return false;
      }
      inlineAddEthereumChain(_chainId) {
        return false;
      }
      inlineWatchAsset() {
        return false;
      }
      inlineSwitchEthereumChain() {
        return false;
      }
      isStandalone() {
        return false;
      }
    };
    exports2.WalletSDKUI = WalletSDKUI;
  }
});

// node_modules/bind-decorator/index.js
var require_bind_decorator = __commonJS({
  "node_modules/bind-decorator/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var constants;
    (function(constants2) {
      constants2.typeOfFunction = "function";
      constants2.boolTrue = true;
    })(constants || (constants = {}));
    function bind(target, propertyKey, descriptor) {
      if (!descriptor || typeof descriptor.value !== constants.typeOfFunction) {
        throw new TypeError("Only methods can be decorated with @bind. <" + propertyKey + "> is not a method!");
      }
      return {
        configurable: constants.boolTrue,
        get: function() {
          var bound = descriptor.value.bind(this);
          Object.defineProperty(this, propertyKey, {
            value: bound,
            configurable: constants.boolTrue,
            writable: constants.boolTrue
          });
          return bound;
        }
      };
    }
    exports2.bind = bind;
    exports2.default = bind;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/connection/ClientMessage.js
var require_ClientMessage = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/connection/ClientMessage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ClientMessagePublishEvent = exports2.ClientMessageSetSessionConfig = exports2.ClientMessageGetSessionConfig = exports2.ClientMessageIsLinked = exports2.ClientMessageHostSession = void 0;
    function ClientMessageHostSession(params) {
      return Object.assign({ type: "HostSession" }, params);
    }
    exports2.ClientMessageHostSession = ClientMessageHostSession;
    function ClientMessageIsLinked(params) {
      return Object.assign({ type: "IsLinked" }, params);
    }
    exports2.ClientMessageIsLinked = ClientMessageIsLinked;
    function ClientMessageGetSessionConfig(params) {
      return Object.assign({ type: "GetSessionConfig" }, params);
    }
    exports2.ClientMessageGetSessionConfig = ClientMessageGetSessionConfig;
    function ClientMessageSetSessionConfig(params) {
      return Object.assign({ type: "SetSessionConfig" }, params);
    }
    exports2.ClientMessageSetSessionConfig = ClientMessageSetSessionConfig;
    function ClientMessagePublishEvent(params) {
      return Object.assign({ type: "PublishEvent" }, params);
    }
    exports2.ClientMessagePublishEvent = ClientMessagePublishEvent;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/connection/RxWebSocket.js
var require_RxWebSocket = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/connection/RxWebSocket.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RxWebSocket = exports2.ConnectionState = void 0;
    var rxjs_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var operators_1 = (init_operators(), __toCommonJS(operators_exports));
    var ConnectionState;
    (function(ConnectionState2) {
      ConnectionState2[ConnectionState2["DISCONNECTED"] = 0] = "DISCONNECTED";
      ConnectionState2[ConnectionState2["CONNECTING"] = 1] = "CONNECTING";
      ConnectionState2[ConnectionState2["CONNECTED"] = 2] = "CONNECTED";
    })(ConnectionState = exports2.ConnectionState || (exports2.ConnectionState = {}));
    var RxWebSocket = class {
      constructor(url, WebSocketClass = WebSocket) {
        this.WebSocketClass = WebSocketClass;
        this.webSocket = null;
        this.connectionStateSubject = new rxjs_1.BehaviorSubject(ConnectionState.DISCONNECTED);
        this.incomingDataSubject = new rxjs_1.Subject();
        this.url = url.replace(/^http/, "ws");
      }
      connect() {
        if (this.webSocket) {
          return (0, rxjs_1.throwError)(new Error("webSocket object is not null"));
        }
        return new rxjs_1.Observable((obs) => {
          let webSocket;
          try {
            this.webSocket = webSocket = new this.WebSocketClass(this.url);
          } catch (err) {
            obs.error(err);
            return;
          }
          this.connectionStateSubject.next(ConnectionState.CONNECTING);
          webSocket.onclose = (evt) => {
            this.clearWebSocket();
            obs.error(new Error(`websocket error ${evt.code}: ${evt.reason}`));
            this.connectionStateSubject.next(ConnectionState.DISCONNECTED);
          };
          webSocket.onopen = (_8) => {
            obs.next();
            obs.complete();
            this.connectionStateSubject.next(ConnectionState.CONNECTED);
          };
          webSocket.onmessage = (evt) => {
            this.incomingDataSubject.next(evt.data);
          };
        }).pipe((0, operators_1.take)(1));
      }
      disconnect() {
        const { webSocket } = this;
        if (!webSocket) {
          return;
        }
        this.clearWebSocket();
        this.connectionStateSubject.next(ConnectionState.DISCONNECTED);
        try {
          webSocket.close();
        } catch (_a2) {
        }
      }
      get connectionState$() {
        return this.connectionStateSubject.asObservable();
      }
      get incomingData$() {
        return this.incomingDataSubject.asObservable();
      }
      get incomingJSONData$() {
        return this.incomingData$.pipe((0, operators_1.flatMap)((m6) => {
          let j8;
          try {
            j8 = JSON.parse(m6);
          } catch (err) {
            return (0, rxjs_1.empty)();
          }
          return (0, rxjs_1.of)(j8);
        }));
      }
      sendData(data) {
        const { webSocket } = this;
        if (!webSocket) {
          throw new Error("websocket is not connected");
        }
        webSocket.send(data);
      }
      clearWebSocket() {
        const { webSocket } = this;
        if (!webSocket) {
          return;
        }
        this.webSocket = null;
        webSocket.onclose = null;
        webSocket.onerror = null;
        webSocket.onmessage = null;
        webSocket.onopen = null;
      }
    };
    exports2.RxWebSocket = RxWebSocket;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/connection/ServerMessage.js
var require_ServerMessage = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/connection/ServerMessage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isServerMessageFail = void 0;
    function isServerMessageFail(msg) {
      return msg && msg.type === "Fail" && typeof msg.id === "number" && typeof msg.sessionId === "string" && typeof msg.error === "string";
    }
    exports2.isServerMessageFail = isServerMessageFail;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/connection/WalletSDKConnection.js
var require_WalletSDKConnection = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/connection/WalletSDKConnection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WalletSDKConnection = void 0;
    var rxjs_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var operators_1 = (init_operators(), __toCommonJS(operators_exports));
    var Session_1 = require_Session();
    var types_1 = require_types2();
    var ClientMessage_1 = require_ClientMessage();
    var EventListener_1 = require_EventListener();
    var RxWebSocket_1 = require_RxWebSocket();
    var ServerMessage_1 = require_ServerMessage();
    var HEARTBEAT_INTERVAL = 1e4;
    var REQUEST_TIMEOUT = 6e4;
    var WalletSDKConnection = class {
      constructor(sessionId, sessionKey, linkAPIUrl, eventListener, WebSocketClass = WebSocket) {
        this.sessionId = sessionId;
        this.sessionKey = sessionKey;
        this.eventListener = eventListener;
        this.subscriptions = new rxjs_1.Subscription();
        this.destroyed = false;
        this.lastHeartbeatResponse = 0;
        this.nextReqId = (0, types_1.IntNumber)(1);
        this.connectedSubject = new rxjs_1.BehaviorSubject(false);
        this.linkedSubject = new rxjs_1.BehaviorSubject(false);
        this.sessionConfigSubject = new rxjs_1.ReplaySubject(1);
        const ws2 = new RxWebSocket_1.RxWebSocket(linkAPIUrl + "/rpc", WebSocketClass);
        this.ws = ws2;
        this.subscriptions.add(ws2.connectionState$.pipe(
          (0, operators_1.tap)((state) => {
            var _a2;
            return (_a2 = this.eventListener) === null || _a2 === void 0 ? void 0 : _a2.onEvent(EventListener_1.EVENTS.CONNECTED_STATE_CHANGE, {
              state,
              sessionIdHash: Session_1.Session.hash(sessionId)
            });
          }),
          (0, operators_1.skip)(1),
          (0, operators_1.filter)((cs2) => cs2 === RxWebSocket_1.ConnectionState.DISCONNECTED && !this.destroyed),
          (0, operators_1.delay)(5e3),
          (0, operators_1.filter)((_8) => !this.destroyed),
          (0, operators_1.flatMap)((_8) => ws2.connect()),
          (0, operators_1.retry)()
        ).subscribe());
        this.subscriptions.add(ws2.connectionState$.pipe(
          (0, operators_1.skip)(2),
          (0, operators_1.switchMap)((cs2) => (0, rxjs_1.iif)(
            () => cs2 === RxWebSocket_1.ConnectionState.CONNECTED,
            this.authenticate().pipe((0, operators_1.tap)((_8) => this.sendIsLinked()), (0, operators_1.tap)((_8) => this.sendGetSessionConfig()), (0, operators_1.map)((_8) => true)),
            (0, rxjs_1.of)(false)
          )),
          (0, operators_1.distinctUntilChanged)(),
          (0, operators_1.catchError)((_8) => (0, rxjs_1.of)(false))
        ).subscribe((connected) => this.connectedSubject.next(connected)));
        this.subscriptions.add(ws2.connectionState$.pipe(
          (0, operators_1.skip)(1),
          (0, operators_1.switchMap)((cs2) => (0, rxjs_1.iif)(
            () => cs2 === RxWebSocket_1.ConnectionState.CONNECTED,
            (0, rxjs_1.timer)(0, HEARTBEAT_INTERVAL)
          ))
        ).subscribe((i6) => i6 === 0 ? this.updateLastHeartbeat() : this.heartbeat()));
        this.subscriptions.add(ws2.incomingData$.pipe((0, operators_1.filter)((m6) => m6 === "h")).subscribe((_8) => this.updateLastHeartbeat()));
        this.subscriptions.add(ws2.incomingJSONData$.pipe((0, operators_1.filter)((m6) => ["IsLinkedOK", "Linked"].includes(m6.type))).subscribe((m6) => {
          var _a2;
          const msg = m6;
          (_a2 = this.eventListener) === null || _a2 === void 0 ? void 0 : _a2.onEvent(EventListener_1.EVENTS.LINKED, {
            sessionIdHash: Session_1.Session.hash(sessionId),
            linked: msg.linked,
            type: m6.type,
            onlineGuests: msg.onlineGuests
          });
          this.linkedSubject.next(msg.linked || msg.onlineGuests > 0);
        }));
        this.subscriptions.add(ws2.incomingJSONData$.pipe((0, operators_1.filter)((m6) => ["GetSessionConfigOK", "SessionConfigUpdated"].includes(m6.type))).subscribe((m6) => {
          var _a2;
          const msg = m6;
          (_a2 = this.eventListener) === null || _a2 === void 0 ? void 0 : _a2.onEvent(EventListener_1.EVENTS.SESSION_CONFIG_RECEIVED, {
            sessionIdHash: Session_1.Session.hash(sessionId),
            metadata_keys: msg && msg.metadata ? Object.keys(msg.metadata) : void 0
          });
          this.sessionConfigSubject.next({
            webhookId: msg.webhookId,
            webhookUrl: msg.webhookUrl,
            metadata: msg.metadata
          });
        }));
      }
      connect() {
        var _a2;
        if (this.destroyed) {
          throw new Error("instance is destroyed");
        }
        (_a2 = this.eventListener) === null || _a2 === void 0 ? void 0 : _a2.onEvent(EventListener_1.EVENTS.STARTED_CONNECTING, {
          sessionIdHash: Session_1.Session.hash(this.sessionId)
        });
        this.ws.connect().subscribe();
      }
      destroy() {
        var _a2;
        this.subscriptions.unsubscribe();
        this.ws.disconnect();
        (_a2 = this.eventListener) === null || _a2 === void 0 ? void 0 : _a2.onEvent(EventListener_1.EVENTS.DISCONNECTED, {
          sessionIdHash: Session_1.Session.hash(this.sessionId)
        });
        this.destroyed = true;
      }
      get isDestroyed() {
        return this.destroyed;
      }
      get connected$() {
        return this.connectedSubject.asObservable();
      }
      get onceConnected$() {
        return this.connected$.pipe((0, operators_1.filter)((v9) => v9), (0, operators_1.take)(1), (0, operators_1.map)(() => void 0));
      }
      get linked$() {
        return this.linkedSubject.asObservable();
      }
      get onceLinked$() {
        return this.linked$.pipe((0, operators_1.filter)((v9) => v9), (0, operators_1.take)(1), (0, operators_1.map)(() => void 0));
      }
      get sessionConfig$() {
        return this.sessionConfigSubject.asObservable();
      }
      get incomingEvent$() {
        return this.ws.incomingJSONData$.pipe((0, operators_1.filter)((m6) => {
          if (m6.type !== "Event") {
            return false;
          }
          const sme = m6;
          return typeof sme.sessionId === "string" && typeof sme.eventId === "string" && typeof sme.event === "string" && typeof sme.data === "string";
        }), (0, operators_1.map)((m6) => m6));
      }
      setSessionMetadata(key2, value2) {
        const message = (0, ClientMessage_1.ClientMessageSetSessionConfig)({
          id: (0, types_1.IntNumber)(this.nextReqId++),
          sessionId: this.sessionId,
          metadata: { [key2]: value2 }
        });
        return this.onceConnected$.pipe((0, operators_1.flatMap)((_8) => this.makeRequest(message)), (0, operators_1.map)((res) => {
          if ((0, ServerMessage_1.isServerMessageFail)(res)) {
            throw new Error(res.error || "failed to set session metadata");
          }
        }));
      }
      publishEvent(event, data, callWebhook = false) {
        const message = (0, ClientMessage_1.ClientMessagePublishEvent)({
          id: (0, types_1.IntNumber)(this.nextReqId++),
          sessionId: this.sessionId,
          event,
          data,
          callWebhook
        });
        return this.onceLinked$.pipe((0, operators_1.flatMap)((_8) => this.makeRequest(message)), (0, operators_1.map)((res) => {
          if ((0, ServerMessage_1.isServerMessageFail)(res)) {
            throw new Error(res.error || "failed to publish event");
          }
          return res.eventId;
        }));
      }
      sendData(message) {
        this.ws.sendData(JSON.stringify(message));
      }
      updateLastHeartbeat() {
        this.lastHeartbeatResponse = Date.now();
      }
      heartbeat() {
        if (Date.now() - this.lastHeartbeatResponse > HEARTBEAT_INTERVAL * 2) {
          this.ws.disconnect();
          return;
        }
        try {
          this.ws.sendData("h");
        } catch (_a2) {
        }
      }
      makeRequest(message, timeout2 = REQUEST_TIMEOUT) {
        const reqId = message.id;
        try {
          this.sendData(message);
        } catch (err) {
          return (0, rxjs_1.throwError)(err);
        }
        return this.ws.incomingJSONData$.pipe((0, operators_1.timeoutWith)(timeout2, (0, rxjs_1.throwError)(new Error(`request ${reqId} timed out`))), (0, operators_1.filter)((m6) => m6.id === reqId), (0, operators_1.take)(1));
      }
      authenticate() {
        const msg = (0, ClientMessage_1.ClientMessageHostSession)({
          id: (0, types_1.IntNumber)(this.nextReqId++),
          sessionId: this.sessionId,
          sessionKey: this.sessionKey
        });
        return this.makeRequest(msg).pipe((0, operators_1.map)((res) => {
          if ((0, ServerMessage_1.isServerMessageFail)(res)) {
            throw new Error(res.error || "failed to authentcate");
          }
        }));
      }
      sendIsLinked() {
        const msg = (0, ClientMessage_1.ClientMessageIsLinked)({
          id: (0, types_1.IntNumber)(this.nextReqId++),
          sessionId: this.sessionId
        });
        this.sendData(msg);
      }
      sendGetSessionConfig() {
        const msg = (0, ClientMessage_1.ClientMessageGetSessionConfig)({
          id: (0, types_1.IntNumber)(this.nextReqId++),
          sessionId: this.sessionId
        });
        this.sendData(msg);
      }
    };
    exports2.WalletSDKConnection = WalletSDKConnection;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/provider/WalletUIError.js
var require_WalletUIError = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/provider/WalletUIError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WalletUIError = void 0;
    var WalletUIError = class extends Error {
      constructor(message, errorCode) {
        super(message);
        this.message = message;
        this.errorCode = errorCode;
      }
    };
    exports2.WalletUIError = WalletUIError;
    WalletUIError.UserRejectedRequest = new WalletUIError("User rejected request");
    WalletUIError.SwitchEthereumChainUnsupportedChainId = new WalletUIError("Unsupported chainId", 4902);
  }
});

// node_modules/@coinbase/wallet-sdk/dist/relay/aes256gcm.js
var require_aes256gcm = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/relay/aes256gcm.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decrypt = exports2.encrypt = void 0;
    var rxjs_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var util_1 = require_util3();
    async function encrypt3(plainText, secret) {
      if (secret.length !== 64)
        throw Error(`secret must be 256 bits`);
      const ivBytes = crypto.getRandomValues(new Uint8Array(12));
      const secretKey = await crypto.subtle.importKey("raw", (0, util_1.hexStringToUint8Array)(secret), { name: "aes-gcm" }, false, ["encrypt", "decrypt"]);
      const enc = new TextEncoder();
      const encryptedResult = await window.crypto.subtle.encrypt({
        name: "AES-GCM",
        iv: ivBytes
      }, secretKey, enc.encode(plainText));
      const tagLength = 16;
      const authTag = encryptedResult.slice(encryptedResult.byteLength - tagLength);
      const encryptedPlaintext = encryptedResult.slice(0, encryptedResult.byteLength - tagLength);
      const authTagBytes = new Uint8Array(authTag);
      const encryptedPlaintextBytes = new Uint8Array(encryptedPlaintext);
      const concatted = new Uint8Array([
        ...ivBytes,
        ...authTagBytes,
        ...encryptedPlaintextBytes
      ]);
      return (0, util_1.uint8ArrayToHex)(concatted);
    }
    exports2.encrypt = encrypt3;
    function decrypt4(cipherText, secret) {
      if (secret.length !== 64)
        throw Error(`secret must be 256 bits`);
      return new rxjs_1.Observable((subscriber) => {
        void async function() {
          const secretKey = await crypto.subtle.importKey("raw", (0, util_1.hexStringToUint8Array)(secret), { name: "aes-gcm" }, false, ["encrypt", "decrypt"]);
          const encrypted = (0, util_1.hexStringToUint8Array)(cipherText);
          const ivBytes = encrypted.slice(0, 12);
          const authTagBytes = encrypted.slice(12, 28);
          const encryptedPlaintextBytes = encrypted.slice(28);
          const concattedBytes = new Uint8Array([
            ...encryptedPlaintextBytes,
            ...authTagBytes
          ]);
          const algo = {
            name: "AES-GCM",
            iv: new Uint8Array(ivBytes)
          };
          try {
            const decrypted = await window.crypto.subtle.decrypt(algo, secretKey, concattedBytes);
            const decoder = new TextDecoder();
            subscriber.next(decoder.decode(decrypted));
            subscriber.complete();
          } catch (err) {
            subscriber.error(err);
          }
        }();
      });
    }
    exports2.decrypt = decrypt4;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/relay/Web3Method.js
var require_Web3Method = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/relay/Web3Method.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Web3Method = void 0;
    var Web3Method;
    (function(Web3Method2) {
      Web3Method2["requestEthereumAccounts"] = "requestEthereumAccounts";
      Web3Method2["signEthereumMessage"] = "signEthereumMessage";
      Web3Method2["signEthereumTransaction"] = "signEthereumTransaction";
      Web3Method2["submitEthereumTransaction"] = "submitEthereumTransaction";
      Web3Method2["ethereumAddressFromSignedMessage"] = "ethereumAddressFromSignedMessage";
      Web3Method2["scanQRCode"] = "scanQRCode";
      Web3Method2["generic"] = "generic";
      Web3Method2["childRequestEthereumAccounts"] = "childRequestEthereumAccounts";
      Web3Method2["addEthereumChain"] = "addEthereumChain";
      Web3Method2["switchEthereumChain"] = "switchEthereumChain";
      Web3Method2["makeEthereumJSONRPCRequest"] = "makeEthereumJSONRPCRequest";
      Web3Method2["watchAsset"] = "watchAsset";
    })(Web3Method = exports2.Web3Method || (exports2.Web3Method = {}));
  }
});

// node_modules/@coinbase/wallet-sdk/dist/relay/RelayMessage.js
var require_RelayMessage = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/relay/RelayMessage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RelayMessageType = void 0;
    var RelayMessageType;
    (function(RelayMessageType2) {
      RelayMessageType2["SESSION_ID_REQUEST"] = "SESSION_ID_REQUEST";
      RelayMessageType2["SESSION_ID_RESPONSE"] = "SESSION_ID_RESPONSE";
      RelayMessageType2["LINKED"] = "LINKED";
      RelayMessageType2["UNLINKED"] = "UNLINKED";
      RelayMessageType2["WEB3_REQUEST"] = "WEB3_REQUEST";
      RelayMessageType2["WEB3_REQUEST_CANCELED"] = "WEB3_REQUEST_CANCELED";
      RelayMessageType2["WEB3_RESPONSE"] = "WEB3_RESPONSE";
    })(RelayMessageType = exports2.RelayMessageType || (exports2.RelayMessageType = {}));
  }
});

// node_modules/@coinbase/wallet-sdk/dist/relay/Web3RequestCanceledMessage.js
var require_Web3RequestCanceledMessage = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/relay/Web3RequestCanceledMessage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Web3RequestCanceledMessage = void 0;
    var RelayMessage_1 = require_RelayMessage();
    function Web3RequestCanceledMessage(id2) {
      return { type: RelayMessage_1.RelayMessageType.WEB3_REQUEST_CANCELED, id: id2 };
    }
    exports2.Web3RequestCanceledMessage = Web3RequestCanceledMessage;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/relay/Web3RequestMessage.js
var require_Web3RequestMessage = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/relay/Web3RequestMessage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Web3RequestMessage = void 0;
    var RelayMessage_1 = require_RelayMessage();
    function Web3RequestMessage(params) {
      return Object.assign({ type: RelayMessage_1.RelayMessageType.WEB3_REQUEST }, params);
    }
    exports2.Web3RequestMessage = Web3RequestMessage;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/relay/Web3Response.js
var require_Web3Response = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/relay/Web3Response.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EthereumAddressFromSignedMessageResponse = exports2.SubmitEthereumTransactionResponse = exports2.SignEthereumTransactionResponse = exports2.SignEthereumMessageResponse = exports2.isRequestEthereumAccountsResponse = exports2.WatchAssetReponse = exports2.RequestEthereumAccountsResponse = exports2.SwitchEthereumChainResponse = exports2.AddEthereumChainResponse = exports2.ErrorResponse = void 0;
    var Web3Method_1 = require_Web3Method();
    function ErrorResponse(method2, errorMessage, errorCode) {
      return { method: method2, errorMessage, errorCode };
    }
    exports2.ErrorResponse = ErrorResponse;
    function AddEthereumChainResponse(addResponse) {
      return {
        method: Web3Method_1.Web3Method.addEthereumChain,
        result: addResponse
      };
    }
    exports2.AddEthereumChainResponse = AddEthereumChainResponse;
    function SwitchEthereumChainResponse(switchResponse) {
      return {
        method: Web3Method_1.Web3Method.switchEthereumChain,
        result: switchResponse
      };
    }
    exports2.SwitchEthereumChainResponse = SwitchEthereumChainResponse;
    function RequestEthereumAccountsResponse(addresses) {
      return { method: Web3Method_1.Web3Method.requestEthereumAccounts, result: addresses };
    }
    exports2.RequestEthereumAccountsResponse = RequestEthereumAccountsResponse;
    function WatchAssetReponse(success) {
      return { method: Web3Method_1.Web3Method.watchAsset, result: success };
    }
    exports2.WatchAssetReponse = WatchAssetReponse;
    function isRequestEthereumAccountsResponse(res) {
      return res && res.method === Web3Method_1.Web3Method.requestEthereumAccounts;
    }
    exports2.isRequestEthereumAccountsResponse = isRequestEthereumAccountsResponse;
    function SignEthereumMessageResponse(signature2) {
      return { method: Web3Method_1.Web3Method.signEthereumMessage, result: signature2 };
    }
    exports2.SignEthereumMessageResponse = SignEthereumMessageResponse;
    function SignEthereumTransactionResponse(signedData) {
      return { method: Web3Method_1.Web3Method.signEthereumTransaction, result: signedData };
    }
    exports2.SignEthereumTransactionResponse = SignEthereumTransactionResponse;
    function SubmitEthereumTransactionResponse(txHash) {
      return { method: Web3Method_1.Web3Method.submitEthereumTransaction, result: txHash };
    }
    exports2.SubmitEthereumTransactionResponse = SubmitEthereumTransactionResponse;
    function EthereumAddressFromSignedMessageResponse(address) {
      return {
        method: Web3Method_1.Web3Method.ethereumAddressFromSignedMessage,
        result: address
      };
    }
    exports2.EthereumAddressFromSignedMessageResponse = EthereumAddressFromSignedMessageResponse;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/relay/Web3ResponseMessage.js
var require_Web3ResponseMessage = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/relay/Web3ResponseMessage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isWeb3ResponseMessage = exports2.Web3ResponseMessage = void 0;
    var RelayMessage_1 = require_RelayMessage();
    function Web3ResponseMessage(params) {
      return Object.assign({ type: RelayMessage_1.RelayMessageType.WEB3_RESPONSE }, params);
    }
    exports2.Web3ResponseMessage = Web3ResponseMessage;
    function isWeb3ResponseMessage(msg) {
      return msg && msg.type === RelayMessage_1.RelayMessageType.WEB3_RESPONSE;
    }
    exports2.isWeb3ResponseMessage = isWeb3ResponseMessage;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/relay/WalletSDKRelay.js
var require_WalletSDKRelay = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/relay/WalletSDKRelay.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o6, m6, k8, k22) {
      if (k22 === void 0)
        k22 = k8;
      Object.defineProperty(o6, k22, { enumerable: true, get: function() {
        return m6[k8];
      } });
    } : function(o6, m6, k8, k22) {
      if (k22 === void 0)
        k22 = k8;
      o6[k22] = m6[k8];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o6, v9) {
      Object.defineProperty(o6, "default", { enumerable: true, value: v9 });
    } : function(o6, v9) {
      o6["default"] = v9;
    });
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key2, desc) {
      var c5 = arguments.length, r6 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d6;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r6 = Reflect.decorate(decorators, target, key2, desc);
      else
        for (var i6 = decorators.length - 1; i6 >= 0; i6--)
          if (d6 = decorators[i6])
            r6 = (c5 < 3 ? d6(r6) : c5 > 3 ? d6(target, key2, r6) : d6(target, key2)) || r6;
      return c5 > 3 && r6 && Object.defineProperty(target, key2, r6), r6;
    };
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k8 in mod2)
          if (k8 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k8))
            __createBinding(result, mod2, k8);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WalletSDKRelay = void 0;
    var bind_decorator_1 = __importDefault(require_bind_decorator());
    var eth_rpc_errors_1 = require_dist2();
    var rxjs_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var operators_1 = (init_operators(), __toCommonJS(operators_exports));
    var EventListener_1 = require_EventListener();
    var WalletSDKConnection_1 = require_WalletSDKConnection();
    var WalletUIError_1 = require_WalletUIError();
    var util_1 = require_util3();
    var aes256gcm = __importStar(require_aes256gcm());
    var Session_1 = require_Session();
    var WalletSDKRelayAbstract_1 = require_WalletSDKRelayAbstract();
    var Web3Method_1 = require_Web3Method();
    var Web3RequestCanceledMessage_1 = require_Web3RequestCanceledMessage();
    var Web3RequestMessage_1 = require_Web3RequestMessage();
    var Web3Response_1 = require_Web3Response();
    var Web3ResponseMessage_1 = require_Web3ResponseMessage();
    var WalletSDKRelay = class extends WalletSDKRelayAbstract_1.WalletSDKRelayAbstract {
      constructor(options) {
        super();
        this.accountsCallback = null;
        this.chainCallback = null;
        this.appName = "";
        this.appLogoUrl = null;
        this.subscriptions = new rxjs_1.Subscription();
        this.linkAPIUrl = options.linkAPIUrl;
        this.storage = options.storage;
        this._session = Session_1.Session.load(options.storage) || new Session_1.Session(options.storage).save();
        this.relayEventManager = options.relayEventManager;
        this.eventListener = options.eventListener;
        this.connection = new WalletSDKConnection_1.WalletSDKConnection(this._session.id, this._session.key, this.linkAPIUrl, this.eventListener);
        this.subscriptions.add(this.connection.sessionConfig$.subscribe({
          next: (sessionConfig) => {
            this.onSessionConfigChanged(sessionConfig);
          },
          error: () => {
            var _a2;
            (_a2 = this.eventListener) === null || _a2 === void 0 ? void 0 : _a2.onEvent(EventListener_1.EVENTS.GENERAL_ERROR, {
              message: "error while invoking session config callback"
            });
          }
        }));
        this.subscriptions.add(this.connection.incomingEvent$.pipe((0, operators_1.filter)((m6) => m6.event === "Web3Response")).subscribe({ next: this.handleIncomingEvent }));
        this.subscriptions.add(this.connection.linked$.pipe((0, operators_1.skip)(1), (0, operators_1.tap)((linked) => {
          var _a2;
          this.isLinked = linked;
          const cachedAddresses = this.storage.getItem(WalletSDKRelayAbstract_1.LOCAL_STORAGE_ADDRESSES_KEY);
          if (linked) {
            this.session.linked = linked;
          }
          this.isUnlinkedErrorState = false;
          if (cachedAddresses) {
            const addresses = cachedAddresses.split(" ");
            const wasConnectedViaStandalone = this.storage.getItem("IsStandaloneSigning") === "true";
            if (addresses[0] !== "" && !linked && this.session.linked && !wasConnectedViaStandalone) {
              this.isUnlinkedErrorState = true;
              const sessionIdHash = this.getSessionIdHash();
              (_a2 = this.eventListener) === null || _a2 === void 0 ? void 0 : _a2.onEvent(EventListener_1.EVENTS.UNLINKED_ERROR_STATE, {
                sessionIdHash
              });
            }
          }
        })).subscribe());
        this.subscriptions.add(this.connection.sessionConfig$.pipe((0, operators_1.filter)((c5) => !!c5.metadata && c5.metadata.__destroyed === "1")).subscribe(() => {
          var _a2;
          const alreadyDestroyed = this.connection.isDestroyed;
          (_a2 = this.eventListener) === null || _a2 === void 0 ? void 0 : _a2.onEvent(EventListener_1.EVENTS.METADATA_DESTROYED, {
            alreadyDestroyed,
            sessionIdHash: this.getSessionIdHash()
          });
          return this.resetAndReload();
        }));
        this.subscriptions.add(this.connection.sessionConfig$.pipe((0, operators_1.filter)((c5) => c5.metadata && c5.metadata.WalletUsername !== void 0)).pipe((0, operators_1.mergeMap)((c5) => aes256gcm.decrypt(c5.metadata.WalletUsername, this._session.secret))).subscribe({
          next: (walletUsername) => {
            this.storage.setItem(WalletSDKRelayAbstract_1.WALLET_USER_NAME_KEY, walletUsername);
          },
          error: () => {
            var _a2;
            (_a2 = this.eventListener) === null || _a2 === void 0 ? void 0 : _a2.onEvent(EventListener_1.EVENTS.GENERAL_ERROR, {
              message: "Had error decrypting",
              value: "username"
            });
          }
        }));
        this.subscriptions.add(this.connection.sessionConfig$.pipe((0, operators_1.filter)((c5) => c5.metadata && c5.metadata.AppVersion !== void 0)).pipe((0, operators_1.mergeMap)((c5) => aes256gcm.decrypt(c5.metadata.AppVersion, this._session.secret))).subscribe({
          next: (appVersion) => {
            this.storage.setItem(WalletSDKRelayAbstract_1.APP_VERSION_KEY, appVersion);
          },
          error: () => {
            var _a2;
            (_a2 = this.eventListener) === null || _a2 === void 0 ? void 0 : _a2.onEvent(EventListener_1.EVENTS.GENERAL_ERROR, {
              message: "Had error decrypting",
              value: "appversion"
            });
          }
        }));
        this.subscriptions.add(this.connection.sessionConfig$.pipe((0, operators_1.filter)((c5) => c5.metadata && c5.metadata.ChainId !== void 0 && c5.metadata.JsonRpcUrl !== void 0)).pipe((0, operators_1.mergeMap)((c5) => (0, rxjs_1.zip)(aes256gcm.decrypt(c5.metadata.ChainId, this._session.secret), aes256gcm.decrypt(c5.metadata.JsonRpcUrl, this._session.secret)))).pipe((0, operators_1.distinctUntilChanged)()).subscribe({
          next: ([chainId, jsonRpcUrl]) => {
            if (this.chainCallback) {
              this.chainCallback(chainId, jsonRpcUrl);
            }
          },
          error: () => {
            var _a2;
            (_a2 = this.eventListener) === null || _a2 === void 0 ? void 0 : _a2.onEvent(EventListener_1.EVENTS.GENERAL_ERROR, {
              message: "Had error decrypting",
              value: "chainId|jsonRpcUrl"
            });
          }
        }));
        this.subscriptions.add(this.connection.sessionConfig$.pipe((0, operators_1.filter)((c5) => c5.metadata && c5.metadata.EthereumAddress !== void 0)).pipe((0, operators_1.mergeMap)((c5) => aes256gcm.decrypt(c5.metadata.EthereumAddress, this._session.secret))).subscribe({
          next: (selectedAddress) => {
            if (this.accountsCallback) {
              this.accountsCallback([selectedAddress]);
            }
            if (WalletSDKRelay.accountRequestCallbackIds.size > 0) {
              Array.from(WalletSDKRelay.accountRequestCallbackIds.values()).forEach((id2) => {
                const message = (0, Web3ResponseMessage_1.Web3ResponseMessage)({
                  id: id2,
                  response: (0, Web3Response_1.RequestEthereumAccountsResponse)([
                    selectedAddress
                  ])
                });
                this.invokeCallback(Object.assign(Object.assign({}, message), { id: id2 }));
              });
              WalletSDKRelay.accountRequestCallbackIds.clear();
            }
          },
          error: () => {
            var _a2;
            (_a2 = this.eventListener) === null || _a2 === void 0 ? void 0 : _a2.onEvent(EventListener_1.EVENTS.GENERAL_ERROR, {
              message: "Had error decrypting",
              value: "selectedAddress"
            });
          }
        }));
        this.ui = options.uiConstructor({
          linkAPIUrl: options.linkAPIUrl,
          version: options.version,
          darkMode: options.darkMode,
          session: this._session,
          connected$: this.connection.connected$
        });
        this.connection.connect();
      }
      attachUI() {
        this.ui.attach();
      }
      resetAndReload() {
        this.connection.setSessionMetadata("__destroyed", "1").pipe((0, operators_1.timeout)(1e3), (0, operators_1.catchError)((_8) => (0, rxjs_1.of)(null))).subscribe((_8) => {
          var _a2, _b, _c;
          try {
            this.subscriptions.unsubscribe();
          } catch (err) {
            (_a2 = this.eventListener) === null || _a2 === void 0 ? void 0 : _a2.onEvent(EventListener_1.EVENTS.GENERAL_ERROR, {
              message: "Had error unsubscribing"
            });
          }
          (_b = this.eventListener) === null || _b === void 0 ? void 0 : _b.onEvent(EventListener_1.EVENTS.SESSION_STATE_CHANGE, {
            method: "relay::resetAndReload",
            sessionMetadataChange: "__destroyed, 1",
            sessionIdHash: this.getSessionIdHash()
          });
          this.connection.destroy();
          const storedSession = Session_1.Session.load(this.storage);
          if ((storedSession === null || storedSession === void 0 ? void 0 : storedSession.id) === this._session.id) {
            this.storage.clear();
          } else if (storedSession) {
            (_c = this.eventListener) === null || _c === void 0 ? void 0 : _c.onEvent(EventListener_1.EVENTS.SKIPPED_CLEARING_SESSION, {
              sessionIdHash: this.getSessionIdHash(),
              storedSessionIdHash: Session_1.Session.hash(storedSession.id)
            });
          }
          this.ui.reloadUI();
        }, (err) => {
          var _a2;
          (_a2 = this.eventListener) === null || _a2 === void 0 ? void 0 : _a2.onEvent(EventListener_1.EVENTS.FAILURE, {
            method: "relay::resetAndReload",
            message: `failed to reset and reload with ${err}`,
            sessionIdHash: this.getSessionIdHash()
          });
        });
      }
      setAppInfo(appName, appLogoUrl) {
        this.appName = appName;
        this.appLogoUrl = appLogoUrl;
      }
      getStorageItem(key2) {
        return this.storage.getItem(key2);
      }
      get session() {
        return this._session;
      }
      setStorageItem(key2, value2) {
        this.storage.setItem(key2, value2);
      }
      signEthereumMessage(message, address, addPrefix, typedDataJson) {
        return this.sendRequest({
          method: Web3Method_1.Web3Method.signEthereumMessage,
          params: {
            message: (0, util_1.hexStringFromBuffer)(message, true),
            address,
            addPrefix,
            typedDataJson: typedDataJson || null
          }
        });
      }
      ethereumAddressFromSignedMessage(message, signature2, addPrefix) {
        return this.sendRequest({
          method: Web3Method_1.Web3Method.ethereumAddressFromSignedMessage,
          params: {
            message: (0, util_1.hexStringFromBuffer)(message, true),
            signature: (0, util_1.hexStringFromBuffer)(signature2, true),
            addPrefix
          }
        });
      }
      signEthereumTransaction(params) {
        return this.sendRequest({
          method: Web3Method_1.Web3Method.signEthereumTransaction,
          params: {
            fromAddress: params.fromAddress,
            toAddress: params.toAddress,
            weiValue: (0, util_1.bigIntStringFromBN)(params.weiValue),
            data: (0, util_1.hexStringFromBuffer)(params.data, true),
            nonce: params.nonce,
            gasPriceInWei: params.gasPriceInWei ? (0, util_1.bigIntStringFromBN)(params.gasPriceInWei) : null,
            maxFeePerGas: params.gasPriceInWei ? (0, util_1.bigIntStringFromBN)(params.gasPriceInWei) : null,
            maxPriorityFeePerGas: params.gasPriceInWei ? (0, util_1.bigIntStringFromBN)(params.gasPriceInWei) : null,
            gasLimit: params.gasLimit ? (0, util_1.bigIntStringFromBN)(params.gasLimit) : null,
            chainId: params.chainId,
            shouldSubmit: false
          }
        });
      }
      signAndSubmitEthereumTransaction(params) {
        return this.sendRequest({
          method: Web3Method_1.Web3Method.signEthereumTransaction,
          params: {
            fromAddress: params.fromAddress,
            toAddress: params.toAddress,
            weiValue: (0, util_1.bigIntStringFromBN)(params.weiValue),
            data: (0, util_1.hexStringFromBuffer)(params.data, true),
            nonce: params.nonce,
            gasPriceInWei: params.gasPriceInWei ? (0, util_1.bigIntStringFromBN)(params.gasPriceInWei) : null,
            maxFeePerGas: params.maxFeePerGas ? (0, util_1.bigIntStringFromBN)(params.maxFeePerGas) : null,
            maxPriorityFeePerGas: params.maxPriorityFeePerGas ? (0, util_1.bigIntStringFromBN)(params.maxPriorityFeePerGas) : null,
            gasLimit: params.gasLimit ? (0, util_1.bigIntStringFromBN)(params.gasLimit) : null,
            chainId: params.chainId,
            shouldSubmit: true
          }
        });
      }
      submitEthereumTransaction(signedTransaction, chainId) {
        return this.sendRequest({
          method: Web3Method_1.Web3Method.submitEthereumTransaction,
          params: {
            signedTransaction: (0, util_1.hexStringFromBuffer)(signedTransaction, true),
            chainId
          }
        });
      }
      scanQRCode(regExp) {
        return this.sendRequest({
          method: Web3Method_1.Web3Method.scanQRCode,
          params: { regExp }
        });
      }
      getQRCodeUrl() {
        return (0, util_1.createQrUrl)(this._session.id, this._session.secret, this.linkAPIUrl, false);
      }
      genericRequest(data, action) {
        return this.sendRequest({
          method: Web3Method_1.Web3Method.generic,
          params: {
            action,
            data
          }
        });
      }
      sendGenericMessage(request) {
        return this.sendRequest(request);
      }
      sendRequest(request) {
        let hideSnackbarItem = null;
        const id2 = (0, util_1.randomBytesHex)(8);
        const cancel = (error) => {
          this.publishWeb3RequestCanceledEvent(id2);
          this.handleErrorResponse(id2, request.method, error);
          hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        };
        const promise = new Promise((resolve, reject) => {
          if (!this.ui.isStandalone()) {
            hideSnackbarItem = this.ui.showConnecting({
              isUnlinkedErrorState: this.isUnlinkedErrorState,
              onCancel: cancel,
              onResetConnection: this.resetAndReload
            });
          }
          this.relayEventManager.callbacks.set(id2, (response) => {
            hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
            if (response.errorMessage) {
              return reject(new Error(response.errorMessage));
            }
            resolve(response);
          });
          if (this.ui.isStandalone()) {
            this.sendRequestStandalone(id2, request);
          } else {
            this.publishWeb3RequestEvent(id2, request);
          }
        });
        return { promise, cancel };
      }
      setConnectDisabled(disabled) {
        this.ui.setConnectDisabled(disabled);
      }
      setAccountsCallback(accountsCallback) {
        this.accountsCallback = accountsCallback;
      }
      setChainCallback(chainCallback) {
        this.chainCallback = chainCallback;
      }
      publishWeb3RequestEvent(id2, request) {
        var _a2;
        const message = (0, Web3RequestMessage_1.Web3RequestMessage)({ id: id2, request });
        const storedSession = Session_1.Session.load(this.storage);
        (_a2 = this.eventListener) === null || _a2 === void 0 ? void 0 : _a2.onEvent(EventListener_1.EVENTS.WEB3_REQUEST, {
          eventId: message.id,
          method: `relay::${message.request.method}`,
          sessionIdHash: this.getSessionIdHash(),
          storedSessionIdHash: storedSession ? Session_1.Session.hash(storedSession.id) : "",
          isSessionMismatched: ((storedSession === null || storedSession === void 0 ? void 0 : storedSession.id) !== this._session.id).toString()
        });
        this.subscriptions.add(this.publishEvent("Web3Request", message, true).subscribe({
          next: (_8) => {
            var _a3;
            (_a3 = this.eventListener) === null || _a3 === void 0 ? void 0 : _a3.onEvent(EventListener_1.EVENTS.WEB3_REQUEST_PUBLISHED, {
              eventId: message.id,
              method: `relay::${message.request.method}`,
              sessionIdHash: this.getSessionIdHash(),
              storedSessionIdHash: storedSession ? Session_1.Session.hash(storedSession.id) : "",
              isSessionMismatched: ((storedSession === null || storedSession === void 0 ? void 0 : storedSession.id) !== this._session.id).toString()
            });
          },
          error: (err) => {
            this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
              id: message.id,
              response: {
                method: message.request.method,
                errorMessage: err.message
              }
            }));
          }
        }));
      }
      publishWeb3RequestCanceledEvent(id2) {
        const message = (0, Web3RequestCanceledMessage_1.Web3RequestCanceledMessage)(id2);
        this.subscriptions.add(this.publishEvent("Web3RequestCanceled", message, false).subscribe());
      }
      publishEvent(event, message, callWebhook) {
        const secret = this.session.secret;
        return new rxjs_1.Observable((subscriber) => {
          void aes256gcm.encrypt(JSON.stringify(Object.assign(Object.assign({}, message), { origin: location.origin })), secret).then((encrypted) => {
            subscriber.next(encrypted);
            subscriber.complete();
          });
        }).pipe((0, operators_1.mergeMap)((encrypted) => {
          return this.connection.publishEvent(event, encrypted, callWebhook);
        }));
      }
      handleIncomingEvent(event) {
        try {
          this.subscriptions.add(aes256gcm.decrypt(event.data, this.session.secret).pipe((0, operators_1.map)((c5) => JSON.parse(c5))).subscribe({
            next: (json) => {
              const message = (0, Web3ResponseMessage_1.isWeb3ResponseMessage)(json) ? json : null;
              if (!message) {
                return;
              }
              this.handleWeb3ResponseMessage(message);
            },
            error: () => {
              var _a2;
              (_a2 = this.eventListener) === null || _a2 === void 0 ? void 0 : _a2.onEvent(EventListener_1.EVENTS.GENERAL_ERROR, {
                message: "Had error decrypting",
                value: "incomingEvent"
              });
            }
          }));
        } catch (_a2) {
          return;
        }
      }
      handleWeb3ResponseMessage(message) {
        var _a2;
        const { response } = message;
        (_a2 = this.eventListener) === null || _a2 === void 0 ? void 0 : _a2.onEvent(EventListener_1.EVENTS.WEB3_RESPONSE, {
          eventId: message.id,
          method: `relay::${response.method}`,
          sessionIdHash: this.getSessionIdHash()
        });
        if ((0, Web3Response_1.isRequestEthereumAccountsResponse)(response)) {
          WalletSDKRelay.accountRequestCallbackIds.forEach((id2) => this.invokeCallback(Object.assign(Object.assign({}, message), { id: id2 })));
          WalletSDKRelay.accountRequestCallbackIds.clear();
          return;
        }
        this.invokeCallback(message);
      }
      handleErrorResponse(id2, method2, error, errorCode) {
        this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
          id: id2,
          response: (0, Web3Response_1.ErrorResponse)(method2, (error !== null && error !== void 0 ? error : WalletUIError_1.WalletUIError.UserRejectedRequest).message, errorCode)
        }));
      }
      invokeCallback(message) {
        const callback = this.relayEventManager.callbacks.get(message.id);
        if (callback) {
          callback(message.response);
          this.relayEventManager.callbacks.delete(message.id);
        }
      }
      requestEthereumAccounts() {
        const request = {
          method: Web3Method_1.Web3Method.requestEthereumAccounts,
          params: {
            appName: this.appName,
            appLogoUrl: this.appLogoUrl || null
          }
        };
        const hideSnackbarItem = null;
        const id2 = (0, util_1.randomBytesHex)(8);
        const cancel = (error) => {
          this.publishWeb3RequestCanceledEvent(id2);
          this.handleErrorResponse(id2, request.method, error);
          hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        };
        const promise = new Promise((resolve, reject) => {
          var _a2;
          this.relayEventManager.callbacks.set(id2, (response) => {
            this.ui.hideRequestEthereumAccounts();
            hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
            if (response.errorMessage) {
              return reject(new Error(response.errorMessage));
            }
            resolve(response);
          });
          const userAgent = ((_a2 = window === null || window === void 0 ? void 0 : window.navigator) === null || _a2 === void 0 ? void 0 : _a2.userAgent) || null;
          if (userAgent && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent)) {
            window.location.href = `https://go.cb-w.com/xoXnYwQimhb?cb_url=${encodeURIComponent(window.location.href)}`;
            return;
          }
          if (this.ui.inlineAccountsResponse()) {
            const onAccounts = (accounts) => {
              this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
                id: id2,
                response: (0, Web3Response_1.RequestEthereumAccountsResponse)(accounts)
              }));
            };
            this.ui.requestEthereumAccounts({
              onCancel: cancel,
              onAccounts
            });
          } else {
            this.ui.requestEthereumAccounts({
              onCancel: cancel
            });
          }
          WalletSDKRelay.accountRequestCallbackIds.add(id2);
          if (!this.ui.inlineAccountsResponse() && !this.ui.isStandalone()) {
            this.publishWeb3RequestEvent(id2, request);
          }
        });
        return { promise, cancel };
      }
      watchAsset(type, address, symbol, decimals, image, chainId) {
        const request = {
          method: Web3Method_1.Web3Method.watchAsset,
          params: {
            type,
            options: {
              address,
              symbol,
              decimals,
              image
            },
            chainId
          }
        };
        let hideSnackbarItem = null;
        const id2 = (0, util_1.randomBytesHex)(8);
        const cancel = (error) => {
          this.publishWeb3RequestCanceledEvent(id2);
          this.handleErrorResponse(id2, request.method, error);
          hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        };
        if (!this.ui.inlineWatchAsset()) {
          hideSnackbarItem = this.ui.showConnecting({
            isUnlinkedErrorState: this.isUnlinkedErrorState,
            onCancel: cancel,
            onResetConnection: this.resetAndReload
          });
        }
        const promise = new Promise((resolve, reject) => {
          this.relayEventManager.callbacks.set(id2, (response) => {
            hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
            if (response.errorMessage) {
              return reject(new Error(response.errorMessage));
            }
            resolve(response);
          });
          const _cancel = (_error) => {
            this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
              id: id2,
              response: (0, Web3Response_1.WatchAssetReponse)(false)
            }));
          };
          const approve = () => {
            this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
              id: id2,
              response: (0, Web3Response_1.WatchAssetReponse)(true)
            }));
          };
          if (this.ui.inlineWatchAsset()) {
            this.ui.watchAsset({
              onApprove: approve,
              onCancel: _cancel,
              type,
              address,
              symbol,
              decimals,
              image,
              chainId
            });
          }
          if (!this.ui.inlineWatchAsset() && !this.ui.isStandalone()) {
            this.publishWeb3RequestEvent(id2, request);
          }
        });
        return { cancel, promise };
      }
      addEthereumChain(chainId, rpcUrls, iconUrls, blockExplorerUrls, chainName, nativeCurrency) {
        const request = {
          method: Web3Method_1.Web3Method.addEthereumChain,
          params: {
            chainId,
            rpcUrls,
            blockExplorerUrls,
            chainName,
            iconUrls,
            nativeCurrency
          }
        };
        let hideSnackbarItem = null;
        const id2 = (0, util_1.randomBytesHex)(8);
        const cancel = (error) => {
          this.publishWeb3RequestCanceledEvent(id2);
          this.handleErrorResponse(id2, request.method, error);
          hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        };
        if (!this.ui.inlineAddEthereumChain(chainId)) {
          hideSnackbarItem = this.ui.showConnecting({
            isUnlinkedErrorState: this.isUnlinkedErrorState,
            onCancel: cancel,
            onResetConnection: this.resetAndReload
          });
        }
        const promise = new Promise((resolve, reject) => {
          this.relayEventManager.callbacks.set(id2, (response) => {
            hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
            if (response.errorMessage) {
              return reject(new Error(response.errorMessage));
            }
            resolve(response);
          });
          const _cancel = (_error) => {
            this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
              id: id2,
              response: (0, Web3Response_1.AddEthereumChainResponse)({
                isApproved: false,
                rpcUrl: ""
              })
            }));
          };
          const approve = (rpcUrl) => {
            this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
              id: id2,
              response: (0, Web3Response_1.AddEthereumChainResponse)({ isApproved: true, rpcUrl })
            }));
          };
          if (this.ui.inlineAddEthereumChain(chainId)) {
            this.ui.addEthereumChain({
              onCancel: _cancel,
              onApprove: approve,
              chainId: request.params.chainId,
              rpcUrls: request.params.rpcUrls,
              blockExplorerUrls: request.params.blockExplorerUrls,
              chainName: request.params.chainName,
              iconUrls: request.params.iconUrls,
              nativeCurrency: request.params.nativeCurrency
            });
          }
          if (!this.ui.inlineAddEthereumChain(chainId) && !this.ui.isStandalone()) {
            this.publishWeb3RequestEvent(id2, request);
          }
        });
        return { promise, cancel };
      }
      switchEthereumChain(chainId) {
        const request = {
          method: Web3Method_1.Web3Method.switchEthereumChain,
          params: {
            chainId
          }
        };
        let hideSnackbarItem = null;
        const id2 = (0, util_1.randomBytesHex)(8);
        const cancel = (error) => {
          this.publishWeb3RequestCanceledEvent(id2);
          this.handleErrorResponse(id2, request.method, error);
          hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        };
        if (!this.ui.inlineSwitchEthereumChain()) {
          hideSnackbarItem = this.ui.showConnecting({
            isUnlinkedErrorState: this.isUnlinkedErrorState,
            onCancel: cancel,
            onResetConnection: this.resetAndReload
          });
        }
        const promise = new Promise((resolve, reject) => {
          this.relayEventManager.callbacks.set(id2, (response) => {
            hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
            if (response.errorMessage && response.errorCode) {
              return reject(eth_rpc_errors_1.ethErrors.provider.custom({
                code: response.errorCode,
                message: `Unrecognized chain ID. Try adding the chain using addEthereumChain first.`
              }));
            } else if (response.errorMessage) {
              return reject(new Error(response.errorMessage));
            }
            resolve(response);
          });
          const _cancel = (error) => {
            if (typeof error === "number") {
              const errorCode = error;
              this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
                id: id2,
                response: (0, Web3Response_1.ErrorResponse)(Web3Method_1.Web3Method.switchEthereumChain, WalletUIError_1.WalletUIError.SwitchEthereumChainUnsupportedChainId.message, errorCode)
              }));
            } else if (error instanceof WalletUIError_1.WalletUIError) {
              this.handleErrorResponse(id2, Web3Method_1.Web3Method.switchEthereumChain, error, error.errorCode);
            } else {
              this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
                id: id2,
                response: (0, Web3Response_1.SwitchEthereumChainResponse)({
                  isApproved: false,
                  rpcUrl: ""
                })
              }));
            }
          };
          const approve = (rpcUrl) => {
            this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
              id: id2,
              response: (0, Web3Response_1.SwitchEthereumChainResponse)({
                isApproved: true,
                rpcUrl
              })
            }));
          };
          this.ui.switchEthereumChain({
            onCancel: _cancel,
            onApprove: approve,
            chainId: request.params.chainId
          });
          if (!this.ui.inlineSwitchEthereumChain() && !this.ui.isStandalone()) {
            this.publishWeb3RequestEvent(id2, request);
          }
        });
        return { promise, cancel };
      }
      inlineAddEthereumChain(chainId) {
        return this.ui.inlineAddEthereumChain(chainId);
      }
      getSessionIdHash() {
        return Session_1.Session.hash(this._session.id);
      }
      sendRequestStandalone(id2, request) {
        const _cancel = (error) => {
          this.handleErrorResponse(id2, request.method, error);
        };
        const onSuccess = (response) => {
          this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
            id: id2,
            response
          }));
        };
        switch (request.method) {
          case Web3Method_1.Web3Method.signEthereumMessage:
            this.ui.signEthereumMessage({
              request,
              onSuccess,
              onCancel: _cancel
            });
            break;
          case Web3Method_1.Web3Method.signEthereumTransaction:
            this.ui.signEthereumTransaction({
              request,
              onSuccess,
              onCancel: _cancel
            });
            break;
          case Web3Method_1.Web3Method.submitEthereumTransaction:
            this.ui.submitEthereumTransaction({
              request,
              onSuccess,
              onCancel: _cancel
            });
            break;
          case Web3Method_1.Web3Method.ethereumAddressFromSignedMessage:
            this.ui.ethereumAddressFromSignedMessage({
              request,
              onSuccess
            });
            break;
          default:
            _cancel();
            break;
        }
      }
      onSessionConfigChanged(_nextSessionConfig) {
      }
    };
    WalletSDKRelay.accountRequestCallbackIds = /* @__PURE__ */ new Set();
    __decorate([
      bind_decorator_1.default
    ], WalletSDKRelay.prototype, "resetAndReload", null);
    __decorate([
      bind_decorator_1.default
    ], WalletSDKRelay.prototype, "handleIncomingEvent", null);
    exports2.WalletSDKRelay = WalletSDKRelay;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/relay/WalletSDKRelayEventManager.js
var require_WalletSDKRelayEventManager = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/relay/WalletSDKRelayEventManager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WalletSDKRelayEventManager = void 0;
    var util_1 = require_util3();
    var WalletSDKRelayEventManager = class {
      constructor() {
        this._nextRequestId = 0;
        this.callbacks = /* @__PURE__ */ new Map();
      }
      makeRequestId() {
        this._nextRequestId = (this._nextRequestId + 1) % 2147483647;
        const id2 = this._nextRequestId;
        const idStr = (0, util_1.prepend0x)(id2.toString(16));
        const callback = this.callbacks.get(idStr);
        if (callback) {
          this.callbacks.delete(idStr);
        }
        return id2;
      }
    };
    exports2.WalletSDKRelayEventManager = WalletSDKRelayEventManager;
  }
});

// node_modules/@coinbase/wallet-sdk/package.json
var require_package = __commonJS({
  "node_modules/@coinbase/wallet-sdk/package.json"(exports2, module2) {
    module2.exports = {
      _from: "@coinbase/wallet-sdk@^3.0.8",
      _id: "@coinbase/wallet-sdk@3.1.0",
      _inBundle: false,
      _integrity: "sha512-8IGfVklv/CMfCT4qd9KfL0IwlINsIgSlW1oQB/or8uSY9wAqoY8lIoQVpOyFx7YDK094Xfd9alhulZtRZNJBjw==",
      _location: "/@coinbase/wallet-sdk",
      _phantomChildren: {},
      _requested: {
        type: "range",
        registry: true,
        raw: "@coinbase/wallet-sdk@^3.0.8",
        name: "@coinbase/wallet-sdk",
        escapedName: "@coinbase%2fwallet-sdk",
        scope: "@coinbase",
        rawSpec: "^3.0.8",
        saveSpec: null,
        fetchSpec: "^3.0.8"
      },
      _requiredBy: [
        "/wagmi"
      ],
      _resolved: "https://registry.npmjs.org/@coinbase/wallet-sdk/-/wallet-sdk-3.1.0.tgz",
      _shasum: "294fbd52cf7262b68137731ac414f0cf5a0580a3",
      _spec: "@coinbase/wallet-sdk@^3.0.8",
      _where: "/home/runner/buildspace-dao-starter-v2/node_modules/wagmi",
      author: {
        name: "Coinbase, Inc."
      },
      bugs: {
        url: "https://github.com/coinbase/coinbase-wallet-sdk/issues"
      },
      bundleDependencies: false,
      dependencies: {
        "@metamask/safe-event-emitter": "2.0.0",
        "bind-decorator": "^1.0.11",
        "bn.js": "^5.1.1",
        clsx: "^1.1.0",
        "eth-block-tracker": "4.4.3",
        "eth-json-rpc-filters": "4.2.2",
        "eth-rpc-errors": "4.0.2",
        "js-sha256": "0.9.0",
        "json-rpc-engine": "6.1.0",
        keccak: "^3.0.1",
        preact: "^10.5.9",
        qs: "^6.10.3",
        rxjs: "^6.6.3",
        "stream-browserify": "^3.0.0"
      },
      deprecated: false,
      description: "Coinbase Wallet JavaScript SDK",
      devDependencies: {
        "@babel/core": "^7.17.9",
        "@babel/plugin-proposal-decorators": "^7.17.9",
        "@babel/plugin-transform-react-jsx": "^7.17.3",
        "@babel/preset-env": "^7.16.11",
        "@babel/preset-typescript": "^7.16.7",
        "@peculiar/webcrypto": "^1.3.3",
        "@testing-library/jest-dom": "^5.16.4",
        "@testing-library/preact": "^2.0.1",
        "@types/bn.js": "^4.11.6",
        "@types/jest": "^27.4.1",
        "@types/node": "^14.14.20",
        "@types/qs": "^6.9.7",
        "@typescript-eslint/eslint-plugin": "^5.7.0",
        "@typescript-eslint/eslint-plugin-tslint": "^5.7.0",
        "@typescript-eslint/parser": "^5.7.0",
        "babel-jest": "^27.5.1",
        browserify: "17.0.0",
        "copy-webpack-plugin": "^6.4.1",
        "core-js": "^3.8.2",
        eslint: "^8.4.1",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-import": "^2.25.3",
        "eslint-plugin-preact": "^0.1.0",
        "eslint-plugin-prettier": "^4.0.0",
        "eslint-plugin-simple-import-sort": "^7.0.0",
        jasmine: "3.8.0",
        jest: "^27.5.1",
        "jest-chrome": "^0.7.2",
        karma: "^6.3.15",
        "karma-browserify": "8.1.0",
        "karma-chrome-launcher": "^3.1.0",
        "karma-jasmine": "^4.0.1",
        nodemon: "^2.0.6",
        prettier: "^2.5.1",
        "raw-loader": "^4.0.2",
        "regenerator-runtime": "^0.13.7",
        sass: "^1.50.0",
        svgo: "^2.8.0",
        "ts-jest": "^27.1.4",
        "ts-loader": "^8.0.13",
        "ts-node": "^10.7.0",
        tslib: "^2.0.3",
        typescript: "^4.1.3",
        watchify: "4.0.0",
        webpack: "^5.72.0",
        "webpack-cli": "^4.9.2",
        "whatwg-fetch": "^3.5.0"
      },
      engines: {
        node: ">= 10.0.0"
      },
      homepage: "https://github.com/coinbase/coinbase-wallet-sdk#readme",
      keywords: [
        "cipher",
        "cipherbrowser",
        "coinbase",
        "coinbasewallet",
        "eth",
        "ether",
        "ethereum",
        "etherium",
        "injection",
        "toshi",
        "wallet",
        "walletlink",
        "web3"
      ],
      license: "Apache-2.0",
      main: "dist/index.js",
      name: "@coinbase/wallet-sdk",
      repository: {
        type: "git",
        url: "git+https://github.com/coinbase/coinbase-wallet-sdk.git"
      },
      scripts: {
        build: "node compile-assets.js && webpack --config webpack.config.js",
        "build-npm": "tsc -p ./tsconfig.build.json",
        "build:dev": "export LINK_API_URL='http://localhost:3000'; yarn build",
        "build:dev:watch": "nodemon -e 'ts,tsx,js,json,css,scss,svg' --ignore 'src/**/*-css.ts' --ignore 'src/**/*-svg.ts' --watch src/ --exec 'yarn build:dev'",
        "build:prod": `yarn prebuild && yarn build && yarn build-npm && cp ./package.json ./README.md ./LICENSE build/npm && cp -a src/vendor-js build/npm/dist && sed -i.bak 's|  "private": true,||g' build/npm/package.json && rm -f build/npm/package.json.bak`,
        "fix:eslint": "yarn lint:eslint --fix",
        "fix:prettier": "prettier . --write",
        "lint:eslint": "eslint ./src --ext .ts,.tsx",
        "lint:prettier": 'prettier --check "{src,__tests__}/**/*.(js|ts|tsx)"',
        "lint:types": "tsc --noEmit",
        prebuild: `node -p "'export const LIB_VERSION = ' + JSON.stringify(require('./package.json').version) + ';'" > src/version.ts`,
        "pretest:unit": "node compile-assets.js",
        release: "./scripts/release.sh",
        "test:karma": "yarn build-npm && karma start",
        "test:unit": "jest",
        "test:unit:coverage": "yarn test:unit && open coverage/lcov-report/index.html"
      },
      types: "dist/index.d.ts",
      version: "3.1.0"
    };
  }
});

// node_modules/@coinbase/wallet-sdk/dist/CoinbaseWalletSDK.js
var require_CoinbaseWalletSDK = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/CoinbaseWalletSDK.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CoinbaseWalletSDK = void 0;
    var ScopedLocalStorage_1 = require_ScopedLocalStorage();
    var CoinbaseWalletProvider_1 = require_CoinbaseWalletProvider();
    var WalletSDKUI_1 = require_WalletSDKUI();
    var WalletSDKRelay_1 = require_WalletSDKRelay();
    var WalletSDKRelayEventManager_1 = require_WalletSDKRelayEventManager();
    var util_1 = require_util3();
    var LINK_API_URL = process.env.LINK_API_URL || "https://www.walletlink.org";
    var SDK_VERSION = process.env.SDK_VERSION || require_package().version || "unknown";
    var CoinbaseWalletSDK2 = class {
      constructor(options) {
        var _a2, _b;
        this._appName = "";
        this._appLogoUrl = null;
        this._relay = null;
        this._relayEventManager = null;
        const linkAPIUrl = options.linkAPIUrl || LINK_API_URL;
        let uiConstructor;
        if (!options.uiConstructor) {
          uiConstructor = (opts) => new WalletSDKUI_1.WalletSDKUI(opts);
        } else {
          uiConstructor = options.uiConstructor;
        }
        if (typeof options.overrideIsMetaMask === "undefined") {
          this._overrideIsMetaMask = false;
        } else {
          this._overrideIsMetaMask = options.overrideIsMetaMask;
        }
        this._overrideIsCoinbaseWallet = (_a2 = options.overrideIsCoinbaseWallet) !== null && _a2 !== void 0 ? _a2 : true;
        this._overrideIsCoinbaseBrowser = (_b = options.overrideIsCoinbaseBrowser) !== null && _b !== void 0 ? _b : false;
        this._eventListener = options.eventListener;
        const u7 = new URL(linkAPIUrl);
        const origin = `${u7.protocol}//${u7.host}`;
        this._storage = new ScopedLocalStorage_1.ScopedLocalStorage(`-walletlink:${origin}`);
        this._storage.setItem("version", CoinbaseWalletSDK2.VERSION);
        if (this.walletExtension) {
          return;
        }
        this._relayEventManager = new WalletSDKRelayEventManager_1.WalletSDKRelayEventManager();
        this._relay = new WalletSDKRelay_1.WalletSDKRelay({
          linkAPIUrl,
          version: SDK_VERSION,
          darkMode: !!options.darkMode,
          uiConstructor,
          storage: this._storage,
          relayEventManager: this._relayEventManager,
          eventListener: this._eventListener
        });
        this.setAppInfo(options.appName, options.appLogoUrl);
        if (!!options.headlessMode)
          return;
        this._relay.attachUI();
      }
      makeWeb3Provider(jsonRpcUrl = "", chainId = 1) {
        const extension = this.walletExtension;
        if (extension) {
          if (!this.isCipherProvider(extension)) {
            extension.setProviderInfo(jsonRpcUrl, chainId);
          }
          return extension;
        }
        const relay = this._relay;
        if (!relay || !this._relayEventManager || !this._storage) {
          throw new Error("Relay not initialized, should never happen");
        }
        if (!jsonRpcUrl)
          relay.setConnectDisabled(true);
        return new CoinbaseWalletProvider_1.CoinbaseWalletProvider({
          relayProvider: () => Promise.resolve(relay),
          relayEventManager: this._relayEventManager,
          storage: this._storage,
          jsonRpcUrl,
          chainId,
          qrUrl: this.getQrUrl(),
          eventListener: this._eventListener,
          overrideIsMetaMask: this._overrideIsMetaMask,
          overrideIsCoinbaseWallet: this._overrideIsCoinbaseWallet,
          overrideIsCoinbaseBrowser: this._overrideIsCoinbaseBrowser
        });
      }
      setAppInfo(appName, appLogoUrl) {
        var _a2;
        this._appName = appName || "DApp";
        this._appLogoUrl = appLogoUrl || (0, util_1.getFavicon)();
        const extension = this.walletExtension;
        if (extension) {
          if (!this.isCipherProvider(extension)) {
            extension.setAppInfo(this._appName, this._appLogoUrl);
          }
        } else {
          (_a2 = this._relay) === null || _a2 === void 0 ? void 0 : _a2.setAppInfo(this._appName, this._appLogoUrl);
        }
      }
      disconnect() {
        var _a2;
        const extension = this.walletExtension;
        if (extension) {
          void extension.close();
        } else {
          (_a2 = this._relay) === null || _a2 === void 0 ? void 0 : _a2.resetAndReload();
        }
      }
      getQrUrl() {
        var _a2, _b;
        return (_b = (_a2 = this._relay) === null || _a2 === void 0 ? void 0 : _a2.getQRCodeUrl()) !== null && _b !== void 0 ? _b : null;
      }
      get walletExtension() {
        var _a2;
        return (_a2 = window.coinbaseWalletExtension) !== null && _a2 !== void 0 ? _a2 : window.walletLinkExtension;
      }
      isCipherProvider(provider) {
        return typeof provider.isCipher === "boolean" && provider.isCipher;
      }
    };
    exports2.CoinbaseWalletSDK = CoinbaseWalletSDK2;
    CoinbaseWalletSDK2.VERSION = SDK_VERSION;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CoinbaseWalletProvider = exports2.CoinbaseWalletSDK = void 0;
    var CoinbaseWalletSDK_1 = require_CoinbaseWalletSDK();
    var CoinbaseWalletProvider_1 = require_CoinbaseWalletProvider();
    var CoinbaseWalletSDK_2 = require_CoinbaseWalletSDK();
    Object.defineProperty(exports2, "CoinbaseWalletSDK", { enumerable: true, get: function() {
      return CoinbaseWalletSDK_2.CoinbaseWalletSDK;
    } });
    var CoinbaseWalletProvider_2 = require_CoinbaseWalletProvider();
    Object.defineProperty(exports2, "CoinbaseWalletProvider", { enumerable: true, get: function() {
      return CoinbaseWalletProvider_2.CoinbaseWalletProvider;
    } });
    exports2.default = CoinbaseWalletSDK_1.CoinbaseWalletSDK;
    if (typeof window !== "undefined") {
      window.CoinbaseWalletSDK = CoinbaseWalletSDK_1.CoinbaseWalletSDK;
      window.CoinbaseWalletProvider = CoinbaseWalletProvider_1.CoinbaseWalletProvider;
      window.WalletLink = CoinbaseWalletSDK_1.CoinbaseWalletSDK;
      window.WalletLinkProvider = CoinbaseWalletProvider_1.CoinbaseWalletProvider;
    }
  }
});

// node_modules/@walletconnect/environment/dist/cjs/crypto.js
var require_crypto = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/crypto.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isBrowserCryptoAvailable = exports2.getSubtleCrypto = exports2.getBrowerCrypto = void 0;
    function getBrowerCrypto2() {
      return (global === null || global === void 0 ? void 0 : global.crypto) || (global === null || global === void 0 ? void 0 : global.msCrypto) || {};
    }
    exports2.getBrowerCrypto = getBrowerCrypto2;
    function getSubtleCrypto2() {
      const browserCrypto = getBrowerCrypto2();
      return browserCrypto.subtle || browserCrypto.webkitSubtle;
    }
    exports2.getSubtleCrypto = getSubtleCrypto2;
    function isBrowserCryptoAvailable() {
      return !!getBrowerCrypto2() && !!getSubtleCrypto2();
    }
    exports2.isBrowserCryptoAvailable = isBrowserCryptoAvailable;
  }
});

// node_modules/@walletconnect/environment/dist/cjs/env.js
var require_env = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/env.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isBrowser = exports2.isNode = exports2.isReactNative = void 0;
    function isReactNative() {
      return typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative";
    }
    exports2.isReactNative = isReactNative;
    function isNode3() {
      return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
    }
    exports2.isNode = isNode3;
    function isBrowser2() {
      return !isReactNative() && !isNode3();
    }
    exports2.isBrowser = isBrowser2;
  }
});

// node_modules/@walletconnect/environment/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o6, m6, k8, k22) {
      if (k22 === void 0)
        k22 = k8;
      Object.defineProperty(o6, k22, { enumerable: true, get: function() {
        return m6[k8];
      } });
    } : function(o6, m6, k8, k22) {
      if (k22 === void 0)
        k22 = k8;
      o6[k22] = m6[k8];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m6, exports3) {
      for (var p7 in m6)
        if (p7 !== "default" && !exports3.hasOwnProperty(p7))
          __createBinding(exports3, m6, p7);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_crypto(), exports2);
    __exportStar(require_env(), exports2);
  }
});

// node_modules/cross-fetch/dist/browser-ponyfill.js
var require_browser_ponyfill = __commonJS({
  "node_modules/cross-fetch/dist/browser-ponyfill.js"(exports2, module2) {
    var global2 = typeof self !== "undefined" ? self : exports2;
    var __self__ = function() {
      function F5() {
        this.fetch = false;
        this.DOMException = global2.DOMException;
      }
      F5.prototype = global2;
      return new F5();
    }();
    (function(self2) {
      var irrelevant = function(exports3) {
        var support = {
          searchParams: "URLSearchParams" in self2,
          iterable: "Symbol" in self2 && "iterator" in Symbol,
          blob: "FileReader" in self2 && "Blob" in self2 && function() {
            try {
              new Blob();
              return true;
            } catch (e6) {
              return false;
            }
          }(),
          formData: "FormData" in self2,
          arrayBuffer: "ArrayBuffer" in self2
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name2) {
          if (typeof name2 !== "string") {
            name2 = String(name2);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name2)) {
            throw new TypeError("Invalid character in header field name");
          }
          return name2.toLowerCase();
        }
        function normalizeValue(value2) {
          if (typeof value2 !== "string") {
            value2 = String(value2);
          }
          return value2;
        }
        function iteratorFor(items) {
          var iterator2 = {
            next: function() {
              var value2 = items.shift();
              return { done: value2 === void 0, value: value2 };
            }
          };
          if (support.iterable) {
            iterator2[Symbol.iterator] = function() {
              return iterator2;
            };
          }
          return iterator2;
        }
        function Headers(headers) {
          this.map = {};
          if (headers instanceof Headers) {
            headers.forEach(function(value2, name2) {
              this.append(name2, value2);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name2) {
              this.append(name2, headers[name2]);
            }, this);
          }
        }
        Headers.prototype.append = function(name2, value2) {
          name2 = normalizeName(name2);
          value2 = normalizeValue(value2);
          var oldValue = this.map[name2];
          this.map[name2] = oldValue ? oldValue + ", " + value2 : value2;
        };
        Headers.prototype["delete"] = function(name2) {
          delete this.map[normalizeName(name2)];
        };
        Headers.prototype.get = function(name2) {
          name2 = normalizeName(name2);
          return this.has(name2) ? this.map[name2] : null;
        };
        Headers.prototype.has = function(name2) {
          return this.map.hasOwnProperty(normalizeName(name2));
        };
        Headers.prototype.set = function(name2, value2) {
          this.map[normalizeName(name2)] = normalizeValue(value2);
        };
        Headers.prototype.forEach = function(callback, thisArg) {
          for (var name2 in this.map) {
            if (this.map.hasOwnProperty(name2)) {
              callback.call(thisArg, this.map[name2], name2, this);
            }
          }
        };
        Headers.prototype.keys = function() {
          var items = [];
          this.forEach(function(value2, name2) {
            items.push(name2);
          });
          return iteratorFor(items);
        };
        Headers.prototype.values = function() {
          var items = [];
          this.forEach(function(value2) {
            items.push(value2);
          });
          return iteratorFor(items);
        };
        Headers.prototype.entries = function() {
          var items = [];
          this.forEach(function(value2, name2) {
            items.push([name2, value2]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        }
        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsText(blob);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i6 = 0; i6 < view.length; i6++) {
            chars[i6] = String.fromCharCode(view[i6]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this._bodyInit = body;
            if (!body) {
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
              } else {
                return this.blob().then(readBlobAsArrayBuffer);
              }
            };
          }
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode3);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function normalizeMethod(method2) {
          var upcased = method2.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method2;
        }
        function Request(input, options) {
          options = options || {};
          var body = options.body;
          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal;
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
        }
        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit });
        };
        function decode3(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split("=");
              var name2 = split.shift().replace(/\+/g, " ");
              var value2 = split.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name2), decodeURIComponent(value2));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
            var parts = line.split(":");
            var key2 = parts.shift().trim();
            if (key2) {
              var value2 = parts.join(":").trim();
              headers.append(key2, value2);
            }
          });
          return headers;
        }
        Body.call(Request.prototype);
        function Response(bodyInit, options) {
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = "statusText" in options ? options.statusText : "OK";
          this.headers = new Headers(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response.prototype);
        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          });
        };
        Response.error = function() {
          var response = new Response(null, { status: 0, statusText: "" });
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response(null, { status, headers: { location: url } });
        };
        exports3.DOMException = self2.DOMException;
        try {
          new exports3.DOMException();
        } catch (err) {
          exports3.DOMException = function(message, name2) {
            this.message = message;
            this.name = name2;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports3.DOMException.prototype = Object.create(Error.prototype);
          exports3.DOMException.prototype.constructor = exports3.DOMException;
        }
        function fetch3(input, init2) {
          return new Promise(function(resolve, reject) {
            var request = new Request(input, init2);
            if (request.signal && request.signal.aborted) {
              return reject(new exports3.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              resolve(new Response(body, options));
            };
            xhr.onerror = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.ontimeout = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.onabort = function() {
              reject(new exports3.DOMException("Aborted", "AbortError"));
            };
            xhr.open(request.method, request.url, true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr && support.blob) {
              xhr.responseType = "blob";
            }
            request.headers.forEach(function(value2, name2) {
              xhr.setRequestHeader(name2, value2);
            });
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch3.polyfill = true;
        if (!self2.fetch) {
          self2.fetch = fetch3;
          self2.Headers = Headers;
          self2.Request = Request;
          self2.Response = Response;
        }
        exports3.Headers = Headers;
        exports3.Request = Request;
        exports3.Response = Response;
        exports3.fetch = fetch3;
        Object.defineProperty(exports3, "__esModule", { value: true });
        return exports3;
      }({});
    })(__self__);
    __self__.fetch.ponyfill = true;
    delete __self__.fetch.polyfill;
    var ctx = __self__;
    exports2 = ctx.fetch;
    exports2.default = ctx.fetch;
    exports2.fetch = ctx.fetch;
    exports2.Headers = ctx.Headers;
    exports2.Request = ctx.Request;
    exports2.Response = ctx.Response;
    module2.exports = exports2;
  }
});

// node_modules/@walletconnect/safe-json/dist/esm/index.js
function safeJsonParse(value2) {
  if (typeof value2 !== "string") {
    throw new Error(`Cannot safe json parse value of type ${typeof value2}`);
  }
  try {
    return JSON.parse(value2);
  } catch (_a2) {
    return value2;
  }
}
function safeJsonStringify(value2) {
  return typeof value2 === "string" ? value2 : JSON.stringify(value2);
}
var init_esm = __esm({
  "node_modules/@walletconnect/safe-json/dist/esm/index.js"() {
  }
});

// node_modules/@walletconnect/window-getters/dist/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/@walletconnect/window-getters/dist/cjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getLocalStorage = exports2.getLocalStorageOrThrow = exports2.getCrypto = exports2.getCryptoOrThrow = exports2.getLocation = exports2.getLocationOrThrow = exports2.getNavigator = exports2.getNavigatorOrThrow = exports2.getDocument = exports2.getDocumentOrThrow = exports2.getFromWindowOrThrow = exports2.getFromWindow = void 0;
    function getFromWindow3(name2) {
      let res = void 0;
      if (typeof window !== "undefined" && typeof window[name2] !== "undefined") {
        res = window[name2];
      }
      return res;
    }
    exports2.getFromWindow = getFromWindow3;
    function getFromWindowOrThrow3(name2) {
      const res = getFromWindow3(name2);
      if (!res) {
        throw new Error(`${name2} is not defined in Window`);
      }
      return res;
    }
    exports2.getFromWindowOrThrow = getFromWindowOrThrow3;
    function getDocumentOrThrow3() {
      return getFromWindowOrThrow3("document");
    }
    exports2.getDocumentOrThrow = getDocumentOrThrow3;
    function getDocument3() {
      return getFromWindow3("document");
    }
    exports2.getDocument = getDocument3;
    function getNavigatorOrThrow3() {
      return getFromWindowOrThrow3("navigator");
    }
    exports2.getNavigatorOrThrow = getNavigatorOrThrow3;
    function getNavigator3() {
      return getFromWindow3("navigator");
    }
    exports2.getNavigator = getNavigator3;
    function getLocationOrThrow3() {
      return getFromWindowOrThrow3("location");
    }
    exports2.getLocationOrThrow = getLocationOrThrow3;
    function getLocation3() {
      return getFromWindow3("location");
    }
    exports2.getLocation = getLocation3;
    function getCryptoOrThrow3() {
      return getFromWindowOrThrow3("crypto");
    }
    exports2.getCryptoOrThrow = getCryptoOrThrow3;
    function getCrypto3() {
      return getFromWindow3("crypto");
    }
    exports2.getCrypto = getCrypto3;
    function getLocalStorageOrThrow3() {
      return getFromWindowOrThrow3("localStorage");
    }
    exports2.getLocalStorageOrThrow = getLocalStorageOrThrow3;
    function getLocalStorage3() {
      return getFromWindow3("localStorage");
    }
    exports2.getLocalStorage = getLocalStorage3;
  }
});

// node_modules/@walletconnect/window-metadata/dist/cjs/index.js
var require_cjs3 = __commonJS({
  "node_modules/@walletconnect/window-metadata/dist/cjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getWindowMetadata = void 0;
    var window_getters_1 = require_cjs2();
    function getWindowMetadata2() {
      let doc;
      let loc;
      try {
        doc = window_getters_1.getDocumentOrThrow();
        loc = window_getters_1.getLocationOrThrow();
      } catch (e6) {
        return null;
      }
      function getIcons() {
        const links = doc.getElementsByTagName("link");
        const icons2 = [];
        for (let i6 = 0; i6 < links.length; i6++) {
          const link = links[i6];
          const rel = link.getAttribute("rel");
          if (rel) {
            if (rel.toLowerCase().indexOf("icon") > -1) {
              const href = link.getAttribute("href");
              if (href) {
                if (href.toLowerCase().indexOf("https:") === -1 && href.toLowerCase().indexOf("http:") === -1 && href.indexOf("//") !== 0) {
                  let absoluteHref = loc.protocol + "//" + loc.host;
                  if (href.indexOf("/") === 0) {
                    absoluteHref += href;
                  } else {
                    const path = loc.pathname.split("/");
                    path.pop();
                    const finalPath = path.join("/");
                    absoluteHref += finalPath + "/" + href;
                  }
                  icons2.push(absoluteHref);
                } else if (href.indexOf("//") === 0) {
                  const absoluteUrl = loc.protocol + href;
                  icons2.push(absoluteUrl);
                } else {
                  icons2.push(href);
                }
              }
            }
          }
        }
        return icons2;
      }
      function getWindowMetadataOfAny(...args) {
        const metaTags = doc.getElementsByTagName("meta");
        for (let i6 = 0; i6 < metaTags.length; i6++) {
          const tag = metaTags[i6];
          const attributes = ["itemprop", "property", "name"].map((target) => tag.getAttribute(target)).filter((attr) => {
            if (attr) {
              return args.includes(attr);
            }
            return false;
          });
          if (attributes.length && attributes) {
            const content = tag.getAttribute("content");
            if (content) {
              return content;
            }
          }
        }
        return "";
      }
      function getName() {
        let name3 = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title");
        if (!name3) {
          name3 = doc.title;
        }
        return name3;
      }
      function getDescription() {
        const description2 = getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
        return description2;
      }
      const name2 = getName();
      const description = getDescription();
      const url = loc.origin;
      const icons = getIcons();
      const meta = {
        description,
        url,
        icons,
        name: name2
      };
      return meta;
    }
    exports2.getWindowMetadata = getWindowMetadata2;
  }
});

// node_modules/@walletconnect/browser-utils/node_modules/detect-browser/es/index.js
function detect(userAgent) {
  if (!!userAgent) {
    return parseUserAgent(userAgent);
  }
  if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return new ReactNativeInfo();
  }
  if (typeof navigator !== "undefined") {
    return parseUserAgent(navigator.userAgent);
  }
  return getNodeVersion();
}
function matchUserAgent(ua2) {
  return ua2 !== "" && userAgentRules.reduce(function(matched, _a2) {
    var browser = _a2[0], regex = _a2[1];
    if (matched) {
      return matched;
    }
    var uaMatch = regex.exec(ua2);
    return !!uaMatch && [browser, uaMatch];
  }, false);
}
function parseUserAgent(ua2) {
  var matchedRule = matchUserAgent(ua2);
  if (!matchedRule) {
    return null;
  }
  var name2 = matchedRule[0], match = matchedRule[1];
  if (name2 === "searchbot") {
    return new BotInfo();
  }
  var versionParts = match[1] && match[1].split(/[._]/).slice(0, 3);
  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS) {
      versionParts = __spreadArrays(versionParts, createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length));
    }
  } else {
    versionParts = [];
  }
  var version27 = versionParts.join(".");
  var os = detectOS(ua2);
  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua2);
  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo(name2, version27, os, searchBotMatch[1]);
  }
  return new BrowserInfo(name2, version27, os);
}
function detectOS(ua2) {
  for (var ii3 = 0, count2 = operatingSystemRules.length; ii3 < count2; ii3++) {
    var _a2 = operatingSystemRules[ii3], os = _a2[0], regex = _a2[1];
    var match = regex.exec(ua2);
    if (match) {
      return os;
    }
  }
  return null;
}
function getNodeVersion() {
  var isNode3 = typeof process !== "undefined" && process.version;
  return isNode3 ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(count2) {
  var output = [];
  for (var ii3 = 0; ii3 < count2; ii3++) {
    output.push("0");
  }
  return output;
}
var __spreadArrays, BrowserInfo, NodeInfo, SearchBotDeviceInfo, BotInfo, ReactNativeInfo, SEARCHBOX_UA_REGEX, SEARCHBOT_OS_REGEX, REQUIRED_VERSION_PARTS, userAgentRules, operatingSystemRules;
var init_es = __esm({
  "node_modules/@walletconnect/browser-utils/node_modules/detect-browser/es/index.js"() {
    __spreadArrays = function() {
      for (var s6 = 0, i6 = 0, il = arguments.length; i6 < il; i6++)
        s6 += arguments[i6].length;
      for (var r6 = Array(s6), k8 = 0, i6 = 0; i6 < il; i6++)
        for (var a5 = arguments[i6], j8 = 0, jl = a5.length; j8 < jl; j8++, k8++)
          r6[k8] = a5[j8];
      return r6;
    };
    BrowserInfo = function() {
      function BrowserInfo3(name2, version27, os) {
        this.name = name2;
        this.version = version27;
        this.os = os;
        this.type = "browser";
      }
      return BrowserInfo3;
    }();
    NodeInfo = function() {
      function NodeInfo3(version27) {
        this.version = version27;
        this.type = "node";
        this.name = "node";
        this.os = process.platform;
      }
      return NodeInfo3;
    }();
    SearchBotDeviceInfo = function() {
      function SearchBotDeviceInfo3(name2, version27, os, bot) {
        this.name = name2;
        this.version = version27;
        this.os = os;
        this.bot = bot;
        this.type = "bot-device";
      }
      return SearchBotDeviceInfo3;
    }();
    BotInfo = function() {
      function BotInfo3() {
        this.type = "bot";
        this.bot = true;
        this.name = "bot";
        this.version = null;
        this.os = null;
      }
      return BotInfo3;
    }();
    ReactNativeInfo = function() {
      function ReactNativeInfo3() {
        this.type = "react-native";
        this.name = "react-native";
        this.version = null;
        this.os = null;
      }
      return ReactNativeInfo3;
    }();
    SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
    SEARCHBOT_OS_REGEX = /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
    REQUIRED_VERSION_PARTS = 3;
    userAgentRules = [
      ["aol", /AOLShield\/([0-9\._]+)/],
      ["edge", /Edge\/([0-9\._]+)/],
      ["edge-ios", /EdgiOS\/([0-9\._]+)/],
      ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
      ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
      ["samsung", /SamsungBrowser\/([0-9\.]+)/],
      ["silk", /\bSilk\/([0-9._-]+)\b/],
      ["miui", /MiuiBrowser\/([0-9\.]+)$/],
      ["beaker", /BeakerBrowser\/([0-9\.]+)/],
      ["edge-chromium", /EdgA?\/([0-9\.]+)/],
      [
        "chromium-webview",
        /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
      ],
      ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
      ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
      ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
      ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
      ["fxios", /FxiOS\/([0-9\.]+)/],
      ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
      ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
      ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
      ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
      ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
      ["ie", /MSIE\s(7\.0)/],
      ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
      ["android", /Android\s([0-9\.]+)/],
      ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
      ["safari", /Version\/([0-9\._]+).*Safari/],
      ["facebook", /FBAV\/([0-9\.]+)/],
      ["instagram", /Instagram\s([0-9\.]+)/],
      ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
      ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
      ["searchbot", SEARCHBOX_UA_REGEX]
    ];
    operatingSystemRules = [
      ["iOS", /iP(hone|od|ad)/],
      ["Android OS", /Android/],
      ["BlackBerry OS", /BlackBerry|BB10/],
      ["Windows Mobile", /IEMobile/],
      ["Amazon OS", /Kindle/],
      ["Windows 3.11", /Win16/],
      ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
      ["Windows 98", /(Windows 98)|(Win98)/],
      ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
      ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
      ["Windows Server 2003", /(Windows NT 5.2)/],
      ["Windows Vista", /(Windows NT 6.0)/],
      ["Windows 7", /(Windows NT 6.1)/],
      ["Windows 8", /(Windows NT 6.2)/],
      ["Windows 8.1", /(Windows NT 6.3)/],
      ["Windows 10", /(Windows NT 10.0)/],
      ["Windows ME", /Windows ME/],
      ["Open BSD", /OpenBSD/],
      ["Sun OS", /SunOS/],
      ["Chrome OS", /CrOS/],
      ["Linux", /(Linux)|(X11)/],
      ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
      ["QNX", /QNX/],
      ["BeOS", /BeOS/],
      ["OS/2", /OS\/2/]
    ];
  }
});

// node_modules/@walletconnect/browser-utils/dist/esm/browser.js
function detectEnv(userAgent) {
  return detect(userAgent);
}
function detectOS2() {
  const env3 = detectEnv();
  return env3 && env3.os ? env3.os : void 0;
}
function isAndroid() {
  const os = detectOS2();
  return os ? os.toLowerCase().includes("android") : false;
}
function isIOS() {
  const os = detectOS2();
  return os ? os.toLowerCase().includes("ios") || os.toLowerCase().includes("mac") && navigator.maxTouchPoints > 1 : false;
}
function isMobile() {
  const os = detectOS2();
  return os ? isAndroid() || isIOS() : false;
}
function isNode2() {
  const env3 = detectEnv();
  const result = env3 && env3.name ? env3.name.toLowerCase() === "node" : false;
  return result;
}
function isBrowser() {
  const result = !isNode2() && !!getNavigator2();
  return result;
}
function getClientMeta() {
  return windowMetadata.getWindowMetadata();
}
var windowMetadata, windowGetters, getFromWindow2, getFromWindowOrThrow2, getDocumentOrThrow2, getDocument2, getNavigatorOrThrow2, getNavigator2, getLocationOrThrow2, getLocation2, getCryptoOrThrow2, getCrypto2, getLocalStorageOrThrow2, getLocalStorage2;
var init_browser = __esm({
  "node_modules/@walletconnect/browser-utils/dist/esm/browser.js"() {
    windowMetadata = __toESM(require_cjs3());
    windowGetters = __toESM(require_cjs2());
    init_es();
    getFromWindow2 = windowGetters.getFromWindow;
    getFromWindowOrThrow2 = windowGetters.getFromWindowOrThrow;
    getDocumentOrThrow2 = windowGetters.getDocumentOrThrow;
    getDocument2 = windowGetters.getDocument;
    getNavigatorOrThrow2 = windowGetters.getNavigatorOrThrow;
    getNavigator2 = windowGetters.getNavigator;
    getLocationOrThrow2 = windowGetters.getLocationOrThrow;
    getLocation2 = windowGetters.getLocation;
    getCryptoOrThrow2 = windowGetters.getCryptoOrThrow;
    getCrypto2 = windowGetters.getCrypto;
    getLocalStorageOrThrow2 = windowGetters.getLocalStorageOrThrow;
    getLocalStorage2 = windowGetters.getLocalStorage;
  }
});

// node_modules/@walletconnect/browser-utils/dist/esm/json.js
var safeJsonParse2, safeJsonStringify2;
var init_json = __esm({
  "node_modules/@walletconnect/browser-utils/dist/esm/json.js"() {
    init_esm();
    safeJsonParse2 = safeJsonParse;
    safeJsonStringify2 = safeJsonStringify;
  }
});

// node_modules/@walletconnect/browser-utils/dist/esm/local.js
function setLocal(key2, data) {
  const raw = safeJsonStringify2(data);
  const local = getLocalStorage2();
  if (local) {
    local.setItem(key2, raw);
  }
}
function getLocal(key2) {
  let data = null;
  let raw = null;
  const local = getLocalStorage2();
  if (local) {
    raw = local.getItem(key2);
  }
  data = raw ? safeJsonParse2(raw) : raw;
  return data;
}
function removeLocal(key2) {
  const local = getLocalStorage2();
  if (local) {
    local.removeItem(key2);
  }
}
var init_local = __esm({
  "node_modules/@walletconnect/browser-utils/dist/esm/local.js"() {
    init_json();
    init_browser();
  }
});

// node_modules/@walletconnect/browser-utils/dist/esm/mobile.js
function formatIOSMobile(uri, entry) {
  const encodedUri = encodeURIComponent(uri);
  return entry.universalLink ? `${entry.universalLink}/wc?uri=${encodedUri}` : entry.deepLink ? `${entry.deepLink}${entry.deepLink.endsWith(":") ? "//" : "/"}wc?uri=${encodedUri}` : "";
}
function saveMobileLinkInfo(data) {
  const focusUri = data.href.split("?")[0];
  setLocal(mobileLinkChoiceKey, Object.assign(Object.assign({}, data), { href: focusUri }));
}
function getMobileRegistryEntry(registry, name2) {
  return registry.filter((entry) => entry.name.toLowerCase().includes(name2.toLowerCase()))[0];
}
function getMobileLinkRegistry(registry, whitelist) {
  let links = registry;
  if (whitelist) {
    links = whitelist.map((name2) => getMobileRegistryEntry(registry, name2)).filter(Boolean);
  }
  return links;
}
var mobileLinkChoiceKey;
var init_mobile = __esm({
  "node_modules/@walletconnect/browser-utils/dist/esm/mobile.js"() {
    init_local();
    mobileLinkChoiceKey = "WALLETCONNECT_DEEPLINK_CHOICE";
  }
});

// node_modules/@walletconnect/browser-utils/dist/esm/registry.js
function getWalletRegistryUrl() {
  return API_URL + "/api/v2/wallets";
}
function getDappRegistryUrl() {
  return API_URL + "/api/v2/dapps";
}
function formatMobileRegistryEntry(entry, platform = "mobile") {
  var _a2;
  return {
    name: entry.name || "",
    shortName: entry.metadata.shortName || "",
    color: entry.metadata.colors.primary || "",
    logo: (_a2 = entry.image_url.sm) !== null && _a2 !== void 0 ? _a2 : "",
    universalLink: entry[platform].universal || "",
    deepLink: entry[platform].native || ""
  };
}
function formatMobileRegistry(registry, platform = "mobile") {
  return Object.values(registry).filter((entry) => !!entry[platform].universal || !!entry[platform].native).map((entry) => formatMobileRegistryEntry(entry, platform));
}
var API_URL;
var init_registry = __esm({
  "node_modules/@walletconnect/browser-utils/dist/esm/registry.js"() {
    API_URL = "https://registry.walletconnect.com";
  }
});

// node_modules/@walletconnect/browser-utils/dist/esm/index.js
var esm_exports3 = {};
__export(esm_exports3, {
  detectEnv: () => detectEnv,
  detectOS: () => detectOS2,
  formatIOSMobile: () => formatIOSMobile,
  formatMobileRegistry: () => formatMobileRegistry,
  formatMobileRegistryEntry: () => formatMobileRegistryEntry,
  getClientMeta: () => getClientMeta,
  getCrypto: () => getCrypto2,
  getCryptoOrThrow: () => getCryptoOrThrow2,
  getDappRegistryUrl: () => getDappRegistryUrl,
  getDocument: () => getDocument2,
  getDocumentOrThrow: () => getDocumentOrThrow2,
  getFromWindow: () => getFromWindow2,
  getFromWindowOrThrow: () => getFromWindowOrThrow2,
  getLocal: () => getLocal,
  getLocalStorage: () => getLocalStorage2,
  getLocalStorageOrThrow: () => getLocalStorageOrThrow2,
  getLocation: () => getLocation2,
  getLocationOrThrow: () => getLocationOrThrow2,
  getMobileLinkRegistry: () => getMobileLinkRegistry,
  getMobileRegistryEntry: () => getMobileRegistryEntry,
  getNavigator: () => getNavigator2,
  getNavigatorOrThrow: () => getNavigatorOrThrow2,
  getWalletRegistryUrl: () => getWalletRegistryUrl,
  isAndroid: () => isAndroid,
  isBrowser: () => isBrowser,
  isIOS: () => isIOS,
  isMobile: () => isMobile,
  isNode: () => isNode2,
  mobileLinkChoiceKey: () => mobileLinkChoiceKey,
  removeLocal: () => removeLocal,
  safeJsonParse: () => safeJsonParse2,
  safeJsonStringify: () => safeJsonStringify2,
  saveMobileLinkInfo: () => saveMobileLinkInfo,
  setLocal: () => setLocal
});
var init_esm2 = __esm({
  "node_modules/@walletconnect/browser-utils/dist/esm/index.js"() {
    init_browser();
    init_json();
    init_local();
    init_mobile();
    init_registry();
  }
});

// node_modules/@walletconnect/utils/node_modules/bn.js/lib/bn.js
var require_bn4 = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/bn.js/lib/bn.js"(exports2, module2) {
    (function(module3, exports3) {
      "use strict";
      function assert3(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN4(number, base2, endian) {
        if (BN4.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base2 === "le" || base2 === "be") {
            endian = base2;
            base2 = 10;
          }
          this._init(number || 0, base2 || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN4;
      } else {
        exports3.BN = BN4;
      }
      BN4.BN = BN4;
      BN4.wordSize = 26;
      var Buffer2;
      try {
        Buffer2 = require_buffer().Buffer;
      } catch (e6) {
      }
      BN4.isBN = function isBN(num) {
        if (num instanceof BN4) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN4.wordSize && Array.isArray(num.words);
      };
      BN4.max = function max2(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN4.min = function min2(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN4.prototype._init = function init2(number, base2, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base2, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base2, endian);
        }
        if (base2 === "hex") {
          base2 = 16;
        }
        assert3(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
        }
        if (base2 === 16) {
          this._parseHex(number, start);
        } else {
          this._parseBase(number, base2, start);
        }
        if (number[0] === "-") {
          this.negative = 1;
        }
        this.strip();
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN4.prototype._initNumber = function _initNumber(number, base2, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert3(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN4.prototype._initArray = function _initArray(number, base2, endian) {
        assert3(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i6 = 0; i6 < this.length; i6++) {
          this.words[i6] = 0;
        }
        var j8, w8;
        var off = 0;
        if (endian === "be") {
          for (i6 = number.length - 1, j8 = 0; i6 >= 0; i6 -= 3) {
            w8 = number[i6] | number[i6 - 1] << 8 | number[i6 - 2] << 16;
            this.words[j8] |= w8 << off & 67108863;
            this.words[j8 + 1] = w8 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j8++;
            }
          }
        } else if (endian === "le") {
          for (i6 = 0, j8 = 0; i6 < number.length; i6 += 3) {
            w8 = number[i6] | number[i6 + 1] << 8 | number[i6 + 2] << 16;
            this.words[j8] |= w8 << off & 67108863;
            this.words[j8 + 1] = w8 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j8++;
            }
          }
        }
        return this.strip();
      };
      function parseHex(str, start, end) {
        var r6 = 0;
        var len = Math.min(str.length, end);
        for (var i6 = start; i6 < len; i6++) {
          var c5 = str.charCodeAt(i6) - 48;
          r6 <<= 4;
          if (c5 >= 49 && c5 <= 54) {
            r6 |= c5 - 49 + 10;
          } else if (c5 >= 17 && c5 <= 22) {
            r6 |= c5 - 17 + 10;
          } else {
            r6 |= c5 & 15;
          }
        }
        return r6;
      }
      BN4.prototype._parseHex = function _parseHex(number, start) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i6 = 0; i6 < this.length; i6++) {
          this.words[i6] = 0;
        }
        var j8, w8;
        var off = 0;
        for (i6 = number.length - 6, j8 = 0; i6 >= start; i6 -= 6) {
          w8 = parseHex(number, i6, i6 + 6);
          this.words[j8] |= w8 << off & 67108863;
          this.words[j8 + 1] |= w8 >>> 26 - off & 4194303;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j8++;
          }
        }
        if (i6 + 6 !== start) {
          w8 = parseHex(number, start, i6 + 6);
          this.words[j8] |= w8 << off & 67108863;
          this.words[j8 + 1] |= w8 >>> 26 - off & 4194303;
        }
        this.strip();
      };
      function parseBase(str, start, end, mul3) {
        var r6 = 0;
        var len = Math.min(str.length, end);
        for (var i6 = start; i6 < len; i6++) {
          var c5 = str.charCodeAt(i6) - 48;
          r6 *= mul3;
          if (c5 >= 49) {
            r6 += c5 - 49 + 10;
          } else if (c5 >= 17) {
            r6 += c5 - 17 + 10;
          } else {
            r6 += c5;
          }
        }
        return r6;
      }
      BN4.prototype._parseBase = function _parseBase(number, base2, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base2 | 0;
        var total = number.length - start;
        var mod2 = total % limbLen;
        var end = Math.min(total, total - mod2) + start;
        var word = 0;
        for (var i6 = start; i6 < end; i6 += limbLen) {
          word = parseBase(number, i6, i6 + limbLen, base2);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod2 !== 0) {
          var pow = 1;
          word = parseBase(number, i6, number.length, base2);
          for (i6 = 0; i6 < mod2; i6++) {
            pow *= base2;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
      };
      BN4.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i6 = 0; i6 < this.length; i6++) {
          dest.words[i6] = this.words[i6];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN4.prototype.clone = function clone() {
        var r6 = new BN4(null);
        this.copy(r6);
        return r6;
      };
      BN4.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN4.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN4.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN4.prototype.inspect = function inspect4() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros2 = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN4.prototype.toString = function toString2(base2, padding2) {
        base2 = base2 || 10;
        padding2 = padding2 | 0 || 1;
        var out;
        if (base2 === 16 || base2 === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i6 = 0; i6 < this.length; i6++) {
            var w8 = this.words[i6];
            var word = ((w8 << off | carry) & 16777215).toString(16);
            carry = w8 >>> 24 - off & 16777215;
            if (carry !== 0 || i6 !== this.length - 1) {
              out = zeros2[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i6--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
          var groupSize = groupSizes[base2];
          var groupBase = groupBases[base2];
          out = "";
          var c5 = this.clone();
          c5.negative = 0;
          while (!c5.isZero()) {
            var r6 = c5.modn(groupBase).toString(base2);
            c5 = c5.idivn(groupBase);
            if (!c5.isZero()) {
              out = zeros2[groupSize - r6.length] + r6 + out;
            } else {
              out = r6 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert3(false, "Base should be between 2 and 36");
      };
      BN4.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert3(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN4.prototype.toJSON = function toJSON2() {
        return this.toString(16);
      };
      BN4.prototype.toBuffer = function toBuffer(endian, length) {
        assert3(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length);
      };
      BN4.prototype.toArray = function toArray2(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN4.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert3(byteLength <= reqLength, "byte array longer than desired length");
        assert3(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b4, i6;
        var q8 = this.clone();
        if (!littleEndian) {
          for (i6 = 0; i6 < reqLength - byteLength; i6++) {
            res[i6] = 0;
          }
          for (i6 = 0; !q8.isZero(); i6++) {
            b4 = q8.andln(255);
            q8.iushrn(8);
            res[reqLength - i6 - 1] = b4;
          }
        } else {
          for (i6 = 0; !q8.isZero(); i6++) {
            b4 = q8.andln(255);
            q8.iushrn(8);
            res[i6] = b4;
          }
          for (; i6 < reqLength; i6++) {
            res[i6] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN4.prototype._countBits = function _countBits(w8) {
          return 32 - Math.clz32(w8);
        };
      } else {
        BN4.prototype._countBits = function _countBits(w8) {
          var t6 = w8;
          var r6 = 0;
          if (t6 >= 4096) {
            r6 += 13;
            t6 >>>= 13;
          }
          if (t6 >= 64) {
            r6 += 7;
            t6 >>>= 7;
          }
          if (t6 >= 8) {
            r6 += 4;
            t6 >>>= 4;
          }
          if (t6 >= 2) {
            r6 += 2;
            t6 >>>= 2;
          }
          return r6 + t6;
        };
      }
      BN4.prototype._zeroBits = function _zeroBits(w8) {
        if (w8 === 0)
          return 26;
        var t6 = w8;
        var r6 = 0;
        if ((t6 & 8191) === 0) {
          r6 += 13;
          t6 >>>= 13;
        }
        if ((t6 & 127) === 0) {
          r6 += 7;
          t6 >>>= 7;
        }
        if ((t6 & 15) === 0) {
          r6 += 4;
          t6 >>>= 4;
        }
        if ((t6 & 3) === 0) {
          r6 += 2;
          t6 >>>= 2;
        }
        if ((t6 & 1) === 0) {
          r6++;
        }
        return r6;
      };
      BN4.prototype.bitLength = function bitLength() {
        var w8 = this.words[this.length - 1];
        var hi2 = this._countBits(w8);
        return (this.length - 1) * 26 + hi2;
      };
      function toBitArray(num) {
        var w8 = new Array(num.bitLength());
        for (var bit = 0; bit < w8.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w8[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w8;
      }
      BN4.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r6 = 0;
        for (var i6 = 0; i6 < this.length; i6++) {
          var b4 = this._zeroBits(this.words[i6]);
          r6 += b4;
          if (b4 !== 26)
            break;
        }
        return r6;
      };
      BN4.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN4.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN4.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN4.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN4.prototype.neg = function neg3() {
        return this.clone().ineg();
      };
      BN4.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN4.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i6 = 0; i6 < num.length; i6++) {
          this.words[i6] = this.words[i6] | num.words[i6];
        }
        return this.strip();
      };
      BN4.prototype.ior = function ior(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN4.prototype.or = function or2(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN4.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN4.prototype.iuand = function iuand(num) {
        var b4;
        if (this.length > num.length) {
          b4 = num;
        } else {
          b4 = this;
        }
        for (var i6 = 0; i6 < b4.length; i6++) {
          this.words[i6] = this.words[i6] & num.words[i6];
        }
        this.length = b4.length;
        return this.strip();
      };
      BN4.prototype.iand = function iand(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN4.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN4.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN4.prototype.iuxor = function iuxor(num) {
        var a5;
        var b4;
        if (this.length > num.length) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        for (var i6 = 0; i6 < b4.length; i6++) {
          this.words[i6] = a5.words[i6] ^ b4.words[i6];
        }
        if (this !== a5) {
          for (; i6 < a5.length; i6++) {
            this.words[i6] = a5.words[i6];
          }
        }
        this.length = a5.length;
        return this.strip();
      };
      BN4.prototype.ixor = function ixor(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN4.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN4.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN4.prototype.inotn = function inotn(width) {
        assert3(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i6 = 0; i6 < bytesNeeded; i6++) {
          this.words[i6] = ~this.words[i6] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i6] = ~this.words[i6] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN4.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN4.prototype.setn = function setn(bit, val) {
        assert3(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN4.prototype.iadd = function iadd(num) {
        var r6;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r6 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r6 = this.isub(num);
          num.negative = 1;
          return r6._normSign();
        }
        var a5, b4;
        if (this.length > num.length) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        var carry = 0;
        for (var i6 = 0; i6 < b4.length; i6++) {
          r6 = (a5.words[i6] | 0) + (b4.words[i6] | 0) + carry;
          this.words[i6] = r6 & 67108863;
          carry = r6 >>> 26;
        }
        for (; carry !== 0 && i6 < a5.length; i6++) {
          r6 = (a5.words[i6] | 0) + carry;
          this.words[i6] = r6 & 67108863;
          carry = r6 >>> 26;
        }
        this.length = a5.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a5 !== this) {
          for (; i6 < a5.length; i6++) {
            this.words[i6] = a5.words[i6];
          }
        }
        return this;
      };
      BN4.prototype.add = function add3(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN4.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r6 = this.iadd(num);
          num.negative = 1;
          return r6._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a5, b4;
        if (cmp > 0) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        var carry = 0;
        for (var i6 = 0; i6 < b4.length; i6++) {
          r6 = (a5.words[i6] | 0) - (b4.words[i6] | 0) + carry;
          carry = r6 >> 26;
          this.words[i6] = r6 & 67108863;
        }
        for (; carry !== 0 && i6 < a5.length; i6++) {
          r6 = (a5.words[i6] | 0) + carry;
          carry = r6 >> 26;
          this.words[i6] = r6 & 67108863;
        }
        if (carry === 0 && i6 < a5.length && a5 !== this) {
          for (; i6 < a5.length; i6++) {
            this.words[i6] = a5.words[i6];
          }
        }
        this.length = Math.max(this.length, i6);
        if (a5 !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN4.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a5 = self2.words[0] | 0;
        var b4 = num.words[0] | 0;
        var r6 = a5 * b4;
        var lo = r6 & 67108863;
        var carry = r6 / 67108864 | 0;
        out.words[0] = lo;
        for (var k8 = 1; k8 < len; k8++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k8, num.length - 1);
          for (var j8 = Math.max(0, k8 - self2.length + 1); j8 <= maxJ; j8++) {
            var i6 = k8 - j8 | 0;
            a5 = self2.words[i6] | 0;
            b4 = num.words[j8] | 0;
            r6 = a5 * b4 + rword;
            ncarry += r6 / 67108864 | 0;
            rword = r6 & 67108863;
          }
          out.words[k8] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k8] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a5 = self2.words;
        var b4 = num.words;
        var o6 = out.words;
        var c5 = 0;
        var lo;
        var mid;
        var hi2;
        var a02 = a5[0] | 0;
        var al0 = a02 & 8191;
        var ah0 = a02 >>> 13;
        var a1 = a5[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a5[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a5[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a42 = a5[4] | 0;
        var al4 = a42 & 8191;
        var ah4 = a42 >>> 13;
        var a52 = a5[5] | 0;
        var al5 = a52 & 8191;
        var ah5 = a52 >>> 13;
        var a6 = a5[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a5[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a5[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a5[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b02 = b4[0] | 0;
        var bl0 = b02 & 8191;
        var bh0 = b02 >>> 13;
        var b1 = b4[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b4[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b4[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b42 = b4[4] | 0;
        var bl4 = b42 & 8191;
        var bh4 = b42 >>> 13;
        var b5 = b4[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b4[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b4[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b4[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b4[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi2 = Math.imul(ah0, bh0);
        var w02 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w02 >>> 26) | 0;
        w02 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi2 = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi2 = hi2 + Math.imul(ah0, bh1) | 0;
        var w1 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi2 = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi2 = hi2 + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi2 = hi2 + Math.imul(ah0, bh2) | 0;
        var w22 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi2 = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi2 = hi2 + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi2 = hi2 + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi2 = hi2 + Math.imul(ah0, bh3) | 0;
        var w32 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi2 = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi2 = hi2 + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi2 = hi2 + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi2 = hi2 + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi2 = hi2 + Math.imul(ah0, bh4) | 0;
        var w42 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
        w42 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi2 = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi2 = hi2 + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi2 = hi2 + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi2 = hi2 + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi2 = hi2 + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi2 = hi2 + Math.imul(ah0, bh5) | 0;
        var w52 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w52 >>> 26) | 0;
        w52 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi2 = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi2 = hi2 + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi2 = hi2 + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi2 = hi2 + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi2 = hi2 + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi2 = hi2 + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi2 = hi2 + Math.imul(ah0, bh6) | 0;
        var w62 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w62 >>> 26) | 0;
        w62 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi2 = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi2 = hi2 + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi2 = hi2 + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi2 = hi2 + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi2 = hi2 + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi2 = hi2 + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi2 = hi2 + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi2 = hi2 + Math.imul(ah0, bh7) | 0;
        var w72 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w72 >>> 26) | 0;
        w72 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi2 = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi2 = hi2 + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi2 = hi2 + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi2 = hi2 + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi2 = hi2 + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi2 = hi2 + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi2 = hi2 + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi2 = hi2 + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi2 = hi2 + Math.imul(ah0, bh8) | 0;
        var w8 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi2 = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi2 = hi2 + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi2 = hi2 + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi2 = hi2 + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi2 = hi2 + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi2 = hi2 + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi2 = hi2 + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi2 = hi2 + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi2 = hi2 + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi2 = hi2 + Math.imul(ah0, bh9) | 0;
        var w9 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi2 = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi2 = hi2 + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi2 = hi2 + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi2 = hi2 + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi2 = hi2 + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi2 = hi2 + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi2 = hi2 + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi2 = hi2 + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi2 = hi2 + Math.imul(ah1, bh9) | 0;
        var w10 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi2 = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi2 = hi2 + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi2 = hi2 + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi2 = hi2 + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi2 = hi2 + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi2 = hi2 + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi2 = hi2 + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi2 = hi2 + Math.imul(ah2, bh9) | 0;
        var w11 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi2 = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi2 = hi2 + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi2 = hi2 + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi2 = hi2 + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi2 = hi2 + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi2 = hi2 + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi2 = hi2 + Math.imul(ah3, bh9) | 0;
        var w12 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi2 = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi2 = hi2 + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi2 = hi2 + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi2 = hi2 + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi2 = hi2 + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi2 = hi2 + Math.imul(ah4, bh9) | 0;
        var w13 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi2 = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi2 = hi2 + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi2 = hi2 + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi2 = hi2 + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi2 = hi2 + Math.imul(ah5, bh9) | 0;
        var w14 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi2 = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi2 = hi2 + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi2 = hi2 + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi2 = hi2 + Math.imul(ah6, bh9) | 0;
        var w15 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi2 = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi2 = hi2 + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi2 = hi2 + Math.imul(ah7, bh9) | 0;
        var w16 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi2 = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi2 = hi2 + Math.imul(ah8, bh9) | 0;
        var w17 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi2 = Math.imul(ah9, bh9);
        var w18 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi2 + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o6[0] = w02;
        o6[1] = w1;
        o6[2] = w22;
        o6[3] = w32;
        o6[4] = w42;
        o6[5] = w52;
        o6[6] = w62;
        o6[7] = w72;
        o6[8] = w8;
        o6[9] = w9;
        o6[10] = w10;
        o6[11] = w11;
        o6[12] = w12;
        o6[13] = w13;
        o6[14] = w14;
        o6[15] = w15;
        o6[16] = w16;
        o6[17] = w17;
        o6[18] = w18;
        if (c5 !== 0) {
          o6[19] = c5;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k8 = 0; k8 < out.length - 1; k8++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k8, num.length - 1);
          for (var j8 = Math.max(0, k8 - self2.length + 1); j8 <= maxJ; j8++) {
            var i6 = k8 - j8;
            var a5 = self2.words[i6] | 0;
            var b4 = num.words[j8] | 0;
            var r6 = a5 * b4;
            var lo = r6 & 67108863;
            ncarry = ncarry + (r6 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k8] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k8] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN4.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x6, y5) {
        this.x = x6;
        this.y = y5;
      }
      FFTM.prototype.makeRBT = function makeRBT(N7) {
        var t6 = new Array(N7);
        var l6 = BN4.prototype._countBits(N7) - 1;
        for (var i6 = 0; i6 < N7; i6++) {
          t6[i6] = this.revBin(i6, l6, N7);
        }
        return t6;
      };
      FFTM.prototype.revBin = function revBin(x6, l6, N7) {
        if (x6 === 0 || x6 === N7 - 1)
          return x6;
        var rb = 0;
        for (var i6 = 0; i6 < l6; i6++) {
          rb |= (x6 & 1) << l6 - i6 - 1;
          x6 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N7) {
        for (var i6 = 0; i6 < N7; i6++) {
          rtws[i6] = rws[rbt[i6]];
          itws[i6] = iws[rbt[i6]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N7, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N7);
        for (var s6 = 1; s6 < N7; s6 <<= 1) {
          var l6 = s6 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l6);
          var itwdf = Math.sin(2 * Math.PI / l6);
          for (var p7 = 0; p7 < N7; p7 += l6) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j8 = 0; j8 < s6; j8++) {
              var re = rtws[p7 + j8];
              var ie2 = itws[p7 + j8];
              var ro3 = rtws[p7 + j8 + s6];
              var io3 = itws[p7 + j8 + s6];
              var rx = rtwdf_ * ro3 - itwdf_ * io3;
              io3 = rtwdf_ * io3 + itwdf_ * ro3;
              ro3 = rx;
              rtws[p7 + j8] = re + ro3;
              itws[p7 + j8] = ie2 + io3;
              rtws[p7 + j8 + s6] = re - ro3;
              itws[p7 + j8 + s6] = ie2 - io3;
              if (j8 !== l6) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n4, m6) {
        var N7 = Math.max(m6, n4) | 1;
        var odd = N7 & 1;
        var i6 = 0;
        for (N7 = N7 / 2 | 0; N7; N7 = N7 >>> 1) {
          i6++;
        }
        return 1 << i6 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N7) {
        if (N7 <= 1)
          return;
        for (var i6 = 0; i6 < N7 / 2; i6++) {
          var t6 = rws[i6];
          rws[i6] = rws[N7 - i6 - 1];
          rws[N7 - i6 - 1] = t6;
          t6 = iws[i6];
          iws[i6] = -iws[N7 - i6 - 1];
          iws[N7 - i6 - 1] = -t6;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws2, N7) {
        var carry = 0;
        for (var i6 = 0; i6 < N7 / 2; i6++) {
          var w8 = Math.round(ws2[2 * i6 + 1] / N7) * 8192 + Math.round(ws2[2 * i6] / N7) + carry;
          ws2[i6] = w8 & 67108863;
          if (w8 < 67108864) {
            carry = 0;
          } else {
            carry = w8 / 67108864 | 0;
          }
        }
        return ws2;
      };
      FFTM.prototype.convert13b = function convert13b(ws2, len, rws, N7) {
        var carry = 0;
        for (var i6 = 0; i6 < len; i6++) {
          carry = carry + (ws2[i6] | 0);
          rws[2 * i6] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i6 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i6 = 2 * len; i6 < N7; ++i6) {
          rws[i6] = 0;
        }
        assert3(carry === 0);
        assert3((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N7) {
        var ph = new Array(N7);
        for (var i6 = 0; i6 < N7; i6++) {
          ph[i6] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x6, y5, out) {
        var N7 = 2 * this.guessLen13b(x6.length, y5.length);
        var rbt = this.makeRBT(N7);
        var _8 = this.stub(N7);
        var rws = new Array(N7);
        var rwst = new Array(N7);
        var iwst = new Array(N7);
        var nrws = new Array(N7);
        var nrwst = new Array(N7);
        var niwst = new Array(N7);
        var rmws = out.words;
        rmws.length = N7;
        this.convert13b(x6.words, x6.length, rws, N7);
        this.convert13b(y5.words, y5.length, nrws, N7);
        this.transform(rws, _8, rwst, iwst, N7, rbt);
        this.transform(nrws, _8, nrwst, niwst, N7, rbt);
        for (var i6 = 0; i6 < N7; i6++) {
          var rx = rwst[i6] * nrwst[i6] - iwst[i6] * niwst[i6];
          iwst[i6] = rwst[i6] * niwst[i6] + iwst[i6] * nrwst[i6];
          rwst[i6] = rx;
        }
        this.conjugate(rwst, iwst, N7);
        this.transform(rwst, iwst, rmws, _8, N7, rbt);
        this.conjugate(rmws, _8, N7);
        this.normalize13b(rmws, N7);
        out.negative = x6.negative ^ y5.negative;
        out.length = x6.length + y5.length;
        return out.strip();
      };
      BN4.prototype.mul = function mul3(num) {
        var out = new BN4(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN4.prototype.mulf = function mulf(num) {
        var out = new BN4(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN4.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN4.prototype.imuln = function imuln(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        var carry = 0;
        for (var i6 = 0; i6 < this.length; i6++) {
          var w8 = (this.words[i6] | 0) * num;
          var lo = (w8 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w8 / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i6] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i6] = carry;
          this.length++;
        }
        return this;
      };
      BN4.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN4.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN4.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN4.prototype.pow = function pow(num) {
        var w8 = toBitArray(num);
        if (w8.length === 0)
          return new BN4(1);
        var res = this;
        for (var i6 = 0; i6 < w8.length; i6++, res = res.sqr()) {
          if (w8[i6] !== 0)
            break;
        }
        if (++i6 < w8.length) {
          for (var q8 = res.sqr(); i6 < w8.length; i6++, q8 = q8.sqr()) {
            if (w8[i6] === 0)
              continue;
            res = res.mul(q8);
          }
        }
        return res;
      };
      BN4.prototype.iushln = function iushln(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r6 = bits % 26;
        var s6 = (bits - r6) / 26;
        var carryMask = 67108863 >>> 26 - r6 << 26 - r6;
        var i6;
        if (r6 !== 0) {
          var carry = 0;
          for (i6 = 0; i6 < this.length; i6++) {
            var newCarry = this.words[i6] & carryMask;
            var c5 = (this.words[i6] | 0) - newCarry << r6;
            this.words[i6] = c5 | carry;
            carry = newCarry >>> 26 - r6;
          }
          if (carry) {
            this.words[i6] = carry;
            this.length++;
          }
        }
        if (s6 !== 0) {
          for (i6 = this.length - 1; i6 >= 0; i6--) {
            this.words[i6 + s6] = this.words[i6];
          }
          for (i6 = 0; i6 < s6; i6++) {
            this.words[i6] = 0;
          }
          this.length += s6;
        }
        return this.strip();
      };
      BN4.prototype.ishln = function ishln(bits) {
        assert3(this.negative === 0);
        return this.iushln(bits);
      };
      BN4.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert3(typeof bits === "number" && bits >= 0);
        var h6;
        if (hint) {
          h6 = (hint - hint % 26) / 26;
        } else {
          h6 = 0;
        }
        var r6 = bits % 26;
        var s6 = Math.min((bits - r6) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r6 << r6;
        var maskedWords = extended;
        h6 -= s6;
        h6 = Math.max(0, h6);
        if (maskedWords) {
          for (var i6 = 0; i6 < s6; i6++) {
            maskedWords.words[i6] = this.words[i6];
          }
          maskedWords.length = s6;
        }
        if (s6 === 0) {
        } else if (this.length > s6) {
          this.length -= s6;
          for (i6 = 0; i6 < this.length; i6++) {
            this.words[i6] = this.words[i6 + s6];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i6 = this.length - 1; i6 >= 0 && (carry !== 0 || i6 >= h6); i6--) {
          var word = this.words[i6] | 0;
          this.words[i6] = carry << 26 - r6 | word >>> r6;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN4.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert3(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN4.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN4.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN4.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN4.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN4.prototype.testn = function testn(bit) {
        assert3(typeof bit === "number" && bit >= 0);
        var r6 = bit % 26;
        var s6 = (bit - r6) / 26;
        var q8 = 1 << r6;
        if (this.length <= s6)
          return false;
        var w8 = this.words[s6];
        return !!(w8 & q8);
      };
      BN4.prototype.imaskn = function imaskn(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r6 = bits % 26;
        var s6 = (bits - r6) / 26;
        assert3(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s6) {
          return this;
        }
        if (r6 !== 0) {
          s6++;
        }
        this.length = Math.min(s6, this.length);
        if (r6 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r6 << r6;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN4.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN4.prototype.iaddn = function iaddn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN4.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i6 = 0; i6 < this.length && this.words[i6] >= 67108864; i6++) {
          this.words[i6] -= 67108864;
          if (i6 === this.length - 1) {
            this.words[i6 + 1] = 1;
          } else {
            this.words[i6 + 1]++;
          }
        }
        this.length = Math.max(this.length, i6 + 1);
        return this;
      };
      BN4.prototype.isubn = function isubn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i6 = 0; i6 < this.length && this.words[i6] < 0; i6++) {
            this.words[i6] += 67108864;
            this.words[i6 + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN4.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN4.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN4.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN4.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN4.prototype._ishlnsubmul = function _ishlnsubmul(num, mul3, shift) {
        var len = num.length + shift;
        var i6;
        this._expand(len);
        var w8;
        var carry = 0;
        for (i6 = 0; i6 < num.length; i6++) {
          w8 = (this.words[i6 + shift] | 0) + carry;
          var right = (num.words[i6] | 0) * mul3;
          w8 -= right & 67108863;
          carry = (w8 >> 26) - (right / 67108864 | 0);
          this.words[i6 + shift] = w8 & 67108863;
        }
        for (; i6 < this.length - shift; i6++) {
          w8 = (this.words[i6 + shift] | 0) + carry;
          carry = w8 >> 26;
          this.words[i6 + shift] = w8 & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert3(carry === -1);
        carry = 0;
        for (i6 = 0; i6 < this.length; i6++) {
          w8 = -(this.words[i6] | 0) + carry;
          carry = w8 >> 26;
          this.words[i6] = w8 & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN4.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a5 = this.clone();
        var b4 = num;
        var bhi = b4.words[b4.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b4 = b4.ushln(shift);
          a5.iushln(shift);
          bhi = b4.words[b4.length - 1] | 0;
        }
        var m6 = a5.length - b4.length;
        var q8;
        if (mode !== "mod") {
          q8 = new BN4(null);
          q8.length = m6 + 1;
          q8.words = new Array(q8.length);
          for (var i6 = 0; i6 < q8.length; i6++) {
            q8.words[i6] = 0;
          }
        }
        var diff = a5.clone()._ishlnsubmul(b4, 1, m6);
        if (diff.negative === 0) {
          a5 = diff;
          if (q8) {
            q8.words[m6] = 1;
          }
        }
        for (var j8 = m6 - 1; j8 >= 0; j8--) {
          var qj = (a5.words[b4.length + j8] | 0) * 67108864 + (a5.words[b4.length + j8 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a5._ishlnsubmul(b4, qj, j8);
          while (a5.negative !== 0) {
            qj--;
            a5.negative = 0;
            a5._ishlnsubmul(b4, 1, j8);
            if (!a5.isZero()) {
              a5.negative ^= 1;
            }
          }
          if (q8) {
            q8.words[j8] = qj;
          }
        }
        if (q8) {
          q8.strip();
        }
        a5.strip();
        if (mode !== "div" && shift !== 0) {
          a5.iushrn(shift);
        }
        return {
          div: q8 || null,
          mod: a5
        };
      };
      BN4.prototype.divmod = function divmod(num, mode, positive) {
        assert3(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN4(0),
            mod: new BN4(0)
          };
        }
        var div, mod2, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.iadd(num);
            }
          }
          return {
            div,
            mod: mod2
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.isub(num);
            }
          }
          return {
            div: res.div,
            mod: mod2
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN4(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN4(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN4(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN4.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN4.prototype.mod = function mod2(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN4.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN4.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r22 = num.andln(1);
        var cmp = mod2.cmp(half);
        if (cmp < 0 || r22 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN4.prototype.modn = function modn(num) {
        assert3(num <= 67108863);
        var p7 = (1 << 26) % num;
        var acc = 0;
        for (var i6 = this.length - 1; i6 >= 0; i6--) {
          acc = (p7 * acc + (this.words[i6] | 0)) % num;
        }
        return acc;
      };
      BN4.prototype.idivn = function idivn(num) {
        assert3(num <= 67108863);
        var carry = 0;
        for (var i6 = this.length - 1; i6 >= 0; i6--) {
          var w8 = (this.words[i6] | 0) + carry * 67108864;
          this.words[i6] = w8 / num | 0;
          carry = w8 % num;
        }
        return this.strip();
      };
      BN4.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN4.prototype.egcd = function egcd(p7) {
        assert3(p7.negative === 0);
        assert3(!p7.isZero());
        var x6 = this;
        var y5 = p7.clone();
        if (x6.negative !== 0) {
          x6 = x6.umod(p7);
        } else {
          x6 = x6.clone();
        }
        var A8 = new BN4(1);
        var B4 = new BN4(0);
        var C5 = new BN4(0);
        var D5 = new BN4(1);
        var g7 = 0;
        while (x6.isEven() && y5.isEven()) {
          x6.iushrn(1);
          y5.iushrn(1);
          ++g7;
        }
        var yp = y5.clone();
        var xp = x6.clone();
        while (!x6.isZero()) {
          for (var i6 = 0, im = 1; (x6.words[0] & im) === 0 && i6 < 26; ++i6, im <<= 1)
            ;
          if (i6 > 0) {
            x6.iushrn(i6);
            while (i6-- > 0) {
              if (A8.isOdd() || B4.isOdd()) {
                A8.iadd(yp);
                B4.isub(xp);
              }
              A8.iushrn(1);
              B4.iushrn(1);
            }
          }
          for (var j8 = 0, jm = 1; (y5.words[0] & jm) === 0 && j8 < 26; ++j8, jm <<= 1)
            ;
          if (j8 > 0) {
            y5.iushrn(j8);
            while (j8-- > 0) {
              if (C5.isOdd() || D5.isOdd()) {
                C5.iadd(yp);
                D5.isub(xp);
              }
              C5.iushrn(1);
              D5.iushrn(1);
            }
          }
          if (x6.cmp(y5) >= 0) {
            x6.isub(y5);
            A8.isub(C5);
            B4.isub(D5);
          } else {
            y5.isub(x6);
            C5.isub(A8);
            D5.isub(B4);
          }
        }
        return {
          a: C5,
          b: D5,
          gcd: y5.iushln(g7)
        };
      };
      BN4.prototype._invmp = function _invmp(p7) {
        assert3(p7.negative === 0);
        assert3(!p7.isZero());
        var a5 = this;
        var b4 = p7.clone();
        if (a5.negative !== 0) {
          a5 = a5.umod(p7);
        } else {
          a5 = a5.clone();
        }
        var x1 = new BN4(1);
        var x22 = new BN4(0);
        var delta = b4.clone();
        while (a5.cmpn(1) > 0 && b4.cmpn(1) > 0) {
          for (var i6 = 0, im = 1; (a5.words[0] & im) === 0 && i6 < 26; ++i6, im <<= 1)
            ;
          if (i6 > 0) {
            a5.iushrn(i6);
            while (i6-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j8 = 0, jm = 1; (b4.words[0] & jm) === 0 && j8 < 26; ++j8, jm <<= 1)
            ;
          if (j8 > 0) {
            b4.iushrn(j8);
            while (j8-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a5.cmp(b4) >= 0) {
            a5.isub(b4);
            x1.isub(x22);
          } else {
            b4.isub(a5);
            x22.isub(x1);
          }
        }
        var res;
        if (a5.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p7);
        }
        return res;
      };
      BN4.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a5 = this.clone();
        var b4 = num.clone();
        a5.negative = 0;
        b4.negative = 0;
        for (var shift = 0; a5.isEven() && b4.isEven(); shift++) {
          a5.iushrn(1);
          b4.iushrn(1);
        }
        do {
          while (a5.isEven()) {
            a5.iushrn(1);
          }
          while (b4.isEven()) {
            b4.iushrn(1);
          }
          var r6 = a5.cmp(b4);
          if (r6 < 0) {
            var t6 = a5;
            a5 = b4;
            b4 = t6;
          } else if (r6 === 0 || b4.cmpn(1) === 0) {
            break;
          }
          a5.isub(b4);
        } while (true);
        return b4.iushln(shift);
      };
      BN4.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN4.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN4.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN4.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN4.prototype.bincn = function bincn(bit) {
        assert3(typeof bit === "number");
        var r6 = bit % 26;
        var s6 = (bit - r6) / 26;
        var q8 = 1 << r6;
        if (this.length <= s6) {
          this._expand(s6 + 1);
          this.words[s6] |= q8;
          return this;
        }
        var carry = q8;
        for (var i6 = s6; carry !== 0 && i6 < this.length; i6++) {
          var w8 = this.words[i6] | 0;
          w8 += carry;
          carry = w8 >>> 26;
          w8 &= 67108863;
          this.words[i6] = w8;
        }
        if (carry !== 0) {
          this.words[i6] = carry;
          this.length++;
        }
        return this;
      };
      BN4.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN4.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert3(num <= 67108863, "Number is too big");
          var w8 = this.words[0] | 0;
          res = w8 === num ? 0 : w8 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN4.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN4.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i6 = this.length - 1; i6 >= 0; i6--) {
          var a5 = this.words[i6] | 0;
          var b4 = num.words[i6] | 0;
          if (a5 === b4)
            continue;
          if (a5 < b4) {
            res = -1;
          } else if (a5 > b4) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN4.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN4.prototype.gt = function gt2(num) {
        return this.cmp(num) === 1;
      };
      BN4.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN4.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN4.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN4.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN4.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN4.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN4.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN4.prototype.eq = function eq4(num) {
        return this.cmp(num) === 0;
      };
      BN4.red = function red(num) {
        return new Red(num);
      };
      BN4.prototype.toRed = function toRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        assert3(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN4.prototype.fromRed = function fromRed() {
        assert3(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN4.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN4.prototype.forceRed = function forceRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN4.prototype.redAdd = function redAdd(num) {
        assert3(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN4.prototype.redIAdd = function redIAdd(num) {
        assert3(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN4.prototype.redSub = function redSub(num) {
        assert3(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN4.prototype.redISub = function redISub(num) {
        assert3(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN4.prototype.redShl = function redShl(num) {
        assert3(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN4.prototype.redMul = function redMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN4.prototype.redIMul = function redIMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN4.prototype.redSqr = function redSqr() {
        assert3(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN4.prototype.redISqr = function redISqr() {
        assert3(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN4.prototype.redSqrt = function redSqrt() {
        assert3(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN4.prototype.redInvm = function redInvm() {
        assert3(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN4.prototype.redNeg = function redNeg() {
        assert3(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN4.prototype.redPow = function redPow(num) {
        assert3(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name2, p7) {
        this.name = name2;
        this.p = new BN4(p7, 16);
        this.n = this.p.bitLength();
        this.k = new BN4(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN4(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r6 = num;
        var rlen;
        do {
          this.split(r6, this.tmp);
          r6 = this.imulK(r6);
          r6 = r6.iadd(this.tmp);
          rlen = r6.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r6.ucmp(this.p);
        if (cmp === 0) {
          r6.words[0] = 0;
          r6.length = 1;
        } else if (cmp > 0) {
          r6.isub(this.p);
        } else {
          r6.strip();
        }
        return r6;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i6 = 0; i6 < outLen; i6++) {
          output.words[i6] = input.words[i6];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i6 = 10; i6 < input.length; i6++) {
          var next = input.words[i6] | 0;
          input.words[i6 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i6 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i6 = 0; i6 < num.length; i6++) {
          var w8 = num.words[i6] | 0;
          lo += w8 * 977;
          num.words[i6] = lo & 67108863;
          lo = w8 * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i6 = 0; i6 < num.length; i6++) {
          var hi2 = (num.words[i6] | 0) * 19 + carry;
          var lo = hi2 & 67108863;
          hi2 >>>= 26;
          num.words[i6] = lo;
          carry = hi2;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN4._prime = function prime(name2) {
        if (primes[name2])
          return primes[name2];
        var prime2;
        if (name2 === "k256") {
          prime2 = new K256();
        } else if (name2 === "p224") {
          prime2 = new P224();
        } else if (name2 === "p192") {
          prime2 = new P192();
        } else if (name2 === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name2);
        }
        primes[name2] = prime2;
        return prime2;
      };
      function Red(m6) {
        if (typeof m6 === "string") {
          var prime = BN4._prime(m6);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert3(m6.gtn(1), "modulus must be greater than 1");
          this.m = m6;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a5) {
        assert3(a5.negative === 0, "red works only with positives");
        assert3(a5.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a5, b4) {
        assert3((a5.negative | b4.negative) === 0, "red works only with positives");
        assert3(
          a5.red && a5.red === b4.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a5) {
        if (this.prime)
          return this.prime.ireduce(a5)._forceRed(this);
        return a5.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg3(a5) {
        if (a5.isZero()) {
          return a5.clone();
        }
        return this.m.sub(a5)._forceRed(this);
      };
      Red.prototype.add = function add3(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.add(b4);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.iadd(b4);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.sub(b4);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.isub(b4);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a5, num) {
        this._verify1(a5);
        return this.imod(a5.ushln(num));
      };
      Red.prototype.imul = function imul(a5, b4) {
        this._verify2(a5, b4);
        return this.imod(a5.imul(b4));
      };
      Red.prototype.mul = function mul3(a5, b4) {
        this._verify2(a5, b4);
        return this.imod(a5.mul(b4));
      };
      Red.prototype.isqr = function isqr(a5) {
        return this.imul(a5, a5.clone());
      };
      Red.prototype.sqr = function sqr(a5) {
        return this.mul(a5, a5);
      };
      Red.prototype.sqrt = function sqrt(a5) {
        if (a5.isZero())
          return a5.clone();
        var mod3 = this.m.andln(3);
        assert3(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN4(1)).iushrn(2);
          return this.pow(a5, pow);
        }
        var q8 = this.m.subn(1);
        var s6 = 0;
        while (!q8.isZero() && q8.andln(1) === 0) {
          s6++;
          q8.iushrn(1);
        }
        assert3(!q8.isZero());
        var one = new BN4(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z6 = this.m.bitLength();
        z6 = new BN4(2 * z6 * z6).toRed(this);
        while (this.pow(z6, lpow).cmp(nOne) !== 0) {
          z6.redIAdd(nOne);
        }
        var c5 = this.pow(z6, q8);
        var r6 = this.pow(a5, q8.addn(1).iushrn(1));
        var t6 = this.pow(a5, q8);
        var m6 = s6;
        while (t6.cmp(one) !== 0) {
          var tmp = t6;
          for (var i6 = 0; tmp.cmp(one) !== 0; i6++) {
            tmp = tmp.redSqr();
          }
          assert3(i6 < m6);
          var b4 = this.pow(c5, new BN4(1).iushln(m6 - i6 - 1));
          r6 = r6.redMul(b4);
          c5 = b4.redSqr();
          t6 = t6.redMul(c5);
          m6 = i6;
        }
        return r6;
      };
      Red.prototype.invm = function invm(a5) {
        var inv = a5._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a5, num) {
        if (num.isZero())
          return new BN4(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a5.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN4(1).toRed(this);
        wnd[1] = a5;
        for (var i6 = 2; i6 < wnd.length; i6++) {
          wnd[i6] = this.mul(wnd[i6 - 1], a5);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i6 = num.length - 1; i6 >= 0; i6--) {
          var word = num.words[i6];
          for (var j8 = start - 1; j8 >= 0; j8--) {
            var bit = word >> j8 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i6 !== 0 || j8 !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r6 = num.umod(this.m);
        return r6 === num ? r6.clone() : r6;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN4.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m6) {
        Red.call(this, m6);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN4(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r6 = this.imod(num.mul(this.rinv));
        r6.red = null;
        return r6;
      };
      Mont.prototype.imul = function imul(a5, b4) {
        if (a5.isZero() || b4.isZero()) {
          a5.words[0] = 0;
          a5.length = 1;
          return a5;
        }
        var t6 = a5.imul(b4);
        var c5 = t6.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u7 = t6.isub(c5).iushrn(this.shift);
        var res = u7;
        if (u7.cmp(this.m) >= 0) {
          res = u7.isub(this.m);
        } else if (u7.cmpn(0) < 0) {
          res = u7.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul3(a5, b4) {
        if (a5.isZero() || b4.isZero())
          return new BN4(0)._forceRed(this);
        var t6 = a5.mul(b4);
        var c5 = t6.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u7 = t6.isub(c5).iushrn(this.shift);
        var res = u7;
        if (u7.cmp(this.m) >= 0) {
          res = u7.isub(this.m);
        } else if (u7.cmpn(0) < 0) {
          res = u7.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a5) {
        var res = this.imod(a5._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module2 === "undefined" || module2, exports2);
  }
});

// node_modules/is-typedarray/index.js
var require_is_typedarray = __commonJS({
  "node_modules/is-typedarray/index.js"(exports2, module2) {
    module2.exports = isTypedArray2;
    isTypedArray2.strict = isStrictTypedArray;
    isTypedArray2.loose = isLooseTypedArray;
    var toString2 = Object.prototype.toString;
    var names2 = {
      "[object Int8Array]": true,
      "[object Int16Array]": true,
      "[object Int32Array]": true,
      "[object Uint8Array]": true,
      "[object Uint8ClampedArray]": true,
      "[object Uint16Array]": true,
      "[object Uint32Array]": true,
      "[object Float32Array]": true,
      "[object Float64Array]": true
    };
    function isTypedArray2(arr) {
      return isStrictTypedArray(arr) || isLooseTypedArray(arr);
    }
    function isStrictTypedArray(arr) {
      return arr instanceof Int8Array || arr instanceof Int16Array || arr instanceof Int32Array || arr instanceof Uint8Array || arr instanceof Uint8ClampedArray || arr instanceof Uint16Array || arr instanceof Uint32Array || arr instanceof Float32Array || arr instanceof Float64Array;
    }
    function isLooseTypedArray(arr) {
      return names2[toString2.call(arr)];
    }
  }
});

// node_modules/typedarray-to-buffer/index.js
var require_typedarray_to_buffer = __commonJS({
  "node_modules/typedarray-to-buffer/index.js"(exports2, module2) {
    var isTypedArray2 = require_is_typedarray().strict;
    module2.exports = function typedarrayToBuffer(arr) {
      if (isTypedArray2(arr)) {
        var buf = Buffer.from(arr.buffer);
        if (arr.byteLength !== arr.buffer.byteLength) {
          buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength);
        }
        return buf;
      } else {
        return Buffer.from(arr);
      }
    };
  }
});

// node_modules/strict-uri-encode/index.js
var require_strict_uri_encode = __commonJS({
  "node_modules/strict-uri-encode/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (str) => encodeURIComponent(str).replace(/[!'()*]/g, (x6) => `%${x6.charCodeAt(0).toString(16).toUpperCase()}`);
  }
});

// node_modules/decode-uri-component/index.js
var require_decode_uri_component = __commonJS({
  "node_modules/decode-uri-component/index.js"(exports2, module2) {
    "use strict";
    var token = "%[a-f0-9]{2}";
    var singleMatcher = new RegExp(token, "gi");
    var multiMatcher = new RegExp("(" + token + ")+", "gi");
    function decodeComponents(components, split) {
      try {
        return decodeURIComponent(components.join(""));
      } catch (err) {
      }
      if (components.length === 1) {
        return components;
      }
      split = split || 1;
      var left = components.slice(0, split);
      var right = components.slice(split);
      return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
    }
    function decode3(input) {
      try {
        return decodeURIComponent(input);
      } catch (err) {
        var tokens = input.match(singleMatcher);
        for (var i6 = 1; i6 < tokens.length; i6++) {
          input = decodeComponents(tokens, i6).join("");
          tokens = input.match(singleMatcher);
        }
        return input;
      }
    }
    function customDecodeURIComponent(input) {
      var replaceMap = {
        "%FE%FF": "\uFFFD\uFFFD",
        "%FF%FE": "\uFFFD\uFFFD"
      };
      var match = multiMatcher.exec(input);
      while (match) {
        try {
          replaceMap[match[0]] = decodeURIComponent(match[0]);
        } catch (err) {
          var result = decode3(match[0]);
          if (result !== match[0]) {
            replaceMap[match[0]] = result;
          }
        }
        match = multiMatcher.exec(input);
      }
      replaceMap["%C2"] = "\uFFFD";
      var entries = Object.keys(replaceMap);
      for (var i6 = 0; i6 < entries.length; i6++) {
        var key2 = entries[i6];
        input = input.replace(new RegExp(key2, "g"), replaceMap[key2]);
      }
      return input;
    }
    module2.exports = function(encodedURI) {
      if (typeof encodedURI !== "string") {
        throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
      }
      try {
        encodedURI = encodedURI.replace(/\+/g, " ");
        return decodeURIComponent(encodedURI);
      } catch (err) {
        return customDecodeURIComponent(encodedURI);
      }
    };
  }
});

// node_modules/split-on-first/index.js
var require_split_on_first = __commonJS({
  "node_modules/split-on-first/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (string, separator) => {
      if (!(typeof string === "string" && typeof separator === "string")) {
        throw new TypeError("Expected the arguments to be of type `string`");
      }
      if (separator === "") {
        return [string];
      }
      const separatorIndex = string.indexOf(separator);
      if (separatorIndex === -1) {
        return [string];
      }
      return [
        string.slice(0, separatorIndex),
        string.slice(separatorIndex + separator.length)
      ];
    };
  }
});

// node_modules/query-string/index.js
var require_query_string = __commonJS({
  "node_modules/query-string/index.js"(exports2) {
    "use strict";
    var strictUriEncode = require_strict_uri_encode();
    var decodeComponent = require_decode_uri_component();
    var splitOnFirst = require_split_on_first();
    var isNullOrUndefined = (value2) => value2 === null || value2 === void 0;
    function encoderForArrayFormat(options) {
      switch (options.arrayFormat) {
        case "index":
          return (key2) => (result, value2) => {
            const index = result.length;
            if (value2 === void 0 || options.skipNull && value2 === null || options.skipEmptyString && value2 === "") {
              return result;
            }
            if (value2 === null) {
              return [...result, [encode4(key2, options), "[", index, "]"].join("")];
            }
            return [
              ...result,
              [encode4(key2, options), "[", encode4(index, options), "]=", encode4(value2, options)].join("")
            ];
          };
        case "bracket":
          return (key2) => (result, value2) => {
            if (value2 === void 0 || options.skipNull && value2 === null || options.skipEmptyString && value2 === "") {
              return result;
            }
            if (value2 === null) {
              return [...result, [encode4(key2, options), "[]"].join("")];
            }
            return [...result, [encode4(key2, options), "[]=", encode4(value2, options)].join("")];
          };
        case "comma":
        case "separator":
          return (key2) => (result, value2) => {
            if (value2 === null || value2 === void 0 || value2.length === 0) {
              return result;
            }
            if (result.length === 0) {
              return [[encode4(key2, options), "=", encode4(value2, options)].join("")];
            }
            return [[result, encode4(value2, options)].join(options.arrayFormatSeparator)];
          };
        default:
          return (key2) => (result, value2) => {
            if (value2 === void 0 || options.skipNull && value2 === null || options.skipEmptyString && value2 === "") {
              return result;
            }
            if (value2 === null) {
              return [...result, encode4(key2, options)];
            }
            return [...result, [encode4(key2, options), "=", encode4(value2, options)].join("")];
          };
      }
    }
    function parserForArrayFormat(options) {
      let result;
      switch (options.arrayFormat) {
        case "index":
          return (key2, value2, accumulator) => {
            result = /\[(\d*)\]$/.exec(key2);
            key2 = key2.replace(/\[\d*\]$/, "");
            if (!result) {
              accumulator[key2] = value2;
              return;
            }
            if (accumulator[key2] === void 0) {
              accumulator[key2] = {};
            }
            accumulator[key2][result[1]] = value2;
          };
        case "bracket":
          return (key2, value2, accumulator) => {
            result = /(\[\])$/.exec(key2);
            key2 = key2.replace(/\[\]$/, "");
            if (!result) {
              accumulator[key2] = value2;
              return;
            }
            if (accumulator[key2] === void 0) {
              accumulator[key2] = [value2];
              return;
            }
            accumulator[key2] = [].concat(accumulator[key2], value2);
          };
        case "comma":
        case "separator":
          return (key2, value2, accumulator) => {
            const isArray2 = typeof value2 === "string" && value2.split("").indexOf(options.arrayFormatSeparator) > -1;
            const newValue = isArray2 ? value2.split(options.arrayFormatSeparator).map((item) => decode3(item, options)) : value2 === null ? value2 : decode3(value2, options);
            accumulator[key2] = newValue;
          };
        default:
          return (key2, value2, accumulator) => {
            if (accumulator[key2] === void 0) {
              accumulator[key2] = value2;
              return;
            }
            accumulator[key2] = [].concat(accumulator[key2], value2);
          };
      }
    }
    function validateArrayFormatSeparator(value2) {
      if (typeof value2 !== "string" || value2.length !== 1) {
        throw new TypeError("arrayFormatSeparator must be single character string");
      }
    }
    function encode4(value2, options) {
      if (options.encode) {
        return options.strict ? strictUriEncode(value2) : encodeURIComponent(value2);
      }
      return value2;
    }
    function decode3(value2, options) {
      if (options.decode) {
        return decodeComponent(value2);
      }
      return value2;
    }
    function keysSorter(input) {
      if (Array.isArray(input)) {
        return input.sort();
      }
      if (typeof input === "object") {
        return keysSorter(Object.keys(input)).sort((a5, b4) => Number(a5) - Number(b4)).map((key2) => input[key2]);
      }
      return input;
    }
    function removeHash(input) {
      const hashStart = input.indexOf("#");
      if (hashStart !== -1) {
        input = input.slice(0, hashStart);
      }
      return input;
    }
    function getHash(url) {
      let hash3 = "";
      const hashStart = url.indexOf("#");
      if (hashStart !== -1) {
        hash3 = url.slice(hashStart);
      }
      return hash3;
    }
    function extract(input) {
      input = removeHash(input);
      const queryStart = input.indexOf("?");
      if (queryStart === -1) {
        return "";
      }
      return input.slice(queryStart + 1);
    }
    function parseValue(value2, options) {
      if (options.parseNumbers && !Number.isNaN(Number(value2)) && (typeof value2 === "string" && value2.trim() !== "")) {
        value2 = Number(value2);
      } else if (options.parseBooleans && value2 !== null && (value2.toLowerCase() === "true" || value2.toLowerCase() === "false")) {
        value2 = value2.toLowerCase() === "true";
      }
      return value2;
    }
    function parse4(input, options) {
      options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: false,
        parseBooleans: false
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const formatter = parserForArrayFormat(options);
      const ret = /* @__PURE__ */ Object.create(null);
      if (typeof input !== "string") {
        return ret;
      }
      input = input.trim().replace(/^[?#&]/, "");
      if (!input) {
        return ret;
      }
      for (const param of input.split("&")) {
        let [key2, value2] = splitOnFirst(options.decode ? param.replace(/\+/g, " ") : param, "=");
        value2 = value2 === void 0 ? null : ["comma", "separator"].includes(options.arrayFormat) ? value2 : decode3(value2, options);
        formatter(decode3(key2, options), value2, ret);
      }
      for (const key2 of Object.keys(ret)) {
        const value2 = ret[key2];
        if (typeof value2 === "object" && value2 !== null) {
          for (const k8 of Object.keys(value2)) {
            value2[k8] = parseValue(value2[k8], options);
          }
        } else {
          ret[key2] = parseValue(value2, options);
        }
      }
      if (options.sort === false) {
        return ret;
      }
      return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key2) => {
        const value2 = ret[key2];
        if (Boolean(value2) && typeof value2 === "object" && !Array.isArray(value2)) {
          result[key2] = keysSorter(value2);
        } else {
          result[key2] = value2;
        }
        return result;
      }, /* @__PURE__ */ Object.create(null));
    }
    exports2.extract = extract;
    exports2.parse = parse4;
    exports2.stringify = (object, options) => {
      if (!object) {
        return "";
      }
      options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: "none",
        arrayFormatSeparator: ","
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const shouldFilter = (key2) => options.skipNull && isNullOrUndefined(object[key2]) || options.skipEmptyString && object[key2] === "";
      const formatter = encoderForArrayFormat(options);
      const objectCopy = {};
      for (const key2 of Object.keys(object)) {
        if (!shouldFilter(key2)) {
          objectCopy[key2] = object[key2];
        }
      }
      const keys = Object.keys(objectCopy);
      if (options.sort !== false) {
        keys.sort(options.sort);
      }
      return keys.map((key2) => {
        const value2 = object[key2];
        if (value2 === void 0) {
          return "";
        }
        if (value2 === null) {
          return encode4(key2, options);
        }
        if (Array.isArray(value2)) {
          return value2.reduce(formatter(key2), []).join("&");
        }
        return encode4(key2, options) + "=" + encode4(value2, options);
      }).filter((x6) => x6.length > 0).join("&");
    };
    exports2.parseUrl = (input, options) => {
      options = Object.assign({
        decode: true
      }, options);
      const [url, hash3] = splitOnFirst(input, "#");
      return Object.assign(
        {
          url: url.split("?")[0] || "",
          query: parse4(extract(input), options)
        },
        options && options.parseFragmentIdentifier && hash3 ? { fragmentIdentifier: decode3(hash3, options) } : {}
      );
    };
    exports2.stringifyUrl = (input, options) => {
      options = Object.assign({
        encode: true,
        strict: true
      }, options);
      const url = removeHash(input.url).split("?")[0] || "";
      const queryFromUrl = exports2.extract(input.url);
      const parsedQueryFromUrl = exports2.parse(queryFromUrl, { sort: false });
      const query = Object.assign(parsedQueryFromUrl, input.query);
      let queryString = exports2.stringify(query, options);
      if (queryString) {
        queryString = `?${queryString}`;
      }
      let hash3 = getHash(input.url);
      if (input.fragmentIdentifier) {
        hash3 = `#${encode4(input.fragmentIdentifier, options)}`;
      }
      return `${url}${queryString}${hash3}`;
    };
  }
});

// node_modules/@walletconnect/socket-transport/node_modules/ws/browser.js
var require_browser2 = __commonJS({
  "node_modules/@walletconnect/socket-transport/node_modules/ws/browser.js"(exports2, module2) {
    "use strict";
    module2.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// node_modules/qrcode/lib/can-promise.js
var require_can_promise = __commonJS({
  "node_modules/qrcode/lib/can-promise.js"(exports2, module2) {
    module2.exports = function() {
      return typeof Promise === "function" && Promise.prototype && Promise.prototype.then;
    };
  }
});

// node_modules/qrcode/lib/utils/typedarray-buffer.js
var require_typedarray_buffer = __commonJS({
  "node_modules/qrcode/lib/utils/typedarray-buffer.js"(exports2, module2) {
    "use strict";
    var isArray2 = require_isarray();
    function typedArraySupport() {
      try {
        var arr = new Uint8Array(1);
        arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
          return 42;
        } };
        return arr.foo() === 42;
      } catch (e6) {
        return false;
      }
    }
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    var K_MAX_LENGTH = Buffer2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
    function Buffer2(arg, offset, length) {
      if (!Buffer2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer2)) {
        return new Buffer2(arg, offset, length);
      }
      if (typeof arg === "number") {
        return allocUnsafe(this, arg);
      }
      return from2(this, arg, offset, length);
    }
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      Buffer2.prototype.__proto__ = Uint8Array.prototype;
      Buffer2.__proto__ = Uint8Array;
      if (typeof Symbol !== "undefined" && Symbol.species && Buffer2[Symbol.species] === Buffer2) {
        Object.defineProperty(Buffer2, Symbol.species, {
          value: null,
          configurable: true,
          enumerable: false,
          writable: false
        });
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function isnan(val) {
      return val !== val;
    }
    function createBuffer(that, length) {
      var buf;
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        buf = new Uint8Array(length);
        buf.__proto__ = Buffer2.prototype;
      } else {
        buf = that;
        if (buf === null) {
          buf = new Buffer2(length);
        }
        buf.length = length;
      }
      return buf;
    }
    function allocUnsafe(that, size) {
      var buf = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
      if (!Buffer2.TYPED_ARRAY_SUPPORT) {
        for (var i6 = 0; i6 < size; ++i6) {
          buf[i6] = 0;
        }
      }
      return buf;
    }
    function fromString(that, string) {
      var length = byteLength(string) | 0;
      var buf = createBuffer(that, length);
      var actual = buf.write(string);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(that, array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      var buf = createBuffer(that, length);
      for (var i6 = 0; i6 < length; i6 += 1) {
        buf[i6] = array[i6] & 255;
      }
      return buf;
    }
    function fromArrayBuffer(that, array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError("'offset' is out of bounds");
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError("'length' is out of bounds");
      }
      var buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        buf.__proto__ = Buffer2.prototype;
      } else {
        buf = fromArrayLike(that, buf);
      }
      return buf;
    }
    function fromObject(that, obj) {
      if (Buffer2.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(that, len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj) {
        if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
          if (typeof obj.length !== "number" || isnan(obj.length)) {
            return createBuffer(that, 0);
          }
          return fromArrayLike(that, obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(that, obj.data);
        }
      }
      throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];
      for (var i6 = 0; i6 < length; ++i6) {
        codePoint = string.charCodeAt(i6);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i6 + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function byteLength(string) {
      if (Buffer2.isBuffer(string)) {
        return string.length;
      }
      if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        string = "" + string;
      }
      var len = string.length;
      if (len === 0)
        return 0;
      return utf8ToBytes(string).length;
    }
    function blitBuffer(src, dst, offset, length) {
      for (var i6 = 0; i6 < length; ++i6) {
        if (i6 + offset >= dst.length || i6 >= src.length)
          break;
        dst[i6 + offset] = src[i6];
      }
      return i6;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function from2(that, value2, offset, length) {
      if (typeof value2 === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
      if (typeof ArrayBuffer !== "undefined" && value2 instanceof ArrayBuffer) {
        return fromArrayBuffer(that, value2, offset, length);
      }
      if (typeof value2 === "string") {
        return fromString(that, value2, offset);
      }
      return fromObject(that, value2);
    }
    Buffer2.prototype.write = function write(string, offset, length) {
      if (offset === void 0) {
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset | 0;
        if (isFinite(length)) {
          length = length | 0;
        } else {
          length = void 0;
        }
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      return utf8Write(this, string, offset, length);
    };
    Buffer2.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf;
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end);
        newBuf.__proto__ = Buffer2.prototype;
      } else {
        var sliceLen = end - start;
        newBuf = new Buffer2(sliceLen, void 0);
        for (var i6 = 0; i6 < sliceLen; ++i6) {
          newBuf[i6] = this[i6 + start];
        }
      }
      return newBuf;
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("sourceStart out of bounds");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      var i6;
      if (this === target && start < targetStart && targetStart < end) {
        for (i6 = len - 1; i6 >= 0; --i6) {
          target[i6 + targetStart] = this[i6 + start];
        }
      } else if (len < 1e3 || !Buffer2.TYPED_ARRAY_SUPPORT) {
        for (i6 = 0; i6 < len; ++i6) {
          target[i6 + targetStart] = this[i6 + start];
        }
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, start + len),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          end = this.length;
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (code < 256) {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i6;
      if (typeof val === "number") {
        for (i6 = start; i6 < end; ++i6) {
          this[i6] = val;
        }
      } else {
        var bytes = Buffer2.isBuffer(val) ? val : new Buffer2(val);
        var len = bytes.length;
        for (i6 = 0; i6 < end - start; ++i6) {
          this[i6 + start] = bytes[i6 % len];
        }
      }
      return this;
    };
    Buffer2.concat = function concat4(list, length) {
      if (!isArray2(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return createBuffer(null, 0);
      }
      var i6;
      if (length === void 0) {
        length = 0;
        for (i6 = 0; i6 < list.length; ++i6) {
          length += list[i6].length;
        }
      }
      var buffer2 = allocUnsafe(null, length);
      var pos = 0;
      for (i6 = 0; i6 < list.length; ++i6) {
        var buf = list[i6];
        if (!Buffer2.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        buf.copy(buffer2, pos);
        pos += buf.length;
      }
      return buffer2;
    };
    Buffer2.byteLength = byteLength;
    Buffer2.prototype._isBuffer = true;
    Buffer2.isBuffer = function isBuffer2(b4) {
      return !!(b4 != null && b4._isBuffer);
    };
    module2.exports.alloc = function(size) {
      var buffer2 = new Buffer2(size);
      buffer2.fill(0);
      return buffer2;
    };
    module2.exports.from = function(data) {
      return new Buffer2(data);
    };
  }
});

// node_modules/qrcode/lib/core/utils.js
var require_utils5 = __commonJS({
  "node_modules/qrcode/lib/core/utils.js"(exports2) {
    var toSJISFunction;
    var CODEWORDS_COUNT = [
      0,
      26,
      44,
      70,
      100,
      134,
      172,
      196,
      242,
      292,
      346,
      404,
      466,
      532,
      581,
      655,
      733,
      815,
      901,
      991,
      1085,
      1156,
      1258,
      1364,
      1474,
      1588,
      1706,
      1828,
      1921,
      2051,
      2185,
      2323,
      2465,
      2611,
      2761,
      2876,
      3034,
      3196,
      3362,
      3532,
      3706
    ];
    exports2.getSymbolSize = function getSymbolSize(version27) {
      if (!version27)
        throw new Error('"version" cannot be null or undefined');
      if (version27 < 1 || version27 > 40)
        throw new Error('"version" should be in range from 1 to 40');
      return version27 * 4 + 17;
    };
    exports2.getSymbolTotalCodewords = function getSymbolTotalCodewords(version27) {
      return CODEWORDS_COUNT[version27];
    };
    exports2.getBCHDigit = function(data) {
      var digit = 0;
      while (data !== 0) {
        digit++;
        data >>>= 1;
      }
      return digit;
    };
    exports2.setToSJISFunction = function setToSJISFunction(f7) {
      if (typeof f7 !== "function") {
        throw new Error('"toSJISFunc" is not a valid function.');
      }
      toSJISFunction = f7;
    };
    exports2.isKanjiModeEnabled = function() {
      return typeof toSJISFunction !== "undefined";
    };
    exports2.toSJIS = function toSJIS(kanji) {
      return toSJISFunction(kanji);
    };
  }
});

// node_modules/qrcode/lib/core/error-correction-level.js
var require_error_correction_level = __commonJS({
  "node_modules/qrcode/lib/core/error-correction-level.js"(exports2) {
    exports2.L = { bit: 1 };
    exports2.M = { bit: 0 };
    exports2.Q = { bit: 3 };
    exports2.H = { bit: 2 };
    function fromString(string) {
      if (typeof string !== "string") {
        throw new Error("Param is not a string");
      }
      var lcStr = string.toLowerCase();
      switch (lcStr) {
        case "l":
        case "low":
          return exports2.L;
        case "m":
        case "medium":
          return exports2.M;
        case "q":
        case "quartile":
          return exports2.Q;
        case "h":
        case "high":
          return exports2.H;
        default:
          throw new Error("Unknown EC Level: " + string);
      }
    }
    exports2.isValid = function isValid2(level) {
      return level && typeof level.bit !== "undefined" && level.bit >= 0 && level.bit < 4;
    };
    exports2.from = function from2(value2, defaultValue) {
      if (exports2.isValid(value2)) {
        return value2;
      }
      try {
        return fromString(value2);
      } catch (e6) {
        return defaultValue;
      }
    };
  }
});

// node_modules/qrcode/lib/core/bit-buffer.js
var require_bit_buffer = __commonJS({
  "node_modules/qrcode/lib/core/bit-buffer.js"(exports2, module2) {
    function BitBuffer() {
      this.buffer = [];
      this.length = 0;
    }
    BitBuffer.prototype = {
      get: function(index) {
        var bufIndex = Math.floor(index / 8);
        return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) === 1;
      },
      put: function(num, length) {
        for (var i6 = 0; i6 < length; i6++) {
          this.putBit((num >>> length - i6 - 1 & 1) === 1);
        }
      },
      getLengthInBits: function() {
        return this.length;
      },
      putBit: function(bit) {
        var bufIndex = Math.floor(this.length / 8);
        if (this.buffer.length <= bufIndex) {
          this.buffer.push(0);
        }
        if (bit) {
          this.buffer[bufIndex] |= 128 >>> this.length % 8;
        }
        this.length++;
      }
    };
    module2.exports = BitBuffer;
  }
});

// node_modules/qrcode/lib/core/bit-matrix.js
var require_bit_matrix = __commonJS({
  "node_modules/qrcode/lib/core/bit-matrix.js"(exports2, module2) {
    var BufferUtil = require_typedarray_buffer();
    function BitMatrix(size) {
      if (!size || size < 1) {
        throw new Error("BitMatrix size must be defined and greater than 0");
      }
      this.size = size;
      this.data = BufferUtil.alloc(size * size);
      this.reservedBit = BufferUtil.alloc(size * size);
    }
    BitMatrix.prototype.set = function(row, col, value2, reserved) {
      var index = row * this.size + col;
      this.data[index] = value2;
      if (reserved)
        this.reservedBit[index] = true;
    };
    BitMatrix.prototype.get = function(row, col) {
      return this.data[row * this.size + col];
    };
    BitMatrix.prototype.xor = function(row, col, value2) {
      this.data[row * this.size + col] ^= value2;
    };
    BitMatrix.prototype.isReserved = function(row, col) {
      return this.reservedBit[row * this.size + col];
    };
    module2.exports = BitMatrix;
  }
});

// node_modules/qrcode/lib/core/alignment-pattern.js
var require_alignment_pattern = __commonJS({
  "node_modules/qrcode/lib/core/alignment-pattern.js"(exports2) {
    var getSymbolSize = require_utils5().getSymbolSize;
    exports2.getRowColCoords = function getRowColCoords(version27) {
      if (version27 === 1)
        return [];
      var posCount = Math.floor(version27 / 7) + 2;
      var size = getSymbolSize(version27);
      var intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2;
      var positions = [size - 7];
      for (var i6 = 1; i6 < posCount - 1; i6++) {
        positions[i6] = positions[i6 - 1] - intervals;
      }
      positions.push(6);
      return positions.reverse();
    };
    exports2.getPositions = function getPositions(version27) {
      var coords = [];
      var pos = exports2.getRowColCoords(version27);
      var posLength = pos.length;
      for (var i6 = 0; i6 < posLength; i6++) {
        for (var j8 = 0; j8 < posLength; j8++) {
          if (i6 === 0 && j8 === 0 || i6 === 0 && j8 === posLength - 1 || i6 === posLength - 1 && j8 === 0) {
            continue;
          }
          coords.push([pos[i6], pos[j8]]);
        }
      }
      return coords;
    };
  }
});

// node_modules/qrcode/lib/core/finder-pattern.js
var require_finder_pattern = __commonJS({
  "node_modules/qrcode/lib/core/finder-pattern.js"(exports2) {
    var getSymbolSize = require_utils5().getSymbolSize;
    var FINDER_PATTERN_SIZE = 7;
    exports2.getPositions = function getPositions(version27) {
      var size = getSymbolSize(version27);
      return [
        [0, 0],
        [size - FINDER_PATTERN_SIZE, 0],
        [0, size - FINDER_PATTERN_SIZE]
      ];
    };
  }
});

// node_modules/qrcode/lib/core/mask-pattern.js
var require_mask_pattern = __commonJS({
  "node_modules/qrcode/lib/core/mask-pattern.js"(exports2) {
    exports2.Patterns = {
      PATTERN000: 0,
      PATTERN001: 1,
      PATTERN010: 2,
      PATTERN011: 3,
      PATTERN100: 4,
      PATTERN101: 5,
      PATTERN110: 6,
      PATTERN111: 7
    };
    var PenaltyScores = {
      N1: 3,
      N2: 3,
      N3: 40,
      N4: 10
    };
    exports2.isValid = function isValid2(mask) {
      return mask != null && mask !== "" && !isNaN(mask) && mask >= 0 && mask <= 7;
    };
    exports2.from = function from2(value2) {
      return exports2.isValid(value2) ? parseInt(value2, 10) : void 0;
    };
    exports2.getPenaltyN1 = function getPenaltyN1(data) {
      var size = data.size;
      var points = 0;
      var sameCountCol = 0;
      var sameCountRow = 0;
      var lastCol = null;
      var lastRow = null;
      for (var row = 0; row < size; row++) {
        sameCountCol = sameCountRow = 0;
        lastCol = lastRow = null;
        for (var col = 0; col < size; col++) {
          var module3 = data.get(row, col);
          if (module3 === lastCol) {
            sameCountCol++;
          } else {
            if (sameCountCol >= 5)
              points += PenaltyScores.N1 + (sameCountCol - 5);
            lastCol = module3;
            sameCountCol = 1;
          }
          module3 = data.get(col, row);
          if (module3 === lastRow) {
            sameCountRow++;
          } else {
            if (sameCountRow >= 5)
              points += PenaltyScores.N1 + (sameCountRow - 5);
            lastRow = module3;
            sameCountRow = 1;
          }
        }
        if (sameCountCol >= 5)
          points += PenaltyScores.N1 + (sameCountCol - 5);
        if (sameCountRow >= 5)
          points += PenaltyScores.N1 + (sameCountRow - 5);
      }
      return points;
    };
    exports2.getPenaltyN2 = function getPenaltyN2(data) {
      var size = data.size;
      var points = 0;
      for (var row = 0; row < size - 1; row++) {
        for (var col = 0; col < size - 1; col++) {
          var last2 = data.get(row, col) + data.get(row, col + 1) + data.get(row + 1, col) + data.get(row + 1, col + 1);
          if (last2 === 4 || last2 === 0)
            points++;
        }
      }
      return points * PenaltyScores.N2;
    };
    exports2.getPenaltyN3 = function getPenaltyN3(data) {
      var size = data.size;
      var points = 0;
      var bitsCol = 0;
      var bitsRow = 0;
      for (var row = 0; row < size; row++) {
        bitsCol = bitsRow = 0;
        for (var col = 0; col < size; col++) {
          bitsCol = bitsCol << 1 & 2047 | data.get(row, col);
          if (col >= 10 && (bitsCol === 1488 || bitsCol === 93))
            points++;
          bitsRow = bitsRow << 1 & 2047 | data.get(col, row);
          if (col >= 10 && (bitsRow === 1488 || bitsRow === 93))
            points++;
        }
      }
      return points * PenaltyScores.N3;
    };
    exports2.getPenaltyN4 = function getPenaltyN4(data) {
      var darkCount = 0;
      var modulesCount = data.data.length;
      for (var i6 = 0; i6 < modulesCount; i6++)
        darkCount += data.data[i6];
      var k8 = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
      return k8 * PenaltyScores.N4;
    };
    function getMaskAt(maskPattern, i6, j8) {
      switch (maskPattern) {
        case exports2.Patterns.PATTERN000:
          return (i6 + j8) % 2 === 0;
        case exports2.Patterns.PATTERN001:
          return i6 % 2 === 0;
        case exports2.Patterns.PATTERN010:
          return j8 % 3 === 0;
        case exports2.Patterns.PATTERN011:
          return (i6 + j8) % 3 === 0;
        case exports2.Patterns.PATTERN100:
          return (Math.floor(i6 / 2) + Math.floor(j8 / 3)) % 2 === 0;
        case exports2.Patterns.PATTERN101:
          return i6 * j8 % 2 + i6 * j8 % 3 === 0;
        case exports2.Patterns.PATTERN110:
          return (i6 * j8 % 2 + i6 * j8 % 3) % 2 === 0;
        case exports2.Patterns.PATTERN111:
          return (i6 * j8 % 3 + (i6 + j8) % 2) % 2 === 0;
        default:
          throw new Error("bad maskPattern:" + maskPattern);
      }
    }
    exports2.applyMask = function applyMask(pattern, data) {
      var size = data.size;
      for (var col = 0; col < size; col++) {
        for (var row = 0; row < size; row++) {
          if (data.isReserved(row, col))
            continue;
          data.xor(row, col, getMaskAt(pattern, row, col));
        }
      }
    };
    exports2.getBestMask = function getBestMask(data, setupFormatFunc) {
      var numPatterns = Object.keys(exports2.Patterns).length;
      var bestPattern = 0;
      var lowerPenalty = Infinity;
      for (var p7 = 0; p7 < numPatterns; p7++) {
        setupFormatFunc(p7);
        exports2.applyMask(p7, data);
        var penalty = exports2.getPenaltyN1(data) + exports2.getPenaltyN2(data) + exports2.getPenaltyN3(data) + exports2.getPenaltyN4(data);
        exports2.applyMask(p7, data);
        if (penalty < lowerPenalty) {
          lowerPenalty = penalty;
          bestPattern = p7;
        }
      }
      return bestPattern;
    };
  }
});

// node_modules/qrcode/lib/core/error-correction-code.js
var require_error_correction_code = __commonJS({
  "node_modules/qrcode/lib/core/error-correction-code.js"(exports2) {
    var ECLevel = require_error_correction_level();
    var EC_BLOCKS_TABLE = [
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      1,
      2,
      2,
      4,
      1,
      2,
      4,
      4,
      2,
      4,
      4,
      4,
      2,
      4,
      6,
      5,
      2,
      4,
      6,
      6,
      2,
      5,
      8,
      8,
      4,
      5,
      8,
      8,
      4,
      5,
      8,
      11,
      4,
      8,
      10,
      11,
      4,
      9,
      12,
      16,
      4,
      9,
      16,
      16,
      6,
      10,
      12,
      18,
      6,
      10,
      17,
      16,
      6,
      11,
      16,
      19,
      6,
      13,
      18,
      21,
      7,
      14,
      21,
      25,
      8,
      16,
      20,
      25,
      8,
      17,
      23,
      25,
      9,
      17,
      23,
      34,
      9,
      18,
      25,
      30,
      10,
      20,
      27,
      32,
      12,
      21,
      29,
      35,
      12,
      23,
      34,
      37,
      12,
      25,
      34,
      40,
      13,
      26,
      35,
      42,
      14,
      28,
      38,
      45,
      15,
      29,
      40,
      48,
      16,
      31,
      43,
      51,
      17,
      33,
      45,
      54,
      18,
      35,
      48,
      57,
      19,
      37,
      51,
      60,
      19,
      38,
      53,
      63,
      20,
      40,
      56,
      66,
      21,
      43,
      59,
      70,
      22,
      45,
      62,
      74,
      24,
      47,
      65,
      77,
      25,
      49,
      68,
      81
    ];
    var EC_CODEWORDS_TABLE = [
      7,
      10,
      13,
      17,
      10,
      16,
      22,
      28,
      15,
      26,
      36,
      44,
      20,
      36,
      52,
      64,
      26,
      48,
      72,
      88,
      36,
      64,
      96,
      112,
      40,
      72,
      108,
      130,
      48,
      88,
      132,
      156,
      60,
      110,
      160,
      192,
      72,
      130,
      192,
      224,
      80,
      150,
      224,
      264,
      96,
      176,
      260,
      308,
      104,
      198,
      288,
      352,
      120,
      216,
      320,
      384,
      132,
      240,
      360,
      432,
      144,
      280,
      408,
      480,
      168,
      308,
      448,
      532,
      180,
      338,
      504,
      588,
      196,
      364,
      546,
      650,
      224,
      416,
      600,
      700,
      224,
      442,
      644,
      750,
      252,
      476,
      690,
      816,
      270,
      504,
      750,
      900,
      300,
      560,
      810,
      960,
      312,
      588,
      870,
      1050,
      336,
      644,
      952,
      1110,
      360,
      700,
      1020,
      1200,
      390,
      728,
      1050,
      1260,
      420,
      784,
      1140,
      1350,
      450,
      812,
      1200,
      1440,
      480,
      868,
      1290,
      1530,
      510,
      924,
      1350,
      1620,
      540,
      980,
      1440,
      1710,
      570,
      1036,
      1530,
      1800,
      570,
      1064,
      1590,
      1890,
      600,
      1120,
      1680,
      1980,
      630,
      1204,
      1770,
      2100,
      660,
      1260,
      1860,
      2220,
      720,
      1316,
      1950,
      2310,
      750,
      1372,
      2040,
      2430
    ];
    exports2.getBlocksCount = function getBlocksCount(version27, errorCorrectionLevel) {
      switch (errorCorrectionLevel) {
        case ECLevel.L:
          return EC_BLOCKS_TABLE[(version27 - 1) * 4 + 0];
        case ECLevel.M:
          return EC_BLOCKS_TABLE[(version27 - 1) * 4 + 1];
        case ECLevel.Q:
          return EC_BLOCKS_TABLE[(version27 - 1) * 4 + 2];
        case ECLevel.H:
          return EC_BLOCKS_TABLE[(version27 - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
    exports2.getTotalCodewordsCount = function getTotalCodewordsCount(version27, errorCorrectionLevel) {
      switch (errorCorrectionLevel) {
        case ECLevel.L:
          return EC_CODEWORDS_TABLE[(version27 - 1) * 4 + 0];
        case ECLevel.M:
          return EC_CODEWORDS_TABLE[(version27 - 1) * 4 + 1];
        case ECLevel.Q:
          return EC_CODEWORDS_TABLE[(version27 - 1) * 4 + 2];
        case ECLevel.H:
          return EC_CODEWORDS_TABLE[(version27 - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
  }
});

// node_modules/qrcode/lib/core/galois-field.js
var require_galois_field = __commonJS({
  "node_modules/qrcode/lib/core/galois-field.js"(exports2) {
    var BufferUtil = require_typedarray_buffer();
    var EXP_TABLE = BufferUtil.alloc(512);
    var LOG_TABLE = BufferUtil.alloc(256);
    (function initTables() {
      var x6 = 1;
      for (var i6 = 0; i6 < 255; i6++) {
        EXP_TABLE[i6] = x6;
        LOG_TABLE[x6] = i6;
        x6 <<= 1;
        if (x6 & 256) {
          x6 ^= 285;
        }
      }
      for (i6 = 255; i6 < 512; i6++) {
        EXP_TABLE[i6] = EXP_TABLE[i6 - 255];
      }
    })();
    exports2.log = function log(n4) {
      if (n4 < 1)
        throw new Error("log(" + n4 + ")");
      return LOG_TABLE[n4];
    };
    exports2.exp = function exp(n4) {
      return EXP_TABLE[n4];
    };
    exports2.mul = function mul3(x6, y5) {
      if (x6 === 0 || y5 === 0)
        return 0;
      return EXP_TABLE[LOG_TABLE[x6] + LOG_TABLE[y5]];
    };
  }
});

// node_modules/qrcode/lib/core/polynomial.js
var require_polynomial = __commonJS({
  "node_modules/qrcode/lib/core/polynomial.js"(exports2) {
    var BufferUtil = require_typedarray_buffer();
    var GF = require_galois_field();
    exports2.mul = function mul3(p1, p22) {
      var coeff = BufferUtil.alloc(p1.length + p22.length - 1);
      for (var i6 = 0; i6 < p1.length; i6++) {
        for (var j8 = 0; j8 < p22.length; j8++) {
          coeff[i6 + j8] ^= GF.mul(p1[i6], p22[j8]);
        }
      }
      return coeff;
    };
    exports2.mod = function mod2(divident, divisor) {
      var result = BufferUtil.from(divident);
      while (result.length - divisor.length >= 0) {
        var coeff = result[0];
        for (var i6 = 0; i6 < divisor.length; i6++) {
          result[i6] ^= GF.mul(divisor[i6], coeff);
        }
        var offset = 0;
        while (offset < result.length && result[offset] === 0)
          offset++;
        result = result.slice(offset);
      }
      return result;
    };
    exports2.generateECPolynomial = function generateECPolynomial(degree) {
      var poly = BufferUtil.from([1]);
      for (var i6 = 0; i6 < degree; i6++) {
        poly = exports2.mul(poly, [1, GF.exp(i6)]);
      }
      return poly;
    };
  }
});

// node_modules/qrcode/lib/core/reed-solomon-encoder.js
var require_reed_solomon_encoder = __commonJS({
  "node_modules/qrcode/lib/core/reed-solomon-encoder.js"(exports2, module2) {
    var BufferUtil = require_typedarray_buffer();
    var Polynomial = require_polynomial();
    var Buffer2 = require_buffer3().Buffer;
    function ReedSolomonEncoder(degree) {
      this.genPoly = void 0;
      this.degree = degree;
      if (this.degree)
        this.initialize(this.degree);
    }
    ReedSolomonEncoder.prototype.initialize = function initialize(degree) {
      this.degree = degree;
      this.genPoly = Polynomial.generateECPolynomial(this.degree);
    };
    ReedSolomonEncoder.prototype.encode = function encode4(data) {
      if (!this.genPoly) {
        throw new Error("Encoder not initialized");
      }
      var pad = BufferUtil.alloc(this.degree);
      var paddedData = Buffer2.concat([data, pad], data.length + this.degree);
      var remainder = Polynomial.mod(paddedData, this.genPoly);
      var start = this.degree - remainder.length;
      if (start > 0) {
        var buff = BufferUtil.alloc(this.degree);
        remainder.copy(buff, start);
        return buff;
      }
      return remainder;
    };
    module2.exports = ReedSolomonEncoder;
  }
});

// node_modules/qrcode/lib/core/version-check.js
var require_version_check = __commonJS({
  "node_modules/qrcode/lib/core/version-check.js"(exports2) {
    exports2.isValid = function isValid2(version27) {
      return !isNaN(version27) && version27 >= 1 && version27 <= 40;
    };
  }
});

// node_modules/qrcode/lib/core/regex.js
var require_regex = __commonJS({
  "node_modules/qrcode/lib/core/regex.js"(exports2) {
    var numeric = "[0-9]+";
    var alphanumeric = "[A-Z $%*+\\-./:]+";
    var kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
    kanji = kanji.replace(/u/g, "\\u");
    var byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + ")(?:.|[\r\n]))+";
    exports2.KANJI = new RegExp(kanji, "g");
    exports2.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
    exports2.BYTE = new RegExp(byte, "g");
    exports2.NUMERIC = new RegExp(numeric, "g");
    exports2.ALPHANUMERIC = new RegExp(alphanumeric, "g");
    var TEST_KANJI = new RegExp("^" + kanji + "$");
    var TEST_NUMERIC = new RegExp("^" + numeric + "$");
    var TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
    exports2.testKanji = function testKanji(str) {
      return TEST_KANJI.test(str);
    };
    exports2.testNumeric = function testNumeric(str) {
      return TEST_NUMERIC.test(str);
    };
    exports2.testAlphanumeric = function testAlphanumeric(str) {
      return TEST_ALPHANUMERIC.test(str);
    };
  }
});

// node_modules/qrcode/lib/core/mode.js
var require_mode = __commonJS({
  "node_modules/qrcode/lib/core/mode.js"(exports2) {
    var VersionCheck = require_version_check();
    var Regex = require_regex();
    exports2.NUMERIC = {
      id: "Numeric",
      bit: 1 << 0,
      ccBits: [10, 12, 14]
    };
    exports2.ALPHANUMERIC = {
      id: "Alphanumeric",
      bit: 1 << 1,
      ccBits: [9, 11, 13]
    };
    exports2.BYTE = {
      id: "Byte",
      bit: 1 << 2,
      ccBits: [8, 16, 16]
    };
    exports2.KANJI = {
      id: "Kanji",
      bit: 1 << 3,
      ccBits: [8, 10, 12]
    };
    exports2.MIXED = {
      bit: -1
    };
    exports2.getCharCountIndicator = function getCharCountIndicator(mode, version27) {
      if (!mode.ccBits)
        throw new Error("Invalid mode: " + mode);
      if (!VersionCheck.isValid(version27)) {
        throw new Error("Invalid version: " + version27);
      }
      if (version27 >= 1 && version27 < 10)
        return mode.ccBits[0];
      else if (version27 < 27)
        return mode.ccBits[1];
      return mode.ccBits[2];
    };
    exports2.getBestModeForData = function getBestModeForData(dataStr) {
      if (Regex.testNumeric(dataStr))
        return exports2.NUMERIC;
      else if (Regex.testAlphanumeric(dataStr))
        return exports2.ALPHANUMERIC;
      else if (Regex.testKanji(dataStr))
        return exports2.KANJI;
      else
        return exports2.BYTE;
    };
    exports2.toString = function toString2(mode) {
      if (mode && mode.id)
        return mode.id;
      throw new Error("Invalid mode");
    };
    exports2.isValid = function isValid2(mode) {
      return mode && mode.bit && mode.ccBits;
    };
    function fromString(string) {
      if (typeof string !== "string") {
        throw new Error("Param is not a string");
      }
      var lcStr = string.toLowerCase();
      switch (lcStr) {
        case "numeric":
          return exports2.NUMERIC;
        case "alphanumeric":
          return exports2.ALPHANUMERIC;
        case "kanji":
          return exports2.KANJI;
        case "byte":
          return exports2.BYTE;
        default:
          throw new Error("Unknown mode: " + string);
      }
    }
    exports2.from = function from2(value2, defaultValue) {
      if (exports2.isValid(value2)) {
        return value2;
      }
      try {
        return fromString(value2);
      } catch (e6) {
        return defaultValue;
      }
    };
  }
});

// node_modules/qrcode/lib/core/version.js
var require_version2 = __commonJS({
  "node_modules/qrcode/lib/core/version.js"(exports2) {
    var Utils = require_utils5();
    var ECCode = require_error_correction_code();
    var ECLevel = require_error_correction_level();
    var Mode = require_mode();
    var VersionCheck = require_version_check();
    var isArray2 = require_isarray();
    var G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
    var G18_BCH = Utils.getBCHDigit(G18);
    function getBestVersionForDataLength(mode, length, errorCorrectionLevel) {
      for (var currentVersion = 1; currentVersion <= 40; currentVersion++) {
        if (length <= exports2.getCapacity(currentVersion, errorCorrectionLevel, mode)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    function getReservedBitsCount(mode, version27) {
      return Mode.getCharCountIndicator(mode, version27) + 4;
    }
    function getTotalBitsFromDataArray(segments, version27) {
      var totalBits = 0;
      segments.forEach(function(data) {
        var reservedBits = getReservedBitsCount(data.mode, version27);
        totalBits += reservedBits + data.getBitsLength();
      });
      return totalBits;
    }
    function getBestVersionForMixedData(segments, errorCorrectionLevel) {
      for (var currentVersion = 1; currentVersion <= 40; currentVersion++) {
        var length = getTotalBitsFromDataArray(segments, currentVersion);
        if (length <= exports2.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    exports2.from = function from2(value2, defaultValue) {
      if (VersionCheck.isValid(value2)) {
        return parseInt(value2, 10);
      }
      return defaultValue;
    };
    exports2.getCapacity = function getCapacity(version27, errorCorrectionLevel, mode) {
      if (!VersionCheck.isValid(version27)) {
        throw new Error("Invalid QR Code version");
      }
      if (typeof mode === "undefined")
        mode = Mode.BYTE;
      var totalCodewords = Utils.getSymbolTotalCodewords(version27);
      var ecTotalCodewords = ECCode.getTotalCodewordsCount(version27, errorCorrectionLevel);
      var dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (mode === Mode.MIXED)
        return dataTotalCodewordsBits;
      var usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version27);
      switch (mode) {
        case Mode.NUMERIC:
          return Math.floor(usableBits / 10 * 3);
        case Mode.ALPHANUMERIC:
          return Math.floor(usableBits / 11 * 2);
        case Mode.KANJI:
          return Math.floor(usableBits / 13);
        case Mode.BYTE:
        default:
          return Math.floor(usableBits / 8);
      }
    };
    exports2.getBestVersionForData = function getBestVersionForData(data, errorCorrectionLevel) {
      var seg;
      var ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M);
      if (isArray2(data)) {
        if (data.length > 1) {
          return getBestVersionForMixedData(data, ecl);
        }
        if (data.length === 0) {
          return 1;
        }
        seg = data[0];
      } else {
        seg = data;
      }
      return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
    };
    exports2.getEncodedBits = function getEncodedBits(version27) {
      if (!VersionCheck.isValid(version27) || version27 < 7) {
        throw new Error("Invalid QR Code version");
      }
      var d6 = version27 << 12;
      while (Utils.getBCHDigit(d6) - G18_BCH >= 0) {
        d6 ^= G18 << Utils.getBCHDigit(d6) - G18_BCH;
      }
      return version27 << 12 | d6;
    };
  }
});

// node_modules/qrcode/lib/core/format-info.js
var require_format_info = __commonJS({
  "node_modules/qrcode/lib/core/format-info.js"(exports2) {
    var Utils = require_utils5();
    var G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
    var G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
    var G15_BCH = Utils.getBCHDigit(G15);
    exports2.getEncodedBits = function getEncodedBits(errorCorrectionLevel, mask) {
      var data = errorCorrectionLevel.bit << 3 | mask;
      var d6 = data << 10;
      while (Utils.getBCHDigit(d6) - G15_BCH >= 0) {
        d6 ^= G15 << Utils.getBCHDigit(d6) - G15_BCH;
      }
      return (data << 10 | d6) ^ G15_MASK;
    };
  }
});

// node_modules/qrcode/lib/core/numeric-data.js
var require_numeric_data = __commonJS({
  "node_modules/qrcode/lib/core/numeric-data.js"(exports2, module2) {
    var Mode = require_mode();
    function NumericData(data) {
      this.mode = Mode.NUMERIC;
      this.data = data.toString();
    }
    NumericData.getBitsLength = function getBitsLength(length) {
      return 10 * Math.floor(length / 3) + (length % 3 ? length % 3 * 3 + 1 : 0);
    };
    NumericData.prototype.getLength = function getLength2() {
      return this.data.length;
    };
    NumericData.prototype.getBitsLength = function getBitsLength() {
      return NumericData.getBitsLength(this.data.length);
    };
    NumericData.prototype.write = function write(bitBuffer) {
      var i6, group, value2;
      for (i6 = 0; i6 + 3 <= this.data.length; i6 += 3) {
        group = this.data.substr(i6, 3);
        value2 = parseInt(group, 10);
        bitBuffer.put(value2, 10);
      }
      var remainingNum = this.data.length - i6;
      if (remainingNum > 0) {
        group = this.data.substr(i6);
        value2 = parseInt(group, 10);
        bitBuffer.put(value2, remainingNum * 3 + 1);
      }
    };
    module2.exports = NumericData;
  }
});

// node_modules/qrcode/lib/core/alphanumeric-data.js
var require_alphanumeric_data = __commonJS({
  "node_modules/qrcode/lib/core/alphanumeric-data.js"(exports2, module2) {
    var Mode = require_mode();
    var ALPHA_NUM_CHARS = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z",
      " ",
      "$",
      "%",
      "*",
      "+",
      "-",
      ".",
      "/",
      ":"
    ];
    function AlphanumericData(data) {
      this.mode = Mode.ALPHANUMERIC;
      this.data = data;
    }
    AlphanumericData.getBitsLength = function getBitsLength(length) {
      return 11 * Math.floor(length / 2) + 6 * (length % 2);
    };
    AlphanumericData.prototype.getLength = function getLength2() {
      return this.data.length;
    };
    AlphanumericData.prototype.getBitsLength = function getBitsLength() {
      return AlphanumericData.getBitsLength(this.data.length);
    };
    AlphanumericData.prototype.write = function write(bitBuffer) {
      var i6;
      for (i6 = 0; i6 + 2 <= this.data.length; i6 += 2) {
        var value2 = ALPHA_NUM_CHARS.indexOf(this.data[i6]) * 45;
        value2 += ALPHA_NUM_CHARS.indexOf(this.data[i6 + 1]);
        bitBuffer.put(value2, 11);
      }
      if (this.data.length % 2) {
        bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i6]), 6);
      }
    };
    module2.exports = AlphanumericData;
  }
});

// node_modules/qrcode/lib/core/byte-data.js
var require_byte_data = __commonJS({
  "node_modules/qrcode/lib/core/byte-data.js"(exports2, module2) {
    var BufferUtil = require_typedarray_buffer();
    var Mode = require_mode();
    function ByteData(data) {
      this.mode = Mode.BYTE;
      this.data = BufferUtil.from(data);
    }
    ByteData.getBitsLength = function getBitsLength(length) {
      return length * 8;
    };
    ByteData.prototype.getLength = function getLength2() {
      return this.data.length;
    };
    ByteData.prototype.getBitsLength = function getBitsLength() {
      return ByteData.getBitsLength(this.data.length);
    };
    ByteData.prototype.write = function(bitBuffer) {
      for (var i6 = 0, l6 = this.data.length; i6 < l6; i6++) {
        bitBuffer.put(this.data[i6], 8);
      }
    };
    module2.exports = ByteData;
  }
});

// node_modules/qrcode/lib/core/kanji-data.js
var require_kanji_data = __commonJS({
  "node_modules/qrcode/lib/core/kanji-data.js"(exports2, module2) {
    var Mode = require_mode();
    var Utils = require_utils5();
    function KanjiData(data) {
      this.mode = Mode.KANJI;
      this.data = data;
    }
    KanjiData.getBitsLength = function getBitsLength(length) {
      return length * 13;
    };
    KanjiData.prototype.getLength = function getLength2() {
      return this.data.length;
    };
    KanjiData.prototype.getBitsLength = function getBitsLength() {
      return KanjiData.getBitsLength(this.data.length);
    };
    KanjiData.prototype.write = function(bitBuffer) {
      var i6;
      for (i6 = 0; i6 < this.data.length; i6++) {
        var value2 = Utils.toSJIS(this.data[i6]);
        if (value2 >= 33088 && value2 <= 40956) {
          value2 -= 33088;
        } else if (value2 >= 57408 && value2 <= 60351) {
          value2 -= 49472;
        } else {
          throw new Error(
            "Invalid SJIS character: " + this.data[i6] + "\nMake sure your charset is UTF-8"
          );
        }
        value2 = (value2 >>> 8 & 255) * 192 + (value2 & 255);
        bitBuffer.put(value2, 13);
      }
    };
    module2.exports = KanjiData;
  }
});

// node_modules/dijkstrajs/dijkstra.js
var require_dijkstra = __commonJS({
  "node_modules/dijkstrajs/dijkstra.js"(exports2, module2) {
    "use strict";
    var dijkstra = {
      single_source_shortest_paths: function(graph, s6, d6) {
        var predecessors = {};
        var costs = {};
        costs[s6] = 0;
        var open = dijkstra.PriorityQueue.make();
        open.push(s6, 0);
        var closest, u7, v9, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;
        while (!open.empty()) {
          closest = open.pop();
          u7 = closest.value;
          cost_of_s_to_u = closest.cost;
          adjacent_nodes = graph[u7] || {};
          for (v9 in adjacent_nodes) {
            if (adjacent_nodes.hasOwnProperty(v9)) {
              cost_of_e = adjacent_nodes[v9];
              cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;
              cost_of_s_to_v = costs[v9];
              first_visit = typeof costs[v9] === "undefined";
              if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
                costs[v9] = cost_of_s_to_u_plus_cost_of_e;
                open.push(v9, cost_of_s_to_u_plus_cost_of_e);
                predecessors[v9] = u7;
              }
            }
          }
        }
        if (typeof d6 !== "undefined" && typeof costs[d6] === "undefined") {
          var msg = ["Could not find a path from ", s6, " to ", d6, "."].join("");
          throw new Error(msg);
        }
        return predecessors;
      },
      extract_shortest_path_from_predecessor_list: function(predecessors, d6) {
        var nodes = [];
        var u7 = d6;
        var predecessor;
        while (u7) {
          nodes.push(u7);
          predecessor = predecessors[u7];
          u7 = predecessors[u7];
        }
        nodes.reverse();
        return nodes;
      },
      find_path: function(graph, s6, d6) {
        var predecessors = dijkstra.single_source_shortest_paths(graph, s6, d6);
        return dijkstra.extract_shortest_path_from_predecessor_list(
          predecessors,
          d6
        );
      },
      PriorityQueue: {
        make: function(opts) {
          var T8 = dijkstra.PriorityQueue, t6 = {}, key2;
          opts = opts || {};
          for (key2 in T8) {
            if (T8.hasOwnProperty(key2)) {
              t6[key2] = T8[key2];
            }
          }
          t6.queue = [];
          t6.sorter = opts.sorter || T8.default_sorter;
          return t6;
        },
        default_sorter: function(a5, b4) {
          return a5.cost - b4.cost;
        },
        push: function(value2, cost) {
          var item = { value: value2, cost };
          this.queue.push(item);
          this.queue.sort(this.sorter);
        },
        pop: function() {
          return this.queue.shift();
        },
        empty: function() {
          return this.queue.length === 0;
        }
      }
    };
    if (typeof module2 !== "undefined") {
      module2.exports = dijkstra;
    }
  }
});

// node_modules/qrcode/lib/core/segments.js
var require_segments = __commonJS({
  "node_modules/qrcode/lib/core/segments.js"(exports2) {
    var Mode = require_mode();
    var NumericData = require_numeric_data();
    var AlphanumericData = require_alphanumeric_data();
    var ByteData = require_byte_data();
    var KanjiData = require_kanji_data();
    var Regex = require_regex();
    var Utils = require_utils5();
    var dijkstra = require_dijkstra();
    function getStringByteLength(str) {
      return unescape(encodeURIComponent(str)).length;
    }
    function getSegments(regex, mode, str) {
      var segments = [];
      var result;
      while ((result = regex.exec(str)) !== null) {
        segments.push({
          data: result[0],
          index: result.index,
          mode,
          length: result[0].length
        });
      }
      return segments;
    }
    function getSegmentsFromString(dataStr) {
      var numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);
      var alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr);
      var byteSegs;
      var kanjiSegs;
      if (Utils.isKanjiModeEnabled()) {
        byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);
        kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);
      } else {
        byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);
        kanjiSegs = [];
      }
      var segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
      return segs.sort(function(s1, s22) {
        return s1.index - s22.index;
      }).map(function(obj) {
        return {
          data: obj.data,
          mode: obj.mode,
          length: obj.length
        };
      });
    }
    function getSegmentBitsLength(length, mode) {
      switch (mode) {
        case Mode.NUMERIC:
          return NumericData.getBitsLength(length);
        case Mode.ALPHANUMERIC:
          return AlphanumericData.getBitsLength(length);
        case Mode.KANJI:
          return KanjiData.getBitsLength(length);
        case Mode.BYTE:
          return ByteData.getBitsLength(length);
      }
    }
    function mergeSegments(segs) {
      return segs.reduce(function(acc, curr) {
        var prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
        if (prevSeg && prevSeg.mode === curr.mode) {
          acc[acc.length - 1].data += curr.data;
          return acc;
        }
        acc.push(curr);
        return acc;
      }, []);
    }
    function buildNodes(segs) {
      var nodes = [];
      for (var i6 = 0; i6 < segs.length; i6++) {
        var seg = segs[i6];
        switch (seg.mode) {
          case Mode.NUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.ALPHANUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.KANJI:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
            break;
          case Mode.BYTE:
            nodes.push([
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
        }
      }
      return nodes;
    }
    function buildGraph(nodes, version27) {
      var table = {};
      var graph = { "start": {} };
      var prevNodeIds = ["start"];
      for (var i6 = 0; i6 < nodes.length; i6++) {
        var nodeGroup = nodes[i6];
        var currentNodeIds = [];
        for (var j8 = 0; j8 < nodeGroup.length; j8++) {
          var node = nodeGroup[j8];
          var key2 = "" + i6 + j8;
          currentNodeIds.push(key2);
          table[key2] = { node, lastCount: 0 };
          graph[key2] = {};
          for (var n4 = 0; n4 < prevNodeIds.length; n4++) {
            var prevNodeId = prevNodeIds[n4];
            if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
              graph[prevNodeId][key2] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);
              table[prevNodeId].lastCount += node.length;
            } else {
              if (table[prevNodeId])
                table[prevNodeId].lastCount = node.length;
              graph[prevNodeId][key2] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode.getCharCountIndicator(node.mode, version27);
            }
          }
        }
        prevNodeIds = currentNodeIds;
      }
      for (n4 = 0; n4 < prevNodeIds.length; n4++) {
        graph[prevNodeIds[n4]]["end"] = 0;
      }
      return { map: graph, table };
    }
    function buildSingleSegment(data, modesHint) {
      var mode;
      var bestMode = Mode.getBestModeForData(data);
      mode = Mode.from(modesHint, bestMode);
      if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {
        throw new Error('"' + data + '" cannot be encoded with mode ' + Mode.toString(mode) + ".\n Suggested mode is: " + Mode.toString(bestMode));
      }
      if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {
        mode = Mode.BYTE;
      }
      switch (mode) {
        case Mode.NUMERIC:
          return new NumericData(data);
        case Mode.ALPHANUMERIC:
          return new AlphanumericData(data);
        case Mode.KANJI:
          return new KanjiData(data);
        case Mode.BYTE:
          return new ByteData(data);
      }
    }
    exports2.fromArray = function fromArray2(array) {
      return array.reduce(function(acc, seg) {
        if (typeof seg === "string") {
          acc.push(buildSingleSegment(seg, null));
        } else if (seg.data) {
          acc.push(buildSingleSegment(seg.data, seg.mode));
        }
        return acc;
      }, []);
    };
    exports2.fromString = function fromString(data, version27) {
      var segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled());
      var nodes = buildNodes(segs);
      var graph = buildGraph(nodes, version27);
      var path = dijkstra.find_path(graph.map, "start", "end");
      var optimizedSegs = [];
      for (var i6 = 1; i6 < path.length - 1; i6++) {
        optimizedSegs.push(graph.table[path[i6]].node);
      }
      return exports2.fromArray(mergeSegments(optimizedSegs));
    };
    exports2.rawSplit = function rawSplit(data) {
      return exports2.fromArray(
        getSegmentsFromString(data, Utils.isKanjiModeEnabled())
      );
    };
  }
});

// node_modules/qrcode/lib/core/qrcode.js
var require_qrcode = __commonJS({
  "node_modules/qrcode/lib/core/qrcode.js"(exports2) {
    var BufferUtil = require_typedarray_buffer();
    var Utils = require_utils5();
    var ECLevel = require_error_correction_level();
    var BitBuffer = require_bit_buffer();
    var BitMatrix = require_bit_matrix();
    var AlignmentPattern = require_alignment_pattern();
    var FinderPattern = require_finder_pattern();
    var MaskPattern = require_mask_pattern();
    var ECCode = require_error_correction_code();
    var ReedSolomonEncoder = require_reed_solomon_encoder();
    var Version = require_version2();
    var FormatInfo = require_format_info();
    var Mode = require_mode();
    var Segments = require_segments();
    var isArray2 = require_isarray();
    function setupFinderPattern(matrix, version27) {
      var size = matrix.size;
      var pos = FinderPattern.getPositions(version27);
      for (var i6 = 0; i6 < pos.length; i6++) {
        var row = pos[i6][0];
        var col = pos[i6][1];
        for (var r6 = -1; r6 <= 7; r6++) {
          if (row + r6 <= -1 || size <= row + r6)
            continue;
          for (var c5 = -1; c5 <= 7; c5++) {
            if (col + c5 <= -1 || size <= col + c5)
              continue;
            if (r6 >= 0 && r6 <= 6 && (c5 === 0 || c5 === 6) || c5 >= 0 && c5 <= 6 && (r6 === 0 || r6 === 6) || r6 >= 2 && r6 <= 4 && c5 >= 2 && c5 <= 4) {
              matrix.set(row + r6, col + c5, true, true);
            } else {
              matrix.set(row + r6, col + c5, false, true);
            }
          }
        }
      }
    }
    function setupTimingPattern(matrix) {
      var size = matrix.size;
      for (var r6 = 8; r6 < size - 8; r6++) {
        var value2 = r6 % 2 === 0;
        matrix.set(r6, 6, value2, true);
        matrix.set(6, r6, value2, true);
      }
    }
    function setupAlignmentPattern(matrix, version27) {
      var pos = AlignmentPattern.getPositions(version27);
      for (var i6 = 0; i6 < pos.length; i6++) {
        var row = pos[i6][0];
        var col = pos[i6][1];
        for (var r6 = -2; r6 <= 2; r6++) {
          for (var c5 = -2; c5 <= 2; c5++) {
            if (r6 === -2 || r6 === 2 || c5 === -2 || c5 === 2 || r6 === 0 && c5 === 0) {
              matrix.set(row + r6, col + c5, true, true);
            } else {
              matrix.set(row + r6, col + c5, false, true);
            }
          }
        }
      }
    }
    function setupVersionInfo(matrix, version27) {
      var size = matrix.size;
      var bits = Version.getEncodedBits(version27);
      var row, col, mod2;
      for (var i6 = 0; i6 < 18; i6++) {
        row = Math.floor(i6 / 3);
        col = i6 % 3 + size - 8 - 3;
        mod2 = (bits >> i6 & 1) === 1;
        matrix.set(row, col, mod2, true);
        matrix.set(col, row, mod2, true);
      }
    }
    function setupFormatInfo(matrix, errorCorrectionLevel, maskPattern) {
      var size = matrix.size;
      var bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);
      var i6, mod2;
      for (i6 = 0; i6 < 15; i6++) {
        mod2 = (bits >> i6 & 1) === 1;
        if (i6 < 6) {
          matrix.set(i6, 8, mod2, true);
        } else if (i6 < 8) {
          matrix.set(i6 + 1, 8, mod2, true);
        } else {
          matrix.set(size - 15 + i6, 8, mod2, true);
        }
        if (i6 < 8) {
          matrix.set(8, size - i6 - 1, mod2, true);
        } else if (i6 < 9) {
          matrix.set(8, 15 - i6 - 1 + 1, mod2, true);
        } else {
          matrix.set(8, 15 - i6 - 1, mod2, true);
        }
      }
      matrix.set(size - 8, 8, 1, true);
    }
    function setupData(matrix, data) {
      var size = matrix.size;
      var inc = -1;
      var row = size - 1;
      var bitIndex = 7;
      var byteIndex = 0;
      for (var col = size - 1; col > 0; col -= 2) {
        if (col === 6)
          col--;
        while (true) {
          for (var c5 = 0; c5 < 2; c5++) {
            if (!matrix.isReserved(row, col - c5)) {
              var dark = false;
              if (byteIndex < data.length) {
                dark = (data[byteIndex] >>> bitIndex & 1) === 1;
              }
              matrix.set(row, col - c5, dark);
              bitIndex--;
              if (bitIndex === -1) {
                byteIndex++;
                bitIndex = 7;
              }
            }
          }
          row += inc;
          if (row < 0 || size <= row) {
            row -= inc;
            inc = -inc;
            break;
          }
        }
      }
    }
    function createData(version27, errorCorrectionLevel, segments) {
      var buffer2 = new BitBuffer();
      segments.forEach(function(data) {
        buffer2.put(data.mode.bit, 4);
        buffer2.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version27));
        data.write(buffer2);
      });
      var totalCodewords = Utils.getSymbolTotalCodewords(version27);
      var ecTotalCodewords = ECCode.getTotalCodewordsCount(version27, errorCorrectionLevel);
      var dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (buffer2.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
        buffer2.put(0, 4);
      }
      while (buffer2.getLengthInBits() % 8 !== 0) {
        buffer2.putBit(0);
      }
      var remainingByte = (dataTotalCodewordsBits - buffer2.getLengthInBits()) / 8;
      for (var i6 = 0; i6 < remainingByte; i6++) {
        buffer2.put(i6 % 2 ? 17 : 236, 8);
      }
      return createCodewords(buffer2, version27, errorCorrectionLevel);
    }
    function createCodewords(bitBuffer, version27, errorCorrectionLevel) {
      var totalCodewords = Utils.getSymbolTotalCodewords(version27);
      var ecTotalCodewords = ECCode.getTotalCodewordsCount(version27, errorCorrectionLevel);
      var dataTotalCodewords = totalCodewords - ecTotalCodewords;
      var ecTotalBlocks = ECCode.getBlocksCount(version27, errorCorrectionLevel);
      var blocksInGroup2 = totalCodewords % ecTotalBlocks;
      var blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
      var totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
      var dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
      var dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
      var ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
      var rs = new ReedSolomonEncoder(ecCount);
      var offset = 0;
      var dcData = new Array(ecTotalBlocks);
      var ecData = new Array(ecTotalBlocks);
      var maxDataSize = 0;
      var buffer2 = BufferUtil.from(bitBuffer.buffer);
      for (var b4 = 0; b4 < ecTotalBlocks; b4++) {
        var dataSize = b4 < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
        dcData[b4] = buffer2.slice(offset, offset + dataSize);
        ecData[b4] = rs.encode(dcData[b4]);
        offset += dataSize;
        maxDataSize = Math.max(maxDataSize, dataSize);
      }
      var data = BufferUtil.alloc(totalCodewords);
      var index = 0;
      var i6, r6;
      for (i6 = 0; i6 < maxDataSize; i6++) {
        for (r6 = 0; r6 < ecTotalBlocks; r6++) {
          if (i6 < dcData[r6].length) {
            data[index++] = dcData[r6][i6];
          }
        }
      }
      for (i6 = 0; i6 < ecCount; i6++) {
        for (r6 = 0; r6 < ecTotalBlocks; r6++) {
          data[index++] = ecData[r6][i6];
        }
      }
      return data;
    }
    function createSymbol(data, version27, errorCorrectionLevel, maskPattern) {
      var segments;
      if (isArray2(data)) {
        segments = Segments.fromArray(data);
      } else if (typeof data === "string") {
        var estimatedVersion = version27;
        if (!estimatedVersion) {
          var rawSegments = Segments.rawSplit(data);
          estimatedVersion = Version.getBestVersionForData(
            rawSegments,
            errorCorrectionLevel
          );
        }
        segments = Segments.fromString(data, estimatedVersion || 40);
      } else {
        throw new Error("Invalid data");
      }
      var bestVersion = Version.getBestVersionForData(
        segments,
        errorCorrectionLevel
      );
      if (!bestVersion) {
        throw new Error("The amount of data is too big to be stored in a QR Code");
      }
      if (!version27) {
        version27 = bestVersion;
      } else if (version27 < bestVersion) {
        throw new Error(
          "\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + bestVersion + ".\n"
        );
      }
      var dataBits = createData(version27, errorCorrectionLevel, segments);
      var moduleCount = Utils.getSymbolSize(version27);
      var modules = new BitMatrix(moduleCount);
      setupFinderPattern(modules, version27);
      setupTimingPattern(modules);
      setupAlignmentPattern(modules, version27);
      setupFormatInfo(modules, errorCorrectionLevel, 0);
      if (version27 >= 7) {
        setupVersionInfo(modules, version27);
      }
      setupData(modules, dataBits);
      if (isNaN(maskPattern)) {
        maskPattern = MaskPattern.getBestMask(
          modules,
          setupFormatInfo.bind(null, modules, errorCorrectionLevel)
        );
      }
      MaskPattern.applyMask(maskPattern, modules);
      setupFormatInfo(modules, errorCorrectionLevel, maskPattern);
      return {
        modules,
        version: version27,
        errorCorrectionLevel,
        maskPattern,
        segments
      };
    }
    exports2.create = function create(data, options) {
      if (typeof data === "undefined" || data === "") {
        throw new Error("No input text");
      }
      var errorCorrectionLevel = ECLevel.M;
      var version27;
      var mask;
      if (typeof options !== "undefined") {
        errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
        version27 = Version.from(options.version);
        mask = MaskPattern.from(options.maskPattern);
        if (options.toSJISFunc) {
          Utils.setToSJISFunction(options.toSJISFunc);
        }
      }
      return createSymbol(data, version27, errorCorrectionLevel, mask);
    };
  }
});

// node_modules/qrcode/lib/renderer/utils.js
var require_utils6 = __commonJS({
  "node_modules/qrcode/lib/renderer/utils.js"(exports2) {
    function hex2rgba(hex) {
      if (typeof hex === "number") {
        hex = hex.toString();
      }
      if (typeof hex !== "string") {
        throw new Error("Color should be defined as hex string");
      }
      var hexCode = hex.slice().replace("#", "").split("");
      if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
        throw new Error("Invalid hex color: " + hex);
      }
      if (hexCode.length === 3 || hexCode.length === 4) {
        hexCode = Array.prototype.concat.apply([], hexCode.map(function(c5) {
          return [c5, c5];
        }));
      }
      if (hexCode.length === 6)
        hexCode.push("F", "F");
      var hexValue5 = parseInt(hexCode.join(""), 16);
      return {
        r: hexValue5 >> 24 & 255,
        g: hexValue5 >> 16 & 255,
        b: hexValue5 >> 8 & 255,
        a: hexValue5 & 255,
        hex: "#" + hexCode.slice(0, 6).join("")
      };
    }
    exports2.getOptions = function getOptions(options) {
      if (!options)
        options = {};
      if (!options.color)
        options.color = {};
      var margin = typeof options.margin === "undefined" || options.margin === null || options.margin < 0 ? 4 : options.margin;
      var width = options.width && options.width >= 21 ? options.width : void 0;
      var scale = options.scale || 4;
      return {
        width,
        scale: width ? 4 : scale,
        margin,
        color: {
          dark: hex2rgba(options.color.dark || "#000000ff"),
          light: hex2rgba(options.color.light || "#ffffffff")
        },
        type: options.type,
        rendererOpts: options.rendererOpts || {}
      };
    };
    exports2.getScale = function getScale(qrSize, opts) {
      return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;
    };
    exports2.getImageWidth = function getImageWidth(qrSize, opts) {
      var scale = exports2.getScale(qrSize, opts);
      return Math.floor((qrSize + opts.margin * 2) * scale);
    };
    exports2.qrToImageData = function qrToImageData(imgData, qr2, opts) {
      var size = qr2.modules.size;
      var data = qr2.modules.data;
      var scale = exports2.getScale(size, opts);
      var symbolSize = Math.floor((size + opts.margin * 2) * scale);
      var scaledMargin = opts.margin * scale;
      var palette = [opts.color.light, opts.color.dark];
      for (var i6 = 0; i6 < symbolSize; i6++) {
        for (var j8 = 0; j8 < symbolSize; j8++) {
          var posDst = (i6 * symbolSize + j8) * 4;
          var pxColor = opts.color.light;
          if (i6 >= scaledMargin && j8 >= scaledMargin && i6 < symbolSize - scaledMargin && j8 < symbolSize - scaledMargin) {
            var iSrc = Math.floor((i6 - scaledMargin) / scale);
            var jSrc = Math.floor((j8 - scaledMargin) / scale);
            pxColor = palette[data[iSrc * size + jSrc] ? 1 : 0];
          }
          imgData[posDst++] = pxColor.r;
          imgData[posDst++] = pxColor.g;
          imgData[posDst++] = pxColor.b;
          imgData[posDst] = pxColor.a;
        }
      }
    };
  }
});

// node_modules/qrcode/lib/renderer/canvas.js
var require_canvas = __commonJS({
  "node_modules/qrcode/lib/renderer/canvas.js"(exports2) {
    var Utils = require_utils6();
    function clearCanvas(ctx, canvas, size) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (!canvas.style)
        canvas.style = {};
      canvas.height = size;
      canvas.width = size;
      canvas.style.height = size + "px";
      canvas.style.width = size + "px";
    }
    function getCanvasElement() {
      try {
        return document.createElement("canvas");
      } catch (e6) {
        throw new Error("You need to specify a canvas element");
      }
    }
    exports2.render = function render(qrData, canvas, options) {
      var opts = options;
      var canvasEl = canvas;
      if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = void 0;
      }
      if (!canvas) {
        canvasEl = getCanvasElement();
      }
      opts = Utils.getOptions(opts);
      var size = Utils.getImageWidth(qrData.modules.size, opts);
      var ctx = canvasEl.getContext("2d");
      var image = ctx.createImageData(size, size);
      Utils.qrToImageData(image.data, qrData, opts);
      clearCanvas(ctx, canvasEl, size);
      ctx.putImageData(image, 0, 0);
      return canvasEl;
    };
    exports2.renderToDataURL = function renderToDataURL(qrData, canvas, options) {
      var opts = options;
      if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = void 0;
      }
      if (!opts)
        opts = {};
      var canvasEl = exports2.render(qrData, canvas, opts);
      var type = opts.type || "image/png";
      var rendererOpts = opts.rendererOpts || {};
      return canvasEl.toDataURL(type, rendererOpts.quality);
    };
  }
});

// node_modules/qrcode/lib/renderer/svg-tag.js
var require_svg_tag = __commonJS({
  "node_modules/qrcode/lib/renderer/svg-tag.js"(exports2) {
    var Utils = require_utils6();
    function getColorAttrib(color, attrib) {
      var alpha = color.a / 255;
      var str = attrib + '="' + color.hex + '"';
      return alpha < 1 ? str + " " + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"' : str;
    }
    function svgCmd(cmd, x6, y5) {
      var str = cmd + x6;
      if (typeof y5 !== "undefined")
        str += " " + y5;
      return str;
    }
    function qrToPath(data, size, margin) {
      var path = "";
      var moveBy = 0;
      var newRow = false;
      var lineLength = 0;
      for (var i6 = 0; i6 < data.length; i6++) {
        var col = Math.floor(i6 % size);
        var row = Math.floor(i6 / size);
        if (!col && !newRow)
          newRow = true;
        if (data[i6]) {
          lineLength++;
          if (!(i6 > 0 && col > 0 && data[i6 - 1])) {
            path += newRow ? svgCmd("M", col + margin, 0.5 + row + margin) : svgCmd("m", moveBy, 0);
            moveBy = 0;
            newRow = false;
          }
          if (!(col + 1 < size && data[i6 + 1])) {
            path += svgCmd("h", lineLength);
            lineLength = 0;
          }
        } else {
          moveBy++;
        }
      }
      return path;
    }
    exports2.render = function render(qrData, options, cb) {
      var opts = Utils.getOptions(options);
      var size = qrData.modules.size;
      var data = qrData.modules.data;
      var qrcodesize = size + opts.margin * 2;
      var bg = !opts.color.light.a ? "" : "<path " + getColorAttrib(opts.color.light, "fill") + ' d="M0 0h' + qrcodesize + "v" + qrcodesize + 'H0z"/>';
      var path = "<path " + getColorAttrib(opts.color.dark, "stroke") + ' d="' + qrToPath(data, size, opts.margin) + '"/>';
      var viewBox = 'viewBox="0 0 ' + qrcodesize + " " + qrcodesize + '"';
      var width = !opts.width ? "" : 'width="' + opts.width + '" height="' + opts.width + '" ';
      var svgTag = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path + "</svg>\n";
      if (typeof cb === "function") {
        cb(null, svgTag);
      }
      return svgTag;
    };
  }
});

// node_modules/qrcode/lib/browser.js
var require_browser3 = __commonJS({
  "node_modules/qrcode/lib/browser.js"(exports2) {
    var canPromise = require_can_promise();
    var QRCode = require_qrcode();
    var CanvasRenderer = require_canvas();
    var SvgRenderer = require_svg_tag();
    function renderCanvas(renderFunc, canvas, text, opts, cb) {
      var args = [].slice.call(arguments, 1);
      var argsNum = args.length;
      var isLastArgCb = typeof args[argsNum - 1] === "function";
      if (!isLastArgCb && !canPromise()) {
        throw new Error("Callback required as last argument");
      }
      if (isLastArgCb) {
        if (argsNum < 2) {
          throw new Error("Too few arguments provided");
        }
        if (argsNum === 2) {
          cb = text;
          text = canvas;
          canvas = opts = void 0;
        } else if (argsNum === 3) {
          if (canvas.getContext && typeof cb === "undefined") {
            cb = opts;
            opts = void 0;
          } else {
            cb = opts;
            opts = text;
            text = canvas;
            canvas = void 0;
          }
        }
      } else {
        if (argsNum < 1) {
          throw new Error("Too few arguments provided");
        }
        if (argsNum === 1) {
          text = canvas;
          canvas = opts = void 0;
        } else if (argsNum === 2 && !canvas.getContext) {
          opts = text;
          text = canvas;
          canvas = void 0;
        }
        return new Promise(function(resolve, reject) {
          try {
            var data2 = QRCode.create(text, opts);
            resolve(renderFunc(data2, canvas, opts));
          } catch (e6) {
            reject(e6);
          }
        });
      }
      try {
        var data = QRCode.create(text, opts);
        cb(null, renderFunc(data, canvas, opts));
      } catch (e6) {
        cb(e6);
      }
    }
    exports2.create = QRCode.create;
    exports2.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
    exports2.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);
    exports2.toString = renderCanvas.bind(null, function(data, _8, opts) {
      return SvgRenderer.render(data, opts);
    });
  }
});

// node_modules/toggle-selection/index.js
var require_toggle_selection = __commonJS({
  "node_modules/toggle-selection/index.js"(exports2, module2) {
    module2.exports = function() {
      var selection = document.getSelection();
      if (!selection.rangeCount) {
        return function() {
        };
      }
      var active = document.activeElement;
      var ranges = [];
      for (var i6 = 0; i6 < selection.rangeCount; i6++) {
        ranges.push(selection.getRangeAt(i6));
      }
      switch (active.tagName.toUpperCase()) {
        case "INPUT":
        case "TEXTAREA":
          active.blur();
          break;
        default:
          active = null;
          break;
      }
      selection.removeAllRanges();
      return function() {
        selection.type === "Caret" && selection.removeAllRanges();
        if (!selection.rangeCount) {
          ranges.forEach(function(range2) {
            selection.addRange(range2);
          });
        }
        active && active.focus();
      };
    };
  }
});

// node_modules/copy-to-clipboard/index.js
var require_copy_to_clipboard = __commonJS({
  "node_modules/copy-to-clipboard/index.js"(exports2, module2) {
    "use strict";
    var deselectCurrent = require_toggle_selection();
    var clipboardToIE11Formatting = {
      "text/plain": "Text",
      "text/html": "Url",
      "default": "Text"
    };
    var defaultMessage = "Copy to clipboard: #{key}, Enter";
    function format(message) {
      var copyKey = (/mac os x/i.test(navigator.userAgent) ? "\u2318" : "Ctrl") + "+C";
      return message.replace(/#{\s*key\s*}/g, copyKey);
    }
    function copy(text, options) {
      var debug, message, reselectPrevious, range2, selection, mark, success = false;
      if (!options) {
        options = {};
      }
      debug = options.debug || false;
      try {
        reselectPrevious = deselectCurrent();
        range2 = document.createRange();
        selection = document.getSelection();
        mark = document.createElement("span");
        mark.textContent = text;
        mark.style.all = "unset";
        mark.style.position = "fixed";
        mark.style.top = 0;
        mark.style.clip = "rect(0, 0, 0, 0)";
        mark.style.whiteSpace = "pre";
        mark.style.webkitUserSelect = "text";
        mark.style.MozUserSelect = "text";
        mark.style.msUserSelect = "text";
        mark.style.userSelect = "text";
        mark.addEventListener("copy", function(e6) {
          e6.stopPropagation();
          if (options.format) {
            e6.preventDefault();
            if (typeof e6.clipboardData === "undefined") {
              debug && console.warn("unable to use e.clipboardData");
              debug && console.warn("trying IE specific stuff");
              window.clipboardData.clearData();
              var format2 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
              window.clipboardData.setData(format2, text);
            } else {
              e6.clipboardData.clearData();
              e6.clipboardData.setData(options.format, text);
            }
          }
          if (options.onCopy) {
            e6.preventDefault();
            options.onCopy(e6.clipboardData);
          }
        });
        document.body.appendChild(mark);
        range2.selectNodeContents(mark);
        selection.addRange(range2);
        var successful = document.execCommand("copy");
        if (!successful) {
          throw new Error("copy command was unsuccessful");
        }
        success = true;
      } catch (err) {
        debug && console.error("unable to copy using execCommand: ", err);
        debug && console.warn("trying IE specific stuff");
        try {
          window.clipboardData.setData(options.format || "text", text);
          options.onCopy && options.onCopy(window.clipboardData);
          success = true;
        } catch (err2) {
          debug && console.error("unable to copy using clipboardData: ", err2);
          debug && console.error("falling back to prompt");
          message = format("message" in options ? options.message : defaultMessage);
          window.prompt(message, text);
        }
      } finally {
        if (selection) {
          if (typeof selection.removeRange == "function") {
            selection.removeRange(range2);
          } else {
            selection.removeAllRanges();
          }
        }
        if (mark) {
          document.body.removeChild(mark);
        }
        reselectPrevious();
      }
      return success;
    }
    module2.exports = copy;
  }
});

// node_modules/@walletconnect/qrcode-modal/node_modules/preact/dist/preact.module.js
function a3(n4, l6) {
  for (var u7 in l6)
    n4[u7] = l6[u7];
  return n4;
}
function v7(n4) {
  var l6 = n4.parentNode;
  l6 && l6.removeChild(n4);
}
function h4(n4, l6, u7) {
  var i6, t6 = arguments, r6 = {};
  for (i6 in l6)
    "key" !== i6 && "ref" !== i6 && (r6[i6] = l6[i6]);
  if (arguments.length > 3)
    for (u7 = [u7], i6 = 3; i6 < arguments.length; i6++)
      u7.push(t6[i6]);
  if (null != u7 && (r6.children = u7), "function" == typeof n4 && null != n4.defaultProps)
    for (i6 in n4.defaultProps)
      void 0 === r6[i6] && (r6[i6] = n4.defaultProps[i6]);
  return p5(n4, r6, l6 && l6.key, l6 && l6.ref, null);
}
function p5(l6, u7, i6, t6, r6) {
  var o6 = { type: l6, props: u7, key: i6, ref: t6, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: r6 };
  return null == r6 && (o6.__v = o6), n3.vnode && n3.vnode(o6), o6;
}
function y3() {
  return {};
}
function d3(n4) {
  return n4.children;
}
function m4(n4, l6) {
  this.props = n4, this.context = l6;
}
function w4(n4, l6) {
  if (null == l6)
    return n4.__ ? w4(n4.__, n4.__.__k.indexOf(n4) + 1) : null;
  for (var u7; l6 < n4.__k.length; l6++)
    if (null != (u7 = n4.__k[l6]) && null != u7.__e)
      return u7.__e;
  return "function" == typeof n4.type ? w4(n4) : null;
}
function k5(n4) {
  var l6, u7;
  if (null != (n4 = n4.__) && null != n4.__c) {
    for (n4.__e = n4.__c.base = null, l6 = 0; l6 < n4.__k.length; l6++)
      if (null != (u7 = n4.__k[l6]) && null != u7.__e) {
        n4.__e = n4.__c.base = u7.__e;
        break;
      }
    return k5(n4);
  }
}
function g5(l6) {
  (!l6.__d && (l6.__d = true) && u4.push(l6) && !i4++ || r4 !== n3.debounceRendering) && ((r4 = n3.debounceRendering) || t4)(_4);
}
function _4() {
  for (var n4; i4 = u4.length; )
    n4 = u4.sort(function(n5, l6) {
      return n5.__v.__b - l6.__v.__b;
    }), u4 = [], n4.some(function(n5) {
      var l6, u7, i6, t6, r6, o6, f7;
      n5.__d && (o6 = (r6 = (l6 = n5).__v).__e, (f7 = l6.__P) && (u7 = [], (i6 = a3({}, r6)).__v = i6, t6 = A4(f7, r6, i6, l6.__n, void 0 !== f7.ownerSVGElement, null, u7, null == o6 ? w4(r6) : o6), T4(u7, r6), t6 != o6 && k5(r6)));
    });
}
function b3(n4, l6, u7, i6, t6, r6, o6, f7, s6) {
  var a5, h6, p7, y5, d6, m6, k8, g7 = u7 && u7.__k || c3, _8 = g7.length;
  if (f7 == e4 && (f7 = null != r6 ? r6[0] : _8 ? w4(u7, 0) : null), a5 = 0, l6.__k = x4(l6.__k, function(u8) {
    if (null != u8) {
      if (u8.__ = l6, u8.__b = l6.__b + 1, null === (p7 = g7[a5]) || p7 && u8.key == p7.key && u8.type === p7.type)
        g7[a5] = void 0;
      else
        for (h6 = 0; h6 < _8; h6++) {
          if ((p7 = g7[h6]) && u8.key == p7.key && u8.type === p7.type) {
            g7[h6] = void 0;
            break;
          }
          p7 = null;
        }
      if (y5 = A4(n4, u8, p7 = p7 || e4, i6, t6, r6, o6, f7, s6), (h6 = u8.ref) && p7.ref != h6 && (k8 || (k8 = []), p7.ref && k8.push(p7.ref, null, u8), k8.push(h6, u8.__c || y5, u8)), null != y5) {
        var c5;
        if (null == m6 && (m6 = y5), void 0 !== u8.__d)
          c5 = u8.__d, u8.__d = void 0;
        else if (r6 == p7 || y5 != f7 || null == y5.parentNode) {
          n:
            if (null == f7 || f7.parentNode !== n4)
              n4.appendChild(y5), c5 = null;
            else {
              for (d6 = f7, h6 = 0; (d6 = d6.nextSibling) && h6 < _8; h6 += 2)
                if (d6 == y5)
                  break n;
              n4.insertBefore(y5, f7), c5 = f7;
            }
          "option" == l6.type && (n4.value = "");
        }
        f7 = void 0 !== c5 ? c5 : y5.nextSibling, "function" == typeof l6.type && (l6.__d = f7);
      } else
        f7 && p7.__e == f7 && f7.parentNode != n4 && (f7 = w4(p7));
    }
    return a5++, u8;
  }), l6.__e = m6, null != r6 && "function" != typeof l6.type)
    for (a5 = r6.length; a5--; )
      null != r6[a5] && v7(r6[a5]);
  for (a5 = _8; a5--; )
    null != g7[a5] && D3(g7[a5], g7[a5]);
  if (k8)
    for (a5 = 0; a5 < k8.length; a5++)
      j5(k8[a5], k8[++a5], k8[++a5]);
}
function x4(n4, l6, u7) {
  if (null == u7 && (u7 = []), null == n4 || "boolean" == typeof n4)
    l6 && u7.push(l6(null));
  else if (Array.isArray(n4))
    for (var i6 = 0; i6 < n4.length; i6++)
      x4(n4[i6], l6, u7);
  else
    u7.push(l6 ? l6("string" == typeof n4 || "number" == typeof n4 ? p5(null, n4, null, null, n4) : null != n4.__e || null != n4.__c ? p5(n4.type, n4.props, n4.key, null, n4.__v) : n4) : n4);
  return u7;
}
function P3(n4, l6, u7, i6, t6) {
  var r6;
  for (r6 in u7)
    "children" === r6 || "key" === r6 || r6 in l6 || N4(n4, r6, null, u7[r6], i6);
  for (r6 in l6)
    t6 && "function" != typeof l6[r6] || "children" === r6 || "key" === r6 || "value" === r6 || "checked" === r6 || u7[r6] === l6[r6] || N4(n4, r6, l6[r6], u7[r6], i6);
}
function C2(n4, l6, u7) {
  "-" === l6[0] ? n4.setProperty(l6, u7) : n4[l6] = "number" == typeof u7 && false === s4.test(l6) ? u7 + "px" : null == u7 ? "" : u7;
}
function N4(n4, l6, u7, i6, t6) {
  var r6, o6, f7, e6, c5;
  if (t6 ? "className" === l6 && (l6 = "class") : "class" === l6 && (l6 = "className"), "style" === l6)
    if (r6 = n4.style, "string" == typeof u7)
      r6.cssText = u7;
    else {
      if ("string" == typeof i6 && (r6.cssText = "", i6 = null), i6)
        for (e6 in i6)
          u7 && e6 in u7 || C2(r6, e6, "");
      if (u7)
        for (c5 in u7)
          i6 && u7[c5] === i6[c5] || C2(r6, c5, u7[c5]);
    }
  else
    "o" === l6[0] && "n" === l6[1] ? (o6 = l6 !== (l6 = l6.replace(/Capture$/, "")), f7 = l6.toLowerCase(), l6 = (f7 in n4 ? f7 : l6).slice(2), u7 ? (i6 || n4.addEventListener(l6, z4, o6), (n4.l || (n4.l = {}))[l6] = u7) : n4.removeEventListener(l6, z4, o6)) : "list" !== l6 && "tagName" !== l6 && "form" !== l6 && "type" !== l6 && "size" !== l6 && !t6 && l6 in n4 ? n4[l6] = null == u7 ? "" : u7 : "function" != typeof u7 && "dangerouslySetInnerHTML" !== l6 && (l6 !== (l6 = l6.replace(/^xlink:?/, "")) ? null == u7 || false === u7 ? n4.removeAttributeNS("http://www.w3.org/1999/xlink", l6.toLowerCase()) : n4.setAttributeNS("http://www.w3.org/1999/xlink", l6.toLowerCase(), u7) : null == u7 || false === u7 && !/^ar/.test(l6) ? n4.removeAttribute(l6) : n4.setAttribute(l6, u7));
}
function z4(l6) {
  this.l[l6.type](n3.event ? n3.event(l6) : l6);
}
function A4(l6, u7, i6, t6, r6, o6, f7, e6, c5) {
  var s6, v9, h6, p7, y5, w8, k8, g7, _8, x6, P5 = u7.type;
  if (void 0 !== u7.constructor)
    return null;
  (s6 = n3.__b) && s6(u7);
  try {
    n:
      if ("function" == typeof P5) {
        if (g7 = u7.props, _8 = (s6 = P5.contextType) && t6[s6.__c], x6 = s6 ? _8 ? _8.props.value : s6.__ : t6, i6.__c ? k8 = (v9 = u7.__c = i6.__c).__ = v9.__E : ("prototype" in P5 && P5.prototype.render ? u7.__c = v9 = new P5(g7, x6) : (u7.__c = v9 = new m4(g7, x6), v9.constructor = P5, v9.render = E2), _8 && _8.sub(v9), v9.props = g7, v9.state || (v9.state = {}), v9.context = x6, v9.__n = t6, h6 = v9.__d = true, v9.__h = []), null == v9.__s && (v9.__s = v9.state), null != P5.getDerivedStateFromProps && (v9.__s == v9.state && (v9.__s = a3({}, v9.__s)), a3(v9.__s, P5.getDerivedStateFromProps(g7, v9.__s))), p7 = v9.props, y5 = v9.state, h6)
          null == P5.getDerivedStateFromProps && null != v9.componentWillMount && v9.componentWillMount(), null != v9.componentDidMount && v9.__h.push(v9.componentDidMount);
        else {
          if (null == P5.getDerivedStateFromProps && g7 !== p7 && null != v9.componentWillReceiveProps && v9.componentWillReceiveProps(g7, x6), !v9.__e && null != v9.shouldComponentUpdate && false === v9.shouldComponentUpdate(g7, v9.__s, x6) || u7.__v === i6.__v && !v9.__) {
            for (v9.props = g7, v9.state = v9.__s, u7.__v !== i6.__v && (v9.__d = false), v9.__v = u7, u7.__e = i6.__e, u7.__k = i6.__k, v9.__h.length && f7.push(v9), s6 = 0; s6 < u7.__k.length; s6++)
              u7.__k[s6] && (u7.__k[s6].__ = u7);
            break n;
          }
          null != v9.componentWillUpdate && v9.componentWillUpdate(g7, v9.__s, x6), null != v9.componentDidUpdate && v9.__h.push(function() {
            v9.componentDidUpdate(p7, y5, w8);
          });
        }
        v9.context = x6, v9.props = g7, v9.state = v9.__s, (s6 = n3.__r) && s6(u7), v9.__d = false, v9.__v = u7, v9.__P = l6, s6 = v9.render(v9.props, v9.state, v9.context), u7.__k = null != s6 && s6.type == d3 && null == s6.key ? s6.props.children : Array.isArray(s6) ? s6 : [s6], null != v9.getChildContext && (t6 = a3(a3({}, t6), v9.getChildContext())), h6 || null == v9.getSnapshotBeforeUpdate || (w8 = v9.getSnapshotBeforeUpdate(p7, y5)), b3(l6, u7, i6, t6, r6, o6, f7, e6, c5), v9.base = u7.__e, v9.__h.length && f7.push(v9), k8 && (v9.__E = v9.__ = null), v9.__e = false;
      } else
        null == o6 && u7.__v === i6.__v ? (u7.__k = i6.__k, u7.__e = i6.__e) : u7.__e = $3(i6.__e, u7, i6, t6, r6, o6, f7, c5);
    (s6 = n3.diffed) && s6(u7);
  } catch (l7) {
    u7.__v = null, n3.__e(l7, u7, i6);
  }
  return u7.__e;
}
function T4(l6, u7) {
  n3.__c && n3.__c(u7, l6), l6.some(function(u8) {
    try {
      l6 = u8.__h, u8.__h = [], l6.some(function(n4) {
        n4.call(u8);
      });
    } catch (l7) {
      n3.__e(l7, u8.__v);
    }
  });
}
function $3(n4, l6, u7, i6, t6, r6, o6, f7) {
  var s6, a5, v9, h6, p7, y5 = u7.props, d6 = l6.props;
  if (t6 = "svg" === l6.type || t6, null != r6) {
    for (s6 = 0; s6 < r6.length; s6++)
      if (null != (a5 = r6[s6]) && ((null === l6.type ? 3 === a5.nodeType : a5.localName === l6.type) || n4 == a5)) {
        n4 = a5, r6[s6] = null;
        break;
      }
  }
  if (null == n4) {
    if (null === l6.type)
      return document.createTextNode(d6);
    n4 = t6 ? document.createElementNS("http://www.w3.org/2000/svg", l6.type) : document.createElement(l6.type, d6.is && { is: d6.is }), r6 = null, f7 = false;
  }
  if (null === l6.type)
    y5 !== d6 && n4.data != d6 && (n4.data = d6);
  else {
    if (null != r6 && (r6 = c3.slice.call(n4.childNodes)), v9 = (y5 = u7.props || e4).dangerouslySetInnerHTML, h6 = d6.dangerouslySetInnerHTML, !f7) {
      if (y5 === e4)
        for (y5 = {}, p7 = 0; p7 < n4.attributes.length; p7++)
          y5[n4.attributes[p7].name] = n4.attributes[p7].value;
      (h6 || v9) && (h6 && v9 && h6.__html == v9.__html || (n4.innerHTML = h6 && h6.__html || ""));
    }
    P3(n4, d6, y5, t6, f7), h6 ? l6.__k = [] : (l6.__k = l6.props.children, b3(n4, l6, u7, i6, "foreignObject" !== l6.type && t6, r6, o6, e4, f7)), f7 || ("value" in d6 && void 0 !== (s6 = d6.value) && s6 !== n4.value && N4(n4, "value", s6, y5.value, false), "checked" in d6 && void 0 !== (s6 = d6.checked) && s6 !== n4.checked && N4(n4, "checked", s6, y5.checked, false));
  }
  return n4;
}
function j5(l6, u7, i6) {
  try {
    "function" == typeof l6 ? l6(u7) : l6.current = u7;
  } catch (l7) {
    n3.__e(l7, i6);
  }
}
function D3(l6, u7, i6) {
  var t6, r6, o6;
  if (n3.unmount && n3.unmount(l6), (t6 = l6.ref) && (t6.current && t6.current !== l6.__e || j5(t6, null, u7)), i6 || "function" == typeof l6.type || (i6 = null != (r6 = l6.__e)), l6.__e = l6.__d = void 0, null != (t6 = l6.__c)) {
    if (t6.componentWillUnmount)
      try {
        t6.componentWillUnmount();
      } catch (l7) {
        n3.__e(l7, u7);
      }
    t6.base = t6.__P = null;
  }
  if (t6 = l6.__k)
    for (o6 = 0; o6 < t6.length; o6++)
      t6[o6] && D3(t6[o6], u7, i6);
  null != r6 && v7(r6);
}
function E2(n4, l6, u7) {
  return this.constructor(n4, u7);
}
function H3(l6, u7, i6) {
  var t6, r6, f7;
  n3.__ && n3.__(l6, u7), r6 = (t6 = i6 === o4) ? null : i6 && i6.__k || u7.__k, l6 = h4(d3, null, [l6]), f7 = [], A4(u7, (t6 ? u7 : i6 || u7).__k = l6, r6 || e4, e4, void 0 !== u7.ownerSVGElement, i6 && !t6 ? [i6] : r6 ? null : c3.slice.call(u7.childNodes), f7, i6 || e4, t6), T4(f7, l6);
}
function I3(n4, l6) {
  H3(n4, l6, o4);
}
function L3(n4, l6) {
  var u7, i6;
  for (i6 in l6 = a3(a3({}, n4.props), l6), arguments.length > 2 && (l6.children = c3.slice.call(arguments, 2)), u7 = {}, l6)
    "key" !== i6 && "ref" !== i6 && (u7[i6] = l6[i6]);
  return p5(n4.type, u7, l6.key || n4.key, l6.ref || n4.ref, null);
}
function M3(n4) {
  var l6 = {}, u7 = { __c: "__cC" + f5++, __: n4, Consumer: function(n5, l7) {
    return n5.children(l7);
  }, Provider: function(n5) {
    var i6, t6 = this;
    return this.getChildContext || (i6 = [], this.getChildContext = function() {
      return l6[u7.__c] = t6, l6;
    }, this.shouldComponentUpdate = function(n6) {
      t6.props.value !== n6.value && i6.some(function(l7) {
        l7.context = n6.value, g5(l7);
      });
    }, this.sub = function(n6) {
      i6.push(n6);
      var l7 = n6.componentWillUnmount;
      n6.componentWillUnmount = function() {
        i6.splice(i6.indexOf(n6), 1), l7 && l7.call(n6);
      };
    }), n5.children;
  } };
  return u7.Consumer.contextType = u7, u7.Provider.__ = u7, u7;
}
var n3, l4, u4, i4, t4, r4, o4, f5, e4, c3, s4;
var init_preact_module2 = __esm({
  "node_modules/@walletconnect/qrcode-modal/node_modules/preact/dist/preact.module.js"() {
    e4 = {};
    c3 = [];
    s4 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord/i;
    n3 = { __e: function(n4, l6) {
      for (var u7, i6; l6 = l6.__; )
        if ((u7 = l6.__c) && !u7.__)
          try {
            if (u7.constructor && null != u7.constructor.getDerivedStateFromError && (i6 = true, u7.setState(u7.constructor.getDerivedStateFromError(n4))), null != u7.componentDidCatch && (i6 = true, u7.componentDidCatch(n4)), i6)
              return g5(u7.__E = u7);
          } catch (l7) {
            n4 = l7;
          }
      throw n4;
    } }, l4 = function(n4) {
      return null != n4 && void 0 === n4.constructor;
    }, m4.prototype.setState = function(n4, l6) {
      var u7;
      u7 = this.__s !== this.state ? this.__s : this.__s = a3({}, this.state), "function" == typeof n4 && (n4 = n4(u7, this.props)), n4 && a3(u7, n4), null != n4 && this.__v && (l6 && this.__h.push(l6), g5(this));
    }, m4.prototype.forceUpdate = function(n4) {
      this.__v && (this.__e = true, n4 && this.__h.push(n4), g5(this));
    }, m4.prototype.render = d3, u4 = [], i4 = 0, t4 = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, o4 = e4, f5 = 0;
  }
});

// node_modules/@walletconnect/qrcode-modal/node_modules/preact/hooks/dist/hooks.module.js
function v8(t6, r6) {
  n3.__h && n3.__h(u5, t6, i5 || r6), i5 = 0;
  var o6 = u5.__H || (u5.__H = { __: [], __h: [] });
  return t6 >= o6.__.length && o6.__.push({}), o6.__[t6];
}
function m5(n4) {
  return i5 = 1, p6(E3, n4);
}
function p6(n4, r6, i6) {
  var o6 = v8(t5++, 2);
  return o6.__c || (o6.__c = u5, o6.__ = [i6 ? i6(r6) : E3(void 0, r6), function(t6) {
    var u7 = n4(o6.__[0], t6);
    o6.__[0] !== u7 && (o6.__[0] = u7, o6.__c.setState({}));
  }]), o6.__;
}
function l5(r6, i6) {
  var o6 = v8(t5++, 3);
  !n3.__s && x5(o6.__H, i6) && (o6.__ = r6, o6.__H = i6, u5.__H.__h.push(o6));
}
function y4(r6, i6) {
  var o6 = v8(t5++, 4);
  !n3.__s && x5(o6.__H, i6) && (o6.__ = r6, o6.__H = i6, u5.__h.push(o6));
}
function d4(n4) {
  return i5 = 5, h5(function() {
    return { current: n4 };
  }, []);
}
function s5(n4, t6, u7) {
  i5 = 6, y4(function() {
    "function" == typeof n4 ? n4(t6()) : n4 && (n4.current = t6());
  }, null == u7 ? u7 : u7.concat(n4));
}
function h5(n4, u7) {
  var r6 = v8(t5++, 7);
  return x5(r6.__H, u7) ? (r6.__H = u7, r6.__h = n4, r6.__ = n4()) : r6.__;
}
function T5(n4, t6) {
  return i5 = 8, h5(function() {
    return n4;
  }, t6);
}
function w5(n4) {
  var r6 = u5.context[n4.__c], i6 = v8(t5++, 9);
  return i6.__c = n4, r6 ? (null == i6.__ && (i6.__ = true, r6.sub(u5)), r6.props.value) : n4.__;
}
function A5(t6, u7) {
  n3.useDebugValue && n3.useDebugValue(u7 ? u7(t6) : t6);
}
function F2(n4) {
  var r6 = v8(t5++, 10), i6 = m5();
  return r6.__ = n4, u5.componentDidCatch || (u5.componentDidCatch = function(n5) {
    r6.__ && r6.__(n5), i6[1](n5);
  }), [i6[0], function() {
    i6[1](void 0);
  }];
}
function _5() {
  o5.some(function(t6) {
    if (t6.__P)
      try {
        t6.__H.__h.forEach(g6), t6.__H.__h.forEach(q5), t6.__H.__h = [];
      } catch (u7) {
        return t6.__H.__h = [], n3.__e(u7, t6.__v), true;
      }
  }), o5 = [];
}
function g6(n4) {
  n4.t && n4.t();
}
function q5(n4) {
  var t6 = n4.__();
  "function" == typeof t6 && (n4.t = t6);
}
function x5(n4, t6) {
  return !n4 || t6.some(function(t7, u7) {
    return t7 !== n4[u7];
  });
}
function E3(n4, t6) {
  return "function" == typeof t6 ? t6(n4) : t6;
}
var t5, u5, r5, i5, o5, c4, f6, e5, a4;
var init_hooks_module2 = __esm({
  "node_modules/@walletconnect/qrcode-modal/node_modules/preact/hooks/dist/hooks.module.js"() {
    init_preact_module2();
    i5 = 0;
    o5 = [];
    c4 = n3.__r;
    f6 = n3.diffed;
    e5 = n3.__c;
    a4 = n3.unmount;
    n3.__r = function(n4) {
      c4 && c4(n4), t5 = 0, (u5 = n4.__c).__H && (u5.__H.__h.forEach(g6), u5.__H.__h.forEach(q5), u5.__H.__h = []);
    }, n3.diffed = function(t6) {
      f6 && f6(t6);
      var u7 = t6.__c;
      if (u7) {
        var i6 = u7.__H;
        i6 && i6.__h.length && (1 !== o5.push(u7) && r5 === n3.requestAnimationFrame || ((r5 = n3.requestAnimationFrame) || function(n4) {
          var t7, u8 = function() {
            clearTimeout(r6), cancelAnimationFrame(t7), setTimeout(n4);
          }, r6 = setTimeout(u8, 100);
          "undefined" != typeof window && (t7 = requestAnimationFrame(u8));
        })(_5));
      }
    }, n3.__c = function(t6, u7) {
      u7.some(function(t7) {
        try {
          t7.__h.forEach(g6), t7.__h = t7.__h.filter(function(n4) {
            return !n4.__ || q5(n4);
          });
        } catch (r6) {
          u7.some(function(n4) {
            n4.__h && (n4.__h = []);
          }), u7 = [], n3.__e(r6, t7.__v);
        }
      }), e5 && e5(t6, u7);
    }, n3.unmount = function(t6) {
      a4 && a4(t6);
      var u7 = t6.__c;
      if (u7) {
        var r6 = u7.__H;
        if (r6)
          try {
            r6.__.forEach(function(n4) {
              return n4.t && n4.t();
            });
          } catch (t7) {
            n3.__e(t7, u7.__v);
          }
      }
    };
  }
});

// node_modules/@walletconnect/qrcode-modal/node_modules/preact/compat/dist/compat.module.js
var compat_module_exports = {};
__export(compat_module_exports, {
  Children: () => R2,
  Component: () => m4,
  Fragment: () => d3,
  PureComponent: () => C3,
  Suspense: () => U2,
  SuspenseList: () => O3,
  cloneElement: () => K3,
  createContext: () => M3,
  createElement: () => h4,
  createFactory: () => G,
  createPortal: () => z5,
  createRef: () => y3,
  default: () => compat_module_default,
  findDOMNode: () => X2,
  forwardRef: () => S3,
  hydrate: () => V2,
  isValidElement: () => J2,
  lazy: () => L4,
  memo: () => _6,
  render: () => T6,
  unmountComponentAtNode: () => Q2,
  unstable_batchedUpdates: () => Y2,
  useCallback: () => T5,
  useContext: () => w5,
  useDebugValue: () => A5,
  useEffect: () => l5,
  useErrorBoundary: () => F2,
  useImperativeHandle: () => s5,
  useLayoutEffect: () => y4,
  useMemo: () => h5,
  useReducer: () => p6,
  useRef: () => d4,
  useState: () => m5,
  version: () => B3
});
function E4(n4, t6) {
  for (var e6 in t6)
    n4[e6] = t6[e6];
  return n4;
}
function w7(n4, t6) {
  for (var e6 in n4)
    if ("__source" !== e6 && !(e6 in t6))
      return true;
  for (var r6 in t6)
    if ("__source" !== r6 && n4[r6] !== t6[r6])
      return true;
  return false;
}
function _6(n4, t6) {
  function e6(n5) {
    var e7 = this.props.ref, r7 = e7 == n5.ref;
    return !r7 && e7 && (e7.call ? e7(null) : e7.current = null), t6 ? !t6(this.props, n5) || !r7 : w7(this.props, n5);
  }
  function r6(t7) {
    return this.shouldComponentUpdate = e6, h4(n4, E4({}, t7));
  }
  return r6.prototype.isReactComponent = true, r6.displayName = "Memo(" + (n4.displayName || n4.name) + ")", r6.t = true, r6;
}
function S3(n4) {
  function t6(t7) {
    var e6 = E4({}, t7);
    return delete e6.ref, n4(e6, t7.ref);
  }
  return t6.prototype.isReactComponent = t6.t = true, t6.displayName = "ForwardRef(" + (n4.displayName || n4.name) + ")", t6;
}
function N5(n4) {
  return n4 && ((n4 = E4({}, n4)).__c = null, n4.__k = n4.__k && n4.__k.map(N5)), n4;
}
function U2() {
  this.__u = 0, this.o = null, this.__b = null;
}
function M4(n4) {
  var t6 = n4.__.__c;
  return t6 && t6.u && t6.u(n4);
}
function L4(n4) {
  var t6, e6, r6;
  function o6(o7) {
    if (t6 || (t6 = n4()).then(function(n5) {
      e6 = n5.default || n5;
    }, function(n5) {
      r6 = n5;
    }), r6)
      throw r6;
    if (!e6)
      throw t6;
    return h4(e6, o7);
  }
  return o6.displayName = "Lazy", o6.t = true, o6;
}
function O3() {
  this.i = null, this.l = null;
}
function j6(n4) {
  var t6 = this, e6 = n4.container, r6 = h4(W2, { context: t6.context }, n4.vnode);
  return t6.s && t6.s !== e6 && (t6.v.parentNode && t6.s.removeChild(t6.v), D3(t6.h), t6.p = false), n4.vnode ? t6.p ? (e6.__k = t6.__k, H3(r6, e6), t6.__k = e6.__k) : (t6.v = document.createTextNode(""), I3("", e6), e6.appendChild(t6.v), t6.p = true, t6.s = e6, H3(r6, e6, t6.v), t6.__k = t6.v.__k) : t6.p && (t6.v.parentNode && t6.s.removeChild(t6.v), D3(t6.h)), t6.h = r6, t6.componentWillUnmount = function() {
    t6.v.parentNode && t6.s.removeChild(t6.v), D3(t6.h);
  }, null;
}
function z5(n4, t6) {
  return h4(j6, { vnode: n4, container: t6 });
}
function T6(n4, t6, e6) {
  if (null == t6.__k)
    for (; t6.firstChild; )
      t6.removeChild(t6.firstChild);
  return H3(n4, t6), "function" == typeof e6 && e6(), n4 ? n4.__c : null;
}
function V2(n4, t6, e6) {
  return I3(n4, t6), "function" == typeof e6 && e6(), n4 ? n4.__c : null;
}
function I4(n4, t6) {
  n4["UNSAFE_" + t6] && !n4[t6] && Object.defineProperty(n4, t6, { configurable: false, get: function() {
    return this["UNSAFE_" + t6];
  }, set: function(n5) {
    this["UNSAFE_" + t6] = n5;
  } });
}
function G(n4) {
  return h4.bind(null, n4);
}
function J2(n4) {
  return !!n4 && n4.$$typeof === H4;
}
function K3(n4) {
  return J2(n4) ? L3.apply(null, arguments) : n4;
}
function Q2(n4) {
  return !!n4.__k && (H3(null, n4), true);
}
function X2(n4) {
  return n4 && (n4.base || 1 === n4.nodeType && n4) || null;
}
var C3, A6, k6, R2, F3, P4, W2, D4, H4, Z2, $4, q6, B3, Y2, compat_module_default;
var init_compat_module = __esm({
  "node_modules/@walletconnect/qrcode-modal/node_modules/preact/compat/dist/compat.module.js"() {
    init_hooks_module2();
    init_hooks_module2();
    init_preact_module2();
    init_preact_module2();
    C3 = function(n4) {
      var t6, e6;
      function r6(t7) {
        var e7;
        return (e7 = n4.call(this, t7) || this).isPureReactComponent = true, e7;
      }
      return e6 = n4, (t6 = r6).prototype = Object.create(e6.prototype), t6.prototype.constructor = t6, t6.__proto__ = e6, r6.prototype.shouldComponentUpdate = function(n5, t7) {
        return w7(this.props, n5) || w7(this.state, t7);
      }, r6;
    }(m4);
    A6 = n3.__b;
    n3.__b = function(n4) {
      n4.type && n4.type.t && n4.ref && (n4.props.ref = n4.ref, n4.ref = null), A6 && A6(n4);
    };
    k6 = function(n4, t6) {
      return n4 ? x4(n4).reduce(function(n5, e6, r6) {
        return n5.concat(t6(e6, r6));
      }, []) : null;
    };
    R2 = { map: k6, forEach: k6, count: function(n4) {
      return n4 ? x4(n4).length : 0;
    }, only: function(n4) {
      if (1 !== (n4 = x4(n4)).length)
        throw new Error("Children.only() expects only one child.");
      return n4[0];
    }, toArray: x4 };
    F3 = n3.__e;
    n3.__e = function(n4, t6, e6) {
      if (n4.then) {
        for (var r6, o6 = t6; o6 = o6.__; )
          if ((r6 = o6.__c) && r6.__c)
            return r6.__c(n4, t6.__c);
      }
      F3(n4, t6, e6);
    }, (U2.prototype = new m4()).__c = function(n4, t6) {
      var e6 = this;
      null == e6.o && (e6.o = []), e6.o.push(t6);
      var r6 = M4(e6.__v), o6 = false, u7 = function() {
        o6 || (o6 = true, r6 ? r6(i6) : i6());
      };
      t6.__c = t6.componentWillUnmount, t6.componentWillUnmount = function() {
        u7(), t6.__c && t6.__c();
      };
      var i6 = function() {
        var n5;
        if (!--e6.__u)
          for (e6.__v.__k[0] = e6.state.u, e6.setState({ u: e6.__b = null }); n5 = e6.o.pop(); )
            n5.forceUpdate();
      };
      e6.__u++ || e6.setState({ u: e6.__b = e6.__v.__k[0] }), n4.then(u7, u7);
    }, U2.prototype.render = function(n4, t6) {
      return this.__b && (this.__v.__k[0] = N5(this.__b), this.__b = null), [h4(m4, null, t6.u ? null : n4.children), t6.u && n4.fallback];
    };
    P4 = function(n4, t6, e6) {
      if (++e6[1] === e6[0] && n4.l.delete(t6), n4.props.revealOrder && ("t" !== n4.props.revealOrder[0] || !n4.l.size))
        for (e6 = n4.i; e6; ) {
          for (; e6.length > 3; )
            e6.pop()();
          if (e6[1] < e6[0])
            break;
          n4.i = e6 = e6[2];
        }
    };
    (O3.prototype = new m4()).u = function(n4) {
      var t6 = this, e6 = M4(t6.__v), r6 = t6.l.get(n4);
      return r6[0]++, function(o6) {
        var u7 = function() {
          t6.props.revealOrder ? (r6.push(o6), P4(t6, n4, r6)) : o6();
        };
        e6 ? e6(u7) : u7();
      };
    }, O3.prototype.render = function(n4) {
      this.i = null, this.l = /* @__PURE__ */ new Map();
      var t6 = x4(n4.children);
      n4.revealOrder && "b" === n4.revealOrder[0] && t6.reverse();
      for (var e6 = t6.length; e6--; )
        this.l.set(t6[e6], this.i = [1, 0, this.i]);
      return n4.children;
    }, O3.prototype.componentDidUpdate = O3.prototype.componentDidMount = function() {
      var n4 = this;
      n4.l.forEach(function(t6, e6) {
        P4(n4, e6, t6);
      });
    };
    W2 = function() {
      function n4() {
      }
      var t6 = n4.prototype;
      return t6.getChildContext = function() {
        return this.props.context;
      }, t6.render = function(n5) {
        return n5.children;
      }, n4;
    }();
    D4 = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;
    m4.prototype.isReactComponent = {};
    H4 = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103;
    Z2 = n3.event;
    n3.event = function(n4) {
      Z2 && (n4 = Z2(n4)), n4.persist = function() {
      };
      var t6 = false, e6 = false, r6 = n4.stopPropagation;
      n4.stopPropagation = function() {
        r6.call(n4), t6 = true;
      };
      var o6 = n4.preventDefault;
      return n4.preventDefault = function() {
        o6.call(n4), e6 = true;
      }, n4.isPropagationStopped = function() {
        return t6;
      }, n4.isDefaultPrevented = function() {
        return e6;
      }, n4.nativeEvent = n4;
    };
    $4 = { configurable: true, get: function() {
      return this.class;
    } };
    q6 = n3.vnode;
    n3.vnode = function(n4) {
      n4.$$typeof = H4;
      var t6 = n4.type, e6 = n4.props;
      if (t6) {
        if (e6.class != e6.className && ($4.enumerable = "className" in e6, null != e6.className && (e6.class = e6.className), Object.defineProperty(e6, "className", $4)), "function" != typeof t6) {
          var r6, o6, u7;
          for (u7 in e6.defaultValue && void 0 !== e6.value && (e6.value || 0 === e6.value || (e6.value = e6.defaultValue), delete e6.defaultValue), Array.isArray(e6.value) && e6.multiple && "select" === t6 && (x4(e6.children).forEach(function(n5) {
            -1 != e6.value.indexOf(n5.props.value) && (n5.props.selected = true);
          }), delete e6.value), e6)
            if (r6 = D4.test(u7))
              break;
          if (r6)
            for (u7 in o6 = n4.props = {}, e6)
              o6[D4.test(u7) ? u7.replace(/[A-Z0-9]/, "-$&").toLowerCase() : u7] = e6[u7];
        }
        !function(t7) {
          var e7 = n4.type, r7 = n4.props;
          if (r7 && "string" == typeof e7) {
            var o7 = {};
            for (var u8 in r7)
              /^on(Ani|Tra|Tou)/.test(u8) && (r7[u8.toLowerCase()] = r7[u8], delete r7[u8]), o7[u8.toLowerCase()] = u8;
            if (o7.ondoubleclick && (r7.ondblclick = r7[o7.ondoubleclick], delete r7[o7.ondoubleclick]), o7.onbeforeinput && (r7.onbeforeinput = r7[o7.onbeforeinput], delete r7[o7.onbeforeinput]), o7.onchange && ("textarea" === e7 || "input" === e7.toLowerCase() && !/^fil|che|ra/i.test(r7.type))) {
              var i6 = o7.oninput || "oninput";
              r7[i6] || (r7[i6] = r7[o7.onchange], delete r7[o7.onchange]);
            }
          }
        }(), "function" == typeof t6 && !t6.m && t6.prototype && (I4(t6.prototype, "componentWillMount"), I4(t6.prototype, "componentWillReceiveProps"), I4(t6.prototype, "componentWillUpdate"), t6.m = true);
      }
      q6 && q6(n4);
    };
    B3 = "16.8.0";
    Y2 = function(n4, t6) {
      return n4(t6);
    };
    compat_module_default = { useState: m5, useReducer: p6, useEffect: l5, useLayoutEffect: y4, useRef: d4, useImperativeHandle: s5, useMemo: h5, useCallback: T5, useContext: w5, useDebugValue: A5, version: "16.8.0", Children: R2, render: T6, hydrate: T6, unmountComponentAtNode: Q2, createPortal: z5, createElement: h4, createContext: M3, createFactory: G, cloneElement: K3, createRef: y3, Fragment: d3, isValidElement: J2, findDOMNode: X2, Component: m4, PureComponent: C3, memo: _6, forwardRef: S3, unstable_batchedUpdates: Y2, Suspense: U2, SuspenseList: O3, lazy: L4 };
  }
});

// node_modules/@walletconnect/qrcode-modal/dist/cjs/index.js
var require_cjs4 = __commonJS({
  "node_modules/@walletconnect/qrcode-modal/dist/cjs/index.js"(exports2, module2) {
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var browserUtils = (init_esm2(), __toCommonJS(esm_exports3));
    var QRCode = _interopDefault(require_browser3());
    var copy = _interopDefault(require_copy_to_clipboard());
    var React11 = (init_compat_module(), __toCommonJS(compat_module_exports));
    function open(uri) {
      QRCode.toString(uri, {
        type: "terminal"
      }).then(console.log);
    }
    var WALLETCONNECT_STYLE_SHEET = ':root {\n  --animation-duration: 300ms;\n}\n\n@keyframes fadeIn {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n\n@keyframes fadeOut {\n  from {\n    opacity: 1;\n  }\n  to {\n    opacity: 0;\n  }\n}\n\n.animated {\n  animation-duration: var(--animation-duration);\n  animation-fill-mode: both;\n}\n\n.fadeIn {\n  animation-name: fadeIn;\n}\n\n.fadeOut {\n  animation-name: fadeOut;\n}\n\n#walletconnect-wrapper {\n  -webkit-user-select: none;\n  align-items: center;\n  display: flex;\n  height: 100%;\n  justify-content: center;\n  left: 0;\n  pointer-events: none;\n  position: fixed;\n  top: 0;\n  user-select: none;\n  width: 100%;\n  z-index: 99999999999999;\n}\n\n.walletconnect-modal__headerLogo {\n  height: 21px;\n}\n\n.walletconnect-modal__header p {\n  color: #ffffff;\n  font-size: 20px;\n  font-weight: 600;\n  margin: 0;\n  align-items: flex-start;\n  display: flex;\n  flex: 1;\n  margin-left: 5px;\n}\n\n.walletconnect-modal__close__wrapper {\n  position: absolute;\n  top: 0px;\n  right: 0px;\n  z-index: 10000;\n  background: white;\n  border-radius: 26px;\n  padding: 6px;\n  box-sizing: border-box;\n  width: 26px;\n  height: 26px;\n  cursor: pointer;\n}\n\n.walletconnect-modal__close__icon {\n  position: relative;\n  top: 7px;\n  right: 0;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  transform: rotate(45deg);\n}\n\n.walletconnect-modal__close__line1 {\n  position: absolute;\n  width: 100%;\n  border: 1px solid rgb(48, 52, 59);\n}\n\n.walletconnect-modal__close__line2 {\n  position: absolute;\n  width: 100%;\n  border: 1px solid rgb(48, 52, 59);\n  transform: rotate(90deg);\n}\n\n.walletconnect-qrcode__base {\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  background: rgba(37, 41, 46, 0.95);\n  height: 100%;\n  left: 0;\n  pointer-events: auto;\n  position: fixed;\n  top: 0;\n  transition: 0.4s cubic-bezier(0.19, 1, 0.22, 1);\n  width: 100%;\n  will-change: opacity;\n  padding: 40px;\n  box-sizing: border-box;\n}\n\n.walletconnect-qrcode__text {\n  color: rgba(60, 66, 82, 0.6);\n  font-size: 16px;\n  font-weight: 600;\n  letter-spacing: 0;\n  line-height: 1.1875em;\n  margin: 10px 0 20px 0;\n  text-align: center;\n  width: 100%;\n}\n\n@media only screen and (max-width: 768px) {\n  .walletconnect-qrcode__text {\n    font-size: 4vw;\n  }\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-qrcode__text {\n    font-size: 14px;\n  }\n}\n\n.walletconnect-qrcode__image {\n  width: calc(100% - 30px);\n  box-sizing: border-box;\n  cursor: none;\n  margin: 0 auto;\n}\n\n.walletconnect-qrcode__notification {\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  font-size: 16px;\n  padding: 16px 20px;\n  border-radius: 16px;\n  text-align: center;\n  transition: all 0.1s ease-in-out;\n  background: white;\n  color: black;\n  margin-bottom: -60px;\n  opacity: 0;\n}\n\n.walletconnect-qrcode__notification.notification__show {\n  opacity: 1;\n}\n\n@media only screen and (max-width: 768px) {\n  .walletconnect-modal__header {\n    height: 130px;\n  }\n  .walletconnect-modal__base {\n    overflow: auto;\n  }\n}\n\n@media only screen and (min-device-width: 415px) and (max-width: 768px) {\n  #content {\n    max-width: 768px;\n    box-sizing: border-box;\n  }\n}\n\n@media only screen and (min-width: 375px) and (max-width: 415px) {\n  #content {\n    max-width: 414px;\n    box-sizing: border-box;\n  }\n}\n\n@media only screen and (min-width: 320px) and (max-width: 375px) {\n  #content {\n    max-width: 375px;\n    box-sizing: border-box;\n  }\n}\n\n@media only screen and (max-width: 320px) {\n  #content {\n    max-width: 320px;\n    box-sizing: border-box;\n  }\n}\n\n.walletconnect-modal__base {\n  -webkit-font-smoothing: antialiased;\n  background: #ffffff;\n  border-radius: 24px;\n  box-shadow: 0 10px 50px 5px rgba(0, 0, 0, 0.4);\n  font-family: ui-rounded, "SF Pro Rounded", "SF Pro Text", medium-content-sans-serif-font,\n    -apple-system, BlinkMacSystemFont, ui-sans-serif, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell,\n    "Open Sans", "Helvetica Neue", sans-serif;\n  margin-top: 41px;\n  padding: 24px 24px 22px;\n  pointer-events: auto;\n  position: relative;\n  text-align: center;\n  transition: 0.4s cubic-bezier(0.19, 1, 0.22, 1);\n  will-change: transform;\n  overflow: visible;\n  transform: translateY(-50%);\n  top: 50%;\n  max-width: 500px;\n  margin: auto;\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-modal__base {\n    padding: 24px 12px;\n  }\n}\n\n.walletconnect-modal__base .hidden {\n  transform: translateY(150%);\n  transition: 0.125s cubic-bezier(0.4, 0, 1, 1);\n}\n\n.walletconnect-modal__header {\n  align-items: center;\n  display: flex;\n  height: 26px;\n  left: 0;\n  justify-content: space-between;\n  position: absolute;\n  top: -42px;\n  width: 100%;\n}\n\n.walletconnect-modal__base .wc-logo {\n  align-items: center;\n  display: flex;\n  height: 26px;\n  margin-top: 15px;\n  padding-bottom: 15px;\n  pointer-events: auto;\n}\n\n.walletconnect-modal__base .wc-logo div {\n  background-color: #3399ff;\n  height: 21px;\n  margin-right: 5px;\n  mask-image: url("images/wc-logo.svg") center no-repeat;\n  width: 32px;\n}\n\n.walletconnect-modal__base .wc-logo p {\n  color: #ffffff;\n  font-size: 20px;\n  font-weight: 600;\n  margin: 0;\n}\n\n.walletconnect-modal__base h2 {\n  color: rgba(60, 66, 82, 0.6);\n  font-size: 16px;\n  font-weight: 600;\n  letter-spacing: 0;\n  line-height: 1.1875em;\n  margin: 0 0 19px 0;\n  text-align: center;\n  width: 100%;\n}\n\n.walletconnect-modal__base__row {\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  align-items: center;\n  border-radius: 20px;\n  cursor: pointer;\n  display: flex;\n  height: 56px;\n  justify-content: space-between;\n  padding: 0 15px;\n  position: relative;\n  margin: 0px 0px 8px;\n  text-align: left;\n  transition: 0.15s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n  will-change: transform;\n  text-decoration: none;\n}\n\n.walletconnect-modal__base__row:hover {\n  background: rgba(60, 66, 82, 0.06);\n}\n\n.walletconnect-modal__base__row:active {\n  background: rgba(60, 66, 82, 0.06);\n  transform: scale(0.975);\n  transition: 0.1s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n}\n\n.walletconnect-modal__base__row__h3 {\n  color: #25292e;\n  font-size: 20px;\n  font-weight: 700;\n  margin: 0;\n  padding-bottom: 3px;\n}\n\n.walletconnect-modal__base__row__right {\n  align-items: center;\n  display: flex;\n  justify-content: center;\n}\n\n.walletconnect-modal__base__row__right__app-icon {\n  border-radius: 8px;\n  height: 34px;\n  margin: 0 11px 2px 0;\n  width: 34px;\n  background-size: 100%;\n  box-shadow: 0 4px 12px 0 rgba(37, 41, 46, 0.25);\n}\n\n.walletconnect-modal__base__row__right__caret {\n  height: 18px;\n  opacity: 0.3;\n  transition: 0.1s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n  width: 8px;\n  will-change: opacity;\n}\n\n.walletconnect-modal__base__row:hover .caret,\n.walletconnect-modal__base__row:active .caret {\n  opacity: 0.6;\n}\n\n.walletconnect-modal__mobile__toggle {\n  width: 80%;\n  display: flex;\n  margin: 0 auto;\n  position: relative;\n  overflow: hidden;\n  border-radius: 8px;\n  margin-bottom: 18px;\n  background: #d4d5d9;\n}\n\n.walletconnect-modal__single_wallet {\n  display: flex;\n  justify-content: center;\n  margin-top: 7px;\n  margin-bottom: 18px;\n}\n\n.walletconnect-modal__single_wallet a {\n  cursor: pointer;\n  color: rgb(64, 153, 255);\n  font-size: 21px;\n  font-weight: 800;\n  text-decoration: none !important;\n  margin: 0 auto;\n}\n\n.walletconnect-modal__mobile__toggle_selector {\n  width: calc(50% - 8px);\n  background: white;\n  position: absolute;\n  border-radius: 5px;\n  height: calc(100% - 8px);\n  top: 4px;\n  transition: all 0.2s ease-in-out;\n  transform: translate3d(4px, 0, 0);\n}\n\n.walletconnect-modal__mobile__toggle.right__selected .walletconnect-modal__mobile__toggle_selector {\n  transform: translate3d(calc(100% + 12px), 0, 0);\n}\n\n.walletconnect-modal__mobile__toggle a {\n  font-size: 12px;\n  width: 50%;\n  text-align: center;\n  padding: 8px;\n  margin: 0;\n  font-weight: 600;\n  z-index: 1;\n}\n\n.walletconnect-modal__footer {\n  display: flex;\n  justify-content: center;\n  margin-top: 20px;\n}\n\n@media only screen and (max-width: 768px) {\n  .walletconnect-modal__footer {\n    margin-top: 5vw;\n  }\n}\n\n.walletconnect-modal__footer a {\n  cursor: pointer;\n  color: #898d97;\n  font-size: 15px;\n  margin: 0 auto;\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-modal__footer a {\n    font-size: 14px;\n  }\n}\n\n.walletconnect-connect__buttons__wrapper {\n  max-height: 44vh;\n}\n\n.walletconnect-connect__buttons__wrapper__android {\n  margin: 50% 0;\n}\n\n.walletconnect-connect__buttons__wrapper__wrap {\n  display: grid;\n  grid-template-columns: repeat(4, 1fr);\n  margin: 10px 0;\n}\n\n@media only screen and (min-width: 768px) {\n  .walletconnect-connect__buttons__wrapper__wrap {\n    margin-top: 40px;\n  }\n}\n\n.walletconnect-connect__button {\n  background-color: rgb(64, 153, 255);\n  padding: 12px;\n  border-radius: 8px;\n  text-decoration: none;\n  color: rgb(255, 255, 255);\n  font-weight: 500;\n}\n\n.walletconnect-connect__button__icon_anchor {\n  cursor: pointer;\n  display: flex;\n  justify-content: flex-start;\n  align-items: center;\n  margin: 8px;\n  width: 42px;\n  justify-self: center;\n  flex-direction: column;\n  text-decoration: none !important;\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-connect__button__icon_anchor {\n    margin: 4px;\n  }\n}\n\n.walletconnect-connect__button__icon {\n  border-radius: 10px;\n  height: 42px;\n  margin: 0;\n  width: 42px;\n  background-size: cover !important;\n  box-shadow: 0 4px 12px 0 rgba(37, 41, 46, 0.25);\n}\n\n.walletconnect-connect__button__text {\n  color: #424952;\n  font-size: 2.7vw;\n  text-decoration: none !important;\n  padding: 0;\n  margin-top: 1.8vw;\n  font-weight: 600;\n}\n\n@media only screen and (min-width: 768px) {\n  .walletconnect-connect__button__text {\n    font-size: 16px;\n    margin-top: 12px;\n  }\n}\n\n.walletconnect-search__input {\n  border: none;\n  background: #d4d5d9;\n  border-style: none;\n  padding: 8px 16px;\n  outline: none;\n  font-style: normal;\n  font-stretch: normal;\n  font-size: 16px;\n  font-style: normal;\n  font-stretch: normal;\n  line-height: normal;\n  letter-spacing: normal;\n  text-align: left;\n  border-radius: 8px;\n  width: calc(100% - 16px);\n  margin: 0;\n  margin-bottom: 8px;\n}\n';
    var _iteratorSymbol = typeof Symbol !== "undefined" ? Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")) : "@@iterator";
    var _asyncIteratorSymbol = typeof Symbol !== "undefined" ? Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator")) : "@@asyncIterator";
    function _catch(body, recover) {
      try {
        var result = body();
      } catch (e6) {
        return recover(e6);
      }
      if (result && result.then) {
        return result.then(void 0, recover);
      }
      return result;
    }
    var WALLETCONNECT_LOGO_SVG_URL = "data:image/svg+xml,%3Csvg height='185' viewBox='0 0 300 185' width='300' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='m61.4385429 36.2562612c48.9112241-47.8881663 128.2119871-47.8881663 177.1232091 0l5.886545 5.7634174c2.445561 2.3944081 2.445561 6.2765112 0 8.6709204l-20.136695 19.715503c-1.222781 1.1972051-3.2053 1.1972051-4.428081 0l-8.100584-7.9311479c-34.121692-33.4079817-89.443886-33.4079817-123.5655788 0l-8.6750562 8.4936051c-1.2227816 1.1972041-3.205301 1.1972041-4.4280806 0l-20.1366949-19.7155031c-2.4455612-2.3944092-2.4455612-6.2765122 0-8.6709204zm218.7677961 40.7737449 17.921697 17.546897c2.445549 2.3943969 2.445563 6.2764769.000031 8.6708899l-80.810171 79.121134c-2.445544 2.394426-6.410582 2.394453-8.85616.000062-.00001-.00001-.000022-.000022-.000032-.000032l-57.354143-56.154572c-.61139-.598602-1.60265-.598602-2.21404 0-.000004.000004-.000007.000008-.000011.000011l-57.3529212 56.154531c-2.4455368 2.394432-6.4105755 2.394472-8.8561612.000087-.0000143-.000014-.0000296-.000028-.0000449-.000044l-80.81241943-79.122185c-2.44556021-2.394408-2.44556021-6.2765115 0-8.6709197l17.92172963-17.5468673c2.4455602-2.3944082 6.4105989-2.3944082 8.8561602 0l57.3549775 56.155357c.6113908.598602 1.602649.598602 2.2140398 0 .0000092-.000009.0000174-.000017.0000265-.000024l57.3521031-56.155333c2.445505-2.3944633 6.410544-2.3945531 8.856161-.0002.000034.0000336.000068.0000673.000101.000101l57.354902 56.155432c.61139.598601 1.60265.598601 2.21404 0l57.353975-56.1543249c2.445561-2.3944092 6.410599-2.3944092 8.85616 0z' fill='%233b99fc'/%3E%3C/svg%3E";
    var WALLETCONNECT_HEADER_TEXT = "WalletConnect";
    var ANIMATION_DURATION = 300;
    var DEFAULT_BUTTON_COLOR = "rgb(64, 153, 255)";
    var WALLETCONNECT_WRAPPER_ID = "walletconnect-wrapper";
    var WALLETCONNECT_STYLE_ID = "walletconnect-style-sheet";
    var WALLETCONNECT_MODAL_ID = "walletconnect-qrcode-modal";
    var WALLETCONNECT_CLOSE_BUTTON_ID = "walletconnect-qrcode-close";
    var WALLETCONNECT_CTA_TEXT_ID = "walletconnect-qrcode-text";
    var WALLETCONNECT_CONNECT_BUTTON_ID = "walletconnect-connect-button";
    function Header(props) {
      return React11.createElement("div", {
        className: "walletconnect-modal__header"
      }, React11.createElement("img", {
        src: WALLETCONNECT_LOGO_SVG_URL,
        className: "walletconnect-modal__headerLogo"
      }), React11.createElement("p", null, WALLETCONNECT_HEADER_TEXT), React11.createElement("div", {
        className: "walletconnect-modal__close__wrapper",
        onClick: props.onClose
      }, React11.createElement("div", {
        id: WALLETCONNECT_CLOSE_BUTTON_ID,
        className: "walletconnect-modal__close__icon"
      }, React11.createElement("div", {
        className: "walletconnect-modal__close__line1"
      }), React11.createElement("div", {
        className: "walletconnect-modal__close__line2"
      }))));
    }
    function ConnectButton(props) {
      return React11.createElement("a", {
        className: "walletconnect-connect__button",
        href: props.href,
        id: WALLETCONNECT_CONNECT_BUTTON_ID + "-" + props.name,
        onClick: props.onClick,
        rel: "noopener noreferrer",
        style: {
          backgroundColor: props.color
        },
        target: "_blank"
      }, props.name);
    }
    var CARET_SVG_URL = "data:image/svg+xml,%3Csvg fill='none' height='18' viewBox='0 0 8 18' width='8' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath clip-rule='evenodd' d='m.586301.213898c-.435947.33907-.5144813.967342-.175411 1.403292l4.87831 6.27212c.28087.36111.28087.86677 0 1.22788l-4.878311 6.27211c-.33907.436-.260536 1.0642.175412 1.4033.435949.3391 1.064219.2605 1.403289-.1754l4.87832-6.2721c.84259-1.08336.84259-2.60034 0-3.68367l-4.87832-6.27212c-.33907-.4359474-.96734-.514482-1.403289-.175412z' fill='%233c4252' fill-rule='evenodd'/%3E%3C/svg%3E";
    function WalletButton(props) {
      var color = props.color;
      var href = props.href;
      var name2 = props.name;
      var logo = props.logo;
      var onClick = props.onClick;
      return React11.createElement("a", {
        className: "walletconnect-modal__base__row",
        href,
        onClick,
        rel: "noopener noreferrer",
        target: "_blank"
      }, React11.createElement("h3", {
        className: "walletconnect-modal__base__row__h3"
      }, name2), React11.createElement("div", {
        className: "walletconnect-modal__base__row__right"
      }, React11.createElement("div", {
        className: "walletconnect-modal__base__row__right__app-icon",
        style: {
          background: "url('" + logo + "') " + color,
          backgroundSize: "100%"
        }
      }), React11.createElement("img", {
        src: CARET_SVG_URL,
        className: "walletconnect-modal__base__row__right__caret"
      })));
    }
    function WalletIcon(props) {
      var color = props.color;
      var href = props.href;
      var name2 = props.name;
      var logo = props.logo;
      var onClick = props.onClick;
      var fontSize = window.innerWidth < 768 ? (name2.length > 8 ? 2.5 : 2.7) + "vw" : "inherit";
      return React11.createElement("a", {
        className: "walletconnect-connect__button__icon_anchor",
        href,
        onClick,
        rel: "noopener noreferrer",
        target: "_blank"
      }, React11.createElement("div", {
        className: "walletconnect-connect__button__icon",
        style: {
          background: "url('" + logo + "') " + color,
          backgroundSize: "100%"
        }
      }), React11.createElement("div", {
        style: {
          fontSize
        },
        className: "walletconnect-connect__button__text"
      }, name2));
    }
    var GRID_MIN_COUNT = 5;
    var LINKS_PER_PAGE = 12;
    function LinkDisplay(props) {
      var android = browserUtils.isAndroid();
      var ref = React11.useState("");
      var input = ref[0];
      var setInput = ref[1];
      var ref$1 = React11.useState("");
      var filter2 = ref$1[0];
      var setFilter = ref$1[1];
      var ref$2 = React11.useState(1);
      var page = ref$2[0];
      var setPage = ref$2[1];
      var links = filter2 ? props.links.filter(function(link) {
        return link.name.toLowerCase().includes(filter2.toLowerCase());
      }) : props.links;
      var errorMessage = props.errorMessage;
      var grid = filter2 || links.length > GRID_MIN_COUNT;
      var pages = Math.ceil(links.length / LINKS_PER_PAGE);
      var range2 = [(page - 1) * LINKS_PER_PAGE + 1, page * LINKS_PER_PAGE];
      var pageLinks = links.length ? links.filter(function(_8, index2) {
        return index2 + 1 >= range2[0] && index2 + 1 <= range2[1];
      }) : [];
      var hasPaging = !!(!android && pages > 1);
      var filterTimeout = void 0;
      function handleInput(e6) {
        setInput(e6.target.value);
        clearTimeout(filterTimeout);
        if (e6.target.value) {
          filterTimeout = setTimeout(function() {
            setFilter(e6.target.value);
            setPage(1);
          }, 1e3);
        } else {
          setInput("");
          setFilter("");
          setPage(1);
        }
      }
      return React11.createElement("div", null, React11.createElement("p", {
        id: WALLETCONNECT_CTA_TEXT_ID,
        className: "walletconnect-qrcode__text"
      }, android ? props.text.connect_mobile_wallet : props.text.choose_preferred_wallet), !android && React11.createElement("input", {
        className: "walletconnect-search__input",
        placeholder: "Search",
        value: input,
        onChange: handleInput
      }), React11.createElement("div", {
        className: "walletconnect-connect__buttons__wrapper" + (android ? "__android" : grid && links.length ? "__wrap" : "")
      }, !android ? pageLinks.length ? pageLinks.map(function(entry) {
        var color = entry.color;
        var name2 = entry.name;
        var shortName = entry.shortName;
        var logo = entry.logo;
        var href = browserUtils.formatIOSMobile(props.uri, entry);
        var handleClickIOS = React11.useCallback(function() {
          browserUtils.saveMobileLinkInfo({
            name: name2,
            href
          });
        }, [pageLinks]);
        return !grid ? React11.createElement(WalletButton, {
          color,
          href,
          name: name2,
          logo,
          onClick: handleClickIOS
        }) : React11.createElement(WalletIcon, {
          color,
          href,
          name: shortName || name2,
          logo,
          onClick: handleClickIOS
        });
      }) : React11.createElement(React11.Fragment, null, React11.createElement("p", null, errorMessage.length ? props.errorMessage : !!props.links.length && !links.length ? props.text.no_wallets_found : props.text.loading)) : React11.createElement(ConnectButton, {
        name: props.text.connect,
        color: DEFAULT_BUTTON_COLOR,
        href: props.uri,
        onClick: React11.useCallback(function() {
          browserUtils.saveMobileLinkInfo({
            name: "Unknown",
            href: props.uri
          });
        }, [])
      })), hasPaging && React11.createElement("div", {
        className: "walletconnect-modal__footer"
      }, Array(pages).fill(0).map(function(_8, index2) {
        var pageNumber = index2 + 1;
        var selected = page === pageNumber;
        return React11.createElement("a", {
          style: {
            margin: "auto 10px",
            fontWeight: selected ? "bold" : "normal"
          },
          onClick: function() {
            return setPage(pageNumber);
          }
        }, pageNumber);
      })));
    }
    function Notification2(props) {
      var show = !!props.message.trim();
      return React11.createElement("div", {
        className: "walletconnect-qrcode__notification" + (show ? " notification__show" : "")
      }, props.message);
    }
    var formatQRCodeImage = function(data) {
      try {
        var result = "";
        return Promise.resolve(QRCode.toString(data, {
          margin: 0,
          type: "svg"
        })).then(function(dataString) {
          if (typeof dataString === "string") {
            result = dataString.replace("<svg", '<svg class="walletconnect-qrcode__image"');
          }
          return result;
        });
      } catch (e6) {
        return Promise.reject(e6);
      }
    };
    function QRCodeDisplay(props) {
      var ref = React11.useState("");
      var notification = ref[0];
      var setNotification = ref[1];
      var ref$1 = React11.useState("");
      var svg = ref$1[0];
      var setSvg = ref$1[1];
      React11.useEffect(function() {
        try {
          return Promise.resolve(formatQRCodeImage(props.uri)).then(function(_formatQRCodeImage) {
            setSvg(_formatQRCodeImage);
          });
        } catch (e6) {
          Promise.reject(e6);
        }
      }, []);
      var copyToClipboard = function() {
        var success = copy(props.uri);
        if (success) {
          setNotification(props.text.copied_to_clipboard);
          setInterval(function() {
            return setNotification("");
          }, 1200);
        } else {
          setNotification("Error");
          setInterval(function() {
            return setNotification("");
          }, 1200);
        }
      };
      return React11.createElement("div", null, React11.createElement("p", {
        id: WALLETCONNECT_CTA_TEXT_ID,
        className: "walletconnect-qrcode__text"
      }, props.text.scan_qrcode_with_wallet), React11.createElement("div", {
        dangerouslySetInnerHTML: {
          __html: svg
        }
      }), React11.createElement("div", {
        className: "walletconnect-modal__footer"
      }, React11.createElement("a", {
        onClick: copyToClipboard
      }, props.text.copy_to_clipboard)), React11.createElement(Notification2, {
        message: notification
      }));
    }
    function Modal(props) {
      var android = browserUtils.isAndroid();
      var mobile = browserUtils.isMobile();
      var whitelist = mobile ? props.qrcodeModalOptions && props.qrcodeModalOptions.mobileLinks ? props.qrcodeModalOptions.mobileLinks : void 0 : props.qrcodeModalOptions && props.qrcodeModalOptions.desktopLinks ? props.qrcodeModalOptions.desktopLinks : void 0;
      var ref = React11.useState(false);
      var loading = ref[0];
      var setLoading = ref[1];
      var ref$1 = React11.useState(false);
      var fetched = ref$1[0];
      var setFetched = ref$1[1];
      var ref$2 = React11.useState(!mobile);
      var displayQRCode = ref$2[0];
      var setDisplayQRCode = ref$2[1];
      var displayProps = {
        mobile,
        text: props.text,
        uri: props.uri,
        qrcodeModalOptions: props.qrcodeModalOptions
      };
      var ref$3 = React11.useState("");
      var singleLinkHref = ref$3[0];
      var setSingleLinkHref = ref$3[1];
      var ref$4 = React11.useState(false);
      var hasSingleLink = ref$4[0];
      var setHasSingleLink = ref$4[1];
      var ref$5 = React11.useState([]);
      var links = ref$5[0];
      var setLinks = ref$5[1];
      var ref$6 = React11.useState("");
      var errorMessage = ref$6[0];
      var setErrorMessage = ref$6[1];
      var getLinksIfNeeded = function() {
        if (fetched || loading || whitelist && !whitelist.length || links.length > 0) {
          return;
        }
        React11.useEffect(function() {
          var initLinks = function() {
            try {
              if (android) {
                return Promise.resolve();
              }
              setLoading(true);
              var _temp = _catch(function() {
                var url = props.qrcodeModalOptions && props.qrcodeModalOptions.registryUrl ? props.qrcodeModalOptions.registryUrl : browserUtils.getWalletRegistryUrl();
                return Promise.resolve(fetch(url)).then(function(registryResponse) {
                  return Promise.resolve(registryResponse.json()).then(function(_registryResponse$jso) {
                    var registry = _registryResponse$jso.listings;
                    var platform = mobile ? "mobile" : "desktop";
                    var _links = browserUtils.getMobileLinkRegistry(browserUtils.formatMobileRegistry(registry, platform), whitelist);
                    setLoading(false);
                    setFetched(true);
                    setErrorMessage(!_links.length ? props.text.no_supported_wallets : "");
                    setLinks(_links);
                    var hasSingleLink2 = _links.length === 1;
                    if (hasSingleLink2) {
                      setSingleLinkHref(browserUtils.formatIOSMobile(props.uri, _links[0]));
                      setDisplayQRCode(true);
                    }
                    setHasSingleLink(hasSingleLink2);
                  });
                });
              }, function(e6) {
                setLoading(false);
                setFetched(true);
                setErrorMessage(props.text.something_went_wrong);
                console.error(e6);
              });
              return Promise.resolve(_temp && _temp.then ? _temp.then(function() {
              }) : void 0);
            } catch (e6) {
              return Promise.reject(e6);
            }
          };
          initLinks();
        });
      };
      getLinksIfNeeded();
      var rightSelected = mobile ? displayQRCode : !displayQRCode;
      return React11.createElement("div", {
        id: WALLETCONNECT_MODAL_ID,
        className: "walletconnect-qrcode__base animated fadeIn"
      }, React11.createElement("div", {
        className: "walletconnect-modal__base"
      }, React11.createElement(Header, {
        onClose: props.onClose
      }), hasSingleLink && displayQRCode ? React11.createElement("div", {
        className: "walletconnect-modal__single_wallet"
      }, React11.createElement("a", {
        onClick: function() {
          return browserUtils.saveMobileLinkInfo({
            name: links[0].name,
            href: singleLinkHref
          });
        },
        href: singleLinkHref,
        rel: "noopener noreferrer",
        target: "_blank"
      }, props.text.connect_with + " " + (hasSingleLink ? links[0].name : "") + " \u203A")) : android || loading || !loading && links.length ? React11.createElement("div", {
        className: "walletconnect-modal__mobile__toggle" + (rightSelected ? " right__selected" : "")
      }, React11.createElement("div", {
        className: "walletconnect-modal__mobile__toggle_selector"
      }), mobile ? React11.createElement(React11.Fragment, null, React11.createElement("a", {
        onClick: function() {
          return setDisplayQRCode(false), getLinksIfNeeded();
        }
      }, props.text.mobile), React11.createElement("a", {
        onClick: function() {
          return setDisplayQRCode(true);
        }
      }, props.text.qrcode)) : React11.createElement(React11.Fragment, null, React11.createElement("a", {
        onClick: function() {
          return setDisplayQRCode(true);
        }
      }, props.text.qrcode), React11.createElement("a", {
        onClick: function() {
          return setDisplayQRCode(false), getLinksIfNeeded();
        }
      }, props.text.desktop))) : null, React11.createElement("div", null, displayQRCode || !android && !loading && !links.length ? React11.createElement(QRCodeDisplay, Object.assign({}, displayProps)) : React11.createElement(LinkDisplay, Object.assign(
        {},
        displayProps,
        {
          links,
          errorMessage
        }
      )))));
    }
    var de3 = {
      choose_preferred_wallet: "W\xE4hle bevorzugte Wallet",
      connect_mobile_wallet: "Verbinde mit Mobile Wallet",
      scan_qrcode_with_wallet: "Scanne den QR-code mit einer WalletConnect kompatiblen Wallet",
      connect: "Verbinden",
      qrcode: "QR-Code",
      mobile: "Mobile",
      desktop: "Desktop",
      copy_to_clipboard: "In die Zwischenablage kopieren",
      copied_to_clipboard: "In die Zwischenablage kopiert!",
      connect_with: "Verbinden mit Hilfe von",
      loading: "Laden...",
      something_went_wrong: "Etwas ist schief gelaufen",
      no_supported_wallets: "Es gibt noch keine unterst\xFCtzten Wallet",
      no_wallets_found: "keine Wallet gefunden"
    };
    var en2 = {
      choose_preferred_wallet: "Choose your preferred wallet",
      connect_mobile_wallet: "Connect to Mobile Wallet",
      scan_qrcode_with_wallet: "Scan QR code with a WalletConnect-compatible wallet",
      connect: "Connect",
      qrcode: "QR Code",
      mobile: "Mobile",
      desktop: "Desktop",
      copy_to_clipboard: "Copy to clipboard",
      copied_to_clipboard: "Copied to clipboard!",
      connect_with: "Connect with",
      loading: "Loading...",
      something_went_wrong: "Something went wrong",
      no_supported_wallets: "There are no supported wallets yet",
      no_wallets_found: "No wallets found"
    };
    var es2 = {
      choose_preferred_wallet: "Elige tu billetera preferida",
      connect_mobile_wallet: "Conectar a billetera m\xF3vil",
      scan_qrcode_with_wallet: "Escanea el c\xF3digo QR con una billetera compatible con WalletConnect",
      connect: "Conectar",
      qrcode: "C\xF3digo QR",
      mobile: "M\xF3vil",
      desktop: "Desktop",
      copy_to_clipboard: "Copiar",
      copied_to_clipboard: "Copiado!",
      connect_with: "Conectar mediante",
      loading: "Cargando...",
      something_went_wrong: "Algo sali\xF3 mal",
      no_supported_wallets: "Todav\xEDa no hay billeteras compatibles",
      no_wallets_found: "No se encontraron billeteras"
    };
    var fr2 = {
      choose_preferred_wallet: "Choisissez votre portefeuille pr\xE9f\xE9r\xE9",
      connect_mobile_wallet: "Se connecter au portefeuille mobile",
      scan_qrcode_with_wallet: "Scannez le QR code avec un portefeuille compatible WalletConnect",
      connect: "Se connecter",
      qrcode: "QR Code",
      mobile: "Mobile",
      desktop: "Desktop",
      copy_to_clipboard: "Copier",
      copied_to_clipboard: "Copi\xE9!",
      connect_with: "Connectez-vous \xE0 l'aide de",
      loading: "Chargement...",
      something_went_wrong: "Quelque chose a mal tourn\xE9",
      no_supported_wallets: "Il n'y a pas encore de portefeuilles pris en charge",
      no_wallets_found: "Aucun portefeuille trouv\xE9"
    };
    var ko2 = {
      choose_preferred_wallet: "\uC6D0\uD558\uB294 \uC9C0\uAC11\uC744 \uC120\uD0DD\uD558\uC138\uC694",
      connect_mobile_wallet: "\uBAA8\uBC14\uC77C \uC9C0\uAC11\uACFC \uC5F0\uACB0",
      scan_qrcode_with_wallet: "WalletConnect \uC9C0\uC6D0 \uC9C0\uAC11\uC5D0\uC11C QR\uCF54\uB4DC\uB97C \uC2A4\uCE94\uD558\uC138\uC694",
      connect: "\uC5F0\uACB0",
      qrcode: "QR \uCF54\uB4DC",
      mobile: "\uBAA8\uBC14\uC77C",
      desktop: "\uB370\uC2A4\uD06C\uD0D1",
      copy_to_clipboard: "\uD074\uB9BD\uBCF4\uB4DC\uC5D0 \uBCF5\uC0AC",
      copied_to_clipboard: "\uD074\uB9BD\uBCF4\uB4DC\uC5D0 \uBCF5\uC0AC\uB418\uC5C8\uC2B5\uB2C8\uB2E4!",
      connect_with: "\uC640 \uC5F0\uACB0\uD558\uB2E4",
      loading: "\uB85C\uB4DC \uC911...",
      something_went_wrong: "\uBB38\uC81C\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4.",
      no_supported_wallets: "\uC544\uC9C1 \uC9C0\uC6D0\uB418\uB294 \uC9C0\uAC11\uC774 \uC5C6\uC2B5\uB2C8\uB2E4",
      no_wallets_found: "\uC9C0\uAC11\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4"
    };
    var pt2 = {
      choose_preferred_wallet: "Escolha sua carteira preferida",
      connect_mobile_wallet: "Conectar-se \xE0 carteira m\xF3vel",
      scan_qrcode_with_wallet: "Ler o c\xF3digo QR com uma carteira compat\xEDvel com WalletConnect",
      connect: "Conectar",
      qrcode: "C\xF3digo QR",
      mobile: "M\xF3vel",
      desktop: "Desktop",
      copy_to_clipboard: "Copiar",
      copied_to_clipboard: "Copiado!",
      connect_with: "Ligar por meio de",
      loading: "Carregamento...",
      something_went_wrong: "Algo correu mal",
      no_supported_wallets: "Ainda n\xE3o h\xE1 carteiras suportadas",
      no_wallets_found: "Nenhuma carteira encontrada"
    };
    var zh = {
      choose_preferred_wallet: "\u9009\u62E9\u4F60\u7684\u94B1\u5305",
      connect_mobile_wallet: "\u8FDE\u63A5\u81F3\u79FB\u52A8\u7AEF\u94B1\u5305",
      scan_qrcode_with_wallet: "\u4F7F\u7528\u517C\u5BB9 WalletConnect \u7684\u94B1\u5305\u626B\u63CF\u4E8C\u7EF4\u7801",
      connect: "\u8FDE\u63A5",
      qrcode: "\u4E8C\u7EF4\u7801",
      mobile: "\u79FB\u52A8",
      desktop: "\u684C\u9762",
      copy_to_clipboard: "\u590D\u5236\u5230\u526A\u8D34\u677F",
      copied_to_clipboard: "\u590D\u5236\u5230\u526A\u8D34\u677F\u6210\u529F\uFF01",
      connect_with: "\u901A\u8FC7\u4EE5\u4E0B\u65B9\u5F0F\u8FDE\u63A5",
      loading: "\u6B63\u5728\u52A0\u8F7D...",
      something_went_wrong: "\u51FA\u4E86\u95EE\u9898",
      no_supported_wallets: "\u76EE\u524D\u8FD8\u6CA1\u6709\u652F\u6301\u7684\u94B1\u5305",
      no_wallets_found: "\u6CA1\u6709\u627E\u5230\u94B1\u5305"
    };
    var fa2 = {
      choose_preferred_wallet: "\u06A9\u06CC\u0641 \u067E\u0648\u0644 \u0645\u0648\u0631\u062F \u0646\u0638\u0631 \u062E\u0648\u062F \u0631\u0627 \u0627\u0646\u062A\u062E\u0627\u0628 \u06A9\u0646\u06CC\u062F",
      connect_mobile_wallet: "\u0628\u0647 \u06A9\u06CC\u0641 \u067E\u0648\u0644 \u0645\u0648\u0628\u0627\u06CC\u0644 \u0648\u0635\u0644 \u0634\u0648\u06CC\u062F",
      scan_qrcode_with_wallet: "\u06A9\u062F QR \u0631\u0627 \u0628\u0627 \u06CC\u06A9 \u06A9\u06CC\u0641 \u067E\u0648\u0644 \u0633\u0627\u0632\u06AF\u0627\u0631 \u0628\u0627 WalletConnect \u0627\u0633\u06A9\u0646 \u06A9\u0646\u06CC\u062F",
      connect: "\u0627\u062A\u0635\u0627\u0644",
      qrcode: "\u06A9\u062F QR",
      mobile: "\u0633\u06CC\u0627\u0631",
      desktop: "\u062F\u0633\u06A9\u062A\u0627\u067E",
      copy_to_clipboard: "\u06A9\u067E\u06CC \u0628\u0647 \u06A9\u0644\u06CC\u067E \u0628\u0648\u0631\u062F",
      copied_to_clipboard: "\u062F\u0631 \u06A9\u0644\u06CC\u067E \u0628\u0648\u0631\u062F \u06A9\u067E\u06CC \u0634\u062F!",
      connect_with: "\u0627\u0631\u062A\u0628\u0627\u0637 \u0628\u0627",
      loading: "...\u0628\u0627\u0631\u06AF\u0630\u0627\u0631\u06CC",
      something_went_wrong: "\u0645\u0634\u06A9\u0644\u06CC \u067E\u06CC\u0634 \u0622\u0645\u062F",
      no_supported_wallets: "\u0647\u0646\u0648\u0632 \u0647\u06CC\u0686 \u06A9\u06CC\u0641 \u067E\u0648\u0644 \u067E\u0634\u062A\u06CC\u0628\u0627\u0646\u06CC \u0634\u062F\u0647 \u0627\u06CC \u0648\u062C\u0648\u062F \u0646\u062F\u0627\u0631\u062F",
      no_wallets_found: "\u0647\u06CC\u0686 \u06A9\u06CC\u0641 \u067E\u0648\u0644\u06CC \u067E\u06CC\u062F\u0627 \u0646\u0634\u062F"
    };
    var languages = {
      de: de3,
      en: en2,
      es: es2,
      fr: fr2,
      ko: ko2,
      pt: pt2,
      zh,
      fa: fa2
    };
    function injectStyleSheet() {
      var doc = browserUtils.getDocumentOrThrow();
      var prev = doc.getElementById(WALLETCONNECT_STYLE_ID);
      if (prev) {
        doc.head.removeChild(prev);
      }
      var style = doc.createElement("style");
      style.setAttribute("id", WALLETCONNECT_STYLE_ID);
      style.innerText = WALLETCONNECT_STYLE_SHEET;
      doc.head.appendChild(style);
    }
    function renderWrapper() {
      var doc = browserUtils.getDocumentOrThrow();
      var wrapper = doc.createElement("div");
      wrapper.setAttribute("id", WALLETCONNECT_WRAPPER_ID);
      doc.body.appendChild(wrapper);
      return wrapper;
    }
    function triggerCloseAnimation() {
      var doc = browserUtils.getDocumentOrThrow();
      var modal = doc.getElementById(WALLETCONNECT_MODAL_ID);
      if (modal) {
        modal.className = modal.className.replace("fadeIn", "fadeOut");
        setTimeout(function() {
          var wrapper = doc.getElementById(WALLETCONNECT_WRAPPER_ID);
          if (wrapper) {
            doc.body.removeChild(wrapper);
          }
        }, ANIMATION_DURATION);
      }
    }
    function getWrappedCallback(cb) {
      return function() {
        triggerCloseAnimation();
        if (cb) {
          cb();
        }
      };
    }
    function getText() {
      var lang = browserUtils.getNavigatorOrThrow().language.split("-")[0] || "en";
      return languages[lang] || languages["en"];
    }
    function open$1(uri, cb, qrcodeModalOptions) {
      injectStyleSheet();
      var wrapper = renderWrapper();
      React11.render(React11.createElement(Modal, {
        text: getText(),
        uri,
        onClose: getWrappedCallback(cb),
        qrcodeModalOptions
      }), wrapper);
    }
    function close$1() {
      triggerCloseAnimation();
    }
    var isNode3 = function() {
      return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
    };
    function open$2(uri, cb, qrcodeModalOptions) {
      console.log(uri);
      if (isNode3()) {
        open(uri);
      } else {
        open$1(uri, cb, qrcodeModalOptions);
      }
    }
    function close$2() {
      if (isNode3())
        ;
      else {
        close$1();
      }
    }
    var index = {
      open: open$2,
      close: close$2
    };
    module2.exports = index;
  }
});

// node_modules/mime/Mime.js
var require_Mime = __commonJS({
  "node_modules/mime/Mime.js"(exports2, module2) {
    "use strict";
    function Mime() {
      this._types = /* @__PURE__ */ Object.create(null);
      this._extensions = /* @__PURE__ */ Object.create(null);
      for (let i6 = 0; i6 < arguments.length; i6++) {
        this.define(arguments[i6]);
      }
      this.define = this.define.bind(this);
      this.getType = this.getType.bind(this);
      this.getExtension = this.getExtension.bind(this);
    }
    Mime.prototype.define = function(typeMap, force) {
      for (let type in typeMap) {
        let extensions = typeMap[type].map(function(t6) {
          return t6.toLowerCase();
        });
        type = type.toLowerCase();
        for (let i6 = 0; i6 < extensions.length; i6++) {
          const ext = extensions[i6];
          if (ext[0] === "*") {
            continue;
          }
          if (!force && ext in this._types) {
            throw new Error(
              'Attempt to change mapping for "' + ext + '" extension from "' + this._types[ext] + '" to "' + type + '". Pass `force=true` to allow this, otherwise remove "' + ext + '" from the list of extensions for "' + type + '".'
            );
          }
          this._types[ext] = type;
        }
        if (force || !this._extensions[type]) {
          const ext = extensions[0];
          this._extensions[type] = ext[0] !== "*" ? ext : ext.substr(1);
        }
      }
    };
    Mime.prototype.getType = function(path) {
      path = String(path);
      let last2 = path.replace(/^.*[/\\]/, "").toLowerCase();
      let ext = last2.replace(/^.*\./, "").toLowerCase();
      let hasPath = last2.length < path.length;
      let hasDot = ext.length < last2.length - 1;
      return (hasDot || !hasPath) && this._types[ext] || null;
    };
    Mime.prototype.getExtension = function(type) {
      type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
      return type && this._extensions[type.toLowerCase()] || null;
    };
    module2.exports = Mime;
  }
});

// node_modules/mime/types/standard.js
var require_standard = __commonJS({
  "node_modules/mime/types/standard.js"(exports2, module2) {
    module2.exports = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomdeleted+xml": ["atomdeleted"], "application/atomsvc+xml": ["atomsvc"], "application/atsc-dwd+xml": ["dwd"], "application/atsc-held+xml": ["held"], "application/atsc-rsat+xml": ["rsat"], "application/bdoc": ["bdoc"], "application/calendar+xml": ["xcs"], "application/ccxml+xml": ["ccxml"], "application/cdfx+xml": ["cdfx"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["es", "ecma"], "application/emma+xml": ["emma"], "application/emotionml+xml": ["emotionml"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/express": ["exp"], "application/fdt+xml": ["fdt"], "application/font-tdpfr": ["pfr"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hjson": ["hjson"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/its+xml": ["its"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lgr+xml": ["lgr"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mmt-aei+xml": ["maei"], "application/mmt-usd+xml": ["musd"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/n-quads": ["nq"], "application/n-triples": ["nt"], "application/node": ["cjs"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/p2p-overlay+xml": ["relo"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/provenance+xml": ["provx"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf", "owl"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/route-apd+xml": ["rapd"], "application/route-s-tsid+xml": ["sls"], "application/route-usd+xml": ["rusd"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/senml+xml": ["senmlx"], "application/sensml+xml": ["sensmlx"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/sieve": ["siv", "sieve"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/swid+xml": ["swidtag"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/toml": ["toml"], "application/trig": ["trig"], "application/ttml+xml": ["ttml"], "application/ubjson": ["ubj"], "application/urc-ressheet+xml": ["rsheet"], "application/urc-targetdesc+xml": ["td"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-att+xml": ["xav"], "application/xcap-caps+xml": ["xca"], "application/xcap-diff+xml": ["xdf"], "application/xcap-el+xml": ["xel"], "application/xcap-ns+xml": ["xns"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xliff+xml": ["xlf"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["*xsl", "xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": ["*3gpp"], "audio/adpcm": ["adp"], "audio/amr": ["amr"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mobile-xmf": ["mxmf"], "audio/mp3": ["*mp3"], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx", "opus"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": ["*wav"], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/aces": ["exr"], "image/apng": ["apng"], "image/avif": ["avif"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/dicom-rle": ["drle"], "image/emf": ["emf"], "image/fits": ["fits"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/heic": ["heic"], "image/heic-sequence": ["heics"], "image/heif": ["heif"], "image/heif-sequence": ["heifs"], "image/hej2k": ["hej2"], "image/hsj2": ["hsj2"], "image/ief": ["ief"], "image/jls": ["jls"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jph": ["jph"], "image/jphc": ["jhc"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/jxr": ["jxr"], "image/jxra": ["jxra"], "image/jxrs": ["jxrs"], "image/jxs": ["jxs"], "image/jxsc": ["jxsc"], "image/jxsi": ["jxsi"], "image/jxss": ["jxss"], "image/ktx": ["ktx"], "image/ktx2": ["ktx2"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/t38": ["t38"], "image/tiff": ["tif", "tiff"], "image/tiff-fx": ["tfx"], "image/webp": ["webp"], "image/wmf": ["wmf"], "message/disposition-notification": ["disposition-notification"], "message/global": ["u8msg"], "message/global-delivery-status": ["u8dsn"], "message/global-disposition-notification": ["u8mdn"], "message/global-headers": ["u8hdr"], "message/rfc822": ["eml", "mime"], "model/3mf": ["3mf"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/mtl": ["mtl"], "model/obj": ["obj"], "model/step+xml": ["stpx"], "model/step+zip": ["stpz"], "model/step-xml+zip": ["stpxz"], "model/stl": ["stl"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["*x3db", "x3dbz"], "model/x3d+fastinfoset": ["x3db"], "model/x3d+vrml": ["*x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "model/x3d-vrml": ["x3dv"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/mdx": ["mdx"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": ["*rtf"], "text/sgml": ["sgml", "sgm"], "text/shex": ["shex"], "text/slim": ["slim", "slm"], "text/spdx": ["spdx"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/xml": ["*xml"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/iso.segment": ["m4s"], "video/jpeg": ["jpgv"], "video/jpm": ["*jpm", "jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"] };
  }
});

// node_modules/mime/lite.js
var require_lite = __commonJS({
  "node_modules/mime/lite.js"(exports2, module2) {
    "use strict";
    var Mime = require_Mime();
    module2.exports = new Mime(require_standard());
  }
});

// node_modules/@thirdweb-dev/react/dist/chunk-VAJNQAU6.mjs
var l = Object.create;
var e = Object.defineProperty;
var m = Object.defineProperties;
var n = Object.getOwnPropertyDescriptor;
var o = Object.getOwnPropertyDescriptors;
var p = Object.getOwnPropertyNames;
var g = Object.getOwnPropertySymbols;
var q = Object.getPrototypeOf;
var h = Object.prototype.hasOwnProperty;
var j = Object.prototype.propertyIsEnumerable;
var i = (a5, b4, c5) => b4 in a5 ? e(a5, b4, { enumerable: true, configurable: true, writable: true, value: c5 }) : a5[b4] = c5;
var r = (a5, b4) => {
  for (var c5 in b4 || (b4 = {}))
    h.call(b4, c5) && i(a5, c5, b4[c5]);
  if (g)
    for (var c5 of g(b4))
      j.call(b4, c5) && i(a5, c5, b4[c5]);
  return a5;
};
var s = (a5, b4) => m(a5, o(b4));
var t = (a5, b4) => e(a5, "name", { value: b4, configurable: true });
var u = ((a5) => typeof __require != "undefined" ? __require : typeof Proxy != "undefined" ? new Proxy(a5, { get: (b4, c5) => (typeof __require != "undefined" ? __require : b4)[c5] }) : a5)(function(a5) {
  if (typeof __require != "undefined")
    return __require.apply(this, arguments);
  throw new Error('Dynamic require of "' + a5 + '" is not supported');
});
var v = (a5, b4) => {
  var c5 = {};
  for (var d6 in a5)
    h.call(a5, d6) && b4.indexOf(d6) < 0 && (c5[d6] = a5[d6]);
  if (a5 != null && g)
    for (var d6 of g(a5))
      b4.indexOf(d6) < 0 && j.call(a5, d6) && (c5[d6] = a5[d6]);
  return c5;
};
var k = (a5, b4, c5, d6) => {
  if (b4 && typeof b4 == "object" || typeof b4 == "function")
    for (let f7 of p(b4))
      !h.call(a5, f7) && f7 !== c5 && e(a5, f7, { get: () => b4[f7], enumerable: !(d6 = n(b4, f7)) || d6.enumerable });
  return a5;
};
var z = (a5, b4, c5) => (c5 = a5 != null ? l(q(a5)) : {}, k(b4 || !a5 || !a5.__esModule ? e(c5, "default", { value: a5, enumerable: true }) : c5, a5));

// node_modules/@thirdweb-dev/sdk/dist/index.mjs
var import_polyfill = __toESM(require_browser_polyfill(), 1);

// node_modules/ethers/lib.esm/ethers.js
var ethers_exports = {};
__export(ethers_exports, {
  BaseContract: () => BaseContract,
  BigNumber: () => BigNumber,
  Contract: () => Contract,
  ContractFactory: () => ContractFactory,
  FixedNumber: () => FixedNumber,
  Signer: () => Signer,
  VoidSigner: () => VoidSigner,
  Wallet: () => Wallet,
  Wordlist: () => Wordlist,
  constants: () => lib_exports7,
  errors: () => ErrorCode,
  getDefaultProvider: () => getDefaultProvider,
  logger: () => logger46,
  providers: () => lib_exports21,
  utils: () => utils_exports,
  version: () => version26,
  wordlists: () => wordlists
});

// node_modules/@ethersproject/contracts/lib.esm/index.js
init_lib11();
init_lib12();
init_lib13();
init_lib7();
init_lib3();
init_lib2();
init_lib4();
init_lib15();
init_lib();

// node_modules/@ethersproject/contracts/lib.esm/_version.js
var version14 = "contracts/5.6.0";

// node_modules/@ethersproject/contracts/lib.esm/index.js
var __awaiter5 = function(thisArg, _arguments, P5, generator) {
  function adopt(value2) {
    return value2 instanceof P5 ? value2 : new P5(function(resolve) {
      resolve(value2);
    });
  }
  return new (P5 || (P5 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e6) {
        reject(e6);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e6) {
        reject(e6);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger19 = new Logger(version14);
var allowedTransactionKeys3 = {
  chainId: true,
  data: true,
  from: true,
  gasLimit: true,
  gasPrice: true,
  nonce: true,
  to: true,
  value: true,
  type: true,
  accessList: true,
  maxFeePerGas: true,
  maxPriorityFeePerGas: true,
  customData: true,
  ccipReadEnabled: true
};
function resolveName(resolver, nameOrPromise) {
  return __awaiter5(this, void 0, void 0, function* () {
    const name2 = yield nameOrPromise;
    if (typeof name2 !== "string") {
      logger19.throwArgumentError("invalid address or ENS name", "name", name2);
    }
    try {
      return getAddress(name2);
    } catch (error) {
    }
    if (!resolver) {
      logger19.throwError("a provider or signer is needed to resolve ENS names", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "resolveName"
      });
    }
    const address = yield resolver.resolveName(name2);
    if (address == null) {
      logger19.throwArgumentError("resolver or addr is not configured for ENS name", "name", name2);
    }
    return address;
  });
}
function resolveAddresses(resolver, value2, paramType) {
  return __awaiter5(this, void 0, void 0, function* () {
    if (Array.isArray(paramType)) {
      return yield Promise.all(paramType.map((paramType2, index) => {
        return resolveAddresses(resolver, Array.isArray(value2) ? value2[index] : value2[paramType2.name], paramType2);
      }));
    }
    if (paramType.type === "address") {
      return yield resolveName(resolver, value2);
    }
    if (paramType.type === "tuple") {
      return yield resolveAddresses(resolver, value2, paramType.components);
    }
    if (paramType.baseType === "array") {
      if (!Array.isArray(value2)) {
        return Promise.reject(logger19.makeError("invalid value for array", Logger.errors.INVALID_ARGUMENT, {
          argument: "value",
          value: value2
        }));
      }
      return yield Promise.all(value2.map((v9) => resolveAddresses(resolver, v9, paramType.arrayChildren)));
    }
    return value2;
  });
}
function populateTransaction(contract, fragment, args) {
  return __awaiter5(this, void 0, void 0, function* () {
    let overrides = {};
    if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
      overrides = shallowCopy(args.pop());
    }
    logger19.checkArgumentCount(args.length, fragment.inputs.length, "passed to contract");
    if (contract.signer) {
      if (overrides.from) {
        overrides.from = resolveProperties({
          override: resolveName(contract.signer, overrides.from),
          signer: contract.signer.getAddress()
        }).then((check) => __awaiter5(this, void 0, void 0, function* () {
          if (getAddress(check.signer) !== check.override) {
            logger19.throwError("Contract with a Signer cannot override from", Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "overrides.from"
            });
          }
          return check.override;
        }));
      } else {
        overrides.from = contract.signer.getAddress();
      }
    } else if (overrides.from) {
      overrides.from = resolveName(contract.provider, overrides.from);
    }
    const resolved = yield resolveProperties({
      args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),
      address: contract.resolvedAddress,
      overrides: resolveProperties(overrides) || {}
    });
    const data = contract.interface.encodeFunctionData(fragment, resolved.args);
    const tx = {
      data,
      to: resolved.address
    };
    const ro3 = resolved.overrides;
    if (ro3.nonce != null) {
      tx.nonce = BigNumber.from(ro3.nonce).toNumber();
    }
    if (ro3.gasLimit != null) {
      tx.gasLimit = BigNumber.from(ro3.gasLimit);
    }
    if (ro3.gasPrice != null) {
      tx.gasPrice = BigNumber.from(ro3.gasPrice);
    }
    if (ro3.maxFeePerGas != null) {
      tx.maxFeePerGas = BigNumber.from(ro3.maxFeePerGas);
    }
    if (ro3.maxPriorityFeePerGas != null) {
      tx.maxPriorityFeePerGas = BigNumber.from(ro3.maxPriorityFeePerGas);
    }
    if (ro3.from != null) {
      tx.from = ro3.from;
    }
    if (ro3.type != null) {
      tx.type = ro3.type;
    }
    if (ro3.accessList != null) {
      tx.accessList = accessListify(ro3.accessList);
    }
    if (tx.gasLimit == null && fragment.gas != null) {
      let intrinsic = 21e3;
      const bytes = arrayify(data);
      for (let i6 = 0; i6 < bytes.length; i6++) {
        intrinsic += 4;
        if (bytes[i6]) {
          intrinsic += 64;
        }
      }
      tx.gasLimit = BigNumber.from(fragment.gas).add(intrinsic);
    }
    if (ro3.value) {
      const roValue = BigNumber.from(ro3.value);
      if (!roValue.isZero() && !fragment.payable) {
        logger19.throwError("non-payable method cannot override value", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "overrides.value",
          value: overrides.value
        });
      }
      tx.value = roValue;
    }
    if (ro3.customData) {
      tx.customData = shallowCopy(ro3.customData);
    }
    if (ro3.ccipReadEnabled) {
      tx.ccipReadEnabled = !!ro3.ccipReadEnabled;
    }
    delete overrides.nonce;
    delete overrides.gasLimit;
    delete overrides.gasPrice;
    delete overrides.from;
    delete overrides.value;
    delete overrides.type;
    delete overrides.accessList;
    delete overrides.maxFeePerGas;
    delete overrides.maxPriorityFeePerGas;
    delete overrides.customData;
    delete overrides.ccipReadEnabled;
    const leftovers = Object.keys(overrides).filter((key2) => overrides[key2] != null);
    if (leftovers.length) {
      logger19.throwError(`cannot override ${leftovers.map((l6) => JSON.stringify(l6)).join(",")}`, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "overrides",
        overrides: leftovers
      });
    }
    return tx;
  });
}
function buildPopulate(contract, fragment) {
  return function(...args) {
    return populateTransaction(contract, fragment, args);
  };
}
function buildEstimate(contract, fragment) {
  const signerOrProvider = contract.signer || contract.provider;
  return function(...args) {
    return __awaiter5(this, void 0, void 0, function* () {
      if (!signerOrProvider) {
        logger19.throwError("estimate require a provider or signer", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "estimateGas"
        });
      }
      const tx = yield populateTransaction(contract, fragment, args);
      return yield signerOrProvider.estimateGas(tx);
    });
  };
}
function addContractWait(contract, tx) {
  const wait = tx.wait.bind(tx);
  tx.wait = (confirmations) => {
    return wait(confirmations).then((receipt) => {
      receipt.events = receipt.logs.map((log) => {
        let event = deepCopy(log);
        let parsed = null;
        try {
          parsed = contract.interface.parseLog(log);
        } catch (e6) {
        }
        if (parsed) {
          event.args = parsed.args;
          event.decode = (data, topics) => {
            return contract.interface.decodeEventLog(parsed.eventFragment, data, topics);
          };
          event.event = parsed.name;
          event.eventSignature = parsed.signature;
        }
        event.removeListener = () => {
          return contract.provider;
        };
        event.getBlock = () => {
          return contract.provider.getBlock(receipt.blockHash);
        };
        event.getTransaction = () => {
          return contract.provider.getTransaction(receipt.transactionHash);
        };
        event.getTransactionReceipt = () => {
          return Promise.resolve(receipt);
        };
        return event;
      });
      return receipt;
    });
  };
}
function buildCall(contract, fragment, collapseSimple) {
  const signerOrProvider = contract.signer || contract.provider;
  return function(...args) {
    return __awaiter5(this, void 0, void 0, function* () {
      let blockTag = void 0;
      if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
        const overrides = shallowCopy(args.pop());
        if (overrides.blockTag != null) {
          blockTag = yield overrides.blockTag;
        }
        delete overrides.blockTag;
        args.push(overrides);
      }
      if (contract.deployTransaction != null) {
        yield contract._deployed(blockTag);
      }
      const tx = yield populateTransaction(contract, fragment, args);
      const result = yield signerOrProvider.call(tx, blockTag);
      try {
        let value2 = contract.interface.decodeFunctionResult(fragment, result);
        if (collapseSimple && fragment.outputs.length === 1) {
          value2 = value2[0];
        }
        return value2;
      } catch (error) {
        if (error.code === Logger.errors.CALL_EXCEPTION) {
          error.address = contract.address;
          error.args = args;
          error.transaction = tx;
        }
        throw error;
      }
    });
  };
}
function buildSend(contract, fragment) {
  return function(...args) {
    return __awaiter5(this, void 0, void 0, function* () {
      if (!contract.signer) {
        logger19.throwError("sending a transaction requires a signer", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "sendTransaction"
        });
      }
      if (contract.deployTransaction != null) {
        yield contract._deployed();
      }
      const txRequest = yield populateTransaction(contract, fragment, args);
      const tx = yield contract.signer.sendTransaction(txRequest);
      addContractWait(contract, tx);
      return tx;
    });
  };
}
function buildDefault(contract, fragment, collapseSimple) {
  if (fragment.constant) {
    return buildCall(contract, fragment, collapseSimple);
  }
  return buildSend(contract, fragment);
}
function getEventTag(filter2) {
  if (filter2.address && (filter2.topics == null || filter2.topics.length === 0)) {
    return "*";
  }
  return (filter2.address || "*") + "@" + (filter2.topics ? filter2.topics.map((topic) => {
    if (Array.isArray(topic)) {
      return topic.join("|");
    }
    return topic;
  }).join(":") : "");
}
var RunningEvent = class {
  constructor(tag, filter2) {
    defineReadOnly(this, "tag", tag);
    defineReadOnly(this, "filter", filter2);
    this._listeners = [];
  }
  addListener(listener, once) {
    this._listeners.push({ listener, once });
  }
  removeListener(listener) {
    let done = false;
    this._listeners = this._listeners.filter((item) => {
      if (done || item.listener !== listener) {
        return true;
      }
      done = true;
      return false;
    });
  }
  removeAllListeners() {
    this._listeners = [];
  }
  listeners() {
    return this._listeners.map((i6) => i6.listener);
  }
  listenerCount() {
    return this._listeners.length;
  }
  run(args) {
    const listenerCount = this.listenerCount();
    this._listeners = this._listeners.filter((item) => {
      const argsCopy = args.slice();
      setTimeout(() => {
        item.listener.apply(this, argsCopy);
      }, 0);
      return !item.once;
    });
    return listenerCount;
  }
  prepareEvent(event) {
  }
  getEmit(event) {
    return [event];
  }
};
var ErrorRunningEvent = class extends RunningEvent {
  constructor() {
    super("error", null);
  }
};
var FragmentRunningEvent = class extends RunningEvent {
  constructor(address, contractInterface, fragment, topics) {
    const filter2 = {
      address
    };
    let topic = contractInterface.getEventTopic(fragment);
    if (topics) {
      if (topic !== topics[0]) {
        logger19.throwArgumentError("topic mismatch", "topics", topics);
      }
      filter2.topics = topics.slice();
    } else {
      filter2.topics = [topic];
    }
    super(getEventTag(filter2), filter2);
    defineReadOnly(this, "address", address);
    defineReadOnly(this, "interface", contractInterface);
    defineReadOnly(this, "fragment", fragment);
  }
  prepareEvent(event) {
    super.prepareEvent(event);
    event.event = this.fragment.name;
    event.eventSignature = this.fragment.format();
    event.decode = (data, topics) => {
      return this.interface.decodeEventLog(this.fragment, data, topics);
    };
    try {
      event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);
    } catch (error) {
      event.args = null;
      event.decodeError = error;
    }
  }
  getEmit(event) {
    const errors = checkResultErrors(event.args);
    if (errors.length) {
      throw errors[0].error;
    }
    const args = (event.args || []).slice();
    args.push(event);
    return args;
  }
};
var WildcardRunningEvent = class extends RunningEvent {
  constructor(address, contractInterface) {
    super("*", { address });
    defineReadOnly(this, "address", address);
    defineReadOnly(this, "interface", contractInterface);
  }
  prepareEvent(event) {
    super.prepareEvent(event);
    try {
      const parsed = this.interface.parseLog(event);
      event.event = parsed.name;
      event.eventSignature = parsed.signature;
      event.decode = (data, topics) => {
        return this.interface.decodeEventLog(parsed.eventFragment, data, topics);
      };
      event.args = parsed.args;
    } catch (error) {
    }
  }
};
var BaseContract = class {
  constructor(addressOrName, contractInterface, signerOrProvider) {
    logger19.checkNew(new.target, Contract);
    defineReadOnly(this, "interface", getStatic(new.target, "getInterface")(contractInterface));
    if (signerOrProvider == null) {
      defineReadOnly(this, "provider", null);
      defineReadOnly(this, "signer", null);
    } else if (Signer.isSigner(signerOrProvider)) {
      defineReadOnly(this, "provider", signerOrProvider.provider || null);
      defineReadOnly(this, "signer", signerOrProvider);
    } else if (Provider.isProvider(signerOrProvider)) {
      defineReadOnly(this, "provider", signerOrProvider);
      defineReadOnly(this, "signer", null);
    } else {
      logger19.throwArgumentError("invalid signer or provider", "signerOrProvider", signerOrProvider);
    }
    defineReadOnly(this, "callStatic", {});
    defineReadOnly(this, "estimateGas", {});
    defineReadOnly(this, "functions", {});
    defineReadOnly(this, "populateTransaction", {});
    defineReadOnly(this, "filters", {});
    {
      const uniqueFilters = {};
      Object.keys(this.interface.events).forEach((eventSignature) => {
        const event = this.interface.events[eventSignature];
        defineReadOnly(this.filters, eventSignature, (...args) => {
          return {
            address: this.address,
            topics: this.interface.encodeFilterTopics(event, args)
          };
        });
        if (!uniqueFilters[event.name]) {
          uniqueFilters[event.name] = [];
        }
        uniqueFilters[event.name].push(eventSignature);
      });
      Object.keys(uniqueFilters).forEach((name2) => {
        const filters = uniqueFilters[name2];
        if (filters.length === 1) {
          defineReadOnly(this.filters, name2, this.filters[filters[0]]);
        } else {
          logger19.warn(`Duplicate definition of ${name2} (${filters.join(", ")})`);
        }
      });
    }
    defineReadOnly(this, "_runningEvents", {});
    defineReadOnly(this, "_wrappedEmits", {});
    if (addressOrName == null) {
      logger19.throwArgumentError("invalid contract address or ENS name", "addressOrName", addressOrName);
    }
    defineReadOnly(this, "address", addressOrName);
    if (this.provider) {
      defineReadOnly(this, "resolvedAddress", resolveName(this.provider, addressOrName));
    } else {
      try {
        defineReadOnly(this, "resolvedAddress", Promise.resolve(getAddress(addressOrName)));
      } catch (error) {
        logger19.throwError("provider is required to use ENS name as contract address", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "new Contract"
        });
      }
    }
    this.resolvedAddress.catch((e6) => {
    });
    const uniqueNames = {};
    const uniqueSignatures = {};
    Object.keys(this.interface.functions).forEach((signature2) => {
      const fragment = this.interface.functions[signature2];
      if (uniqueSignatures[signature2]) {
        logger19.warn(`Duplicate ABI entry for ${JSON.stringify(signature2)}`);
        return;
      }
      uniqueSignatures[signature2] = true;
      {
        const name2 = fragment.name;
        if (!uniqueNames[`%${name2}`]) {
          uniqueNames[`%${name2}`] = [];
        }
        uniqueNames[`%${name2}`].push(signature2);
      }
      if (this[signature2] == null) {
        defineReadOnly(this, signature2, buildDefault(this, fragment, true));
      }
      if (this.functions[signature2] == null) {
        defineReadOnly(this.functions, signature2, buildDefault(this, fragment, false));
      }
      if (this.callStatic[signature2] == null) {
        defineReadOnly(this.callStatic, signature2, buildCall(this, fragment, true));
      }
      if (this.populateTransaction[signature2] == null) {
        defineReadOnly(this.populateTransaction, signature2, buildPopulate(this, fragment));
      }
      if (this.estimateGas[signature2] == null) {
        defineReadOnly(this.estimateGas, signature2, buildEstimate(this, fragment));
      }
    });
    Object.keys(uniqueNames).forEach((name2) => {
      const signatures = uniqueNames[name2];
      if (signatures.length > 1) {
        return;
      }
      name2 = name2.substring(1);
      const signature2 = signatures[0];
      try {
        if (this[name2] == null) {
          defineReadOnly(this, name2, this[signature2]);
        }
      } catch (e6) {
      }
      if (this.functions[name2] == null) {
        defineReadOnly(this.functions, name2, this.functions[signature2]);
      }
      if (this.callStatic[name2] == null) {
        defineReadOnly(this.callStatic, name2, this.callStatic[signature2]);
      }
      if (this.populateTransaction[name2] == null) {
        defineReadOnly(this.populateTransaction, name2, this.populateTransaction[signature2]);
      }
      if (this.estimateGas[name2] == null) {
        defineReadOnly(this.estimateGas, name2, this.estimateGas[signature2]);
      }
    });
  }
  static getContractAddress(transaction) {
    return getContractAddress(transaction);
  }
  static getInterface(contractInterface) {
    if (Interface.isInterface(contractInterface)) {
      return contractInterface;
    }
    return new Interface(contractInterface);
  }
  deployed() {
    return this._deployed();
  }
  _deployed(blockTag) {
    if (!this._deployedPromise) {
      if (this.deployTransaction) {
        this._deployedPromise = this.deployTransaction.wait().then(() => {
          return this;
        });
      } else {
        this._deployedPromise = this.provider.getCode(this.address, blockTag).then((code) => {
          if (code === "0x") {
            logger19.throwError("contract not deployed", Logger.errors.UNSUPPORTED_OPERATION, {
              contractAddress: this.address,
              operation: "getDeployed"
            });
          }
          return this;
        });
      }
    }
    return this._deployedPromise;
  }
  fallback(overrides) {
    if (!this.signer) {
      logger19.throwError("sending a transactions require a signer", Logger.errors.UNSUPPORTED_OPERATION, { operation: "sendTransaction(fallback)" });
    }
    const tx = shallowCopy(overrides || {});
    ["from", "to"].forEach(function(key2) {
      if (tx[key2] == null) {
        return;
      }
      logger19.throwError("cannot override " + key2, Logger.errors.UNSUPPORTED_OPERATION, { operation: key2 });
    });
    tx.to = this.resolvedAddress;
    return this.deployed().then(() => {
      return this.signer.sendTransaction(tx);
    });
  }
  connect(signerOrProvider) {
    if (typeof signerOrProvider === "string") {
      signerOrProvider = new VoidSigner(signerOrProvider, this.provider);
    }
    const contract = new this.constructor(this.address, this.interface, signerOrProvider);
    if (this.deployTransaction) {
      defineReadOnly(contract, "deployTransaction", this.deployTransaction);
    }
    return contract;
  }
  attach(addressOrName) {
    return new this.constructor(addressOrName, this.interface, this.signer || this.provider);
  }
  static isIndexed(value2) {
    return Indexed.isIndexed(value2);
  }
  _normalizeRunningEvent(runningEvent) {
    if (this._runningEvents[runningEvent.tag]) {
      return this._runningEvents[runningEvent.tag];
    }
    return runningEvent;
  }
  _getRunningEvent(eventName) {
    if (typeof eventName === "string") {
      if (eventName === "error") {
        return this._normalizeRunningEvent(new ErrorRunningEvent());
      }
      if (eventName === "event") {
        return this._normalizeRunningEvent(new RunningEvent("event", null));
      }
      if (eventName === "*") {
        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
      }
      const fragment = this.interface.getEvent(eventName);
      return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));
    }
    if (eventName.topics && eventName.topics.length > 0) {
      try {
        const topic = eventName.topics[0];
        if (typeof topic !== "string") {
          throw new Error("invalid topic");
        }
        const fragment = this.interface.getEvent(topic);
        return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));
      } catch (error) {
      }
      const filter2 = {
        address: this.address,
        topics: eventName.topics
      };
      return this._normalizeRunningEvent(new RunningEvent(getEventTag(filter2), filter2));
    }
    return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
  }
  _checkRunningEvents(runningEvent) {
    if (runningEvent.listenerCount() === 0) {
      delete this._runningEvents[runningEvent.tag];
      const emit = this._wrappedEmits[runningEvent.tag];
      if (emit && runningEvent.filter) {
        this.provider.off(runningEvent.filter, emit);
        delete this._wrappedEmits[runningEvent.tag];
      }
    }
  }
  _wrapEvent(runningEvent, log, listener) {
    const event = deepCopy(log);
    event.removeListener = () => {
      if (!listener) {
        return;
      }
      runningEvent.removeListener(listener);
      this._checkRunningEvents(runningEvent);
    };
    event.getBlock = () => {
      return this.provider.getBlock(log.blockHash);
    };
    event.getTransaction = () => {
      return this.provider.getTransaction(log.transactionHash);
    };
    event.getTransactionReceipt = () => {
      return this.provider.getTransactionReceipt(log.transactionHash);
    };
    runningEvent.prepareEvent(event);
    return event;
  }
  _addEventListener(runningEvent, listener, once) {
    if (!this.provider) {
      logger19.throwError("events require a provider or a signer with a provider", Logger.errors.UNSUPPORTED_OPERATION, { operation: "once" });
    }
    runningEvent.addListener(listener, once);
    this._runningEvents[runningEvent.tag] = runningEvent;
    if (!this._wrappedEmits[runningEvent.tag]) {
      const wrappedEmit = (log) => {
        let event = this._wrapEvent(runningEvent, log, listener);
        if (event.decodeError == null) {
          try {
            const args = runningEvent.getEmit(event);
            this.emit(runningEvent.filter, ...args);
          } catch (error) {
            event.decodeError = error.error;
          }
        }
        if (runningEvent.filter != null) {
          this.emit("event", event);
        }
        if (event.decodeError != null) {
          this.emit("error", event.decodeError, event);
        }
      };
      this._wrappedEmits[runningEvent.tag] = wrappedEmit;
      if (runningEvent.filter != null) {
        this.provider.on(runningEvent.filter, wrappedEmit);
      }
    }
  }
  queryFilter(event, fromBlockOrBlockhash, toBlock) {
    const runningEvent = this._getRunningEvent(event);
    const filter2 = shallowCopy(runningEvent.filter);
    if (typeof fromBlockOrBlockhash === "string" && isHexString(fromBlockOrBlockhash, 32)) {
      if (toBlock != null) {
        logger19.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", toBlock);
      }
      filter2.blockHash = fromBlockOrBlockhash;
    } else {
      filter2.fromBlock = fromBlockOrBlockhash != null ? fromBlockOrBlockhash : 0;
      filter2.toBlock = toBlock != null ? toBlock : "latest";
    }
    return this.provider.getLogs(filter2).then((logs) => {
      return logs.map((log) => this._wrapEvent(runningEvent, log, null));
    });
  }
  on(event, listener) {
    this._addEventListener(this._getRunningEvent(event), listener, false);
    return this;
  }
  once(event, listener) {
    this._addEventListener(this._getRunningEvent(event), listener, true);
    return this;
  }
  emit(eventName, ...args) {
    if (!this.provider) {
      return false;
    }
    const runningEvent = this._getRunningEvent(eventName);
    const result = runningEvent.run(args) > 0;
    this._checkRunningEvents(runningEvent);
    return result;
  }
  listenerCount(eventName) {
    if (!this.provider) {
      return 0;
    }
    if (eventName == null) {
      return Object.keys(this._runningEvents).reduce((accum, key2) => {
        return accum + this._runningEvents[key2].listenerCount();
      }, 0);
    }
    return this._getRunningEvent(eventName).listenerCount();
  }
  listeners(eventName) {
    if (!this.provider) {
      return [];
    }
    if (eventName == null) {
      const result = [];
      for (let tag in this._runningEvents) {
        this._runningEvents[tag].listeners().forEach((listener) => {
          result.push(listener);
        });
      }
      return result;
    }
    return this._getRunningEvent(eventName).listeners();
  }
  removeAllListeners(eventName) {
    if (!this.provider) {
      return this;
    }
    if (eventName == null) {
      for (const tag in this._runningEvents) {
        const runningEvent2 = this._runningEvents[tag];
        runningEvent2.removeAllListeners();
        this._checkRunningEvents(runningEvent2);
      }
      return this;
    }
    const runningEvent = this._getRunningEvent(eventName);
    runningEvent.removeAllListeners();
    this._checkRunningEvents(runningEvent);
    return this;
  }
  off(eventName, listener) {
    if (!this.provider) {
      return this;
    }
    const runningEvent = this._getRunningEvent(eventName);
    runningEvent.removeListener(listener);
    this._checkRunningEvents(runningEvent);
    return this;
  }
  removeListener(eventName, listener) {
    return this.off(eventName, listener);
  }
};
var Contract = class extends BaseContract {
};
var ContractFactory = class {
  constructor(contractInterface, bytecode, signer) {
    let bytecodeHex = null;
    if (typeof bytecode === "string") {
      bytecodeHex = bytecode;
    } else if (isBytes(bytecode)) {
      bytecodeHex = hexlify(bytecode);
    } else if (bytecode && typeof bytecode.object === "string") {
      bytecodeHex = bytecode.object;
    } else {
      bytecodeHex = "!";
    }
    if (bytecodeHex.substring(0, 2) !== "0x") {
      bytecodeHex = "0x" + bytecodeHex;
    }
    if (!isHexString(bytecodeHex) || bytecodeHex.length % 2) {
      logger19.throwArgumentError("invalid bytecode", "bytecode", bytecode);
    }
    if (signer && !Signer.isSigner(signer)) {
      logger19.throwArgumentError("invalid signer", "signer", signer);
    }
    defineReadOnly(this, "bytecode", bytecodeHex);
    defineReadOnly(this, "interface", getStatic(new.target, "getInterface")(contractInterface));
    defineReadOnly(this, "signer", signer || null);
  }
  getDeployTransaction(...args) {
    let tx = {};
    if (args.length === this.interface.deploy.inputs.length + 1 && typeof args[args.length - 1] === "object") {
      tx = shallowCopy(args.pop());
      for (const key2 in tx) {
        if (!allowedTransactionKeys3[key2]) {
          throw new Error("unknown transaction override " + key2);
        }
      }
    }
    ["data", "from", "to"].forEach((key2) => {
      if (tx[key2] == null) {
        return;
      }
      logger19.throwError("cannot override " + key2, Logger.errors.UNSUPPORTED_OPERATION, { operation: key2 });
    });
    if (tx.value) {
      const value2 = BigNumber.from(tx.value);
      if (!value2.isZero() && !this.interface.deploy.payable) {
        logger19.throwError("non-payable constructor cannot override value", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "overrides.value",
          value: tx.value
        });
      }
    }
    logger19.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
    tx.data = hexlify(concat([
      this.bytecode,
      this.interface.encodeDeploy(args)
    ]));
    return tx;
  }
  deploy(...args) {
    return __awaiter5(this, void 0, void 0, function* () {
      let overrides = {};
      if (args.length === this.interface.deploy.inputs.length + 1) {
        overrides = args.pop();
      }
      logger19.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
      const params = yield resolveAddresses(this.signer, args, this.interface.deploy.inputs);
      params.push(overrides);
      const unsignedTx = this.getDeployTransaction(...params);
      const tx = yield this.signer.sendTransaction(unsignedTx);
      const address = getStatic(this.constructor, "getContractAddress")(tx);
      const contract = getStatic(this.constructor, "getContract")(address, this.interface, this.signer);
      addContractWait(contract, tx);
      defineReadOnly(contract, "deployTransaction", tx);
      return contract;
    });
  }
  attach(address) {
    return this.constructor.getContract(address, this.interface, this.signer);
  }
  connect(signer) {
    return new this.constructor(this.interface, this.bytecode, signer);
  }
  static fromSolidity(compilerOutput, signer) {
    if (compilerOutput == null) {
      logger19.throwError("missing compiler output", Logger.errors.MISSING_ARGUMENT, { argument: "compilerOutput" });
    }
    if (typeof compilerOutput === "string") {
      compilerOutput = JSON.parse(compilerOutput);
    }
    const abi = compilerOutput.abi;
    let bytecode = null;
    if (compilerOutput.bytecode) {
      bytecode = compilerOutput.bytecode;
    } else if (compilerOutput.evm && compilerOutput.evm.bytecode) {
      bytecode = compilerOutput.evm.bytecode;
    }
    return new this(abi, bytecode, signer);
  }
  static getInterface(contractInterface) {
    return Contract.getInterface(contractInterface);
  }
  static getContractAddress(tx) {
    return getContractAddress(tx);
  }
  static getContract(address, contractInterface, signer) {
    return new Contract(address, contractInterface, signer);
  }
};

// node_modules/ethers/lib.esm/ethers.js
init_lib3();
init_lib13();
init_lib23();
init_lib8();

// node_modules/@ethersproject/providers/lib.esm/index.js
var lib_exports21 = {};
__export(lib_exports21, {
  AlchemyProvider: () => AlchemyProvider,
  AlchemyWebSocketProvider: () => AlchemyWebSocketProvider,
  AnkrProvider: () => AnkrProvider,
  BaseProvider: () => BaseProvider,
  CloudflareProvider: () => CloudflareProvider,
  EtherscanProvider: () => EtherscanProvider,
  FallbackProvider: () => FallbackProvider,
  Formatter: () => Formatter,
  InfuraProvider: () => InfuraProvider,
  InfuraWebSocketProvider: () => InfuraWebSocketProvider,
  IpcProvider: () => IpcProvider,
  JsonRpcBatchProvider: () => JsonRpcBatchProvider,
  JsonRpcProvider: () => JsonRpcProvider,
  JsonRpcSigner: () => JsonRpcSigner,
  NodesmithProvider: () => NodesmithProvider,
  PocketProvider: () => PocketProvider,
  Provider: () => Provider,
  Resolver: () => Resolver,
  StaticJsonRpcProvider: () => StaticJsonRpcProvider,
  UrlJsonRpcProvider: () => UrlJsonRpcProvider,
  Web3Provider: () => Web3Provider,
  WebSocketProvider: () => WebSocketProvider,
  getDefaultProvider: () => getDefaultProvider,
  getNetwork: () => getNetwork,
  isCommunityResourcable: () => isCommunityResourcable,
  isCommunityResource: () => isCommunityResource,
  showThrottleMessage: () => showThrottleMessage
});
init_lib12();

// node_modules/@ethersproject/networks/lib.esm/index.js
init_lib();

// node_modules/@ethersproject/networks/lib.esm/_version.js
var version21 = "networks/5.6.1";

// node_modules/@ethersproject/networks/lib.esm/index.js
var logger27 = new Logger(version21);
function isRenetworkable(value2) {
  return value2 && typeof value2.renetwork === "function";
}
function ethDefaultProvider(network) {
  const func = function(providers, options) {
    if (options == null) {
      options = {};
    }
    const providerList = [];
    if (providers.InfuraProvider && options.infura !== "-") {
      try {
        providerList.push(new providers.InfuraProvider(network, options.infura));
      } catch (error) {
      }
    }
    if (providers.EtherscanProvider && options.etherscan !== "-") {
      try {
        providerList.push(new providers.EtherscanProvider(network, options.etherscan));
      } catch (error) {
      }
    }
    if (providers.AlchemyProvider && options.alchemy !== "-") {
      try {
        providerList.push(new providers.AlchemyProvider(network, options.alchemy));
      } catch (error) {
      }
    }
    if (providers.PocketProvider && options.pocket !== "-") {
      const skip2 = ["goerli", "ropsten", "rinkeby"];
      try {
        const provider = new providers.PocketProvider(network);
        if (provider.network && skip2.indexOf(provider.network.name) === -1) {
          providerList.push(provider);
        }
      } catch (error) {
      }
    }
    if (providers.CloudflareProvider && options.cloudflare !== "-") {
      try {
        providerList.push(new providers.CloudflareProvider(network));
      } catch (error) {
      }
    }
    if (providers.AnkrProvider && options.ankr !== "-") {
      try {
        providerList.push(new providers.AnkrProvider(network, options.ankr));
      } catch (error) {
      }
    }
    if (providerList.length === 0) {
      return null;
    }
    if (providers.FallbackProvider) {
      let quorum = 1;
      if (options.quorum != null) {
        quorum = options.quorum;
      } else if (network === "homestead") {
        quorum = 2;
      }
      return new providers.FallbackProvider(providerList, quorum);
    }
    return providerList[0];
  };
  func.renetwork = function(network2) {
    return ethDefaultProvider(network2);
  };
  return func;
}
function etcDefaultProvider(url, network) {
  const func = function(providers, options) {
    if (providers.JsonRpcProvider) {
      return new providers.JsonRpcProvider(url, network);
    }
    return null;
  };
  func.renetwork = function(network2) {
    return etcDefaultProvider(url, network2);
  };
  return func;
}
var homestead = {
  chainId: 1,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "homestead",
  _defaultProvider: ethDefaultProvider("homestead")
};
var ropsten = {
  chainId: 3,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "ropsten",
  _defaultProvider: ethDefaultProvider("ropsten")
};
var classicMordor = {
  chainId: 63,
  name: "classicMordor",
  _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/mordor", "classicMordor")
};
var networks = {
  unspecified: { chainId: 0, name: "unspecified" },
  homestead,
  mainnet: homestead,
  morden: { chainId: 2, name: "morden" },
  ropsten,
  testnet: ropsten,
  rinkeby: {
    chainId: 4,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "rinkeby",
    _defaultProvider: ethDefaultProvider("rinkeby")
  },
  kovan: {
    chainId: 42,
    name: "kovan",
    _defaultProvider: ethDefaultProvider("kovan")
  },
  goerli: {
    chainId: 5,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "goerli",
    _defaultProvider: ethDefaultProvider("goerli")
  },
  kintsugi: { chainId: 1337702, name: "kintsugi" },
  classic: {
    chainId: 61,
    name: "classic",
    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/etc", "classic")
  },
  classicMorden: { chainId: 62, name: "classicMorden" },
  classicMordor,
  classicTestnet: classicMordor,
  classicKotti: {
    chainId: 6,
    name: "classicKotti",
    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/kotti", "classicKotti")
  },
  xdai: { chainId: 100, name: "xdai" },
  matic: { chainId: 137, name: "matic" },
  maticmum: { chainId: 80001, name: "maticmum" },
  optimism: { chainId: 10, name: "optimism" },
  "optimism-kovan": { chainId: 69, name: "optimism-kovan" },
  "optimism-goerli": { chainId: 420, name: "optimism-goerli" },
  arbitrum: { chainId: 42161, name: "arbitrum" },
  "arbitrum-rinkeby": { chainId: 421611, name: "arbitrum-rinkeby" },
  bnb: { chainId: 56, name: "bnb" },
  bnbt: { chainId: 97, name: "bnbt" }
};
function getNetwork(network) {
  if (network == null) {
    return null;
  }
  if (typeof network === "number") {
    for (const name2 in networks) {
      const standard2 = networks[name2];
      if (standard2.chainId === network) {
        return {
          name: standard2.name,
          chainId: standard2.chainId,
          ensAddress: standard2.ensAddress || null,
          _defaultProvider: standard2._defaultProvider || null
        };
      }
    }
    return {
      chainId: network,
      name: "unknown"
    };
  }
  if (typeof network === "string") {
    const standard2 = networks[network];
    if (standard2 == null) {
      return null;
    }
    return {
      name: standard2.name,
      chainId: standard2.chainId,
      ensAddress: standard2.ensAddress,
      _defaultProvider: standard2._defaultProvider || null
    };
  }
  const standard = networks[network.name];
  if (!standard) {
    if (typeof network.chainId !== "number") {
      logger27.throwArgumentError("invalid network chainId", "network", network);
    }
    return network;
  }
  if (network.chainId !== 0 && network.chainId !== standard.chainId) {
    logger27.throwArgumentError("network chainId mismatch", "network", network);
  }
  let defaultProvider = network._defaultProvider || null;
  if (defaultProvider == null && standard._defaultProvider) {
    if (isRenetworkable(standard._defaultProvider)) {
      defaultProvider = standard._defaultProvider.renetwork(network);
    } else {
      defaultProvider = standard._defaultProvider;
    }
  }
  return {
    name: network.name,
    chainId: standard.chainId,
    ensAddress: network.ensAddress || standard.ensAddress || null,
    _defaultProvider: defaultProvider
  };
}

// node_modules/@ethersproject/providers/lib.esm/base-provider.js
init_lib12();
init_lib16();
init_lib3();
init_lib2();
init_lib8();
init_lib10();
init_lib4();
init_lib17();
init_lib9();
init_lib25();
var import_bech32 = __toESM(require_bech32());
init_lib();

// node_modules/@ethersproject/providers/lib.esm/_version.js
var version23 = "providers/5.6.2";

// node_modules/@ethersproject/providers/lib.esm/formatter.js
init_lib7();
init_lib3();
init_lib2();
init_lib8();
init_lib4();
init_lib15();
init_lib();
var logger29 = new Logger(version23);
var Formatter = class {
  constructor() {
    logger29.checkNew(new.target, Formatter);
    this.formats = this.getDefaultFormats();
  }
  getDefaultFormats() {
    const formats = {};
    const address = this.address.bind(this);
    const bigNumber = this.bigNumber.bind(this);
    const blockTag = this.blockTag.bind(this);
    const data = this.data.bind(this);
    const hash3 = this.hash.bind(this);
    const hex = this.hex.bind(this);
    const number = this.number.bind(this);
    const type = this.type.bind(this);
    const strictData = (v9) => {
      return this.data(v9, true);
    };
    formats.transaction = {
      hash: hash3,
      type,
      accessList: Formatter.allowNull(this.accessList.bind(this), null),
      blockHash: Formatter.allowNull(hash3, null),
      blockNumber: Formatter.allowNull(number, null),
      transactionIndex: Formatter.allowNull(number, null),
      confirmations: Formatter.allowNull(number, null),
      from: address,
      gasPrice: Formatter.allowNull(bigNumber),
      maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
      maxFeePerGas: Formatter.allowNull(bigNumber),
      gasLimit: bigNumber,
      to: Formatter.allowNull(address, null),
      value: bigNumber,
      nonce: number,
      data,
      r: Formatter.allowNull(this.uint256),
      s: Formatter.allowNull(this.uint256),
      v: Formatter.allowNull(number),
      creates: Formatter.allowNull(address, null),
      raw: Formatter.allowNull(data)
    };
    formats.transactionRequest = {
      from: Formatter.allowNull(address),
      nonce: Formatter.allowNull(number),
      gasLimit: Formatter.allowNull(bigNumber),
      gasPrice: Formatter.allowNull(bigNumber),
      maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
      maxFeePerGas: Formatter.allowNull(bigNumber),
      to: Formatter.allowNull(address),
      value: Formatter.allowNull(bigNumber),
      data: Formatter.allowNull(strictData),
      type: Formatter.allowNull(number),
      accessList: Formatter.allowNull(this.accessList.bind(this), null)
    };
    formats.receiptLog = {
      transactionIndex: number,
      blockNumber: number,
      transactionHash: hash3,
      address,
      topics: Formatter.arrayOf(hash3),
      data,
      logIndex: number,
      blockHash: hash3
    };
    formats.receipt = {
      to: Formatter.allowNull(this.address, null),
      from: Formatter.allowNull(this.address, null),
      contractAddress: Formatter.allowNull(address, null),
      transactionIndex: number,
      root: Formatter.allowNull(hex),
      gasUsed: bigNumber,
      logsBloom: Formatter.allowNull(data),
      blockHash: hash3,
      transactionHash: hash3,
      logs: Formatter.arrayOf(this.receiptLog.bind(this)),
      blockNumber: number,
      confirmations: Formatter.allowNull(number, null),
      cumulativeGasUsed: bigNumber,
      effectiveGasPrice: Formatter.allowNull(bigNumber),
      status: Formatter.allowNull(number),
      type
    };
    formats.block = {
      hash: Formatter.allowNull(hash3),
      parentHash: hash3,
      number,
      timestamp: number,
      nonce: Formatter.allowNull(hex),
      difficulty: this.difficulty.bind(this),
      gasLimit: bigNumber,
      gasUsed: bigNumber,
      miner: Formatter.allowNull(address),
      extraData: data,
      transactions: Formatter.allowNull(Formatter.arrayOf(hash3)),
      baseFeePerGas: Formatter.allowNull(bigNumber)
    };
    formats.blockWithTransactions = shallowCopy(formats.block);
    formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));
    formats.filter = {
      fromBlock: Formatter.allowNull(blockTag, void 0),
      toBlock: Formatter.allowNull(blockTag, void 0),
      blockHash: Formatter.allowNull(hash3, void 0),
      address: Formatter.allowNull(address, void 0),
      topics: Formatter.allowNull(this.topics.bind(this), void 0)
    };
    formats.filterLog = {
      blockNumber: Formatter.allowNull(number),
      blockHash: Formatter.allowNull(hash3),
      transactionIndex: number,
      removed: Formatter.allowNull(this.boolean.bind(this)),
      address,
      data: Formatter.allowFalsish(data, "0x"),
      topics: Formatter.arrayOf(hash3),
      transactionHash: hash3,
      logIndex: number
    };
    return formats;
  }
  accessList(accessList) {
    return accessListify(accessList || []);
  }
  number(number) {
    if (number === "0x") {
      return 0;
    }
    return BigNumber.from(number).toNumber();
  }
  type(number) {
    if (number === "0x" || number == null) {
      return 0;
    }
    return BigNumber.from(number).toNumber();
  }
  bigNumber(value2) {
    return BigNumber.from(value2);
  }
  boolean(value2) {
    if (typeof value2 === "boolean") {
      return value2;
    }
    if (typeof value2 === "string") {
      value2 = value2.toLowerCase();
      if (value2 === "true") {
        return true;
      }
      if (value2 === "false") {
        return false;
      }
    }
    throw new Error("invalid boolean - " + value2);
  }
  hex(value2, strict) {
    if (typeof value2 === "string") {
      if (!strict && value2.substring(0, 2) !== "0x") {
        value2 = "0x" + value2;
      }
      if (isHexString(value2)) {
        return value2.toLowerCase();
      }
    }
    return logger29.throwArgumentError("invalid hash", "value", value2);
  }
  data(value2, strict) {
    const result = this.hex(value2, strict);
    if (result.length % 2 !== 0) {
      throw new Error("invalid data; odd-length - " + value2);
    }
    return result;
  }
  address(value2) {
    return getAddress(value2);
  }
  callAddress(value2) {
    if (!isHexString(value2, 32)) {
      return null;
    }
    const address = getAddress(hexDataSlice(value2, 12));
    return address === AddressZero ? null : address;
  }
  contractAddress(value2) {
    return getContractAddress(value2);
  }
  blockTag(blockTag) {
    if (blockTag == null) {
      return "latest";
    }
    if (blockTag === "earliest") {
      return "0x0";
    }
    if (blockTag === "latest" || blockTag === "pending") {
      return blockTag;
    }
    if (typeof blockTag === "number" || isHexString(blockTag)) {
      return hexValue(blockTag);
    }
    throw new Error("invalid blockTag");
  }
  hash(value2, strict) {
    const result = this.hex(value2, strict);
    if (hexDataLength(result) !== 32) {
      return logger29.throwArgumentError("invalid hash", "value", value2);
    }
    return result;
  }
  difficulty(value2) {
    if (value2 == null) {
      return null;
    }
    const v9 = BigNumber.from(value2);
    try {
      return v9.toNumber();
    } catch (error) {
    }
    return null;
  }
  uint256(value2) {
    if (!isHexString(value2)) {
      throw new Error("invalid uint256");
    }
    return hexZeroPad(value2, 32);
  }
  _block(value2, format) {
    if (value2.author != null && value2.miner == null) {
      value2.miner = value2.author;
    }
    const difficulty = value2._difficulty != null ? value2._difficulty : value2.difficulty;
    const result = Formatter.check(format, value2);
    result._difficulty = difficulty == null ? null : BigNumber.from(difficulty);
    return result;
  }
  block(value2) {
    return this._block(value2, this.formats.block);
  }
  blockWithTransactions(value2) {
    return this._block(value2, this.formats.blockWithTransactions);
  }
  transactionRequest(value2) {
    return Formatter.check(this.formats.transactionRequest, value2);
  }
  transactionResponse(transaction) {
    if (transaction.gas != null && transaction.gasLimit == null) {
      transaction.gasLimit = transaction.gas;
    }
    if (transaction.to && BigNumber.from(transaction.to).isZero()) {
      transaction.to = "0x0000000000000000000000000000000000000000";
    }
    if (transaction.input != null && transaction.data == null) {
      transaction.data = transaction.input;
    }
    if (transaction.to == null && transaction.creates == null) {
      transaction.creates = this.contractAddress(transaction);
    }
    if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) {
      transaction.accessList = [];
    }
    const result = Formatter.check(this.formats.transaction, transaction);
    if (transaction.chainId != null) {
      let chainId = transaction.chainId;
      if (isHexString(chainId)) {
        chainId = BigNumber.from(chainId).toNumber();
      }
      result.chainId = chainId;
    } else {
      let chainId = transaction.networkId;
      if (chainId == null && result.v == null) {
        chainId = transaction.chainId;
      }
      if (isHexString(chainId)) {
        chainId = BigNumber.from(chainId).toNumber();
      }
      if (typeof chainId !== "number" && result.v != null) {
        chainId = (result.v - 35) / 2;
        if (chainId < 0) {
          chainId = 0;
        }
        chainId = parseInt(chainId);
      }
      if (typeof chainId !== "number") {
        chainId = 0;
      }
      result.chainId = chainId;
    }
    if (result.blockHash && result.blockHash.replace(/0/g, "") === "x") {
      result.blockHash = null;
    }
    return result;
  }
  transaction(value2) {
    return parse(value2);
  }
  receiptLog(value2) {
    return Formatter.check(this.formats.receiptLog, value2);
  }
  receipt(value2) {
    const result = Formatter.check(this.formats.receipt, value2);
    if (result.root != null) {
      if (result.root.length <= 4) {
        const value3 = BigNumber.from(result.root).toNumber();
        if (value3 === 0 || value3 === 1) {
          if (result.status != null && result.status !== value3) {
            logger29.throwArgumentError("alt-root-status/status mismatch", "value", { root: result.root, status: result.status });
          }
          result.status = value3;
          delete result.root;
        } else {
          logger29.throwArgumentError("invalid alt-root-status", "value.root", result.root);
        }
      } else if (result.root.length !== 66) {
        logger29.throwArgumentError("invalid root hash", "value.root", result.root);
      }
    }
    if (result.status != null) {
      result.byzantium = true;
    }
    return result;
  }
  topics(value2) {
    if (Array.isArray(value2)) {
      return value2.map((v9) => this.topics(v9));
    } else if (value2 != null) {
      return this.hash(value2, true);
    }
    return null;
  }
  filter(value2) {
    return Formatter.check(this.formats.filter, value2);
  }
  filterLog(value2) {
    return Formatter.check(this.formats.filterLog, value2);
  }
  static check(format, object) {
    const result = {};
    for (const key2 in format) {
      try {
        const value2 = format[key2](object[key2]);
        if (value2 !== void 0) {
          result[key2] = value2;
        }
      } catch (error) {
        error.checkKey = key2;
        error.checkValue = object[key2];
        throw error;
      }
    }
    return result;
  }
  static allowNull(format, nullValue) {
    return function(value2) {
      if (value2 == null) {
        return nullValue;
      }
      return format(value2);
    };
  }
  static allowFalsish(format, replaceValue) {
    return function(value2) {
      if (!value2) {
        return replaceValue;
      }
      return format(value2);
    };
  }
  static arrayOf(format) {
    return function(array) {
      if (!Array.isArray(array)) {
        throw new Error("not an array");
      }
      const result = [];
      array.forEach(function(value2) {
        result.push(format(value2));
      });
      return result;
    };
  }
};
function isCommunityResourcable(value2) {
  return value2 && typeof value2.isCommunityResource === "function";
}
function isCommunityResource(value2) {
  return isCommunityResourcable(value2) && value2.isCommunityResource();
}
var throttleMessage = false;
function showThrottleMessage() {
  if (throttleMessage) {
    return;
  }
  throttleMessage = true;
  console.log("========= NOTICE =========");
  console.log("Request-Rate Exceeded  (this message will not be repeated)");
  console.log("");
  console.log("The default API keys for each service are provided as a highly-throttled,");
  console.log("community resource for low-traffic projects and early prototyping.");
  console.log("");
  console.log("While your application will continue to function, we highly recommended");
  console.log("signing up for your own API keys to improve performance, increase your");
  console.log("request rate/limit and enable other perks, such as metrics and advanced APIs.");
  console.log("");
  console.log("For more details: https://docs.ethers.io/api-keys/");
  console.log("==========================");
}

// node_modules/@ethersproject/providers/lib.esm/base-provider.js
var __awaiter10 = function(thisArg, _arguments, P5, generator) {
  function adopt(value2) {
    return value2 instanceof P5 ? value2 : new P5(function(resolve) {
      resolve(value2);
    });
  }
  return new (P5 || (P5 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e6) {
        reject(e6);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e6) {
        reject(e6);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger30 = new Logger(version23);
var MAX_CCIP_REDIRECTS = 10;
function checkTopic(topic) {
  if (topic == null) {
    return "null";
  }
  if (hexDataLength(topic) !== 32) {
    logger30.throwArgumentError("invalid topic", "topic", topic);
  }
  return topic.toLowerCase();
}
function serializeTopics(topics) {
  topics = topics.slice();
  while (topics.length > 0 && topics[topics.length - 1] == null) {
    topics.pop();
  }
  return topics.map((topic) => {
    if (Array.isArray(topic)) {
      const unique = {};
      topic.forEach((topic2) => {
        unique[checkTopic(topic2)] = true;
      });
      const sorted = Object.keys(unique);
      sorted.sort();
      return sorted.join("|");
    } else {
      return checkTopic(topic);
    }
  }).join("&");
}
function deserializeTopics(data) {
  if (data === "") {
    return [];
  }
  return data.split(/&/g).map((topic) => {
    if (topic === "") {
      return [];
    }
    const comps = topic.split("|").map((topic2) => {
      return topic2 === "null" ? null : topic2;
    });
    return comps.length === 1 ? comps[0] : comps;
  });
}
function getEventTag2(eventName) {
  if (typeof eventName === "string") {
    eventName = eventName.toLowerCase();
    if (hexDataLength(eventName) === 32) {
      return "tx:" + eventName;
    }
    if (eventName.indexOf(":") === -1) {
      return eventName;
    }
  } else if (Array.isArray(eventName)) {
    return "filter:*:" + serializeTopics(eventName);
  } else if (ForkEvent.isForkEvent(eventName)) {
    logger30.warn("not implemented");
    throw new Error("not implemented");
  } else if (eventName && typeof eventName === "object") {
    return "filter:" + (eventName.address || "*") + ":" + serializeTopics(eventName.topics || []);
  }
  throw new Error("invalid event - " + eventName);
}
function getTime() {
  return new Date().getTime();
}
function stall(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
var PollableEvents = ["block", "network", "pending", "poll"];
var Event = class {
  constructor(tag, listener, once) {
    defineReadOnly(this, "tag", tag);
    defineReadOnly(this, "listener", listener);
    defineReadOnly(this, "once", once);
    this._lastBlockNumber = -2;
    this._inflight = false;
  }
  get event() {
    switch (this.type) {
      case "tx":
        return this.hash;
      case "filter":
        return this.filter;
    }
    return this.tag;
  }
  get type() {
    return this.tag.split(":")[0];
  }
  get hash() {
    const comps = this.tag.split(":");
    if (comps[0] !== "tx") {
      return null;
    }
    return comps[1];
  }
  get filter() {
    const comps = this.tag.split(":");
    if (comps[0] !== "filter") {
      return null;
    }
    const address = comps[1];
    const topics = deserializeTopics(comps[2]);
    const filter2 = {};
    if (topics.length > 0) {
      filter2.topics = topics;
    }
    if (address && address !== "*") {
      filter2.address = address;
    }
    return filter2;
  }
  pollable() {
    return this.tag.indexOf(":") >= 0 || PollableEvents.indexOf(this.tag) >= 0;
  }
};
var coinInfos = {
  "0": { symbol: "btc", p2pkh: 0, p2sh: 5, prefix: "bc" },
  "2": { symbol: "ltc", p2pkh: 48, p2sh: 50, prefix: "ltc" },
  "3": { symbol: "doge", p2pkh: 30, p2sh: 22 },
  "60": { symbol: "eth", ilk: "eth" },
  "61": { symbol: "etc", ilk: "eth" },
  "700": { symbol: "xdai", ilk: "eth" }
};
function bytes32ify(value2) {
  return hexZeroPad(BigNumber.from(value2).toHexString(), 32);
}
function base58Encode(data) {
  return Base58.encode(concat([data, hexDataSlice(sha256(sha256(data)), 0, 4)]));
}
var matcherIpfs = new RegExp("^(ipfs)://(.*)$", "i");
var matchers = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  matcherIpfs,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
function _parseString(result, start) {
  try {
    return toUtf8String(_parseBytes(result, start));
  } catch (error) {
  }
  return null;
}
function _parseBytes(result, start) {
  if (result === "0x") {
    return null;
  }
  const offset = BigNumber.from(hexDataSlice(result, start, start + 32)).toNumber();
  const length = BigNumber.from(hexDataSlice(result, offset, offset + 32)).toNumber();
  return hexDataSlice(result, offset + 32, offset + 32 + length);
}
function getIpfsLink(link) {
  if (link.match(/^ipfs:\/\/ipfs\//i)) {
    link = link.substring(12);
  } else if (link.match(/^ipfs:\/\//i)) {
    link = link.substring(7);
  } else {
    logger30.throwArgumentError("unsupported IPFS format", "link", link);
  }
  return `https://gateway.ipfs.io/ipfs/${link}`;
}
function numPad(value2) {
  const result = arrayify(value2);
  if (result.length > 32) {
    throw new Error("internal; should not happen");
  }
  const padded = new Uint8Array(32);
  padded.set(result, 32 - result.length);
  return padded;
}
function bytesPad(value2) {
  if (value2.length % 32 === 0) {
    return value2;
  }
  const result = new Uint8Array(Math.ceil(value2.length / 32) * 32);
  result.set(value2);
  return result;
}
function encodeBytes(datas) {
  const result = [];
  let byteCount = 0;
  for (let i6 = 0; i6 < datas.length; i6++) {
    result.push(null);
    byteCount += 32;
  }
  for (let i6 = 0; i6 < datas.length; i6++) {
    const data = arrayify(datas[i6]);
    result[i6] = numPad(byteCount);
    result.push(numPad(data.length));
    result.push(bytesPad(data));
    byteCount += 32 + Math.ceil(data.length / 32) * 32;
  }
  return hexConcat(result);
}
var Resolver = class {
  constructor(provider, address, name2, resolvedAddress) {
    defineReadOnly(this, "provider", provider);
    defineReadOnly(this, "name", name2);
    defineReadOnly(this, "address", provider.formatter.address(address));
    defineReadOnly(this, "_resolvedAddress", resolvedAddress);
  }
  supportsWildcard() {
    if (!this._supportsEip2544) {
      this._supportsEip2544 = this.provider.call({
        to: this.address,
        data: "0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000"
      }).then((result) => {
        return BigNumber.from(result).eq(1);
      }).catch((error) => {
        if (error.code === Logger.errors.CALL_EXCEPTION) {
          return false;
        }
        this._supportsEip2544 = null;
        throw error;
      });
    }
    return this._supportsEip2544;
  }
  _fetch(selector, parameters) {
    return __awaiter10(this, void 0, void 0, function* () {
      const tx = {
        to: this.address,
        ccipReadEnabled: true,
        data: hexConcat([selector, namehash(this.name), parameters || "0x"])
      };
      let parseBytes = false;
      if (yield this.supportsWildcard()) {
        parseBytes = true;
        tx.data = hexConcat(["0x9061b923", encodeBytes([dnsEncode(this.name), tx.data])]);
      }
      try {
        let result = yield this.provider.call(tx);
        if (arrayify(result).length % 32 === 4) {
          logger30.throwError("resolver threw error", Logger.errors.CALL_EXCEPTION, {
            transaction: tx,
            data: result
          });
        }
        if (parseBytes) {
          result = _parseBytes(result, 0);
        }
        return result;
      } catch (error) {
        if (error.code === Logger.errors.CALL_EXCEPTION) {
          return null;
        }
        throw error;
      }
    });
  }
  _fetchBytes(selector, parameters) {
    return __awaiter10(this, void 0, void 0, function* () {
      const result = yield this._fetch(selector, parameters);
      if (result != null) {
        return _parseBytes(result, 0);
      }
      return null;
    });
  }
  _getAddress(coinType, hexBytes) {
    const coinInfo = coinInfos[String(coinType)];
    if (coinInfo == null) {
      logger30.throwError(`unsupported coin type: ${coinType}`, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: `getAddress(${coinType})`
      });
    }
    if (coinInfo.ilk === "eth") {
      return this.provider.formatter.address(hexBytes);
    }
    const bytes = arrayify(hexBytes);
    if (coinInfo.p2pkh != null) {
      const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
      if (p2pkh) {
        const length = parseInt(p2pkh[1], 16);
        if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) {
          return base58Encode(concat([[coinInfo.p2pkh], "0x" + p2pkh[2]]));
        }
      }
    }
    if (coinInfo.p2sh != null) {
      const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
      if (p2sh) {
        const length = parseInt(p2sh[1], 16);
        if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) {
          return base58Encode(concat([[coinInfo.p2sh], "0x" + p2sh[2]]));
        }
      }
    }
    if (coinInfo.prefix != null) {
      const length = bytes[1];
      let version27 = bytes[0];
      if (version27 === 0) {
        if (length !== 20 && length !== 32) {
          version27 = -1;
        }
      } else {
        version27 = -1;
      }
      if (version27 >= 0 && bytes.length === 2 + length && length >= 1 && length <= 75) {
        const words2 = import_bech32.default.toWords(bytes.slice(2));
        words2.unshift(version27);
        return import_bech32.default.encode(coinInfo.prefix, words2);
      }
    }
    return null;
  }
  getAddress(coinType) {
    return __awaiter10(this, void 0, void 0, function* () {
      if (coinType == null) {
        coinType = 60;
      }
      if (coinType === 60) {
        try {
          const result = yield this._fetch("0x3b3b57de");
          if (result === "0x" || result === HashZero) {
            return null;
          }
          return this.provider.formatter.callAddress(result);
        } catch (error) {
          if (error.code === Logger.errors.CALL_EXCEPTION) {
            return null;
          }
          throw error;
        }
      }
      const hexBytes = yield this._fetchBytes("0xf1cb7e06", bytes32ify(coinType));
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      const address = this._getAddress(coinType, hexBytes);
      if (address == null) {
        logger30.throwError(`invalid or unsupported coin data`, Logger.errors.UNSUPPORTED_OPERATION, {
          operation: `getAddress(${coinType})`,
          coinType,
          data: hexBytes
        });
      }
      return address;
    });
  }
  getAvatar() {
    return __awaiter10(this, void 0, void 0, function* () {
      const linkage = [{ type: "name", content: this.name }];
      try {
        const avatar = yield this.getText("avatar");
        if (avatar == null) {
          return null;
        }
        for (let i6 = 0; i6 < matchers.length; i6++) {
          const match = avatar.match(matchers[i6]);
          if (match == null) {
            continue;
          }
          const scheme = match[1].toLowerCase();
          switch (scheme) {
            case "https":
              linkage.push({ type: "url", content: avatar });
              return { linkage, url: avatar };
            case "data":
              linkage.push({ type: "data", content: avatar });
              return { linkage, url: avatar };
            case "ipfs":
              linkage.push({ type: "ipfs", content: avatar });
              return { linkage, url: getIpfsLink(avatar) };
            case "erc721":
            case "erc1155": {
              const selector = scheme === "erc721" ? "0xc87b56dd" : "0x0e89341c";
              linkage.push({ type: scheme, content: avatar });
              const owner = this._resolvedAddress || (yield this.getAddress());
              const comps = (match[2] || "").split("/");
              if (comps.length !== 2) {
                return null;
              }
              const addr = yield this.provider.formatter.address(comps[0]);
              const tokenId = hexZeroPad(BigNumber.from(comps[1]).toHexString(), 32);
              if (scheme === "erc721") {
                const tokenOwner = this.provider.formatter.callAddress(yield this.provider.call({
                  to: addr,
                  data: hexConcat(["0x6352211e", tokenId])
                }));
                if (owner !== tokenOwner) {
                  return null;
                }
                linkage.push({ type: "owner", content: tokenOwner });
              } else if (scheme === "erc1155") {
                const balance = BigNumber.from(yield this.provider.call({
                  to: addr,
                  data: hexConcat(["0x00fdd58e", hexZeroPad(owner, 32), tokenId])
                }));
                if (balance.isZero()) {
                  return null;
                }
                linkage.push({ type: "balance", content: balance.toString() });
              }
              const tx = {
                to: this.provider.formatter.address(comps[0]),
                data: hexConcat([selector, tokenId])
              };
              let metadataUrl = _parseString(yield this.provider.call(tx), 0);
              if (metadataUrl == null) {
                return null;
              }
              linkage.push({ type: "metadata-url-base", content: metadataUrl });
              if (scheme === "erc1155") {
                metadataUrl = metadataUrl.replace("{id}", tokenId.substring(2));
                linkage.push({ type: "metadata-url-expanded", content: metadataUrl });
              }
              if (metadataUrl.match(/^ipfs:/i)) {
                metadataUrl = getIpfsLink(metadataUrl);
              }
              linkage.push({ type: "metadata-url", content: metadataUrl });
              const metadata = yield fetchJson(metadataUrl);
              if (!metadata) {
                return null;
              }
              linkage.push({ type: "metadata", content: JSON.stringify(metadata) });
              let imageUrl = metadata.image;
              if (typeof imageUrl !== "string") {
                return null;
              }
              if (imageUrl.match(/^(https:\/\/|data:)/i)) {
              } else {
                const ipfs = imageUrl.match(matcherIpfs);
                if (ipfs == null) {
                  return null;
                }
                linkage.push({ type: "url-ipfs", content: imageUrl });
                imageUrl = getIpfsLink(imageUrl);
              }
              linkage.push({ type: "url", content: imageUrl });
              return { linkage, url: imageUrl };
            }
          }
        }
      } catch (error) {
      }
      return null;
    });
  }
  getContentHash() {
    return __awaiter10(this, void 0, void 0, function* () {
      const hexBytes = yield this._fetchBytes("0xbc1c58d1");
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (ipfs) {
        const length = parseInt(ipfs[3], 16);
        if (ipfs[4].length === length * 2) {
          return "ipfs://" + Base58.encode("0x" + ipfs[1]);
        }
      }
      const ipns = hexBytes.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (ipns) {
        const length = parseInt(ipns[3], 16);
        if (ipns[4].length === length * 2) {
          return "ipns://" + Base58.encode("0x" + ipns[1]);
        }
      }
      const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);
      if (swarm) {
        if (swarm[1].length === 32 * 2) {
          return "bzz://" + swarm[1];
        }
      }
      return logger30.throwError(`invalid or unsupported content hash data`, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "getContentHash()",
        data: hexBytes
      });
    });
  }
  getText(key2) {
    return __awaiter10(this, void 0, void 0, function* () {
      let keyBytes = toUtf8Bytes(key2);
      keyBytes = concat([bytes32ify(64), bytes32ify(keyBytes.length), keyBytes]);
      if (keyBytes.length % 32 !== 0) {
        keyBytes = concat([keyBytes, hexZeroPad("0x", 32 - key2.length % 32)]);
      }
      const hexBytes = yield this._fetchBytes("0x59d1d43c", hexlify(keyBytes));
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      return toUtf8String(hexBytes);
    });
  }
};
var defaultFormatter = null;
var nextPollId = 1;
var BaseProvider = class extends Provider {
  constructor(network) {
    logger30.checkNew(new.target, Provider);
    super();
    this._events = [];
    this._emitted = { block: -2 };
    this.disableCcipRead = false;
    this.formatter = new.target.getFormatter();
    defineReadOnly(this, "anyNetwork", network === "any");
    if (this.anyNetwork) {
      network = this.detectNetwork();
    }
    if (network instanceof Promise) {
      this._networkPromise = network;
      network.catch((error) => {
      });
      this._ready().catch((error) => {
      });
    } else {
      const knownNetwork = getStatic(new.target, "getNetwork")(network);
      if (knownNetwork) {
        defineReadOnly(this, "_network", knownNetwork);
        this.emit("network", knownNetwork, null);
      } else {
        logger30.throwArgumentError("invalid network", "network", network);
      }
    }
    this._maxInternalBlockNumber = -1024;
    this._lastBlockNumber = -2;
    this._maxFilterBlockRange = 10;
    this._pollingInterval = 4e3;
    this._fastQueryDate = 0;
  }
  _ready() {
    return __awaiter10(this, void 0, void 0, function* () {
      if (this._network == null) {
        let network = null;
        if (this._networkPromise) {
          try {
            network = yield this._networkPromise;
          } catch (error) {
          }
        }
        if (network == null) {
          network = yield this.detectNetwork();
        }
        if (!network) {
          logger30.throwError("no network detected", Logger.errors.UNKNOWN_ERROR, {});
        }
        if (this._network == null) {
          if (this.anyNetwork) {
            this._network = network;
          } else {
            defineReadOnly(this, "_network", network);
          }
          this.emit("network", network, null);
        }
      }
      return this._network;
    });
  }
  get ready() {
    return poll(() => {
      return this._ready().then((network) => {
        return network;
      }, (error) => {
        if (error.code === Logger.errors.NETWORK_ERROR && error.event === "noNetwork") {
          return void 0;
        }
        throw error;
      });
    });
  }
  static getFormatter() {
    if (defaultFormatter == null) {
      defaultFormatter = new Formatter();
    }
    return defaultFormatter;
  }
  static getNetwork(network) {
    return getNetwork(network == null ? "homestead" : network);
  }
  ccipReadFetch(tx, calldata, urls) {
    return __awaiter10(this, void 0, void 0, function* () {
      if (this.disableCcipRead || urls.length === 0) {
        return null;
      }
      const sender = tx.to.toLowerCase();
      const data = calldata.toLowerCase();
      const errorMessages = [];
      for (let i6 = 0; i6 < urls.length; i6++) {
        const url = urls[i6];
        const href = url.replace("{sender}", sender).replace("{data}", data);
        const json = url.indexOf("{data}") >= 0 ? null : JSON.stringify({ data, sender });
        const result = yield fetchJson({ url: href, errorPassThrough: true }, json, (value2, response) => {
          value2.status = response.statusCode;
          return value2;
        });
        if (result.data) {
          return result.data;
        }
        const errorMessage = result.message || "unknown error";
        if (result.status >= 400 && result.status < 500) {
          return logger30.throwError(`response not found during CCIP fetch: ${errorMessage}`, Logger.errors.SERVER_ERROR, { url, errorMessage });
        }
        errorMessages.push(errorMessage);
      }
      return logger30.throwError(`error encountered during CCIP fetch: ${errorMessages.map((m6) => JSON.stringify(m6)).join(", ")}`, Logger.errors.SERVER_ERROR, {
        urls,
        errorMessages
      });
    });
  }
  _getInternalBlockNumber(maxAge) {
    return __awaiter10(this, void 0, void 0, function* () {
      yield this._ready();
      if (maxAge > 0) {
        while (this._internalBlockNumber) {
          const internalBlockNumber = this._internalBlockNumber;
          try {
            const result = yield internalBlockNumber;
            if (getTime() - result.respTime <= maxAge) {
              return result.blockNumber;
            }
            break;
          } catch (error) {
            if (this._internalBlockNumber === internalBlockNumber) {
              break;
            }
          }
        }
      }
      const reqTime = getTime();
      const checkInternalBlockNumber = resolveProperties({
        blockNumber: this.perform("getBlockNumber", {}),
        networkError: this.getNetwork().then((network) => null, (error) => error)
      }).then(({ blockNumber, networkError }) => {
        if (networkError) {
          if (this._internalBlockNumber === checkInternalBlockNumber) {
            this._internalBlockNumber = null;
          }
          throw networkError;
        }
        const respTime = getTime();
        blockNumber = BigNumber.from(blockNumber).toNumber();
        if (blockNumber < this._maxInternalBlockNumber) {
          blockNumber = this._maxInternalBlockNumber;
        }
        this._maxInternalBlockNumber = blockNumber;
        this._setFastBlockNumber(blockNumber);
        return { blockNumber, reqTime, respTime };
      });
      this._internalBlockNumber = checkInternalBlockNumber;
      checkInternalBlockNumber.catch((error) => {
        if (this._internalBlockNumber === checkInternalBlockNumber) {
          this._internalBlockNumber = null;
        }
      });
      return (yield checkInternalBlockNumber).blockNumber;
    });
  }
  poll() {
    return __awaiter10(this, void 0, void 0, function* () {
      const pollId = nextPollId++;
      const runners = [];
      let blockNumber = null;
      try {
        blockNumber = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);
      } catch (error) {
        this.emit("error", error);
        return;
      }
      this._setFastBlockNumber(blockNumber);
      this.emit("poll", pollId, blockNumber);
      if (blockNumber === this._lastBlockNumber) {
        this.emit("didPoll", pollId);
        return;
      }
      if (this._emitted.block === -2) {
        this._emitted.block = blockNumber - 1;
      }
      if (Math.abs(this._emitted.block - blockNumber) > 1e3) {
        logger30.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${blockNumber})`);
        this.emit("error", logger30.makeError("network block skew detected", Logger.errors.NETWORK_ERROR, {
          blockNumber,
          event: "blockSkew",
          previousBlockNumber: this._emitted.block
        }));
        this.emit("block", blockNumber);
      } else {
        for (let i6 = this._emitted.block + 1; i6 <= blockNumber; i6++) {
          this.emit("block", i6);
        }
      }
      if (this._emitted.block !== blockNumber) {
        this._emitted.block = blockNumber;
        Object.keys(this._emitted).forEach((key2) => {
          if (key2 === "block") {
            return;
          }
          const eventBlockNumber = this._emitted[key2];
          if (eventBlockNumber === "pending") {
            return;
          }
          if (blockNumber - eventBlockNumber > 12) {
            delete this._emitted[key2];
          }
        });
      }
      if (this._lastBlockNumber === -2) {
        this._lastBlockNumber = blockNumber - 1;
      }
      this._events.forEach((event) => {
        switch (event.type) {
          case "tx": {
            const hash3 = event.hash;
            let runner = this.getTransactionReceipt(hash3).then((receipt) => {
              if (!receipt || receipt.blockNumber == null) {
                return null;
              }
              this._emitted["t:" + hash3] = receipt.blockNumber;
              this.emit(hash3, receipt);
              return null;
            }).catch((error) => {
              this.emit("error", error);
            });
            runners.push(runner);
            break;
          }
          case "filter": {
            if (!event._inflight) {
              event._inflight = true;
              const filter2 = event.filter;
              filter2.fromBlock = event._lastBlockNumber + 1;
              filter2.toBlock = blockNumber;
              if (filter2.toBlock - this._maxFilterBlockRange > filter2.fromBlock) {
                filter2.fromBlock = filter2.toBlock - this._maxFilterBlockRange;
              }
              const runner = this.getLogs(filter2).then((logs) => {
                event._inflight = false;
                if (logs.length === 0) {
                  return;
                }
                logs.forEach((log) => {
                  if (log.blockNumber > event._lastBlockNumber) {
                    event._lastBlockNumber = log.blockNumber;
                  }
                  this._emitted["b:" + log.blockHash] = log.blockNumber;
                  this._emitted["t:" + log.transactionHash] = log.blockNumber;
                  this.emit(filter2, log);
                });
              }).catch((error) => {
                this.emit("error", error);
                event._inflight = false;
              });
              runners.push(runner);
            }
            break;
          }
        }
      });
      this._lastBlockNumber = blockNumber;
      Promise.all(runners).then(() => {
        this.emit("didPoll", pollId);
      }).catch((error) => {
        this.emit("error", error);
      });
      return;
    });
  }
  resetEventsBlock(blockNumber) {
    this._lastBlockNumber = blockNumber - 1;
    if (this.polling) {
      this.poll();
    }
  }
  get network() {
    return this._network;
  }
  detectNetwork() {
    return __awaiter10(this, void 0, void 0, function* () {
      return logger30.throwError("provider does not support network detection", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "provider.detectNetwork"
      });
    });
  }
  getNetwork() {
    return __awaiter10(this, void 0, void 0, function* () {
      const network = yield this._ready();
      const currentNetwork = yield this.detectNetwork();
      if (network.chainId !== currentNetwork.chainId) {
        if (this.anyNetwork) {
          this._network = currentNetwork;
          this._lastBlockNumber = -2;
          this._fastBlockNumber = null;
          this._fastBlockNumberPromise = null;
          this._fastQueryDate = 0;
          this._emitted.block = -2;
          this._maxInternalBlockNumber = -1024;
          this._internalBlockNumber = null;
          this.emit("network", currentNetwork, network);
          yield stall(0);
          return this._network;
        }
        const error = logger30.makeError("underlying network changed", Logger.errors.NETWORK_ERROR, {
          event: "changed",
          network,
          detectedNetwork: currentNetwork
        });
        this.emit("error", error);
        throw error;
      }
      return network;
    });
  }
  get blockNumber() {
    this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {
      this._setFastBlockNumber(blockNumber);
    }, (error) => {
    });
    return this._fastBlockNumber != null ? this._fastBlockNumber : -1;
  }
  get polling() {
    return this._poller != null;
  }
  set polling(value2) {
    if (value2 && !this._poller) {
      this._poller = setInterval(() => {
        this.poll();
      }, this.pollingInterval);
      if (!this._bootstrapPoll) {
        this._bootstrapPoll = setTimeout(() => {
          this.poll();
          this._bootstrapPoll = setTimeout(() => {
            if (!this._poller) {
              this.poll();
            }
            this._bootstrapPoll = null;
          }, this.pollingInterval);
        }, 0);
      }
    } else if (!value2 && this._poller) {
      clearInterval(this._poller);
      this._poller = null;
    }
  }
  get pollingInterval() {
    return this._pollingInterval;
  }
  set pollingInterval(value2) {
    if (typeof value2 !== "number" || value2 <= 0 || parseInt(String(value2)) != value2) {
      throw new Error("invalid polling interval");
    }
    this._pollingInterval = value2;
    if (this._poller) {
      clearInterval(this._poller);
      this._poller = setInterval(() => {
        this.poll();
      }, this._pollingInterval);
    }
  }
  _getFastBlockNumber() {
    const now2 = getTime();
    if (now2 - this._fastQueryDate > 2 * this._pollingInterval) {
      this._fastQueryDate = now2;
      this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {
        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
          this._fastBlockNumber = blockNumber;
        }
        return this._fastBlockNumber;
      });
    }
    return this._fastBlockNumberPromise;
  }
  _setFastBlockNumber(blockNumber) {
    if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {
      return;
    }
    this._fastQueryDate = getTime();
    if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
      this._fastBlockNumber = blockNumber;
      this._fastBlockNumberPromise = Promise.resolve(blockNumber);
    }
  }
  waitForTransaction(transactionHash, confirmations, timeout2) {
    return __awaiter10(this, void 0, void 0, function* () {
      return this._waitForTransaction(transactionHash, confirmations == null ? 1 : confirmations, timeout2 || 0, null);
    });
  }
  _waitForTransaction(transactionHash, confirmations, timeout2, replaceable) {
    return __awaiter10(this, void 0, void 0, function* () {
      const receipt = yield this.getTransactionReceipt(transactionHash);
      if ((receipt ? receipt.confirmations : 0) >= confirmations) {
        return receipt;
      }
      return new Promise((resolve, reject) => {
        const cancelFuncs = [];
        let done = false;
        const alreadyDone = function() {
          if (done) {
            return true;
          }
          done = true;
          cancelFuncs.forEach((func) => {
            func();
          });
          return false;
        };
        const minedHandler = (receipt2) => {
          if (receipt2.confirmations < confirmations) {
            return;
          }
          if (alreadyDone()) {
            return;
          }
          resolve(receipt2);
        };
        this.on(transactionHash, minedHandler);
        cancelFuncs.push(() => {
          this.removeListener(transactionHash, minedHandler);
        });
        if (replaceable) {
          let lastBlockNumber = replaceable.startBlock;
          let scannedBlock = null;
          const replaceHandler = (blockNumber) => __awaiter10(this, void 0, void 0, function* () {
            if (done) {
              return;
            }
            yield stall(1e3);
            this.getTransactionCount(replaceable.from).then((nonce) => __awaiter10(this, void 0, void 0, function* () {
              if (done) {
                return;
              }
              if (nonce <= replaceable.nonce) {
                lastBlockNumber = blockNumber;
              } else {
                {
                  const mined = yield this.getTransaction(transactionHash);
                  if (mined && mined.blockNumber != null) {
                    return;
                  }
                }
                if (scannedBlock == null) {
                  scannedBlock = lastBlockNumber - 3;
                  if (scannedBlock < replaceable.startBlock) {
                    scannedBlock = replaceable.startBlock;
                  }
                }
                while (scannedBlock <= blockNumber) {
                  if (done) {
                    return;
                  }
                  const block = yield this.getBlockWithTransactions(scannedBlock);
                  for (let ti = 0; ti < block.transactions.length; ti++) {
                    const tx = block.transactions[ti];
                    if (tx.hash === transactionHash) {
                      return;
                    }
                    if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {
                      if (done) {
                        return;
                      }
                      const receipt2 = yield this.waitForTransaction(tx.hash, confirmations);
                      if (alreadyDone()) {
                        return;
                      }
                      let reason = "replaced";
                      if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {
                        reason = "repriced";
                      } else if (tx.data === "0x" && tx.from === tx.to && tx.value.isZero()) {
                        reason = "cancelled";
                      }
                      reject(logger30.makeError("transaction was replaced", Logger.errors.TRANSACTION_REPLACED, {
                        cancelled: reason === "replaced" || reason === "cancelled",
                        reason,
                        replacement: this._wrapTransaction(tx),
                        hash: transactionHash,
                        receipt: receipt2
                      }));
                      return;
                    }
                  }
                  scannedBlock++;
                }
              }
              if (done) {
                return;
              }
              this.once("block", replaceHandler);
            }), (error) => {
              if (done) {
                return;
              }
              this.once("block", replaceHandler);
            });
          });
          if (done) {
            return;
          }
          this.once("block", replaceHandler);
          cancelFuncs.push(() => {
            this.removeListener("block", replaceHandler);
          });
        }
        if (typeof timeout2 === "number" && timeout2 > 0) {
          const timer3 = setTimeout(() => {
            if (alreadyDone()) {
              return;
            }
            reject(logger30.makeError("timeout exceeded", Logger.errors.TIMEOUT, { timeout: timeout2 }));
          }, timeout2);
          if (timer3.unref) {
            timer3.unref();
          }
          cancelFuncs.push(() => {
            clearTimeout(timer3);
          });
        }
      });
    });
  }
  getBlockNumber() {
    return __awaiter10(this, void 0, void 0, function* () {
      return this._getInternalBlockNumber(0);
    });
  }
  getGasPrice() {
    return __awaiter10(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const result = yield this.perform("getGasPrice", {});
      try {
        return BigNumber.from(result);
      } catch (error) {
        return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getGasPrice",
          result,
          error
        });
      }
    });
  }
  getBalance(addressOrName, blockTag) {
    return __awaiter10(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getBalance", params);
      try {
        return BigNumber.from(result);
      } catch (error) {
        return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getBalance",
          params,
          result,
          error
        });
      }
    });
  }
  getTransactionCount(addressOrName, blockTag) {
    return __awaiter10(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getTransactionCount", params);
      try {
        return BigNumber.from(result).toNumber();
      } catch (error) {
        return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getTransactionCount",
          params,
          result,
          error
        });
      }
    });
  }
  getCode(addressOrName, blockTag) {
    return __awaiter10(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getCode", params);
      try {
        return hexlify(result);
      } catch (error) {
        return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getCode",
          params,
          result,
          error
        });
      }
    });
  }
  getStorageAt(addressOrName, position, blockTag) {
    return __awaiter10(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag),
        position: Promise.resolve(position).then((p7) => hexValue(p7))
      });
      const result = yield this.perform("getStorageAt", params);
      try {
        return hexlify(result);
      } catch (error) {
        return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getStorageAt",
          params,
          result,
          error
        });
      }
    });
  }
  _wrapTransaction(tx, hash3, startBlock) {
    if (hash3 != null && hexDataLength(hash3) !== 32) {
      throw new Error("invalid response - sendTransaction");
    }
    const result = tx;
    if (hash3 != null && tx.hash !== hash3) {
      logger30.throwError("Transaction hash mismatch from Provider.sendTransaction.", Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash3 });
    }
    result.wait = (confirms, timeout2) => __awaiter10(this, void 0, void 0, function* () {
      if (confirms == null) {
        confirms = 1;
      }
      if (timeout2 == null) {
        timeout2 = 0;
      }
      let replacement = void 0;
      if (confirms !== 0 && startBlock != null) {
        replacement = {
          data: tx.data,
          from: tx.from,
          nonce: tx.nonce,
          to: tx.to,
          value: tx.value,
          startBlock
        };
      }
      const receipt = yield this._waitForTransaction(tx.hash, confirms, timeout2, replacement);
      if (receipt == null && confirms === 0) {
        return null;
      }
      this._emitted["t:" + tx.hash] = receipt.blockNumber;
      if (receipt.status === 0) {
        logger30.throwError("transaction failed", Logger.errors.CALL_EXCEPTION, {
          transactionHash: tx.hash,
          transaction: tx,
          receipt
        });
      }
      return receipt;
    });
    return result;
  }
  sendTransaction(signedTransaction) {
    return __awaiter10(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const hexTx = yield Promise.resolve(signedTransaction).then((t6) => hexlify(t6));
      const tx = this.formatter.transaction(signedTransaction);
      if (tx.confirmations == null) {
        tx.confirmations = 0;
      }
      const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
      try {
        const hash3 = yield this.perform("sendTransaction", { signedTransaction: hexTx });
        return this._wrapTransaction(tx, hash3, blockNumber);
      } catch (error) {
        error.transaction = tx;
        error.transactionHash = tx.hash;
        throw error;
      }
    });
  }
  _getTransactionRequest(transaction) {
    return __awaiter10(this, void 0, void 0, function* () {
      const values = yield transaction;
      const tx = {};
      ["from", "to"].forEach((key2) => {
        if (values[key2] == null) {
          return;
        }
        tx[key2] = Promise.resolve(values[key2]).then((v9) => v9 ? this._getAddress(v9) : null);
      });
      ["gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "value"].forEach((key2) => {
        if (values[key2] == null) {
          return;
        }
        tx[key2] = Promise.resolve(values[key2]).then((v9) => v9 ? BigNumber.from(v9) : null);
      });
      ["type"].forEach((key2) => {
        if (values[key2] == null) {
          return;
        }
        tx[key2] = Promise.resolve(values[key2]).then((v9) => v9 != null ? v9 : null);
      });
      if (values.accessList) {
        tx.accessList = this.formatter.accessList(values.accessList);
      }
      ["data"].forEach((key2) => {
        if (values[key2] == null) {
          return;
        }
        tx[key2] = Promise.resolve(values[key2]).then((v9) => v9 ? hexlify(v9) : null);
      });
      return this.formatter.transactionRequest(yield resolveProperties(tx));
    });
  }
  _getFilter(filter2) {
    return __awaiter10(this, void 0, void 0, function* () {
      filter2 = yield filter2;
      const result = {};
      if (filter2.address != null) {
        result.address = this._getAddress(filter2.address);
      }
      ["blockHash", "topics"].forEach((key2) => {
        if (filter2[key2] == null) {
          return;
        }
        result[key2] = filter2[key2];
      });
      ["fromBlock", "toBlock"].forEach((key2) => {
        if (filter2[key2] == null) {
          return;
        }
        result[key2] = this._getBlockTag(filter2[key2]);
      });
      return this.formatter.filter(yield resolveProperties(result));
    });
  }
  _call(transaction, blockTag, attempt) {
    return __awaiter10(this, void 0, void 0, function* () {
      if (attempt >= MAX_CCIP_REDIRECTS) {
        logger30.throwError("CCIP read exceeded maximum redirections", Logger.errors.SERVER_ERROR, {
          redirects: attempt,
          transaction
        });
      }
      const txSender = transaction.to;
      const result = yield this.perform("call", { transaction, blockTag });
      if (attempt >= 0 && blockTag === "latest" && txSender != null && result.substring(0, 10) === "0x556f1830" && hexDataLength(result) % 32 === 4) {
        try {
          const data = hexDataSlice(result, 4);
          const sender = hexDataSlice(data, 0, 32);
          if (!BigNumber.from(sender).eq(txSender)) {
            logger30.throwError("CCIP Read sender did not match", Logger.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction,
              data: result
            });
          }
          const urls = [];
          const urlsOffset = BigNumber.from(hexDataSlice(data, 32, 64)).toNumber();
          const urlsLength = BigNumber.from(hexDataSlice(data, urlsOffset, urlsOffset + 32)).toNumber();
          const urlsData = hexDataSlice(data, urlsOffset + 32);
          for (let u7 = 0; u7 < urlsLength; u7++) {
            const url = _parseString(urlsData, u7 * 32);
            if (url == null) {
              logger30.throwError("CCIP Read contained corrupt URL string", Logger.errors.CALL_EXCEPTION, {
                name: "OffchainLookup",
                signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                transaction,
                data: result
              });
            }
            urls.push(url);
          }
          const calldata = _parseBytes(data, 64);
          if (!BigNumber.from(hexDataSlice(data, 100, 128)).isZero()) {
            logger30.throwError("CCIP Read callback selector included junk", Logger.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction,
              data: result
            });
          }
          const callbackSelector = hexDataSlice(data, 96, 100);
          const extraData = _parseBytes(data, 128);
          const ccipResult = yield this.ccipReadFetch(transaction, calldata, urls);
          if (ccipResult == null) {
            logger30.throwError("CCIP Read disabled or provided no URLs", Logger.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction,
              data: result
            });
          }
          const tx = {
            to: txSender,
            data: hexConcat([callbackSelector, encodeBytes([ccipResult, extraData])])
          };
          return this._call(tx, blockTag, attempt + 1);
        } catch (error) {
          if (error.code === Logger.errors.SERVER_ERROR) {
            throw error;
          }
        }
      }
      try {
        return hexlify(result);
      } catch (error) {
        return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "call",
          params: { transaction, blockTag },
          result,
          error
        });
      }
    });
  }
  call(transaction, blockTag) {
    return __awaiter10(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const resolved = yield resolveProperties({
        transaction: this._getTransactionRequest(transaction),
        blockTag: this._getBlockTag(blockTag),
        ccipReadEnabled: Promise.resolve(transaction.ccipReadEnabled)
      });
      return this._call(resolved.transaction, resolved.blockTag, resolved.ccipReadEnabled ? 0 : -1);
    });
  }
  estimateGas(transaction) {
    return __awaiter10(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        transaction: this._getTransactionRequest(transaction)
      });
      const result = yield this.perform("estimateGas", params);
      try {
        return BigNumber.from(result);
      } catch (error) {
        return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "estimateGas",
          params,
          result,
          error
        });
      }
    });
  }
  _getAddress(addressOrName) {
    return __awaiter10(this, void 0, void 0, function* () {
      addressOrName = yield addressOrName;
      if (typeof addressOrName !== "string") {
        logger30.throwArgumentError("invalid address or ENS name", "name", addressOrName);
      }
      const address = yield this.resolveName(addressOrName);
      if (address == null) {
        logger30.throwError("ENS name not configured", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: `resolveName(${JSON.stringify(addressOrName)})`
        });
      }
      return address;
    });
  }
  _getBlock(blockHashOrBlockTag, includeTransactions) {
    return __awaiter10(this, void 0, void 0, function* () {
      yield this.getNetwork();
      blockHashOrBlockTag = yield blockHashOrBlockTag;
      let blockNumber = -128;
      const params = {
        includeTransactions: !!includeTransactions
      };
      if (isHexString(blockHashOrBlockTag, 32)) {
        params.blockHash = blockHashOrBlockTag;
      } else {
        try {
          params.blockTag = yield this._getBlockTag(blockHashOrBlockTag);
          if (isHexString(params.blockTag)) {
            blockNumber = parseInt(params.blockTag.substring(2), 16);
          }
        } catch (error) {
          logger30.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", blockHashOrBlockTag);
        }
      }
      return poll(() => __awaiter10(this, void 0, void 0, function* () {
        const block = yield this.perform("getBlock", params);
        if (block == null) {
          if (params.blockHash != null) {
            if (this._emitted["b:" + params.blockHash] == null) {
              return null;
            }
          }
          if (params.blockTag != null) {
            if (blockNumber > this._emitted.block) {
              return null;
            }
          }
          return void 0;
        }
        if (includeTransactions) {
          let blockNumber2 = null;
          for (let i6 = 0; i6 < block.transactions.length; i6++) {
            const tx = block.transactions[i6];
            if (tx.blockNumber == null) {
              tx.confirmations = 0;
            } else if (tx.confirmations == null) {
              if (blockNumber2 == null) {
                blockNumber2 = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
              }
              let confirmations = blockNumber2 - tx.blockNumber + 1;
              if (confirmations <= 0) {
                confirmations = 1;
              }
              tx.confirmations = confirmations;
            }
          }
          const blockWithTxs = this.formatter.blockWithTransactions(block);
          blockWithTxs.transactions = blockWithTxs.transactions.map((tx) => this._wrapTransaction(tx));
          return blockWithTxs;
        }
        return this.formatter.block(block);
      }), { oncePoll: this });
    });
  }
  getBlock(blockHashOrBlockTag) {
    return this._getBlock(blockHashOrBlockTag, false);
  }
  getBlockWithTransactions(blockHashOrBlockTag) {
    return this._getBlock(blockHashOrBlockTag, true);
  }
  getTransaction(transactionHash) {
    return __awaiter10(this, void 0, void 0, function* () {
      yield this.getNetwork();
      transactionHash = yield transactionHash;
      const params = { transactionHash: this.formatter.hash(transactionHash, true) };
      return poll(() => __awaiter10(this, void 0, void 0, function* () {
        const result = yield this.perform("getTransaction", params);
        if (result == null) {
          if (this._emitted["t:" + transactionHash] == null) {
            return null;
          }
          return void 0;
        }
        const tx = this.formatter.transactionResponse(result);
        if (tx.blockNumber == null) {
          tx.confirmations = 0;
        } else if (tx.confirmations == null) {
          const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
          let confirmations = blockNumber - tx.blockNumber + 1;
          if (confirmations <= 0) {
            confirmations = 1;
          }
          tx.confirmations = confirmations;
        }
        return this._wrapTransaction(tx);
      }), { oncePoll: this });
    });
  }
  getTransactionReceipt(transactionHash) {
    return __awaiter10(this, void 0, void 0, function* () {
      yield this.getNetwork();
      transactionHash = yield transactionHash;
      const params = { transactionHash: this.formatter.hash(transactionHash, true) };
      return poll(() => __awaiter10(this, void 0, void 0, function* () {
        const result = yield this.perform("getTransactionReceipt", params);
        if (result == null) {
          if (this._emitted["t:" + transactionHash] == null) {
            return null;
          }
          return void 0;
        }
        if (result.blockHash == null) {
          return void 0;
        }
        const receipt = this.formatter.receipt(result);
        if (receipt.blockNumber == null) {
          receipt.confirmations = 0;
        } else if (receipt.confirmations == null) {
          const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
          let confirmations = blockNumber - receipt.blockNumber + 1;
          if (confirmations <= 0) {
            confirmations = 1;
          }
          receipt.confirmations = confirmations;
        }
        return receipt;
      }), { oncePoll: this });
    });
  }
  getLogs(filter2) {
    return __awaiter10(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({ filter: this._getFilter(filter2) });
      const logs = yield this.perform("getLogs", params);
      logs.forEach((log) => {
        if (log.removed == null) {
          log.removed = false;
        }
      });
      return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);
    });
  }
  getEtherPrice() {
    return __awaiter10(this, void 0, void 0, function* () {
      yield this.getNetwork();
      return this.perform("getEtherPrice", {});
    });
  }
  _getBlockTag(blockTag) {
    return __awaiter10(this, void 0, void 0, function* () {
      blockTag = yield blockTag;
      if (typeof blockTag === "number" && blockTag < 0) {
        if (blockTag % 1) {
          logger30.throwArgumentError("invalid BlockTag", "blockTag", blockTag);
        }
        let blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
        blockNumber += blockTag;
        if (blockNumber < 0) {
          blockNumber = 0;
        }
        return this.formatter.blockTag(blockNumber);
      }
      return this.formatter.blockTag(blockTag);
    });
  }
  getResolver(name2) {
    return __awaiter10(this, void 0, void 0, function* () {
      let currentName = name2;
      while (true) {
        if (currentName === "" || currentName === ".") {
          return null;
        }
        if (name2 !== "eth" && currentName === "eth") {
          return null;
        }
        const addr = yield this._getResolver(currentName, "getResolver");
        if (addr != null) {
          const resolver = new Resolver(this, addr, name2);
          if (currentName !== name2 && !(yield resolver.supportsWildcard())) {
            return null;
          }
          return resolver;
        }
        currentName = currentName.split(".").slice(1).join(".");
      }
    });
  }
  _getResolver(name2, operation) {
    return __awaiter10(this, void 0, void 0, function* () {
      if (operation == null) {
        operation = "ENS";
      }
      const network = yield this.getNetwork();
      if (!network.ensAddress) {
        logger30.throwError("network does not support ENS", Logger.errors.UNSUPPORTED_OPERATION, { operation, network: network.name });
      }
      try {
        const addrData = yield this.call({
          to: network.ensAddress,
          data: "0x0178b8bf" + namehash(name2).substring(2)
        });
        return this.formatter.callAddress(addrData);
      } catch (error) {
      }
      return null;
    });
  }
  resolveName(name2) {
    return __awaiter10(this, void 0, void 0, function* () {
      name2 = yield name2;
      try {
        return Promise.resolve(this.formatter.address(name2));
      } catch (error) {
        if (isHexString(name2)) {
          throw error;
        }
      }
      if (typeof name2 !== "string") {
        logger30.throwArgumentError("invalid ENS name", "name", name2);
      }
      const resolver = yield this.getResolver(name2);
      if (!resolver) {
        return null;
      }
      return yield resolver.getAddress();
    });
  }
  lookupAddress(address) {
    return __awaiter10(this, void 0, void 0, function* () {
      address = yield address;
      address = this.formatter.address(address);
      const node = address.substring(2).toLowerCase() + ".addr.reverse";
      const resolverAddr = yield this._getResolver(node, "lookupAddress");
      if (resolverAddr == null) {
        return null;
      }
      const name2 = _parseString(yield this.call({
        to: resolverAddr,
        data: "0x691f3431" + namehash(node).substring(2)
      }), 0);
      const addr = yield this.resolveName(name2);
      if (addr != address) {
        return null;
      }
      return name2;
    });
  }
  getAvatar(nameOrAddress) {
    return __awaiter10(this, void 0, void 0, function* () {
      let resolver = null;
      if (isHexString(nameOrAddress)) {
        const address = this.formatter.address(nameOrAddress);
        const node = address.substring(2).toLowerCase() + ".addr.reverse";
        const resolverAddress = yield this._getResolver(node, "getAvatar");
        if (!resolverAddress) {
          return null;
        }
        resolver = new Resolver(this, resolverAddress, node);
        try {
          const avatar2 = yield resolver.getAvatar();
          if (avatar2) {
            return avatar2.url;
          }
        } catch (error) {
          if (error.code !== Logger.errors.CALL_EXCEPTION) {
            throw error;
          }
        }
        try {
          const name2 = _parseString(yield this.call({
            to: resolverAddress,
            data: "0x691f3431" + namehash(node).substring(2)
          }), 0);
          resolver = yield this.getResolver(name2);
        } catch (error) {
          if (error.code !== Logger.errors.CALL_EXCEPTION) {
            throw error;
          }
          return null;
        }
      } else {
        resolver = yield this.getResolver(nameOrAddress);
        if (!resolver) {
          return null;
        }
      }
      const avatar = yield resolver.getAvatar();
      if (avatar == null) {
        return null;
      }
      return avatar.url;
    });
  }
  perform(method2, params) {
    return logger30.throwError(method2 + " not implemented", Logger.errors.NOT_IMPLEMENTED, { operation: method2 });
  }
  _startEvent(event) {
    this.polling = this._events.filter((e6) => e6.pollable()).length > 0;
  }
  _stopEvent(event) {
    this.polling = this._events.filter((e6) => e6.pollable()).length > 0;
  }
  _addEventListener(eventName, listener, once) {
    const event = new Event(getEventTag2(eventName), listener, once);
    this._events.push(event);
    this._startEvent(event);
    return this;
  }
  on(eventName, listener) {
    return this._addEventListener(eventName, listener, false);
  }
  once(eventName, listener) {
    return this._addEventListener(eventName, listener, true);
  }
  emit(eventName, ...args) {
    let result = false;
    let stopped = [];
    let eventTag = getEventTag2(eventName);
    this._events = this._events.filter((event) => {
      if (event.tag !== eventTag) {
        return true;
      }
      setTimeout(() => {
        event.listener.apply(this, args);
      }, 0);
      result = true;
      if (event.once) {
        stopped.push(event);
        return false;
      }
      return true;
    });
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return result;
  }
  listenerCount(eventName) {
    if (!eventName) {
      return this._events.length;
    }
    let eventTag = getEventTag2(eventName);
    return this._events.filter((event) => {
      return event.tag === eventTag;
    }).length;
  }
  listeners(eventName) {
    if (eventName == null) {
      return this._events.map((event) => event.listener);
    }
    let eventTag = getEventTag2(eventName);
    return this._events.filter((event) => event.tag === eventTag).map((event) => event.listener);
  }
  off(eventName, listener) {
    if (listener == null) {
      return this.removeAllListeners(eventName);
    }
    const stopped = [];
    let found = false;
    let eventTag = getEventTag2(eventName);
    this._events = this._events.filter((event) => {
      if (event.tag !== eventTag || event.listener != listener) {
        return true;
      }
      if (found) {
        return true;
      }
      found = true;
      stopped.push(event);
      return false;
    });
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return this;
  }
  removeAllListeners(eventName) {
    let stopped = [];
    if (eventName == null) {
      stopped = this._events;
      this._events = [];
    } else {
      const eventTag = getEventTag2(eventName);
      this._events = this._events.filter((event) => {
        if (event.tag !== eventTag) {
          return true;
        }
        stopped.push(event);
        return false;
      });
    }
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return this;
  }
};

// node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js
init_lib4();

// node_modules/@ethersproject/providers/lib.esm/websocket-provider.js
init_lib3();
init_lib4();

// node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js
init_lib13();
init_lib3();
init_lib2();
init_lib10();
init_lib4();
init_lib9();
init_lib15();
init_lib25();
init_lib();
var __awaiter11 = function(thisArg, _arguments, P5, generator) {
  function adopt(value2) {
    return value2 instanceof P5 ? value2 : new P5(function(resolve) {
      resolve(value2);
    });
  }
  return new (P5 || (P5 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e6) {
        reject(e6);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e6) {
        reject(e6);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger31 = new Logger(version23);
var errorGas = ["call", "estimateGas"];
function spelunk(value2) {
  if (value2 == null) {
    return null;
  }
  if (typeof value2.message === "string" && value2.message.match("reverted") && isHexString(value2.data)) {
    return { message: value2.message, data: value2.data };
  }
  if (typeof value2 === "object") {
    for (const key2 in value2) {
      const result = spelunk(value2[key2]);
      if (result) {
        return result;
      }
    }
    return null;
  }
  if (typeof value2 === "string") {
    try {
      return spelunk(JSON.parse(value2));
    } catch (error) {
    }
  }
  return null;
}
function checkError(method2, error, params) {
  if (method2 === "call") {
    const result = spelunk(error);
    if (result) {
      return result.data;
    }
    logger31.throwError("missing revert data in call exception", Logger.errors.CALL_EXCEPTION, {
      error,
      data: "0x"
    });
  }
  let message = error.message;
  if (error.code === Logger.errors.SERVER_ERROR && error.error && typeof error.error.message === "string") {
    message = error.error.message;
  } else if (typeof error.body === "string") {
    message = error.body;
  } else if (typeof error.responseText === "string") {
    message = error.responseText;
  }
  message = (message || "").toLowerCase();
  const transaction = params.transaction || params.signedTransaction;
  if (message.match(/insufficient funds|base fee exceeds gas limit/)) {
    logger31.throwError("insufficient funds for intrinsic transaction cost", Logger.errors.INSUFFICIENT_FUNDS, {
      error,
      method: method2,
      transaction
    });
  }
  if (message.match(/nonce too low/)) {
    logger31.throwError("nonce has already been used", Logger.errors.NONCE_EXPIRED, {
      error,
      method: method2,
      transaction
    });
  }
  if (message.match(/replacement transaction underpriced/)) {
    logger31.throwError("replacement fee too low", Logger.errors.REPLACEMENT_UNDERPRICED, {
      error,
      method: method2,
      transaction
    });
  }
  if (message.match(/only replay-protected/)) {
    logger31.throwError("legacy pre-eip-155 transactions not supported", Logger.errors.UNSUPPORTED_OPERATION, {
      error,
      method: method2,
      transaction
    });
  }
  if (errorGas.indexOf(method2) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted/)) {
    logger31.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
      error,
      method: method2,
      transaction
    });
  }
  throw error;
}
function timer(timeout2) {
  return new Promise(function(resolve) {
    setTimeout(resolve, timeout2);
  });
}
function getResult(payload) {
  if (payload.error) {
    const error = new Error(payload.error.message);
    error.code = payload.error.code;
    error.data = payload.error.data;
    throw error;
  }
  return payload.result;
}
function getLowerCase(value2) {
  if (value2) {
    return value2.toLowerCase();
  }
  return value2;
}
var _constructorGuard5 = {};
var JsonRpcSigner = class extends Signer {
  constructor(constructorGuard, provider, addressOrIndex) {
    logger31.checkNew(new.target, JsonRpcSigner);
    super();
    if (constructorGuard !== _constructorGuard5) {
      throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");
    }
    defineReadOnly(this, "provider", provider);
    if (addressOrIndex == null) {
      addressOrIndex = 0;
    }
    if (typeof addressOrIndex === "string") {
      defineReadOnly(this, "_address", this.provider.formatter.address(addressOrIndex));
      defineReadOnly(this, "_index", null);
    } else if (typeof addressOrIndex === "number") {
      defineReadOnly(this, "_index", addressOrIndex);
      defineReadOnly(this, "_address", null);
    } else {
      logger31.throwArgumentError("invalid address or index", "addressOrIndex", addressOrIndex);
    }
  }
  connect(provider) {
    return logger31.throwError("cannot alter JSON-RPC Signer connection", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "connect"
    });
  }
  connectUnchecked() {
    return new UncheckedJsonRpcSigner(_constructorGuard5, this.provider, this._address || this._index);
  }
  getAddress() {
    if (this._address) {
      return Promise.resolve(this._address);
    }
    return this.provider.send("eth_accounts", []).then((accounts) => {
      if (accounts.length <= this._index) {
        logger31.throwError("unknown account #" + this._index, Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "getAddress"
        });
      }
      return this.provider.formatter.address(accounts[this._index]);
    });
  }
  sendUncheckedTransaction(transaction) {
    transaction = shallowCopy(transaction);
    const fromAddress = this.getAddress().then((address) => {
      if (address) {
        address = address.toLowerCase();
      }
      return address;
    });
    if (transaction.gasLimit == null) {
      const estimate = shallowCopy(transaction);
      estimate.from = fromAddress;
      transaction.gasLimit = this.provider.estimateGas(estimate);
    }
    if (transaction.to != null) {
      transaction.to = Promise.resolve(transaction.to).then((to2) => __awaiter11(this, void 0, void 0, function* () {
        if (to2 == null) {
          return null;
        }
        const address = yield this.provider.resolveName(to2);
        if (address == null) {
          logger31.throwArgumentError("provided ENS name resolves to null", "tx.to", to2);
        }
        return address;
      }));
    }
    return resolveProperties({
      tx: resolveProperties(transaction),
      sender: fromAddress
    }).then(({ tx, sender }) => {
      if (tx.from != null) {
        if (tx.from.toLowerCase() !== sender) {
          logger31.throwArgumentError("from address mismatch", "transaction", transaction);
        }
      } else {
        tx.from = sender;
      }
      const hexTx = this.provider.constructor.hexlifyTransaction(tx, { from: true });
      return this.provider.send("eth_sendTransaction", [hexTx]).then((hash3) => {
        return hash3;
      }, (error) => {
        return checkError("sendTransaction", error, hexTx);
      });
    });
  }
  signTransaction(transaction) {
    return logger31.throwError("signing transactions is unsupported", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "signTransaction"
    });
  }
  sendTransaction(transaction) {
    return __awaiter11(this, void 0, void 0, function* () {
      const blockNumber = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);
      const hash3 = yield this.sendUncheckedTransaction(transaction);
      try {
        return yield poll(() => __awaiter11(this, void 0, void 0, function* () {
          const tx = yield this.provider.getTransaction(hash3);
          if (tx === null) {
            return void 0;
          }
          return this.provider._wrapTransaction(tx, hash3, blockNumber);
        }), { oncePoll: this.provider });
      } catch (error) {
        error.transactionHash = hash3;
        throw error;
      }
    });
  }
  signMessage(message) {
    return __awaiter11(this, void 0, void 0, function* () {
      const data = typeof message === "string" ? toUtf8Bytes(message) : message;
      const address = yield this.getAddress();
      return yield this.provider.send("personal_sign", [hexlify(data), address.toLowerCase()]);
    });
  }
  _legacySignMessage(message) {
    return __awaiter11(this, void 0, void 0, function* () {
      const data = typeof message === "string" ? toUtf8Bytes(message) : message;
      const address = yield this.getAddress();
      return yield this.provider.send("eth_sign", [address.toLowerCase(), hexlify(data)]);
    });
  }
  _signTypedData(domain2, types, value2) {
    return __awaiter11(this, void 0, void 0, function* () {
      const populated = yield TypedDataEncoder.resolveNames(domain2, types, value2, (name2) => {
        return this.provider.resolveName(name2);
      });
      const address = yield this.getAddress();
      return yield this.provider.send("eth_signTypedData_v4", [
        address.toLowerCase(),
        JSON.stringify(TypedDataEncoder.getPayload(populated.domain, types, populated.value))
      ]);
    });
  }
  unlock(password) {
    return __awaiter11(this, void 0, void 0, function* () {
      const provider = this.provider;
      const address = yield this.getAddress();
      return provider.send("personal_unlockAccount", [address.toLowerCase(), password, null]);
    });
  }
};
var UncheckedJsonRpcSigner = class extends JsonRpcSigner {
  sendTransaction(transaction) {
    return this.sendUncheckedTransaction(transaction).then((hash3) => {
      return {
        hash: hash3,
        nonce: null,
        gasLimit: null,
        gasPrice: null,
        data: null,
        value: null,
        chainId: null,
        confirmations: 0,
        from: null,
        wait: (confirmations) => {
          return this.provider.waitForTransaction(hash3, confirmations);
        }
      };
    });
  }
};
var allowedTransactionKeys4 = {
  chainId: true,
  data: true,
  gasLimit: true,
  gasPrice: true,
  nonce: true,
  to: true,
  value: true,
  type: true,
  accessList: true,
  maxFeePerGas: true,
  maxPriorityFeePerGas: true
};
var JsonRpcProvider = class extends BaseProvider {
  constructor(url, network) {
    logger31.checkNew(new.target, JsonRpcProvider);
    let networkOrReady = network;
    if (networkOrReady == null) {
      networkOrReady = new Promise((resolve, reject) => {
        setTimeout(() => {
          this.detectNetwork().then((network2) => {
            resolve(network2);
          }, (error) => {
            reject(error);
          });
        }, 0);
      });
    }
    super(networkOrReady);
    if (!url) {
      url = getStatic(this.constructor, "defaultUrl")();
    }
    if (typeof url === "string") {
      defineReadOnly(this, "connection", Object.freeze({
        url
      }));
    } else {
      defineReadOnly(this, "connection", Object.freeze(shallowCopy(url)));
    }
    this._nextId = 42;
  }
  get _cache() {
    if (this._eventLoopCache == null) {
      this._eventLoopCache = {};
    }
    return this._eventLoopCache;
  }
  static defaultUrl() {
    return "http://localhost:8545";
  }
  detectNetwork() {
    if (!this._cache["detectNetwork"]) {
      this._cache["detectNetwork"] = this._uncachedDetectNetwork();
      setTimeout(() => {
        this._cache["detectNetwork"] = null;
      }, 0);
    }
    return this._cache["detectNetwork"];
  }
  _uncachedDetectNetwork() {
    return __awaiter11(this, void 0, void 0, function* () {
      yield timer(0);
      let chainId = null;
      try {
        chainId = yield this.send("eth_chainId", []);
      } catch (error) {
        try {
          chainId = yield this.send("net_version", []);
        } catch (error2) {
        }
      }
      if (chainId != null) {
        const getNetwork2 = getStatic(this.constructor, "getNetwork");
        try {
          return getNetwork2(BigNumber.from(chainId).toNumber());
        } catch (error) {
          return logger31.throwError("could not detect network", Logger.errors.NETWORK_ERROR, {
            chainId,
            event: "invalidNetwork",
            serverError: error
          });
        }
      }
      return logger31.throwError("could not detect network", Logger.errors.NETWORK_ERROR, {
        event: "noNetwork"
      });
    });
  }
  getSigner(addressOrIndex) {
    return new JsonRpcSigner(_constructorGuard5, this, addressOrIndex);
  }
  getUncheckedSigner(addressOrIndex) {
    return this.getSigner(addressOrIndex).connectUnchecked();
  }
  listAccounts() {
    return this.send("eth_accounts", []).then((accounts) => {
      return accounts.map((a5) => this.formatter.address(a5));
    });
  }
  send(method2, params) {
    const request = {
      method: method2,
      params,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    this.emit("debug", {
      action: "request",
      request: deepCopy(request),
      provider: this
    });
    const cache = ["eth_chainId", "eth_blockNumber"].indexOf(method2) >= 0;
    if (cache && this._cache[method2]) {
      return this._cache[method2];
    }
    const result = fetchJson(this.connection, JSON.stringify(request), getResult).then((result2) => {
      this.emit("debug", {
        action: "response",
        request,
        response: result2,
        provider: this
      });
      return result2;
    }, (error) => {
      this.emit("debug", {
        action: "response",
        error,
        request,
        provider: this
      });
      throw error;
    });
    if (cache) {
      this._cache[method2] = result;
      setTimeout(() => {
        this._cache[method2] = null;
      }, 0);
    }
    return result;
  }
  prepareRequest(method2, params) {
    switch (method2) {
      case "getBlockNumber":
        return ["eth_blockNumber", []];
      case "getGasPrice":
        return ["eth_gasPrice", []];
      case "getBalance":
        return ["eth_getBalance", [getLowerCase(params.address), params.blockTag]];
      case "getTransactionCount":
        return ["eth_getTransactionCount", [getLowerCase(params.address), params.blockTag]];
      case "getCode":
        return ["eth_getCode", [getLowerCase(params.address), params.blockTag]];
      case "getStorageAt":
        return ["eth_getStorageAt", [getLowerCase(params.address), params.position, params.blockTag]];
      case "sendTransaction":
        return ["eth_sendRawTransaction", [params.signedTransaction]];
      case "getBlock":
        if (params.blockTag) {
          return ["eth_getBlockByNumber", [params.blockTag, !!params.includeTransactions]];
        } else if (params.blockHash) {
          return ["eth_getBlockByHash", [params.blockHash, !!params.includeTransactions]];
        }
        return null;
      case "getTransaction":
        return ["eth_getTransactionByHash", [params.transactionHash]];
      case "getTransactionReceipt":
        return ["eth_getTransactionReceipt", [params.transactionHash]];
      case "call": {
        const hexlifyTransaction = getStatic(this.constructor, "hexlifyTransaction");
        return ["eth_call", [hexlifyTransaction(params.transaction, { from: true }), params.blockTag]];
      }
      case "estimateGas": {
        const hexlifyTransaction = getStatic(this.constructor, "hexlifyTransaction");
        return ["eth_estimateGas", [hexlifyTransaction(params.transaction, { from: true })]];
      }
      case "getLogs":
        if (params.filter && params.filter.address != null) {
          params.filter.address = getLowerCase(params.filter.address);
        }
        return ["eth_getLogs", [params.filter]];
      default:
        break;
    }
    return null;
  }
  perform(method2, params) {
    return __awaiter11(this, void 0, void 0, function* () {
      if (method2 === "call" || method2 === "estimateGas") {
        const tx = params.transaction;
        if (tx && tx.type != null && BigNumber.from(tx.type).isZero()) {
          if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
            const feeData = yield this.getFeeData();
            if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
              params = shallowCopy(params);
              params.transaction = shallowCopy(tx);
              delete params.transaction.type;
            }
          }
        }
      }
      const args = this.prepareRequest(method2, params);
      if (args == null) {
        logger31.throwError(method2 + " not implemented", Logger.errors.NOT_IMPLEMENTED, { operation: method2 });
      }
      try {
        return yield this.send(args[0], args[1]);
      } catch (error) {
        return checkError(method2, error, params);
      }
    });
  }
  _startEvent(event) {
    if (event.tag === "pending") {
      this._startPending();
    }
    super._startEvent(event);
  }
  _startPending() {
    if (this._pendingFilter != null) {
      return;
    }
    const self2 = this;
    const pendingFilter = this.send("eth_newPendingTransactionFilter", []);
    this._pendingFilter = pendingFilter;
    pendingFilter.then(function(filterId) {
      function poll2() {
        self2.send("eth_getFilterChanges", [filterId]).then(function(hashes) {
          if (self2._pendingFilter != pendingFilter) {
            return null;
          }
          let seq = Promise.resolve();
          hashes.forEach(function(hash3) {
            self2._emitted["t:" + hash3.toLowerCase()] = "pending";
            seq = seq.then(function() {
              return self2.getTransaction(hash3).then(function(tx) {
                self2.emit("pending", tx);
                return null;
              });
            });
          });
          return seq.then(function() {
            return timer(1e3);
          });
        }).then(function() {
          if (self2._pendingFilter != pendingFilter) {
            self2.send("eth_uninstallFilter", [filterId]);
            return;
          }
          setTimeout(function() {
            poll2();
          }, 0);
          return null;
        }).catch((error) => {
        });
      }
      poll2();
      return filterId;
    }).catch((error) => {
    });
  }
  _stopEvent(event) {
    if (event.tag === "pending" && this.listenerCount("pending") === 0) {
      this._pendingFilter = null;
    }
    super._stopEvent(event);
  }
  static hexlifyTransaction(transaction, allowExtra) {
    const allowed = shallowCopy(allowedTransactionKeys4);
    if (allowExtra) {
      for (const key2 in allowExtra) {
        if (allowExtra[key2]) {
          allowed[key2] = true;
        }
      }
    }
    checkProperties(transaction, allowed);
    const result = {};
    ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function(key2) {
      if (transaction[key2] == null) {
        return;
      }
      const value2 = hexValue(transaction[key2]);
      if (key2 === "gasLimit") {
        key2 = "gas";
      }
      result[key2] = value2;
    });
    ["from", "to", "data"].forEach(function(key2) {
      if (transaction[key2] == null) {
        return;
      }
      result[key2] = hexlify(transaction[key2]);
    });
    if (transaction.accessList) {
      result["accessList"] = accessListify(transaction.accessList);
    }
    return result;
  }
};

// node_modules/@ethersproject/providers/lib.esm/ws.js
init_lib();
var WS = null;
try {
  WS = WebSocket;
  if (WS == null) {
    throw new Error("inject please");
  }
} catch (error) {
  const logger47 = new Logger(version23);
  WS = function() {
    logger47.throwError("WebSockets not supported in this environment", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "new WebSocket()"
    });
  };
}

// node_modules/@ethersproject/providers/lib.esm/websocket-provider.js
init_lib();
var __awaiter12 = function(thisArg, _arguments, P5, generator) {
  function adopt(value2) {
    return value2 instanceof P5 ? value2 : new P5(function(resolve) {
      resolve(value2);
    });
  }
  return new (P5 || (P5 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e6) {
        reject(e6);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e6) {
        reject(e6);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger32 = new Logger(version23);
var NextId = 1;
var WebSocketProvider = class extends JsonRpcProvider {
  constructor(url, network) {
    if (network === "any") {
      logger32.throwError("WebSocketProvider does not support 'any' network yet", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "network:any"
      });
    }
    if (typeof url === "string") {
      super(url, network);
    } else {
      super("_websocket", network);
    }
    this._pollingInterval = -1;
    this._wsReady = false;
    if (typeof url === "string") {
      defineReadOnly(this, "_websocket", new WS(this.connection.url));
    } else {
      defineReadOnly(this, "_websocket", url);
    }
    defineReadOnly(this, "_requests", {});
    defineReadOnly(this, "_subs", {});
    defineReadOnly(this, "_subIds", {});
    defineReadOnly(this, "_detectNetwork", super.detectNetwork());
    this.websocket.onopen = () => {
      this._wsReady = true;
      Object.keys(this._requests).forEach((id2) => {
        this.websocket.send(this._requests[id2].payload);
      });
    };
    this.websocket.onmessage = (messageEvent) => {
      const data = messageEvent.data;
      const result = JSON.parse(data);
      if (result.id != null) {
        const id2 = String(result.id);
        const request = this._requests[id2];
        delete this._requests[id2];
        if (result.result !== void 0) {
          request.callback(null, result.result);
          this.emit("debug", {
            action: "response",
            request: JSON.parse(request.payload),
            response: result.result,
            provider: this
          });
        } else {
          let error = null;
          if (result.error) {
            error = new Error(result.error.message || "unknown error");
            defineReadOnly(error, "code", result.error.code || null);
            defineReadOnly(error, "response", data);
          } else {
            error = new Error("unknown error");
          }
          request.callback(error, void 0);
          this.emit("debug", {
            action: "response",
            error,
            request: JSON.parse(request.payload),
            provider: this
          });
        }
      } else if (result.method === "eth_subscription") {
        const sub = this._subs[result.params.subscription];
        if (sub) {
          sub.processFunc(result.params.result);
        }
      } else {
        console.warn("this should not happen");
      }
    };
    const fauxPoll = setInterval(() => {
      this.emit("poll");
    }, 1e3);
    if (fauxPoll.unref) {
      fauxPoll.unref();
    }
  }
  get websocket() {
    return this._websocket;
  }
  detectNetwork() {
    return this._detectNetwork;
  }
  get pollingInterval() {
    return 0;
  }
  resetEventsBlock(blockNumber) {
    logger32.throwError("cannot reset events block on WebSocketProvider", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "resetEventBlock"
    });
  }
  set pollingInterval(value2) {
    logger32.throwError("cannot set polling interval on WebSocketProvider", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "setPollingInterval"
    });
  }
  poll() {
    return __awaiter12(this, void 0, void 0, function* () {
      return null;
    });
  }
  set polling(value2) {
    if (!value2) {
      return;
    }
    logger32.throwError("cannot set polling on WebSocketProvider", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "setPolling"
    });
  }
  send(method2, params) {
    const rid = NextId++;
    return new Promise((resolve, reject) => {
      function callback(error, result) {
        if (error) {
          return reject(error);
        }
        return resolve(result);
      }
      const payload = JSON.stringify({
        method: method2,
        params,
        id: rid,
        jsonrpc: "2.0"
      });
      this.emit("debug", {
        action: "request",
        request: JSON.parse(payload),
        provider: this
      });
      this._requests[String(rid)] = { callback, payload };
      if (this._wsReady) {
        this.websocket.send(payload);
      }
    });
  }
  static defaultUrl() {
    return "ws://localhost:8546";
  }
  _subscribe(tag, param, processFunc) {
    return __awaiter12(this, void 0, void 0, function* () {
      let subIdPromise = this._subIds[tag];
      if (subIdPromise == null) {
        subIdPromise = Promise.all(param).then((param2) => {
          return this.send("eth_subscribe", param2);
        });
        this._subIds[tag] = subIdPromise;
      }
      const subId = yield subIdPromise;
      this._subs[subId] = { tag, processFunc };
    });
  }
  _startEvent(event) {
    switch (event.type) {
      case "block":
        this._subscribe("block", ["newHeads"], (result) => {
          const blockNumber = BigNumber.from(result.number).toNumber();
          this._emitted.block = blockNumber;
          this.emit("block", blockNumber);
        });
        break;
      case "pending":
        this._subscribe("pending", ["newPendingTransactions"], (result) => {
          this.emit("pending", result);
        });
        break;
      case "filter":
        this._subscribe(event.tag, ["logs", this._getFilter(event.filter)], (result) => {
          if (result.removed == null) {
            result.removed = false;
          }
          this.emit(event.filter, this.formatter.filterLog(result));
        });
        break;
      case "tx": {
        const emitReceipt = (event2) => {
          const hash3 = event2.hash;
          this.getTransactionReceipt(hash3).then((receipt) => {
            if (!receipt) {
              return;
            }
            this.emit(hash3, receipt);
          });
        };
        emitReceipt(event);
        this._subscribe("tx", ["newHeads"], (result) => {
          this._events.filter((e6) => e6.type === "tx").forEach(emitReceipt);
        });
        break;
      }
      case "debug":
      case "poll":
      case "willPoll":
      case "didPoll":
      case "error":
        break;
      default:
        console.log("unhandled:", event);
        break;
    }
  }
  _stopEvent(event) {
    let tag = event.tag;
    if (event.type === "tx") {
      if (this._events.filter((e6) => e6.type === "tx").length) {
        return;
      }
      tag = "tx";
    } else if (this.listenerCount(event.event)) {
      return;
    }
    const subId = this._subIds[tag];
    if (!subId) {
      return;
    }
    delete this._subIds[tag];
    subId.then((subId2) => {
      if (!this._subs[subId2]) {
        return;
      }
      delete this._subs[subId2];
      this.send("eth_unsubscribe", [subId2]);
    });
  }
  destroy() {
    return __awaiter12(this, void 0, void 0, function* () {
      if (this.websocket.readyState === WS.CONNECTING) {
        yield new Promise((resolve) => {
          this.websocket.onopen = function() {
            resolve(true);
          };
          this.websocket.onerror = function() {
            resolve(false);
          };
        });
      }
      this.websocket.close(1e3);
    });
  }
};

// node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js
init_lib();

// node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js
init_lib4();
init_lib();
var __awaiter13 = function(thisArg, _arguments, P5, generator) {
  function adopt(value2) {
    return value2 instanceof P5 ? value2 : new P5(function(resolve) {
      resolve(value2);
    });
  }
  return new (P5 || (P5 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e6) {
        reject(e6);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e6) {
        reject(e6);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger33 = new Logger(version23);
var StaticJsonRpcProvider = class extends JsonRpcProvider {
  detectNetwork() {
    const _super = Object.create(null, {
      detectNetwork: { get: () => super.detectNetwork }
    });
    return __awaiter13(this, void 0, void 0, function* () {
      let network = this.network;
      if (network == null) {
        network = yield _super.detectNetwork.call(this);
        if (!network) {
          logger33.throwError("no network detected", Logger.errors.UNKNOWN_ERROR, {});
        }
        if (this._network == null) {
          defineReadOnly(this, "_network", network);
          this.emit("network", network, null);
        }
      }
      return network;
    });
  }
};
var UrlJsonRpcProvider = class extends StaticJsonRpcProvider {
  constructor(network, apiKey) {
    logger33.checkAbstract(new.target, UrlJsonRpcProvider);
    network = getStatic(new.target, "getNetwork")(network);
    apiKey = getStatic(new.target, "getApiKey")(apiKey);
    const connection = getStatic(new.target, "getUrl")(network, apiKey);
    super(connection, network);
    if (typeof apiKey === "string") {
      defineReadOnly(this, "apiKey", apiKey);
    } else if (apiKey != null) {
      Object.keys(apiKey).forEach((key2) => {
        defineReadOnly(this, key2, apiKey[key2]);
      });
    }
  }
  _startPending() {
    logger33.warn("WARNING: API provider does not support pending filters");
  }
  isCommunityResource() {
    return false;
  }
  getSigner(address) {
    return logger33.throwError("API provider does not support signing", Logger.errors.UNSUPPORTED_OPERATION, { operation: "getSigner" });
  }
  listAccounts() {
    return Promise.resolve([]);
  }
  static getApiKey(apiKey) {
    return apiKey;
  }
  static getUrl(network, apiKey) {
    return logger33.throwError("not implemented; sub-classes must override getUrl", Logger.errors.NOT_IMPLEMENTED, {
      operation: "getUrl"
    });
  }
};

// node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js
var logger34 = new Logger(version23);
var defaultApiKey = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
var AlchemyWebSocketProvider = class extends WebSocketProvider {
  constructor(network, apiKey) {
    const provider = new AlchemyProvider(network, apiKey);
    const url = provider.connection.url.replace(/^http/i, "ws").replace(".alchemyapi.", ".ws.alchemyapi.");
    super(url, provider.network);
    defineReadOnly(this, "apiKey", provider.apiKey);
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey;
  }
};
var AlchemyProvider = class extends UrlJsonRpcProvider {
  static getWebSocketProvider(network, apiKey) {
    return new AlchemyWebSocketProvider(network, apiKey);
  }
  static getApiKey(apiKey) {
    if (apiKey == null) {
      return defaultApiKey;
    }
    if (apiKey && typeof apiKey !== "string") {
      logger34.throwArgumentError("invalid apiKey", "apiKey", apiKey);
    }
    return apiKey;
  }
  static getUrl(network, apiKey) {
    let host = null;
    switch (network.name) {
      case "homestead":
        host = "eth-mainnet.alchemyapi.io/v2/";
        break;
      case "ropsten":
        host = "eth-ropsten.alchemyapi.io/v2/";
        break;
      case "rinkeby":
        host = "eth-rinkeby.alchemyapi.io/v2/";
        break;
      case "goerli":
        host = "eth-goerli.alchemyapi.io/v2/";
        break;
      case "kovan":
        host = "eth-kovan.alchemyapi.io/v2/";
        break;
      case "matic":
        host = "polygon-mainnet.g.alchemy.com/v2/";
        break;
      case "maticmum":
        host = "polygon-mumbai.g.alchemy.com/v2/";
        break;
      case "arbitrum":
        host = "arb-mainnet.g.alchemy.com/v2/";
        break;
      case "arbitrum-rinkeby":
        host = "arb-rinkeby.g.alchemy.com/v2/";
        break;
      case "optimism":
        host = "opt-mainnet.g.alchemy.com/v2/";
        break;
      case "optimism-kovan":
        host = "opt-kovan.g.alchemy.com/v2/";
        break;
      default:
        logger34.throwArgumentError("unsupported network", "network", arguments[0]);
    }
    return {
      allowGzip: true,
      url: "https://" + host + apiKey,
      throttleCallback: (attempt, url) => {
        if (apiKey === defaultApiKey) {
          showThrottleMessage();
        }
        return Promise.resolve(true);
      }
    };
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey;
  }
};

// node_modules/@ethersproject/providers/lib.esm/ankr-provider.js
init_lib();
var logger35 = new Logger(version23);
var defaultApiKey2 = "9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972";
function getHost(name2) {
  switch (name2) {
    case "homestead":
      return "rpc.ankr.com/eth/";
    case "matic":
      return "rpc.ankr.com/polygon/";
    case "arbitrum":
      return "rpc.ankr.com/arbitrum/";
  }
  return logger35.throwArgumentError("unsupported network", "name", name2);
}
var AnkrProvider = class extends UrlJsonRpcProvider {
  isCommunityResource() {
    return this.apiKey === defaultApiKey2;
  }
  static getApiKey(apiKey) {
    if (apiKey == null) {
      return defaultApiKey2;
    }
    return apiKey;
  }
  static getUrl(network, apiKey) {
    if (apiKey == null) {
      apiKey = defaultApiKey2;
    }
    const connection = {
      allowGzip: true,
      url: "https://" + getHost(network.name) + apiKey,
      throttleCallback: (attempt, url) => {
        if (apiKey.apiKey === defaultApiKey2) {
          showThrottleMessage();
        }
        return Promise.resolve(true);
      }
    };
    if (apiKey.projectSecret != null) {
      connection.user = "";
      connection.password = apiKey.projectSecret;
    }
    return connection;
  }
};

// node_modules/@ethersproject/providers/lib.esm/cloudflare-provider.js
init_lib();
var __awaiter14 = function(thisArg, _arguments, P5, generator) {
  function adopt(value2) {
    return value2 instanceof P5 ? value2 : new P5(function(resolve) {
      resolve(value2);
    });
  }
  return new (P5 || (P5 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e6) {
        reject(e6);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e6) {
        reject(e6);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger36 = new Logger(version23);
var CloudflareProvider = class extends UrlJsonRpcProvider {
  static getApiKey(apiKey) {
    if (apiKey != null) {
      logger36.throwArgumentError("apiKey not supported for cloudflare", "apiKey", apiKey);
    }
    return null;
  }
  static getUrl(network, apiKey) {
    let host = null;
    switch (network.name) {
      case "homestead":
        host = "https://cloudflare-eth.com/";
        break;
      default:
        logger36.throwArgumentError("unsupported network", "network", arguments[0]);
    }
    return host;
  }
  perform(method2, params) {
    const _super = Object.create(null, {
      perform: { get: () => super.perform }
    });
    return __awaiter14(this, void 0, void 0, function* () {
      if (method2 === "getBlockNumber") {
        const block = yield _super.perform.call(this, "getBlock", { blockTag: "latest" });
        return block.number;
      }
      return _super.perform.call(this, method2, params);
    });
  }
};

// node_modules/@ethersproject/providers/lib.esm/etherscan-provider.js
init_lib2();
init_lib4();
init_lib15();
init_lib25();
init_lib();
var __awaiter15 = function(thisArg, _arguments, P5, generator) {
  function adopt(value2) {
    return value2 instanceof P5 ? value2 : new P5(function(resolve) {
      resolve(value2);
    });
  }
  return new (P5 || (P5 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e6) {
        reject(e6);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e6) {
        reject(e6);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger37 = new Logger(version23);
function getTransactionPostData(transaction) {
  const result = {};
  for (let key2 in transaction) {
    if (transaction[key2] == null) {
      continue;
    }
    let value2 = transaction[key2];
    if (key2 === "type" && value2 === 0) {
      continue;
    }
    if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key2]) {
      value2 = hexValue(hexlify(value2));
    } else if (key2 === "accessList") {
      value2 = "[" + accessListify(value2).map((set) => {
        return `{address:"${set.address}",storageKeys:["${set.storageKeys.join('","')}"]}`;
      }).join(",") + "]";
    } else {
      value2 = hexlify(value2);
    }
    result[key2] = value2;
  }
  return result;
}
function getResult2(result) {
  if (result.status == 0 && (result.message === "No records found" || result.message === "No transactions found")) {
    return result.result;
  }
  if (result.status != 1 || result.message != "OK") {
    const error = new Error("invalid response");
    error.result = JSON.stringify(result);
    if ((result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
      error.throttleRetry = true;
    }
    throw error;
  }
  return result.result;
}
function getJsonResult(result) {
  if (result && result.status == 0 && result.message == "NOTOK" && (result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
    const error = new Error("throttled response");
    error.result = JSON.stringify(result);
    error.throttleRetry = true;
    throw error;
  }
  if (result.jsonrpc != "2.0") {
    const error = new Error("invalid response");
    error.result = JSON.stringify(result);
    throw error;
  }
  if (result.error) {
    const error = new Error(result.error.message || "unknown error");
    if (result.error.code) {
      error.code = result.error.code;
    }
    if (result.error.data) {
      error.data = result.error.data;
    }
    throw error;
  }
  return result.result;
}
function checkLogTag(blockTag) {
  if (blockTag === "pending") {
    throw new Error("pending not supported");
  }
  if (blockTag === "latest") {
    return blockTag;
  }
  return parseInt(blockTag.substring(2), 16);
}
var defaultApiKey3 = "9D13ZE7XSBTJ94N9BNJ2MA33VMAY2YPIRB";
function checkError2(method2, error, transaction) {
  if (method2 === "call" && error.code === Logger.errors.SERVER_ERROR) {
    const e6 = error.error;
    if (e6 && (e6.message.match(/reverted/i) || e6.message.match(/VM execution error/i))) {
      let data = e6.data;
      if (data) {
        data = "0x" + data.replace(/^.*0x/i, "");
      }
      if (isHexString(data)) {
        return data;
      }
      logger37.throwError("missing revert data in call exception", Logger.errors.CALL_EXCEPTION, {
        error,
        data: "0x"
      });
    }
  }
  let message = error.message;
  if (error.code === Logger.errors.SERVER_ERROR) {
    if (error.error && typeof error.error.message === "string") {
      message = error.error.message;
    } else if (typeof error.body === "string") {
      message = error.body;
    } else if (typeof error.responseText === "string") {
      message = error.responseText;
    }
  }
  message = (message || "").toLowerCase();
  if (message.match(/insufficient funds/)) {
    logger37.throwError("insufficient funds for intrinsic transaction cost", Logger.errors.INSUFFICIENT_FUNDS, {
      error,
      method: method2,
      transaction
    });
  }
  if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {
    logger37.throwError("nonce has already been used", Logger.errors.NONCE_EXPIRED, {
      error,
      method: method2,
      transaction
    });
  }
  if (message.match(/another transaction with same nonce/)) {
    logger37.throwError("replacement fee too low", Logger.errors.REPLACEMENT_UNDERPRICED, {
      error,
      method: method2,
      transaction
    });
  }
  if (message.match(/execution failed due to an exception|execution reverted/)) {
    logger37.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
      error,
      method: method2,
      transaction
    });
  }
  throw error;
}
var EtherscanProvider = class extends BaseProvider {
  constructor(network, apiKey) {
    logger37.checkNew(new.target, EtherscanProvider);
    super(network);
    defineReadOnly(this, "baseUrl", this.getBaseUrl());
    defineReadOnly(this, "apiKey", apiKey || defaultApiKey3);
  }
  getBaseUrl() {
    switch (this.network ? this.network.name : "invalid") {
      case "homestead":
        return "https://api.etherscan.io";
      case "ropsten":
        return "https://api-ropsten.etherscan.io";
      case "rinkeby":
        return "https://api-rinkeby.etherscan.io";
      case "kovan":
        return "https://api-kovan.etherscan.io";
      case "goerli":
        return "https://api-goerli.etherscan.io";
      default:
    }
    return logger37.throwArgumentError("unsupported network", "network", name);
  }
  getUrl(module2, params) {
    const query = Object.keys(params).reduce((accum, key2) => {
      const value2 = params[key2];
      if (value2 != null) {
        accum += `&${key2}=${value2}`;
      }
      return accum;
    }, "");
    const apiKey = this.apiKey ? `&apikey=${this.apiKey}` : "";
    return `${this.baseUrl}/api?module=${module2}${query}${apiKey}`;
  }
  getPostUrl() {
    return `${this.baseUrl}/api`;
  }
  getPostData(module2, params) {
    params.module = module2;
    params.apikey = this.apiKey;
    return params;
  }
  fetch(module2, params, post) {
    return __awaiter15(this, void 0, void 0, function* () {
      const url = post ? this.getPostUrl() : this.getUrl(module2, params);
      const payload = post ? this.getPostData(module2, params) : null;
      const procFunc = module2 === "proxy" ? getJsonResult : getResult2;
      this.emit("debug", {
        action: "request",
        request: url,
        provider: this
      });
      const connection = {
        url,
        throttleSlotInterval: 1e3,
        throttleCallback: (attempt, url2) => {
          if (this.isCommunityResource()) {
            showThrottleMessage();
          }
          return Promise.resolve(true);
        }
      };
      let payloadStr = null;
      if (payload) {
        connection.headers = { "content-type": "application/x-www-form-urlencoded; charset=UTF-8" };
        payloadStr = Object.keys(payload).map((key2) => {
          return `${key2}=${payload[key2]}`;
        }).join("&");
      }
      const result = yield fetchJson(connection, payloadStr, procFunc || getJsonResult);
      this.emit("debug", {
        action: "response",
        request: url,
        response: deepCopy(result),
        provider: this
      });
      return result;
    });
  }
  detectNetwork() {
    return __awaiter15(this, void 0, void 0, function* () {
      return this.network;
    });
  }
  perform(method2, params) {
    const _super = Object.create(null, {
      perform: { get: () => super.perform }
    });
    return __awaiter15(this, void 0, void 0, function* () {
      switch (method2) {
        case "getBlockNumber":
          return this.fetch("proxy", { action: "eth_blockNumber" });
        case "getGasPrice":
          return this.fetch("proxy", { action: "eth_gasPrice" });
        case "getBalance":
          return this.fetch("account", {
            action: "balance",
            address: params.address,
            tag: params.blockTag
          });
        case "getTransactionCount":
          return this.fetch("proxy", {
            action: "eth_getTransactionCount",
            address: params.address,
            tag: params.blockTag
          });
        case "getCode":
          return this.fetch("proxy", {
            action: "eth_getCode",
            address: params.address,
            tag: params.blockTag
          });
        case "getStorageAt":
          return this.fetch("proxy", {
            action: "eth_getStorageAt",
            address: params.address,
            position: params.position,
            tag: params.blockTag
          });
        case "sendTransaction":
          return this.fetch("proxy", {
            action: "eth_sendRawTransaction",
            hex: params.signedTransaction
          }, true).catch((error) => {
            return checkError2("sendTransaction", error, params.signedTransaction);
          });
        case "getBlock":
          if (params.blockTag) {
            return this.fetch("proxy", {
              action: "eth_getBlockByNumber",
              tag: params.blockTag,
              boolean: params.includeTransactions ? "true" : "false"
            });
          }
          throw new Error("getBlock by blockHash not implemented");
        case "getTransaction":
          return this.fetch("proxy", {
            action: "eth_getTransactionByHash",
            txhash: params.transactionHash
          });
        case "getTransactionReceipt":
          return this.fetch("proxy", {
            action: "eth_getTransactionReceipt",
            txhash: params.transactionHash
          });
        case "call": {
          if (params.blockTag !== "latest") {
            throw new Error("EtherscanProvider does not support blockTag for call");
          }
          const postData = getTransactionPostData(params.transaction);
          postData.module = "proxy";
          postData.action = "eth_call";
          try {
            return yield this.fetch("proxy", postData, true);
          } catch (error) {
            return checkError2("call", error, params.transaction);
          }
        }
        case "estimateGas": {
          const postData = getTransactionPostData(params.transaction);
          postData.module = "proxy";
          postData.action = "eth_estimateGas";
          try {
            return yield this.fetch("proxy", postData, true);
          } catch (error) {
            return checkError2("estimateGas", error, params.transaction);
          }
        }
        case "getLogs": {
          const args = { action: "getLogs" };
          if (params.filter.fromBlock) {
            args.fromBlock = checkLogTag(params.filter.fromBlock);
          }
          if (params.filter.toBlock) {
            args.toBlock = checkLogTag(params.filter.toBlock);
          }
          if (params.filter.address) {
            args.address = params.filter.address;
          }
          if (params.filter.topics && params.filter.topics.length > 0) {
            if (params.filter.topics.length > 1) {
              logger37.throwError("unsupported topic count", Logger.errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });
            }
            if (params.filter.topics.length === 1) {
              const topic0 = params.filter.topics[0];
              if (typeof topic0 !== "string" || topic0.length !== 66) {
                logger37.throwError("unsupported topic format", Logger.errors.UNSUPPORTED_OPERATION, { topic0 });
              }
              args.topic0 = topic0;
            }
          }
          const logs = yield this.fetch("logs", args);
          let blocks2 = {};
          for (let i6 = 0; i6 < logs.length; i6++) {
            const log = logs[i6];
            if (log.blockHash != null) {
              continue;
            }
            if (blocks2[log.blockNumber] == null) {
              const block = yield this.getBlock(log.blockNumber);
              if (block) {
                blocks2[log.blockNumber] = block.hash;
              }
            }
            log.blockHash = blocks2[log.blockNumber];
          }
          return logs;
        }
        case "getEtherPrice":
          if (this.network.name !== "homestead") {
            return 0;
          }
          return parseFloat((yield this.fetch("stats", { action: "ethprice" })).ethusd);
        default:
          break;
      }
      return _super.perform.call(this, method2, params);
    });
  }
  getHistory(addressOrName, startBlock, endBlock) {
    return __awaiter15(this, void 0, void 0, function* () {
      const params = {
        action: "txlist",
        address: yield this.resolveName(addressOrName),
        startblock: startBlock == null ? 0 : startBlock,
        endblock: endBlock == null ? 99999999 : endBlock,
        sort: "asc"
      };
      const result = yield this.fetch("account", params);
      return result.map((tx) => {
        ["contractAddress", "to"].forEach(function(key2) {
          if (tx[key2] == "") {
            delete tx[key2];
          }
        });
        if (tx.creates == null && tx.contractAddress != null) {
          tx.creates = tx.contractAddress;
        }
        const item = this.formatter.transactionResponse(tx);
        if (tx.timeStamp) {
          item.timestamp = parseInt(tx.timeStamp);
        }
        return item;
      });
    });
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey3;
  }
};

// node_modules/@ethersproject/providers/lib.esm/fallback-provider.js
init_lib12();
init_lib3();
init_lib2();
init_lib4();
init_lib21();
init_lib25();
init_lib();
var __awaiter16 = function(thisArg, _arguments, P5, generator) {
  function adopt(value2) {
    return value2 instanceof P5 ? value2 : new P5(function(resolve) {
      resolve(value2);
    });
  }
  return new (P5 || (P5 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e6) {
        reject(e6);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e6) {
        reject(e6);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger38 = new Logger(version23);
function now() {
  return new Date().getTime();
}
function checkNetworks(networks2) {
  let result = null;
  for (let i6 = 0; i6 < networks2.length; i6++) {
    const network = networks2[i6];
    if (network == null) {
      return null;
    }
    if (result) {
      if (!(result.name === network.name && result.chainId === network.chainId && (result.ensAddress === network.ensAddress || result.ensAddress == null && network.ensAddress == null))) {
        logger38.throwArgumentError("provider mismatch", "networks", networks2);
      }
    } else {
      result = network;
    }
  }
  return result;
}
function median(values, maxDelta) {
  values = values.slice().sort();
  const middle = Math.floor(values.length / 2);
  if (values.length % 2) {
    return values[middle];
  }
  const a5 = values[middle - 1], b4 = values[middle];
  if (maxDelta != null && Math.abs(a5 - b4) > maxDelta) {
    return null;
  }
  return (a5 + b4) / 2;
}
function serialize2(value2) {
  if (value2 === null) {
    return "null";
  } else if (typeof value2 === "number" || typeof value2 === "boolean") {
    return JSON.stringify(value2);
  } else if (typeof value2 === "string") {
    return value2;
  } else if (BigNumber.isBigNumber(value2)) {
    return value2.toString();
  } else if (Array.isArray(value2)) {
    return JSON.stringify(value2.map((i6) => serialize2(i6)));
  } else if (typeof value2 === "object") {
    const keys = Object.keys(value2);
    keys.sort();
    return "{" + keys.map((key2) => {
      let v9 = value2[key2];
      if (typeof v9 === "function") {
        v9 = "[function]";
      } else {
        v9 = serialize2(v9);
      }
      return JSON.stringify(key2) + ":" + v9;
    }).join(",") + "}";
  }
  throw new Error("unknown value type: " + typeof value2);
}
var nextRid = 1;
function stall2(duration) {
  let cancel = null;
  let timer3 = null;
  let promise = new Promise((resolve) => {
    cancel = function() {
      if (timer3) {
        clearTimeout(timer3);
        timer3 = null;
      }
      resolve();
    };
    timer3 = setTimeout(cancel, duration);
  });
  const wait = (func) => {
    promise = promise.then(func);
    return promise;
  };
  function getPromise() {
    return promise;
  }
  return { cancel, getPromise, wait };
}
var ForwardErrors = [
  Logger.errors.CALL_EXCEPTION,
  Logger.errors.INSUFFICIENT_FUNDS,
  Logger.errors.NONCE_EXPIRED,
  Logger.errors.REPLACEMENT_UNDERPRICED,
  Logger.errors.UNPREDICTABLE_GAS_LIMIT
];
var ForwardProperties = [
  "address",
  "args",
  "errorArgs",
  "errorSignature",
  "method",
  "transaction"
];
function exposeDebugConfig(config2, now2) {
  const result = {
    weight: config2.weight
  };
  Object.defineProperty(result, "provider", { get: () => config2.provider });
  if (config2.start) {
    result.start = config2.start;
  }
  if (now2) {
    result.duration = now2 - config2.start;
  }
  if (config2.done) {
    if (config2.error) {
      result.error = config2.error;
    } else {
      result.result = config2.result || null;
    }
  }
  return result;
}
function normalizedTally(normalize, quorum) {
  return function(configs) {
    const tally = {};
    configs.forEach((c5) => {
      const value2 = normalize(c5.result);
      if (!tally[value2]) {
        tally[value2] = { count: 0, result: c5.result };
      }
      tally[value2].count++;
    });
    const keys = Object.keys(tally);
    for (let i6 = 0; i6 < keys.length; i6++) {
      const check = tally[keys[i6]];
      if (check.count >= quorum) {
        return check.result;
      }
    }
    return void 0;
  };
}
function getProcessFunc(provider, method2, params) {
  let normalize = serialize2;
  switch (method2) {
    case "getBlockNumber":
      return function(configs) {
        const values = configs.map((c5) => c5.result);
        let blockNumber = median(configs.map((c5) => c5.result), 2);
        if (blockNumber == null) {
          return void 0;
        }
        blockNumber = Math.ceil(blockNumber);
        if (values.indexOf(blockNumber + 1) >= 0) {
          blockNumber++;
        }
        if (blockNumber >= provider._highestBlockNumber) {
          provider._highestBlockNumber = blockNumber;
        }
        return provider._highestBlockNumber;
      };
    case "getGasPrice":
      return function(configs) {
        const values = configs.map((c5) => c5.result);
        values.sort();
        return values[Math.floor(values.length / 2)];
      };
    case "getEtherPrice":
      return function(configs) {
        return median(configs.map((c5) => c5.result));
      };
    case "getBalance":
    case "getTransactionCount":
    case "getCode":
    case "getStorageAt":
    case "call":
    case "estimateGas":
    case "getLogs":
      break;
    case "getTransaction":
    case "getTransactionReceipt":
      normalize = function(tx) {
        if (tx == null) {
          return null;
        }
        tx = shallowCopy(tx);
        tx.confirmations = -1;
        return serialize2(tx);
      };
      break;
    case "getBlock":
      if (params.includeTransactions) {
        normalize = function(block) {
          if (block == null) {
            return null;
          }
          block = shallowCopy(block);
          block.transactions = block.transactions.map((tx) => {
            tx = shallowCopy(tx);
            tx.confirmations = -1;
            return tx;
          });
          return serialize2(block);
        };
      } else {
        normalize = function(block) {
          if (block == null) {
            return null;
          }
          return serialize2(block);
        };
      }
      break;
    default:
      throw new Error("unknown method: " + method2);
  }
  return normalizedTally(normalize, provider.quorum);
}
function waitForSync(config2, blockNumber) {
  return __awaiter16(this, void 0, void 0, function* () {
    const provider = config2.provider;
    if (provider.blockNumber != null && provider.blockNumber >= blockNumber || blockNumber === -1) {
      return provider;
    }
    return poll(() => {
      return new Promise((resolve, reject) => {
        setTimeout(function() {
          if (provider.blockNumber >= blockNumber) {
            return resolve(provider);
          }
          if (config2.cancelled) {
            return resolve(null);
          }
          return resolve(void 0);
        }, 0);
      });
    }, { oncePoll: provider });
  });
}
function getRunner(config2, currentBlockNumber, method2, params) {
  return __awaiter16(this, void 0, void 0, function* () {
    let provider = config2.provider;
    switch (method2) {
      case "getBlockNumber":
      case "getGasPrice":
        return provider[method2]();
      case "getEtherPrice":
        if (provider.getEtherPrice) {
          return provider.getEtherPrice();
        }
        break;
      case "getBalance":
      case "getTransactionCount":
      case "getCode":
        if (params.blockTag && isHexString(params.blockTag)) {
          provider = yield waitForSync(config2, currentBlockNumber);
        }
        return provider[method2](params.address, params.blockTag || "latest");
      case "getStorageAt":
        if (params.blockTag && isHexString(params.blockTag)) {
          provider = yield waitForSync(config2, currentBlockNumber);
        }
        return provider.getStorageAt(params.address, params.position, params.blockTag || "latest");
      case "getBlock":
        if (params.blockTag && isHexString(params.blockTag)) {
          provider = yield waitForSync(config2, currentBlockNumber);
        }
        return provider[params.includeTransactions ? "getBlockWithTransactions" : "getBlock"](params.blockTag || params.blockHash);
      case "call":
      case "estimateGas":
        if (params.blockTag && isHexString(params.blockTag)) {
          provider = yield waitForSync(config2, currentBlockNumber);
        }
        return provider[method2](params.transaction);
      case "getTransaction":
      case "getTransactionReceipt":
        return provider[method2](params.transactionHash);
      case "getLogs": {
        let filter2 = params.filter;
        if (filter2.fromBlock && isHexString(filter2.fromBlock) || filter2.toBlock && isHexString(filter2.toBlock)) {
          provider = yield waitForSync(config2, currentBlockNumber);
        }
        return provider.getLogs(filter2);
      }
    }
    return logger38.throwError("unknown method error", Logger.errors.UNKNOWN_ERROR, {
      method: method2,
      params
    });
  });
}
var FallbackProvider = class extends BaseProvider {
  constructor(providers, quorum) {
    logger38.checkNew(new.target, FallbackProvider);
    if (providers.length === 0) {
      logger38.throwArgumentError("missing providers", "providers", providers);
    }
    const providerConfigs = providers.map((configOrProvider, index) => {
      if (Provider.isProvider(configOrProvider)) {
        const stallTimeout = isCommunityResource(configOrProvider) ? 2e3 : 750;
        const priority = 1;
        return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout, priority });
      }
      const config2 = shallowCopy(configOrProvider);
      if (config2.priority == null) {
        config2.priority = 1;
      }
      if (config2.stallTimeout == null) {
        config2.stallTimeout = isCommunityResource(configOrProvider) ? 2e3 : 750;
      }
      if (config2.weight == null) {
        config2.weight = 1;
      }
      const weight = config2.weight;
      if (weight % 1 || weight > 512 || weight < 1) {
        logger38.throwArgumentError("invalid weight; must be integer in [1, 512]", `providers[${index}].weight`, weight);
      }
      return Object.freeze(config2);
    });
    const total = providerConfigs.reduce((accum, c5) => accum + c5.weight, 0);
    if (quorum == null) {
      quorum = total / 2;
    } else if (quorum > total) {
      logger38.throwArgumentError("quorum will always fail; larger than total weight", "quorum", quorum);
    }
    let networkOrReady = checkNetworks(providerConfigs.map((c5) => c5.provider.network));
    if (networkOrReady == null) {
      networkOrReady = new Promise((resolve, reject) => {
        setTimeout(() => {
          this.detectNetwork().then(resolve, reject);
        }, 0);
      });
    }
    super(networkOrReady);
    defineReadOnly(this, "providerConfigs", Object.freeze(providerConfigs));
    defineReadOnly(this, "quorum", quorum);
    this._highestBlockNumber = -1;
  }
  detectNetwork() {
    return __awaiter16(this, void 0, void 0, function* () {
      const networks2 = yield Promise.all(this.providerConfigs.map((c5) => c5.provider.getNetwork()));
      return checkNetworks(networks2);
    });
  }
  perform(method2, params) {
    return __awaiter16(this, void 0, void 0, function* () {
      if (method2 === "sendTransaction") {
        const results2 = yield Promise.all(this.providerConfigs.map((c5) => {
          return c5.provider.sendTransaction(params.signedTransaction).then((result) => {
            return result.hash;
          }, (error) => {
            return error;
          });
        }));
        for (let i7 = 0; i7 < results2.length; i7++) {
          const result = results2[i7];
          if (typeof result === "string") {
            return result;
          }
        }
        throw results2[0];
      }
      if (this._highestBlockNumber === -1 && method2 !== "getBlockNumber") {
        yield this.getBlockNumber();
      }
      const processFunc = getProcessFunc(this, method2, params);
      const configs = shuffled(this.providerConfigs.map(shallowCopy));
      configs.sort((a5, b4) => a5.priority - b4.priority);
      const currentBlockNumber = this._highestBlockNumber;
      let i6 = 0;
      let first2 = true;
      while (true) {
        const t02 = now();
        let inflightWeight = configs.filter((c5) => c5.runner && t02 - c5.start < c5.stallTimeout).reduce((accum, c5) => accum + c5.weight, 0);
        while (inflightWeight < this.quorum && i6 < configs.length) {
          const config2 = configs[i6++];
          const rid = nextRid++;
          config2.start = now();
          config2.staller = stall2(config2.stallTimeout);
          config2.staller.wait(() => {
            config2.staller = null;
          });
          config2.runner = getRunner(config2, currentBlockNumber, method2, params).then((result) => {
            config2.done = true;
            config2.result = result;
            if (this.listenerCount("debug")) {
              this.emit("debug", {
                action: "request",
                rid,
                backend: exposeDebugConfig(config2, now()),
                request: { method: method2, params: deepCopy(params) },
                provider: this
              });
            }
          }, (error) => {
            config2.done = true;
            config2.error = error;
            if (this.listenerCount("debug")) {
              this.emit("debug", {
                action: "request",
                rid,
                backend: exposeDebugConfig(config2, now()),
                request: { method: method2, params: deepCopy(params) },
                provider: this
              });
            }
          });
          if (this.listenerCount("debug")) {
            this.emit("debug", {
              action: "request",
              rid,
              backend: exposeDebugConfig(config2, null),
              request: { method: method2, params: deepCopy(params) },
              provider: this
            });
          }
          inflightWeight += config2.weight;
        }
        const waiting = [];
        configs.forEach((c5) => {
          if (c5.done || !c5.runner) {
            return;
          }
          waiting.push(c5.runner);
          if (c5.staller) {
            waiting.push(c5.staller.getPromise());
          }
        });
        if (waiting.length) {
          yield Promise.race(waiting);
        }
        const results2 = configs.filter((c5) => c5.done && c5.error == null);
        if (results2.length >= this.quorum) {
          const result = processFunc(results2);
          if (result !== void 0) {
            configs.forEach((c5) => {
              if (c5.staller) {
                c5.staller.cancel();
              }
              c5.cancelled = true;
            });
            return result;
          }
          if (!first2) {
            yield stall2(100).getPromise();
          }
          first2 = false;
        }
        const errors = configs.reduce((accum, c5) => {
          if (!c5.done || c5.error == null) {
            return accum;
          }
          const code = c5.error.code;
          if (ForwardErrors.indexOf(code) >= 0) {
            if (!accum[code]) {
              accum[code] = { error: c5.error, weight: 0 };
            }
            accum[code].weight += c5.weight;
          }
          return accum;
        }, {});
        Object.keys(errors).forEach((errorCode) => {
          const tally = errors[errorCode];
          if (tally.weight < this.quorum) {
            return;
          }
          configs.forEach((c5) => {
            if (c5.staller) {
              c5.staller.cancel();
            }
            c5.cancelled = true;
          });
          const e6 = tally.error;
          const props = {};
          ForwardProperties.forEach((name2) => {
            if (e6[name2] == null) {
              return;
            }
            props[name2] = e6[name2];
          });
          logger38.throwError(e6.reason || e6.message, errorCode, props);
        });
        if (configs.filter((c5) => !c5.done).length === 0) {
          break;
        }
      }
      configs.forEach((c5) => {
        if (c5.staller) {
          c5.staller.cancel();
        }
        c5.cancelled = true;
      });
      return logger38.throwError("failed to meet quorum", Logger.errors.SERVER_ERROR, {
        method: method2,
        params,
        results: configs.map((c5) => exposeDebugConfig(c5)),
        provider: this
      });
    });
  }
};

// node_modules/@ethersproject/providers/lib.esm/ipc-provider.js
var IpcProvider = null;

// node_modules/@ethersproject/providers/lib.esm/infura-provider.js
init_lib4();
init_lib();
var logger39 = new Logger(version23);
var defaultProjectId = "84842078b09946638c03157f83405213";
var InfuraWebSocketProvider = class extends WebSocketProvider {
  constructor(network, apiKey) {
    const provider = new InfuraProvider(network, apiKey);
    const connection = provider.connection;
    if (connection.password) {
      logger39.throwError("INFURA WebSocket project secrets unsupported", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "InfuraProvider.getWebSocketProvider()"
      });
    }
    const url = connection.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
    super(url, network);
    defineReadOnly(this, "apiKey", provider.projectId);
    defineReadOnly(this, "projectId", provider.projectId);
    defineReadOnly(this, "projectSecret", provider.projectSecret);
  }
  isCommunityResource() {
    return this.projectId === defaultProjectId;
  }
};
var InfuraProvider = class extends UrlJsonRpcProvider {
  static getWebSocketProvider(network, apiKey) {
    return new InfuraWebSocketProvider(network, apiKey);
  }
  static getApiKey(apiKey) {
    const apiKeyObj = {
      apiKey: defaultProjectId,
      projectId: defaultProjectId,
      projectSecret: null
    };
    if (apiKey == null) {
      return apiKeyObj;
    }
    if (typeof apiKey === "string") {
      apiKeyObj.projectId = apiKey;
    } else if (apiKey.projectSecret != null) {
      logger39.assertArgument(typeof apiKey.projectId === "string", "projectSecret requires a projectId", "projectId", apiKey.projectId);
      logger39.assertArgument(typeof apiKey.projectSecret === "string", "invalid projectSecret", "projectSecret", "[REDACTED]");
      apiKeyObj.projectId = apiKey.projectId;
      apiKeyObj.projectSecret = apiKey.projectSecret;
    } else if (apiKey.projectId) {
      apiKeyObj.projectId = apiKey.projectId;
    }
    apiKeyObj.apiKey = apiKeyObj.projectId;
    return apiKeyObj;
  }
  static getUrl(network, apiKey) {
    let host = null;
    switch (network ? network.name : "unknown") {
      case "homestead":
        host = "mainnet.infura.io";
        break;
      case "ropsten":
        host = "ropsten.infura.io";
        break;
      case "rinkeby":
        host = "rinkeby.infura.io";
        break;
      case "kovan":
        host = "kovan.infura.io";
        break;
      case "goerli":
        host = "goerli.infura.io";
        break;
      case "matic":
        host = "polygon-mainnet.infura.io";
        break;
      case "maticmum":
        host = "polygon-mumbai.infura.io";
        break;
      case "optimism":
        host = "optimism-mainnet.infura.io";
        break;
      case "optimism-kovan":
        host = "optimism-kovan.infura.io";
        break;
      case "arbitrum":
        host = "arbitrum-mainnet.infura.io";
        break;
      case "arbitrum-rinkeby":
        host = "arbitrum-rinkeby.infura.io";
        break;
      default:
        logger39.throwError("unsupported network", Logger.errors.INVALID_ARGUMENT, {
          argument: "network",
          value: network
        });
    }
    const connection = {
      allowGzip: true,
      url: "https://" + host + "/v3/" + apiKey.projectId,
      throttleCallback: (attempt, url) => {
        if (apiKey.projectId === defaultProjectId) {
          showThrottleMessage();
        }
        return Promise.resolve(true);
      }
    };
    if (apiKey.projectSecret != null) {
      connection.user = "";
      connection.password = apiKey.projectSecret;
    }
    return connection;
  }
  isCommunityResource() {
    return this.projectId === defaultProjectId;
  }
};

// node_modules/@ethersproject/providers/lib.esm/json-rpc-batch-provider.js
init_lib4();
init_lib25();
var JsonRpcBatchProvider = class extends JsonRpcProvider {
  send(method2, params) {
    const request = {
      method: method2,
      params,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    if (this._pendingBatch == null) {
      this._pendingBatch = [];
    }
    const inflightRequest = { request, resolve: null, reject: null };
    const promise = new Promise((resolve, reject) => {
      inflightRequest.resolve = resolve;
      inflightRequest.reject = reject;
    });
    this._pendingBatch.push(inflightRequest);
    if (!this._pendingBatchAggregator) {
      this._pendingBatchAggregator = setTimeout(() => {
        const batch = this._pendingBatch;
        this._pendingBatch = null;
        this._pendingBatchAggregator = null;
        const request2 = batch.map((inflight) => inflight.request);
        this.emit("debug", {
          action: "requestBatch",
          request: deepCopy(request2),
          provider: this
        });
        return fetchJson(this.connection, JSON.stringify(request2)).then((result) => {
          this.emit("debug", {
            action: "response",
            request: request2,
            response: result,
            provider: this
          });
          batch.forEach((inflightRequest2, index) => {
            const payload = result[index];
            if (payload.error) {
              const error = new Error(payload.error.message);
              error.code = payload.error.code;
              error.data = payload.error.data;
              inflightRequest2.reject(error);
            } else {
              inflightRequest2.resolve(payload.result);
            }
          });
        }, (error) => {
          this.emit("debug", {
            action: "response",
            error,
            request: request2,
            provider: this
          });
          batch.forEach((inflightRequest2) => {
            inflightRequest2.reject(error);
          });
        });
      }, 10);
    }
    return promise;
  }
};

// node_modules/@ethersproject/providers/lib.esm/nodesmith-provider.js
init_lib();
var logger40 = new Logger(version23);
var defaultApiKey4 = "ETHERS_JS_SHARED";
var NodesmithProvider = class extends UrlJsonRpcProvider {
  static getApiKey(apiKey) {
    if (apiKey && typeof apiKey !== "string") {
      logger40.throwArgumentError("invalid apiKey", "apiKey", apiKey);
    }
    return apiKey || defaultApiKey4;
  }
  static getUrl(network, apiKey) {
    logger40.warn("NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.");
    let host = null;
    switch (network.name) {
      case "homestead":
        host = "https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc";
        break;
      case "ropsten":
        host = "https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc";
        break;
      case "rinkeby":
        host = "https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc";
        break;
      case "goerli":
        host = "https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc";
        break;
      case "kovan":
        host = "https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc";
        break;
      default:
        logger40.throwArgumentError("unsupported network", "network", arguments[0]);
    }
    return host + "?apiKey=" + apiKey;
  }
};

// node_modules/@ethersproject/providers/lib.esm/pocket-provider.js
init_lib4();
init_lib();
var logger41 = new Logger(version23);
var defaultApplicationIds = {
  homestead: "6004bcd10040261633ade990",
  ropsten: "6004bd4d0040261633ade991",
  rinkeby: "6004bda20040261633ade994",
  goerli: "6004bd860040261633ade992"
};
var PocketProvider = class extends UrlJsonRpcProvider {
  constructor(network, apiKey) {
    if (apiKey == null) {
      const n4 = getStatic(new.target, "getNetwork")(network);
      if (n4) {
        const applicationId = defaultApplicationIds[n4.name];
        if (applicationId) {
          apiKey = {
            applicationId,
            loadBalancer: true
          };
        }
      }
      if (apiKey == null) {
        logger41.throwError("unsupported network", Logger.errors.INVALID_ARGUMENT, {
          argument: "network",
          value: network
        });
      }
    }
    super(network, apiKey);
  }
  static getApiKey(apiKey) {
    if (apiKey == null) {
      logger41.throwArgumentError("PocketProvider.getApiKey does not support null apiKey", "apiKey", apiKey);
    }
    const apiKeyObj = {
      applicationId: null,
      loadBalancer: false,
      applicationSecretKey: null
    };
    if (typeof apiKey === "string") {
      apiKeyObj.applicationId = apiKey;
    } else if (apiKey.applicationSecretKey != null) {
      logger41.assertArgument(typeof apiKey.applicationId === "string", "applicationSecretKey requires an applicationId", "applicationId", apiKey.applicationId);
      logger41.assertArgument(typeof apiKey.applicationSecretKey === "string", "invalid applicationSecretKey", "applicationSecretKey", "[REDACTED]");
      apiKeyObj.applicationId = apiKey.applicationId;
      apiKeyObj.applicationSecretKey = apiKey.applicationSecretKey;
      apiKeyObj.loadBalancer = !!apiKey.loadBalancer;
    } else if (apiKey.applicationId) {
      logger41.assertArgument(typeof apiKey.applicationId === "string", "apiKey.applicationId must be a string", "apiKey.applicationId", apiKey.applicationId);
      apiKeyObj.applicationId = apiKey.applicationId;
      apiKeyObj.loadBalancer = !!apiKey.loadBalancer;
    } else {
      logger41.throwArgumentError("unsupported PocketProvider apiKey", "apiKey", apiKey);
    }
    return apiKeyObj;
  }
  static getUrl(network, apiKey) {
    let host = null;
    switch (network ? network.name : "unknown") {
      case "homestead":
        host = "eth-mainnet.gateway.pokt.network";
        break;
      case "ropsten":
        host = "eth-ropsten.gateway.pokt.network";
        break;
      case "rinkeby":
        host = "eth-rinkeby.gateway.pokt.network";
        break;
      case "goerli":
        host = "eth-goerli.gateway.pokt.network";
        break;
      default:
        logger41.throwError("unsupported network", Logger.errors.INVALID_ARGUMENT, {
          argument: "network",
          value: network
        });
    }
    let url = null;
    if (apiKey.loadBalancer) {
      url = `https://${host}/v1/lb/${apiKey.applicationId}`;
    } else {
      url = `https://${host}/v1/${apiKey.applicationId}`;
    }
    const connection = { url };
    connection.headers = {};
    if (apiKey.applicationSecretKey != null) {
      connection.user = "";
      connection.password = apiKey.applicationSecretKey;
    }
    return connection;
  }
  isCommunityResource() {
    return this.applicationId === defaultApplicationIds[this.network.name];
  }
};

// node_modules/@ethersproject/providers/lib.esm/web3-provider.js
init_lib4();
init_lib();
var logger42 = new Logger(version23);
var _nextId = 1;
function buildWeb3LegacyFetcher(provider, sendFunc) {
  const fetcher = "Web3LegacyFetcher";
  return function(method2, params) {
    const request = {
      method: method2,
      params,
      id: _nextId++,
      jsonrpc: "2.0"
    };
    return new Promise((resolve, reject) => {
      this.emit("debug", {
        action: "request",
        fetcher,
        request: deepCopy(request),
        provider: this
      });
      sendFunc(request, (error, response) => {
        if (error) {
          this.emit("debug", {
            action: "response",
            fetcher,
            error,
            request,
            provider: this
          });
          return reject(error);
        }
        this.emit("debug", {
          action: "response",
          fetcher,
          request,
          response,
          provider: this
        });
        if (response.error) {
          const error2 = new Error(response.error.message);
          error2.code = response.error.code;
          error2.data = response.error.data;
          return reject(error2);
        }
        resolve(response.result);
      });
    });
  };
}
function buildEip1193Fetcher(provider) {
  return function(method2, params) {
    if (params == null) {
      params = [];
    }
    const request = { method: method2, params };
    this.emit("debug", {
      action: "request",
      fetcher: "Eip1193Fetcher",
      request: deepCopy(request),
      provider: this
    });
    return provider.request(request).then((response) => {
      this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request,
        response,
        provider: this
      });
      return response;
    }, (error) => {
      this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request,
        error,
        provider: this
      });
      throw error;
    });
  };
}
var Web3Provider = class extends JsonRpcProvider {
  constructor(provider, network) {
    logger42.checkNew(new.target, Web3Provider);
    if (provider == null) {
      logger42.throwArgumentError("missing provider", "provider", provider);
    }
    let path = null;
    let jsonRpcFetchFunc = null;
    let subprovider = null;
    if (typeof provider === "function") {
      path = "unknown:";
      jsonRpcFetchFunc = provider;
    } else {
      path = provider.host || provider.path || "";
      if (!path && provider.isMetaMask) {
        path = "metamask";
      }
      subprovider = provider;
      if (provider.request) {
        if (path === "") {
          path = "eip-1193:";
        }
        jsonRpcFetchFunc = buildEip1193Fetcher(provider);
      } else if (provider.sendAsync) {
        jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));
      } else if (provider.send) {
        jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));
      } else {
        logger42.throwArgumentError("unsupported provider", "provider", provider);
      }
      if (!path) {
        path = "unknown:";
      }
    }
    super(path, network);
    defineReadOnly(this, "jsonRpcFetchFunc", jsonRpcFetchFunc);
    defineReadOnly(this, "provider", subprovider);
  }
  send(method2, params) {
    return this.jsonRpcFetchFunc(method2, params);
  }
};

// node_modules/@ethersproject/providers/lib.esm/index.js
init_lib();
var logger43 = new Logger(version23);
function getDefaultProvider(network, options) {
  if (network == null) {
    network = "homestead";
  }
  if (typeof network === "string") {
    const match = network.match(/^(ws|http)s?:/i);
    if (match) {
      switch (match[1]) {
        case "http":
          return new JsonRpcProvider(network);
        case "ws":
          return new WebSocketProvider(network);
        default:
          logger43.throwArgumentError("unsupported URL scheme", "network", network);
      }
    }
  }
  const n4 = getNetwork(network);
  if (!n4 || !n4._defaultProvider) {
    logger43.throwError("unsupported getDefaultProvider network", Logger.errors.NETWORK_ERROR, {
      operation: "getDefaultProvider",
      network
    });
  }
  return n4._defaultProvider({
    FallbackProvider,
    AlchemyProvider,
    AnkrProvider,
    CloudflareProvider,
    EtherscanProvider,
    InfuraProvider,
    JsonRpcProvider,
    NodesmithProvider,
    PocketProvider,
    Web3Provider,
    IpcProvider
  }, options);
}

// node_modules/ethers/lib.esm/ethers.js
init_lib19();

// node_modules/ethers/lib.esm/utils.js
var utils_exports = {};
__export(utils_exports, {
  AbiCoder: () => AbiCoder,
  ConstructorFragment: () => ConstructorFragment,
  ErrorFragment: () => ErrorFragment,
  EventFragment: () => EventFragment,
  FormatTypes: () => FormatTypes,
  Fragment: () => Fragment,
  FunctionFragment: () => FunctionFragment,
  HDNode: () => HDNode,
  Indexed: () => Indexed,
  Interface: () => Interface,
  LogDescription: () => LogDescription,
  Logger: () => Logger,
  ParamType: () => ParamType,
  RLP: () => lib_exports5,
  SigningKey: () => SigningKey,
  SupportedAlgorithm: () => SupportedAlgorithm,
  TransactionDescription: () => TransactionDescription,
  TransactionTypes: () => TransactionTypes,
  UnicodeNormalizationForm: () => UnicodeNormalizationForm,
  Utf8ErrorFuncs: () => Utf8ErrorFuncs,
  Utf8ErrorReason: () => Utf8ErrorReason,
  _TypedDataEncoder: () => TypedDataEncoder,
  _fetchData: () => _fetchData,
  _toEscapedUtf8String: () => _toEscapedUtf8String,
  accessListify: () => accessListify,
  arrayify: () => arrayify,
  base58: () => Base58,
  base64: () => lib_exports19,
  checkProperties: () => checkProperties,
  checkResultErrors: () => checkResultErrors,
  commify: () => commify,
  computeAddress: () => computeAddress,
  computeHmac: () => computeHmac,
  computePublicKey: () => computePublicKey,
  concat: () => concat,
  deepCopy: () => deepCopy,
  defaultAbiCoder: () => defaultAbiCoder,
  defaultPath: () => defaultPath,
  defineReadOnly: () => defineReadOnly,
  dnsEncode: () => dnsEncode,
  entropyToMnemonic: () => entropyToMnemonic,
  fetchJson: () => fetchJson,
  formatBytes32String: () => formatBytes32String,
  formatEther: () => formatEther,
  formatUnits: () => formatUnits,
  getAccountPath: () => getAccountPath,
  getAddress: () => getAddress,
  getContractAddress: () => getContractAddress,
  getCreate2Address: () => getCreate2Address,
  getIcapAddress: () => getIcapAddress,
  getJsonWalletAddress: () => getJsonWalletAddress,
  getStatic: () => getStatic,
  hashMessage: () => hashMessage,
  hexConcat: () => hexConcat,
  hexDataLength: () => hexDataLength,
  hexDataSlice: () => hexDataSlice,
  hexStripZeros: () => hexStripZeros,
  hexValue: () => hexValue,
  hexZeroPad: () => hexZeroPad,
  hexlify: () => hexlify,
  id: () => id,
  isAddress: () => isAddress,
  isBytes: () => isBytes,
  isBytesLike: () => isBytesLike,
  isHexString: () => isHexString,
  isValidMnemonic: () => isValidMnemonic,
  isValidName: () => isValidName,
  joinSignature: () => joinSignature,
  keccak256: () => keccak256,
  mnemonicToEntropy: () => mnemonicToEntropy,
  mnemonicToSeed: () => mnemonicToSeed,
  namehash: () => namehash,
  nameprep: () => nameprep,
  parseBytes32String: () => parseBytes32String,
  parseEther: () => parseEther,
  parseTransaction: () => parse,
  parseUnits: () => parseUnits,
  poll: () => poll,
  randomBytes: () => randomBytes,
  recoverAddress: () => recoverAddress,
  recoverPublicKey: () => recoverPublicKey,
  resolveProperties: () => resolveProperties,
  ripemd160: () => ripemd160,
  serializeTransaction: () => serialize,
  sha256: () => sha256,
  sha512: () => sha512,
  shallowCopy: () => shallowCopy,
  shuffled: () => shuffled,
  solidityKeccak256: () => keccak2562,
  solidityPack: () => pack2,
  soliditySha256: () => sha2562,
  splitSignature: () => splitSignature,
  stripZeros: () => stripZeros,
  toUtf8Bytes: () => toUtf8Bytes,
  toUtf8CodePoints: () => toUtf8CodePoints,
  toUtf8String: () => toUtf8String,
  verifyMessage: () => verifyMessage,
  verifyTypedData: () => verifyTypedData,
  zeroPad: () => zeroPad
});
init_lib11();
init_lib7();
init_lib24();
init_lib16();
init_lib2();
init_lib10();
init_lib20();
init_lib22();
init_lib5();
init_lib();
init_lib17();
init_lib26();
init_lib21();
init_lib4();
init_lib6();
init_lib14();
init_lib9();
init_lib15();
init_lib27();
init_lib23();
init_lib25();
init_lib17();
init_lib9();

// node_modules/ethers/lib.esm/ethers.js
init_lib();

// node_modules/ethers/lib.esm/_version.js
var version26 = "ethers/5.6.2";

// node_modules/ethers/lib.esm/ethers.js
var logger46 = new Logger(version26);

// node_modules/ethers/lib.esm/index.js
try {
  const anyGlobal2 = window;
  if (anyGlobal2._ethers == null) {
    anyGlobal2._ethers = ethers_exports;
  }
} catch (error) {
}

// node_modules/zod/lib/index.mjs
var util;
(function(util2) {
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k8) => typeof obj[obj[k8]] !== "number");
    const filtered = {};
    for (const k8 of validKeys) {
      filtered[k8] = obj[k8];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e6) {
      return obj[e6];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key2 in object) {
      if (Object.prototype.hasOwnProperty.call(object, key2)) {
        keys.push(key2);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
})(util || (util = {}));
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
var ZodError = class extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i6 = 0;
          while (i6 < issue.path.length) {
            const el = issue.path[i6];
            const terminal = i6 === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i6++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, null, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
var defaultErrorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (issue.validation !== "regex")
        message = `Invalid ${issue.validation}`;
      else
        message = "Invalid";
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be greater than ${issue.inclusive ? `or equal to ` : ``}${issue.minimum}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be less than ${issue.inclusive ? `or equal to ` : ``}${issue.maximum}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var overrideErrorMap = defaultErrorMap;
var setErrorMap = (map2) => {
  overrideErrorMap = map2;
};
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t6 = typeof data;
  switch (t6) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  let errorMessage = "";
  const maps = errorMaps.filter((m6) => !!m6).slice().reverse();
  for (const map2 of maps) {
    errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: issueData.message || errorMessage
  };
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      overrideErrorMap,
      defaultErrorMap
    ].filter((x6) => !!x6)
  });
  ctx.common.issues.push(issue);
}
var ParseStatus = class {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results2) {
    const arrayValue = [];
    for (const s6 of results2) {
      if (s6.status === "aborted")
        return INVALID;
      if (s6.status === "dirty")
        status.dirty();
      arrayValue.push(s6.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs2) {
    const syncPairs = [];
    for (const pair of pairs2) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs2) {
    const finalObject = {};
    for (const pair of pairs2) {
      const { key: key2, value: value2 } = pair;
      if (key2.status === "aborted")
        return INVALID;
      if (value2.status === "aborted")
        return INVALID;
      if (key2.status === "dirty")
        status.dirty();
      if (value2.status === "dirty")
        status.dirty();
      if (typeof value2.value !== "undefined" || pair.alwaysSet) {
        finalObject[key2.value] = value2.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value2) => ({ status: "dirty", value: value2 });
var OK = (value2) => ({ status: "valid", value: value2 });
var isAborted = (x6) => x6.status === "aborted";
var isDirty = (x6) => x6.status === "dirty";
var isValid = (x6) => x6.status === "valid";
var isAsync = (x6) => typeof Promise !== void 0 && x6 instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
var ParseInputLazyPath = class {
  constructor(parent, value2, path, key2) {
    this.parent = parent;
    this.data = value2;
    this._path = path;
    this._key = key2;
  }
  get path() {
    return this._path.concat(this._key);
  }
};
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    const error = new ZodError(ctx.common.issues);
    return { success: false, error };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap, invalid_type_error, required_error, description } = params;
  if (errorMap && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid" or "required" in conjunction with custom error map.`);
  }
  if (errorMap)
    return { errorMap, description };
  const customMap = (iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined" && required_error)
      return { message: required_error };
    if (params.invalid_type_error)
      return { message: params.invalid_type_error };
    return { message: ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
var ZodType = class {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this.superRefine = this._refinement;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.default = this.default.bind(this);
    this.describe = this.describe.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a2;
    const ctx = {
      common: {
        issues: [],
        async: (_a2 = params === null || params === void 0 ? void 0 : params.async) !== null && _a2 !== void 0 ? _a2 : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: [], parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  optional() {
    return ZodOptional.create(this);
  }
  nullable() {
    return ZodNullable.create(this);
  }
  nullish() {
    return this.optional().nullable();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this);
  }
  or(option) {
    return ZodUnion.create([this, option]);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming);
  }
  transform(transform) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
var emailRegex = /^(([^<>()[\]\.,;:\s@\"]+(\.[^<>()[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i;
var ZodString = class extends ZodType {
  constructor() {
    super(...arguments);
    this._regex = (regex, validation, message) => this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
    this.nonempty = (message) => this.min(1, errorUtil.errToObj(message));
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(
        ctx2,
        {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        }
      );
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a2) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      }
    }
    return { status: status.value, value: input.data };
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this.min(len, message).max(len, message);
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get minLength() {
    let min2 = -Infinity;
    this._def.checks.map((ch) => {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2) {
          min2 = ch.value;
        }
      }
    });
    return min2;
  }
  get maxLength() {
    let max2 = null;
    this._def.checks.map((ch) => {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2) {
          max2 = ch.value;
        }
      }
    });
    return max2;
  }
};
ZodString.create = (params) => {
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
var ZodNumber = class extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value2, message) {
    return this.setLimit("min", value2, true, errorUtil.toString(message));
  }
  gt(value2, message) {
    return this.setLimit("min", value2, false, errorUtil.toString(message));
  }
  lte(value2, message) {
    return this.setLimit("max", value2, true, errorUtil.toString(message));
  }
  lt(value2, message) {
    return this.setLimit("max", value2, false, errorUtil.toString(message));
  }
  setLimit(kind, value2, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value: value2,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value2, message) {
    return this._addCheck({
      kind: "multipleOf",
      value: value2,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2;
  }
  get maxValue() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int");
  }
};
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    ...processCreateParams(params)
  });
};
var ZodBigInt = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBigInt.create = (params) => {
  return new ZodBigInt({
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    ...processCreateParams(params)
  });
};
var ZodBoolean = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    ...processCreateParams(params)
  });
};
var ZodDate = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    return {
      status: "valid",
      value: new Date(input.data.getTime())
    };
  }
};
ZodDate.create = (params) => {
  return new ZodDate({
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var ZodUndefined = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var ZodNull = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var ZodNever = class extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var ZodVoid = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var ZodArray = class extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all(ctx.data.map((item, i6) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i6));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = ctx.data.map((item, i6) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i6));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return this.min(len, message).max(len, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first2, second) => {
    return {
      ...first2,
      ...second
    };
  };
})(objectUtil || (objectUtil = {}));
var AugmentFactory = (def) => (augmentation) => {
  return new ZodObject({
    ...def,
    shape: () => ({
      ...def.shape(),
      ...augmentation
    })
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key2 in schema.shape) {
      const fieldSchema = schema.shape[key2];
      newShape[key2] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return ZodArray.create(deepPartialify(schema.element));
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
var ZodObject = class extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = AugmentFactory(this._def);
    this.extend = AugmentFactory(this._def);
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    for (const key2 in ctx.data) {
      if (!shapeKeys.includes(key2)) {
        extraKeys.push(key2);
      }
    }
    const pairs2 = [];
    for (const key2 of shapeKeys) {
      const keyValidator = shape[key2];
      const value2 = ctx.data[key2];
      pairs2.push({
        key: { status: "valid", value: key2 },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value2, ctx.path, key2)),
        alwaysSet: key2 in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key2 of extraKeys) {
          pairs2.push({
            key: { status: "valid", value: key2 },
            value: { status: "valid", value: ctx.data[key2] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key2 of extraKeys) {
        const value2 = ctx.data[key2];
        pairs2.push({
          key: { status: "valid", value: key2 },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value2, ctx.path, key2)
          ),
          alwaysSet: key2 in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs2) {
          const key2 = await pair.key;
          syncPairs.push({
            key: key2,
            value: await pair.value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs2);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a2, _b, _c, _d;
          const defaultError = (_c = (_b = (_a2 = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a2, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  setKey(key2, schema) {
    return this.augment({ [key2]: schema });
  }
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  catchall(index) {
    return new ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).map((key2) => {
      shape[key2] = this.shape[key2];
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).map((key2) => {
      if (util.objectKeys(mask).indexOf(key2) === -1) {
        shape[key2] = this.shape[key2];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    if (mask) {
      util.objectKeys(this.shape).map((key2) => {
        if (util.objectKeys(mask).indexOf(key2) === -1) {
          newShape[key2] = this.shape[key2];
        } else {
          newShape[key2] = this.shape[key2].optional();
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => newShape
      });
    } else {
      for (const key2 in this.shape) {
        const fieldSchema = this.shape[key2];
        newShape[key2] = fieldSchema.optional();
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required() {
    const newShape = {};
    for (const key2 in this.shape) {
      const fieldSchema = this.shape[key2];
      let newField = fieldSchema;
      while (newField instanceof ZodOptional) {
        newField = newField._def.innerType;
      }
      newShape[key2] = newField;
    }
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
};
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var ZodUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results2) {
      for (const result of results2) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results2) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results2.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var ZodDiscriminatedUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.options.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: this.validDiscriminatorValues,
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get validDiscriminatorValues() {
    return Array.from(this.options.keys());
  }
  get options() {
    return this._def.options;
  }
  static create(discriminator, types, params) {
    const options = /* @__PURE__ */ new Map();
    try {
      types.forEach((type) => {
        const discriminatorValue = type.shape[discriminator].value;
        options.set(discriminatorValue, type);
      });
    } catch (e6) {
      throw new Error("The discriminator value could not be extracted from all the provided schemas");
    }
    if (options.size !== types.length) {
      throw new Error("Some of the discriminator values are not unique");
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a5, b4) {
  const aType = getParsedType(a5);
  const bType = getParsedType(b4);
  if (a5 === b4) {
    return { valid: true, data: a5 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b4);
    const sharedKeys = util.objectKeys(a5).filter((key2) => bKeys.indexOf(key2) !== -1);
    const newObj = { ...a5, ...b4 };
    for (const key2 of sharedKeys) {
      const sharedValue = mergeValues(a5[key2], b4[key2]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key2] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a5.length !== b4.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a5.length; index++) {
      const itemA = a5[index];
      const itemB = b4[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a5 === +b4) {
    return { valid: true, data: a5 };
  } else {
    return { valid: false };
  }
}
var ZodIntersection = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var ZodTuple = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        type: "array"
      });
      status.dirty();
    }
    const items = ctx.data.map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x6) => !!x6);
    if (ctx.common.async) {
      return Promise.all(items).then((results2) => {
        return ParseStatus.mergeArray(status, results2);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas, params) => {
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs2 = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key2 in ctx.data) {
      pairs2.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key2, ctx.path, key2)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key2], ctx.path, key2))
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs2);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs2);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first2, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first2,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first2,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
var ZodMap = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs2 = [...ctx.data.entries()].map(([key2, value2], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key2, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value2, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs2) {
          const key2 = await pair.key;
          const value2 = await pair.value;
          if (key2.status === "aborted" || value2.status === "aborted") {
            return INVALID;
          }
          if (key2.status === "dirty" || value2.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key2.value, value2.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs2) {
        const key2 = pair.key;
        const value2 = pair.value;
        if (key2.status === "aborted" || value2.status === "aborted") {
          return INVALID;
        }
        if (key2.status === "dirty" || value2.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key2.value, value2.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var ZodSet = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i6) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i6)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var ZodFunction = class extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          overrideErrorMap,
          defaultErrorMap
        ].filter((x6) => !!x6),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          overrideErrorMap,
          defaultErrorMap
        ].filter((x6) => !!x6),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn2 = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      return OK(async (...args) => {
        const error = new ZodError([]);
        const parsedArgs = await this._def.args.parseAsync(args, params).catch((e6) => {
          error.addIssue(makeArgsIssue(args, e6));
          throw error;
        });
        const result = await fn2(...parsedArgs);
        const parsedReturns = await this._def.returns._def.type.parseAsync(result, params).catch((e6) => {
          error.addIssue(makeReturnsIssue(result, e6));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      return OK((...args) => {
        const parsedArgs = this._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = fn2(...parsedArgs.data);
        const parsedReturns = this._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
};
ZodFunction.create = (args, returns, params) => {
  return new ZodFunction({
    args: args ? args.rest(ZodUnknown.create()) : ZodTuple.create([]).rest(ZodUnknown.create()),
    returns: returns || ZodUnknown.create(),
    typeName: ZodFirstPartyTypeKind.ZodFunction,
    ...processCreateParams(params)
  });
};
var ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var ZodLiteral = class extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value2, params) => {
  return new ZodLiteral({
    value: value2,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum
  });
}
var ZodEnum = class extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (this._def.values.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
};
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (nativeEnumValues.indexOf(input.data) === -1) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var ZodPromise = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data);
      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed2) => {
          return this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
        });
      } else {
        return this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base2 = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base2))
          return base2;
        const result = effect.transform(base2.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base2) => {
          if (!isValid(base2))
            return base2;
          return Promise.resolve(effect.transform(base2.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var ZodOptional = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNullable = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var ZodDefault = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNaN = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var custom = (check, params) => {
  if (check)
    return ZodAny.create().refine(check, params);
  return ZodAny.create();
};
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var mod = Object.freeze({
  __proto__: null,
  ZodParsedType,
  getParsedType,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  ZodType,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  get objectUtil() {
    return objectUtil;
  },
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodNaN,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  ZodIssueCode,
  quotelessJson,
  ZodError,
  defaultErrorMap,
  get overrideErrorMap() {
    return overrideErrorMap;
  },
  setErrorMap
});

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

// node_modules/uuid/dist/esm-browser/validate.js
function validate5(uuid2) {
  return typeof uuid2 === "string" && regex_default.test(uuid2);
}
var validate_default = validate5;

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (i6 = 0; i6 < 256; ++i6) {
  byteToHex.push((i6 + 256).toString(16).substr(1));
}
var i6;
function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid2 = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate_default(uuid2)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid2;
}
var stringify_default = stringify;

// node_modules/uuid/dist/esm-browser/parse.js
function parse2(uuid2) {
  if (!validate_default(uuid2)) {
    throw TypeError("Invalid UUID");
  }
  var v9;
  var arr = new Uint8Array(16);
  arr[0] = (v9 = parseInt(uuid2.slice(0, 8), 16)) >>> 24;
  arr[1] = v9 >>> 16 & 255;
  arr[2] = v9 >>> 8 & 255;
  arr[3] = v9 & 255;
  arr[4] = (v9 = parseInt(uuid2.slice(9, 13), 16)) >>> 8;
  arr[5] = v9 & 255;
  arr[6] = (v9 = parseInt(uuid2.slice(14, 18), 16)) >>> 8;
  arr[7] = v9 & 255;
  arr[8] = (v9 = parseInt(uuid2.slice(19, 23), 16)) >>> 8;
  arr[9] = v9 & 255;
  arr[10] = (v9 = parseInt(uuid2.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v9 / 4294967296 & 255;
  arr[12] = v9 >>> 24 & 255;
  arr[13] = v9 >>> 16 & 255;
  arr[14] = v9 >>> 8 & 255;
  arr[15] = v9 & 255;
  return arr;
}
var parse_default = parse2;

// node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  var bytes = [];
  for (var i6 = 0; i6 < str.length; ++i6) {
    bytes.push(str.charCodeAt(i6));
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35_default(name2, version27, hashfunc) {
  function generateUUID(value2, namespace, buf, offset) {
    if (typeof value2 === "string") {
      value2 = stringToBytes(value2);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (namespace.length !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    var bytes = new Uint8Array(16 + value2.length);
    bytes.set(namespace);
    bytes.set(value2, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version27;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (var i6 = 0; i6 < 16; ++i6) {
        buf[offset + i6] = bytes[i6];
      }
      return buf;
    }
    return stringify_default(bytes);
  }
  try {
    generateUUID.name = name2;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL2;
  return generateUUID;
}

// node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg.length);
    for (var i6 = 0; i6 < msg.length; ++i6) {
      bytes[i6] = msg.charCodeAt(i6);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
  var output = [];
  var length32 = input.length * 32;
  var hexTab = "0123456789abcdef";
  for (var i6 = 0; i6 < length32; i6 += 8) {
    var x6 = input[i6 >> 5] >>> i6 % 32 & 255;
    var hex = parseInt(hexTab.charAt(x6 >>> 4 & 15) + hexTab.charAt(x6 & 15), 16);
    output.push(hex);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x6, len) {
  x6[len >> 5] |= 128 << len % 32;
  x6[getOutputLength(len) - 1] = len;
  var a5 = 1732584193;
  var b4 = -271733879;
  var c5 = -1732584194;
  var d6 = 271733878;
  for (var i6 = 0; i6 < x6.length; i6 += 16) {
    var olda = a5;
    var oldb = b4;
    var oldc = c5;
    var oldd = d6;
    a5 = md5ff(a5, b4, c5, d6, x6[i6], 7, -680876936);
    d6 = md5ff(d6, a5, b4, c5, x6[i6 + 1], 12, -389564586);
    c5 = md5ff(c5, d6, a5, b4, x6[i6 + 2], 17, 606105819);
    b4 = md5ff(b4, c5, d6, a5, x6[i6 + 3], 22, -1044525330);
    a5 = md5ff(a5, b4, c5, d6, x6[i6 + 4], 7, -176418897);
    d6 = md5ff(d6, a5, b4, c5, x6[i6 + 5], 12, 1200080426);
    c5 = md5ff(c5, d6, a5, b4, x6[i6 + 6], 17, -1473231341);
    b4 = md5ff(b4, c5, d6, a5, x6[i6 + 7], 22, -45705983);
    a5 = md5ff(a5, b4, c5, d6, x6[i6 + 8], 7, 1770035416);
    d6 = md5ff(d6, a5, b4, c5, x6[i6 + 9], 12, -1958414417);
    c5 = md5ff(c5, d6, a5, b4, x6[i6 + 10], 17, -42063);
    b4 = md5ff(b4, c5, d6, a5, x6[i6 + 11], 22, -1990404162);
    a5 = md5ff(a5, b4, c5, d6, x6[i6 + 12], 7, 1804603682);
    d6 = md5ff(d6, a5, b4, c5, x6[i6 + 13], 12, -40341101);
    c5 = md5ff(c5, d6, a5, b4, x6[i6 + 14], 17, -1502002290);
    b4 = md5ff(b4, c5, d6, a5, x6[i6 + 15], 22, 1236535329);
    a5 = md5gg(a5, b4, c5, d6, x6[i6 + 1], 5, -165796510);
    d6 = md5gg(d6, a5, b4, c5, x6[i6 + 6], 9, -1069501632);
    c5 = md5gg(c5, d6, a5, b4, x6[i6 + 11], 14, 643717713);
    b4 = md5gg(b4, c5, d6, a5, x6[i6], 20, -373897302);
    a5 = md5gg(a5, b4, c5, d6, x6[i6 + 5], 5, -701558691);
    d6 = md5gg(d6, a5, b4, c5, x6[i6 + 10], 9, 38016083);
    c5 = md5gg(c5, d6, a5, b4, x6[i6 + 15], 14, -660478335);
    b4 = md5gg(b4, c5, d6, a5, x6[i6 + 4], 20, -405537848);
    a5 = md5gg(a5, b4, c5, d6, x6[i6 + 9], 5, 568446438);
    d6 = md5gg(d6, a5, b4, c5, x6[i6 + 14], 9, -1019803690);
    c5 = md5gg(c5, d6, a5, b4, x6[i6 + 3], 14, -187363961);
    b4 = md5gg(b4, c5, d6, a5, x6[i6 + 8], 20, 1163531501);
    a5 = md5gg(a5, b4, c5, d6, x6[i6 + 13], 5, -1444681467);
    d6 = md5gg(d6, a5, b4, c5, x6[i6 + 2], 9, -51403784);
    c5 = md5gg(c5, d6, a5, b4, x6[i6 + 7], 14, 1735328473);
    b4 = md5gg(b4, c5, d6, a5, x6[i6 + 12], 20, -1926607734);
    a5 = md5hh(a5, b4, c5, d6, x6[i6 + 5], 4, -378558);
    d6 = md5hh(d6, a5, b4, c5, x6[i6 + 8], 11, -2022574463);
    c5 = md5hh(c5, d6, a5, b4, x6[i6 + 11], 16, 1839030562);
    b4 = md5hh(b4, c5, d6, a5, x6[i6 + 14], 23, -35309556);
    a5 = md5hh(a5, b4, c5, d6, x6[i6 + 1], 4, -1530992060);
    d6 = md5hh(d6, a5, b4, c5, x6[i6 + 4], 11, 1272893353);
    c5 = md5hh(c5, d6, a5, b4, x6[i6 + 7], 16, -155497632);
    b4 = md5hh(b4, c5, d6, a5, x6[i6 + 10], 23, -1094730640);
    a5 = md5hh(a5, b4, c5, d6, x6[i6 + 13], 4, 681279174);
    d6 = md5hh(d6, a5, b4, c5, x6[i6], 11, -358537222);
    c5 = md5hh(c5, d6, a5, b4, x6[i6 + 3], 16, -722521979);
    b4 = md5hh(b4, c5, d6, a5, x6[i6 + 6], 23, 76029189);
    a5 = md5hh(a5, b4, c5, d6, x6[i6 + 9], 4, -640364487);
    d6 = md5hh(d6, a5, b4, c5, x6[i6 + 12], 11, -421815835);
    c5 = md5hh(c5, d6, a5, b4, x6[i6 + 15], 16, 530742520);
    b4 = md5hh(b4, c5, d6, a5, x6[i6 + 2], 23, -995338651);
    a5 = md5ii(a5, b4, c5, d6, x6[i6], 6, -198630844);
    d6 = md5ii(d6, a5, b4, c5, x6[i6 + 7], 10, 1126891415);
    c5 = md5ii(c5, d6, a5, b4, x6[i6 + 14], 15, -1416354905);
    b4 = md5ii(b4, c5, d6, a5, x6[i6 + 5], 21, -57434055);
    a5 = md5ii(a5, b4, c5, d6, x6[i6 + 12], 6, 1700485571);
    d6 = md5ii(d6, a5, b4, c5, x6[i6 + 3], 10, -1894986606);
    c5 = md5ii(c5, d6, a5, b4, x6[i6 + 10], 15, -1051523);
    b4 = md5ii(b4, c5, d6, a5, x6[i6 + 1], 21, -2054922799);
    a5 = md5ii(a5, b4, c5, d6, x6[i6 + 8], 6, 1873313359);
    d6 = md5ii(d6, a5, b4, c5, x6[i6 + 15], 10, -30611744);
    c5 = md5ii(c5, d6, a5, b4, x6[i6 + 6], 15, -1560198380);
    b4 = md5ii(b4, c5, d6, a5, x6[i6 + 13], 21, 1309151649);
    a5 = md5ii(a5, b4, c5, d6, x6[i6 + 4], 6, -145523070);
    d6 = md5ii(d6, a5, b4, c5, x6[i6 + 11], 10, -1120210379);
    c5 = md5ii(c5, d6, a5, b4, x6[i6 + 2], 15, 718787259);
    b4 = md5ii(b4, c5, d6, a5, x6[i6 + 9], 21, -343485551);
    a5 = safeAdd(a5, olda);
    b4 = safeAdd(b4, oldb);
    c5 = safeAdd(c5, oldc);
    d6 = safeAdd(d6, oldd);
  }
  return [a5, b4, c5, d6];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  var length8 = input.length * 8;
  var output = new Uint32Array(getOutputLength(length8));
  for (var i6 = 0; i6 < length8; i6 += 8) {
    output[i6 >> 5] |= (input[i6 / 8] & 255) << i6 % 32;
  }
  return output;
}
function safeAdd(x6, y5) {
  var lsw = (x6 & 65535) + (y5 & 65535);
  var msw = (x6 >> 16) + (y5 >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q8, a5, b4, x6, s6, t6) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a5, q8), safeAdd(x6, t6)), s6), b4);
}
function md5ff(a5, b4, c5, d6, x6, s6, t6) {
  return md5cmn(b4 & c5 | ~b4 & d6, a5, b4, x6, s6, t6);
}
function md5gg(a5, b4, c5, d6, x6, s6, t6) {
  return md5cmn(b4 & d6 | c5 & ~d6, a5, b4, x6, s6, t6);
}
function md5hh(a5, b4, c5, d6, x6, s6, t6) {
  return md5cmn(b4 ^ c5 ^ d6, a5, b4, x6, s6, t6);
}
function md5ii(a5, b4, c5, d6, x6, s6, t6) {
  return md5cmn(c5 ^ (b4 | ~d6), a5, b4, x6, s6, t6);
}
var md5_default = md5;

// node_modules/uuid/dist/esm-browser/v3.js
var v3 = v35_default("v3", 48, md5_default);

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (var i6 = 0; i6 < 16; ++i6) {
      buf[offset + i6] = rnds[i6];
    }
    return buf;
  }
  return stringify_default(rnds);
}
var v4_default = v4;

// node_modules/uuid/dist/esm-browser/sha1.js
function f(s6, x6, y5, z6) {
  switch (s6) {
    case 0:
      return x6 & y5 ^ ~x6 & z6;
    case 1:
      return x6 ^ y5 ^ z6;
    case 2:
      return x6 & y5 ^ x6 & z6 ^ y5 & z6;
    case 3:
      return x6 ^ y5 ^ z6;
  }
}
function ROTL(x6, n4) {
  return x6 << n4 | x6 >>> 32 - n4;
}
function sha1(bytes) {
  var K5 = [1518500249, 1859775393, 2400959708, 3395469782];
  var H5 = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (var i6 = 0; i6 < msg.length; ++i6) {
      bytes.push(msg.charCodeAt(i6));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  var l6 = bytes.length / 4 + 2;
  var N7 = Math.ceil(l6 / 16);
  var M6 = new Array(N7);
  for (var _i2 = 0; _i2 < N7; ++_i2) {
    var arr = new Uint32Array(16);
    for (var j8 = 0; j8 < 16; ++j8) {
      arr[j8] = bytes[_i2 * 64 + j8 * 4] << 24 | bytes[_i2 * 64 + j8 * 4 + 1] << 16 | bytes[_i2 * 64 + j8 * 4 + 2] << 8 | bytes[_i2 * 64 + j8 * 4 + 3];
    }
    M6[_i2] = arr;
  }
  M6[N7 - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M6[N7 - 1][14] = Math.floor(M6[N7 - 1][14]);
  M6[N7 - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (var _i22 = 0; _i22 < N7; ++_i22) {
    var W4 = new Uint32Array(80);
    for (var t6 = 0; t6 < 16; ++t6) {
      W4[t6] = M6[_i22][t6];
    }
    for (var _t2 = 16; _t2 < 80; ++_t2) {
      W4[_t2] = ROTL(W4[_t2 - 3] ^ W4[_t2 - 8] ^ W4[_t2 - 14] ^ W4[_t2 - 16], 1);
    }
    var a5 = H5[0];
    var b4 = H5[1];
    var c5 = H5[2];
    var d6 = H5[3];
    var e6 = H5[4];
    for (var _t22 = 0; _t22 < 80; ++_t22) {
      var s6 = Math.floor(_t22 / 20);
      var T8 = ROTL(a5, 5) + f(s6, b4, c5, d6) + e6 + K5[s6] + W4[_t22] >>> 0;
      e6 = d6;
      d6 = c5;
      c5 = ROTL(b4, 30) >>> 0;
      b4 = a5;
      a5 = T8;
    }
    H5[0] = H5[0] + a5 >>> 0;
    H5[1] = H5[1] + b4 >>> 0;
    H5[2] = H5[2] + c5 >>> 0;
    H5[3] = H5[3] + d6 >>> 0;
    H5[4] = H5[4] + e6 >>> 0;
  }
  return [H5[0] >> 24 & 255, H5[0] >> 16 & 255, H5[0] >> 8 & 255, H5[0] & 255, H5[1] >> 24 & 255, H5[1] >> 16 & 255, H5[1] >> 8 & 255, H5[1] & 255, H5[2] >> 24 & 255, H5[2] >> 16 & 255, H5[2] >> 8 & 255, H5[2] & 255, H5[3] >> 24 & 255, H5[3] >> 16 & 255, H5[3] >> 8 & 255, H5[3] & 255, H5[4] >> 24 & 255, H5[4] >> 16 & 255, H5[4] >> 8 & 255, H5[4] & 255];
}
var sha1_default = sha1;

// node_modules/uuid/dist/esm-browser/v5.js
var v5 = v35_default("v5", 80, sha1_default);

// node_modules/tiny-invariant/dist/tiny-invariant.esm.js
var isProduction = false;
var prefix = "Invariant failed";
function invariant(condition, message) {
  if (condition) {
    return;
  }
  if (isProduction) {
    throw new Error(prefix);
  }
  var provided = typeof message === "function" ? message() : message;
  var value2 = provided ? prefix + ": " + provided : prefix;
  throw new Error(value2);
}

// node_modules/@thirdweb-dev/sdk/dist/index.mjs
var import_eventemitter2 = __toESM(require_eventemitter2(), 1);
var import_merkletreejs = __toESM(require_dist(), 1);
var import_keccak25613 = __toESM(require_keccak256(), 1);
var import_deep_equal = __toESM(require_deep_equal(), 1);
var import_deep_equal2 = __toESM(require_deep_equal(), 1);
var import_deep_equal3 = __toESM(require_deep_equal(), 1);
var C0 = Object.defineProperty;
var Hi = Object.defineProperties;
var Zi = Object.getOwnPropertyDescriptors;
var w0 = Object.getOwnPropertySymbols;
var ji = Object.prototype.hasOwnProperty;
var Yi = Object.prototype.propertyIsEnumerable;
var Ca = (r6, e6, t6) => e6 in r6 ? C0(r6, e6, { enumerable: true, configurable: true, writable: true, value: t6 }) : r6[e6] = t6;
var w = (r6, e6) => {
  for (var t6 in e6 || (e6 = {}))
    ji.call(e6, t6) && Ca(r6, t6, e6[t6]);
  if (w0)
    for (var t6 of w0(e6))
      Yi.call(e6, t6) && Ca(r6, t6, e6[t6]);
  return r6;
};
var B = (r6, e6) => Hi(r6, Zi(e6));
var p2 = (r6, e6) => C0(r6, "name", { value: e6, configurable: true });
var v0 = ((r6) => typeof __require != "undefined" ? __require : typeof Proxy != "undefined" ? new Proxy(r6, { get: (e6, t6) => (typeof __require != "undefined" ? __require : e6)[t6] }) : r6)(function(r6) {
  if (typeof __require != "undefined")
    return __require.apply(this, arguments);
  throw new Error('Dynamic require of "' + r6 + '" is not supported');
});
var We = (r6, e6) => () => (e6 || r6((e6 = { exports: {} }).exports, e6), e6.exports);
var f2 = (r6, e6, t6) => (Ca(r6, typeof e6 != "symbol" ? e6 + "" : e6, t6), t6);
var Ci = We((Il, Cp) => {
  Cp.exports = [{ inputs: [{ internalType: "address", name: "_thirdwebFee", type: "address" }], stateMutability: "nonpayable", type: "constructor" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "owner", type: "address" }, { indexed: true, internalType: "address", name: "approved", type: "address" }, { indexed: true, internalType: "uint256", name: "tokenId", type: "uint256" }], name: "Approval", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "owner", type: "address" }, { indexed: true, internalType: "address", name: "operator", type: "address" }, { indexed: false, internalType: "bool", name: "approved", type: "bool" }], name: "ApprovalForAll", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "newRoyaltyRecipient", type: "address" }, { indexed: false, internalType: "uint256", name: "newRoyaltyBps", type: "uint256" }], name: "DefaultRoyalty", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "prevOwner", type: "address" }, { indexed: false, internalType: "address", name: "newOwner", type: "address" }], name: "OwnerUpdated", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "platformFeeRecipient", type: "address" }, { indexed: false, internalType: "uint256", name: "platformFeeBps", type: "uint256" }], name: "PlatformFeeInfoUpdated", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "recipient", type: "address" }], name: "PrimarySaleRecipientUpdated", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "role", type: "bytes32" }, { indexed: true, internalType: "bytes32", name: "previousAdminRole", type: "bytes32" }, { indexed: true, internalType: "bytes32", name: "newAdminRole", type: "bytes32" }], name: "RoleAdminChanged", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "role", type: "bytes32" }, { indexed: true, internalType: "address", name: "account", type: "address" }, { indexed: true, internalType: "address", name: "sender", type: "address" }], name: "RoleGranted", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "role", type: "bytes32" }, { indexed: true, internalType: "address", name: "account", type: "address" }, { indexed: true, internalType: "address", name: "sender", type: "address" }], name: "RoleRevoked", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "uint256", name: "tokenId", type: "uint256" }, { indexed: false, internalType: "address", name: "royaltyRecipient", type: "address" }, { indexed: false, internalType: "uint256", name: "royaltyBps", type: "uint256" }], name: "RoyaltyForToken", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "mintedTo", type: "address" }, { indexed: true, internalType: "uint256", name: "tokenIdMinted", type: "uint256" }, { indexed: false, internalType: "string", name: "uri", type: "string" }], name: "TokensMinted", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "signer", type: "address" }, { indexed: true, internalType: "address", name: "mintedTo", type: "address" }, { indexed: true, internalType: "uint256", name: "tokenIdMinted", type: "uint256" }, { components: [{ internalType: "address", name: "to", type: "address" }, { internalType: "address", name: "royaltyRecipient", type: "address" }, { internalType: "uint256", name: "royaltyBps", type: "uint256" }, { internalType: "address", name: "primarySaleRecipient", type: "address" }, { internalType: "string", name: "uri", type: "string" }, { internalType: "uint256", name: "price", type: "uint256" }, { internalType: "address", name: "currency", type: "address" }, { internalType: "uint128", name: "validityStartTimestamp", type: "uint128" }, { internalType: "uint128", name: "validityEndTimestamp", type: "uint128" }, { internalType: "bytes32", name: "uid", type: "bytes32" }], indexed: false, internalType: "struct ITokenERC721.MintRequest", name: "mintRequest", type: "tuple" }], name: "TokensMintedWithSignature", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "from", type: "address" }, { indexed: true, internalType: "address", name: "to", type: "address" }, { indexed: true, internalType: "uint256", name: "tokenId", type: "uint256" }], name: "Transfer", type: "event" }, { inputs: [], name: "DEFAULT_ADMIN_ROLE", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "tokenId", type: "uint256" }], name: "approve", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "owner", type: "address" }], name: "balanceOf", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }], name: "burn", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "contractType", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "pure", type: "function" }, { inputs: [], name: "contractURI", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [], name: "contractVersion", outputs: [{ internalType: "uint8", name: "", type: "uint8" }], stateMutability: "pure", type: "function" }, { inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }], name: "getApproved", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [], name: "getDefaultRoyaltyInfo", outputs: [{ internalType: "address", name: "", type: "address" }, { internalType: "uint16", name: "", type: "uint16" }], stateMutability: "view", type: "function" }, { inputs: [], name: "getPlatformFeeInfo", outputs: [{ internalType: "address", name: "", type: "address" }, { internalType: "uint16", name: "", type: "uint16" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }], name: "getRoleAdmin", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "uint256", name: "index", type: "uint256" }], name: "getRoleMember", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }], name: "getRoleMemberCount", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "_tokenId", type: "uint256" }], name: "getRoyaltyInfoForToken", outputs: [{ internalType: "address", name: "", type: "address" }, { internalType: "uint16", name: "", type: "uint16" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "grantRole", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "hasRole", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_defaultAdmin", type: "address" }, { internalType: "string", name: "_name", type: "string" }, { internalType: "string", name: "_symbol", type: "string" }, { internalType: "string", name: "_contractURI", type: "string" }, { internalType: "address[]", name: "_trustedForwarders", type: "address[]" }, { internalType: "address", name: "_saleRecipient", type: "address" }, { internalType: "address", name: "_royaltyRecipient", type: "address" }, { internalType: "uint128", name: "_royaltyBps", type: "uint128" }, { internalType: "uint128", name: "_platformFeeBps", type: "uint128" }, { internalType: "address", name: "_platformFeeRecipient", type: "address" }], name: "initialize", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "owner", type: "address" }, { internalType: "address", name: "operator", type: "address" }], name: "isApprovedForAll", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "forwarder", type: "address" }], name: "isTrustedForwarder", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_to", type: "address" }, { internalType: "string", name: "_uri", type: "string" }], name: "mintTo", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ components: [{ internalType: "address", name: "to", type: "address" }, { internalType: "address", name: "royaltyRecipient", type: "address" }, { internalType: "uint256", name: "royaltyBps", type: "uint256" }, { internalType: "address", name: "primarySaleRecipient", type: "address" }, { internalType: "string", name: "uri", type: "string" }, { internalType: "uint256", name: "price", type: "uint256" }, { internalType: "address", name: "currency", type: "address" }, { internalType: "uint128", name: "validityStartTimestamp", type: "uint128" }, { internalType: "uint128", name: "validityEndTimestamp", type: "uint128" }, { internalType: "bytes32", name: "uid", type: "bytes32" }], internalType: "struct ITokenERC721.MintRequest", name: "_req", type: "tuple" }, { internalType: "bytes", name: "_signature", type: "bytes" }], name: "mintWithSignature", outputs: [{ internalType: "uint256", name: "tokenIdMinted", type: "uint256" }], stateMutability: "payable", type: "function" }, { inputs: [{ internalType: "bytes[]", name: "data", type: "bytes[]" }], name: "multicall", outputs: [{ internalType: "bytes[]", name: "results", type: "bytes[]" }], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "name", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [], name: "nextTokenIdToMint", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "owner", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }], name: "ownerOf", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [], name: "platformFeeBps", outputs: [{ internalType: "uint128", name: "", type: "uint128" }], stateMutability: "view", type: "function" }, { inputs: [], name: "platformFeeRecipient", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [], name: "primarySaleRecipient", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "renounceRole", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "revokeRole", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }, { internalType: "uint256", name: "salePrice", type: "uint256" }], name: "royaltyInfo", outputs: [{ internalType: "address", name: "receiver", type: "address" }, { internalType: "uint256", name: "royaltyAmount", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "from", type: "address" }, { internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "tokenId", type: "uint256" }], name: "safeTransferFrom", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "from", type: "address" }, { internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "tokenId", type: "uint256" }, { internalType: "bytes", name: "_data", type: "bytes" }], name: "safeTransferFrom", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "operator", type: "address" }, { internalType: "bool", name: "approved", type: "bool" }], name: "setApprovalForAll", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "string", name: "_uri", type: "string" }], name: "setContractURI", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_royaltyRecipient", type: "address" }, { internalType: "uint256", name: "_royaltyBps", type: "uint256" }], name: "setDefaultRoyaltyInfo", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_newOwner", type: "address" }], name: "setOwner", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_platformFeeRecipient", type: "address" }, { internalType: "uint256", name: "_platformFeeBps", type: "uint256" }], name: "setPlatformFeeInfo", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_saleRecipient", type: "address" }], name: "setPrimarySaleRecipient", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "_tokenId", type: "uint256" }, { internalType: "address", name: "_recipient", type: "address" }, { internalType: "uint256", name: "_bps", type: "uint256" }], name: "setRoyaltyInfoForToken", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }], name: "supportsInterface", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [], name: "symbol", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [], name: "thirdwebFee", outputs: [{ internalType: "contract ITWFee", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "index", type: "uint256" }], name: "tokenByIndex", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "owner", type: "address" }, { internalType: "uint256", name: "index", type: "uint256" }], name: "tokenOfOwnerByIndex", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "_tokenId", type: "uint256" }], name: "tokenURI", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [], name: "totalSupply", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "from", type: "address" }, { internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "tokenId", type: "uint256" }], name: "transferFrom", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ components: [{ internalType: "address", name: "to", type: "address" }, { internalType: "address", name: "royaltyRecipient", type: "address" }, { internalType: "uint256", name: "royaltyBps", type: "uint256" }, { internalType: "address", name: "primarySaleRecipient", type: "address" }, { internalType: "string", name: "uri", type: "string" }, { internalType: "uint256", name: "price", type: "uint256" }, { internalType: "address", name: "currency", type: "address" }, { internalType: "uint128", name: "validityStartTimestamp", type: "uint128" }, { internalType: "uint128", name: "validityEndTimestamp", type: "uint128" }, { internalType: "bytes32", name: "uid", type: "bytes32" }], internalType: "struct ITokenERC721.MintRequest", name: "_req", type: "tuple" }, { internalType: "bytes", name: "_signature", type: "bytes" }], name: "verify", outputs: [{ internalType: "bool", name: "", type: "bool" }, { internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }];
});
var vi = We((Zl, xp) => {
  xp.exports = [{ inputs: [{ internalType: "address", name: "_thirdwebFee", type: "address" }], stateMutability: "nonpayable", type: "constructor" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "account", type: "address" }, { indexed: true, internalType: "address", name: "operator", type: "address" }, { indexed: false, internalType: "bool", name: "approved", type: "bool" }], name: "ApprovalForAll", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "uint256", name: "tokenId", type: "uint256" }, { components: [{ internalType: "uint256", name: "startTimestamp", type: "uint256" }, { internalType: "uint256", name: "maxClaimableSupply", type: "uint256" }, { internalType: "uint256", name: "supplyClaimed", type: "uint256" }, { internalType: "uint256", name: "quantityLimitPerTransaction", type: "uint256" }, { internalType: "uint256", name: "waitTimeInSecondsBetweenClaims", type: "uint256" }, { internalType: "bytes32", name: "merkleRoot", type: "bytes32" }, { internalType: "uint256", name: "pricePerToken", type: "uint256" }, { internalType: "address", name: "currency", type: "address" }], indexed: false, internalType: "struct IDropClaimCondition.ClaimCondition[]", name: "claimConditions", type: "tuple[]" }], name: "ClaimConditionsUpdated", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "newRoyaltyRecipient", type: "address" }, { indexed: false, internalType: "uint256", name: "newRoyaltyBps", type: "uint256" }], name: "DefaultRoyalty", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "uint256", name: "tokenId", type: "uint256" }, { indexed: false, internalType: "uint256", name: "maxTotalSupply", type: "uint256" }], name: "MaxTotalSupplyUpdated", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "uint256", name: "tokenId", type: "uint256" }, { indexed: false, internalType: "uint256", name: "count", type: "uint256" }], name: "MaxWalletClaimCountUpdated", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "prevOwner", type: "address" }, { indexed: false, internalType: "address", name: "newOwner", type: "address" }], name: "OwnerUpdated", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "platformFeeRecipient", type: "address" }, { indexed: false, internalType: "uint256", name: "platformFeeBps", type: "uint256" }], name: "PlatformFeeInfoUpdated", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "recipient", type: "address" }], name: "PrimarySaleRecipientUpdated", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "role", type: "bytes32" }, { indexed: true, internalType: "bytes32", name: "previousAdminRole", type: "bytes32" }, { indexed: true, internalType: "bytes32", name: "newAdminRole", type: "bytes32" }], name: "RoleAdminChanged", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "role", type: "bytes32" }, { indexed: true, internalType: "address", name: "account", type: "address" }, { indexed: true, internalType: "address", name: "sender", type: "address" }], name: "RoleGranted", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "role", type: "bytes32" }, { indexed: true, internalType: "address", name: "account", type: "address" }, { indexed: true, internalType: "address", name: "sender", type: "address" }], name: "RoleRevoked", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "uint256", name: "tokenId", type: "uint256" }, { indexed: false, internalType: "address", name: "royaltyRecipient", type: "address" }, { indexed: false, internalType: "uint256", name: "royaltyBps", type: "uint256" }], name: "RoyaltyForToken", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "uint256", name: "claimConditionIndex", type: "uint256" }, { indexed: true, internalType: "uint256", name: "tokenId", type: "uint256" }, { indexed: true, internalType: "address", name: "claimer", type: "address" }, { indexed: false, internalType: "address", name: "receiver", type: "address" }, { indexed: false, internalType: "uint256", name: "quantityClaimed", type: "uint256" }], name: "TokensClaimed", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "uint256", name: "startTokenId", type: "uint256" }, { indexed: false, internalType: "uint256", name: "endTokenId", type: "uint256" }, { indexed: false, internalType: "string", name: "baseURI", type: "string" }], name: "TokensLazyMinted", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "operator", type: "address" }, { indexed: true, internalType: "address", name: "from", type: "address" }, { indexed: true, internalType: "address", name: "to", type: "address" }, { indexed: false, internalType: "uint256[]", name: "ids", type: "uint256[]" }, { indexed: false, internalType: "uint256[]", name: "values", type: "uint256[]" }], name: "TransferBatch", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "operator", type: "address" }, { indexed: true, internalType: "address", name: "from", type: "address" }, { indexed: true, internalType: "address", name: "to", type: "address" }, { indexed: false, internalType: "uint256", name: "id", type: "uint256" }, { indexed: false, internalType: "uint256", name: "value", type: "uint256" }], name: "TransferSingle", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "string", name: "value", type: "string" }, { indexed: true, internalType: "uint256", name: "id", type: "uint256" }], name: "URI", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "uint256", name: "tokenId", type: "uint256" }, { indexed: true, internalType: "address", name: "wallet", type: "address" }, { indexed: false, internalType: "uint256", name: "count", type: "uint256" }], name: "WalletClaimCountUpdated", type: "event" }, { inputs: [], name: "DEFAULT_ADMIN_ROLE", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "account", type: "address" }, { internalType: "uint256", name: "id", type: "uint256" }], name: "balanceOf", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address[]", name: "accounts", type: "address[]" }, { internalType: "uint256[]", name: "ids", type: "uint256[]" }], name: "balanceOfBatch", outputs: [{ internalType: "uint256[]", name: "", type: "uint256[]" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "account", type: "address" }, { internalType: "uint256", name: "id", type: "uint256" }, { internalType: "uint256", name: "value", type: "uint256" }], name: "burn", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "account", type: "address" }, { internalType: "uint256[]", name: "ids", type: "uint256[]" }, { internalType: "uint256[]", name: "values", type: "uint256[]" }], name: "burnBatch", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_receiver", type: "address" }, { internalType: "uint256", name: "_tokenId", type: "uint256" }, { internalType: "uint256", name: "_quantity", type: "uint256" }, { internalType: "address", name: "_currency", type: "address" }, { internalType: "uint256", name: "_pricePerToken", type: "uint256" }, { internalType: "bytes32[]", name: "_proofs", type: "bytes32[]" }, { internalType: "uint256", name: "_proofMaxQuantityPerTransaction", type: "uint256" }], name: "claim", outputs: [], stateMutability: "payable", type: "function" }, { inputs: [{ internalType: "uint256", name: "", type: "uint256" }], name: "claimCondition", outputs: [{ internalType: "uint256", name: "currentStartId", type: "uint256" }, { internalType: "uint256", name: "count", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "contractType", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "pure", type: "function" }, { inputs: [], name: "contractURI", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [], name: "contractVersion", outputs: [{ internalType: "uint8", name: "", type: "uint8" }], stateMutability: "pure", type: "function" }, { inputs: [{ internalType: "uint256", name: "_tokenId", type: "uint256" }], name: "getActiveClaimConditionId", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "_tokenId", type: "uint256" }, { internalType: "uint256", name: "_conditionId", type: "uint256" }], name: "getClaimConditionById", outputs: [{ components: [{ internalType: "uint256", name: "startTimestamp", type: "uint256" }, { internalType: "uint256", name: "maxClaimableSupply", type: "uint256" }, { internalType: "uint256", name: "supplyClaimed", type: "uint256" }, { internalType: "uint256", name: "quantityLimitPerTransaction", type: "uint256" }, { internalType: "uint256", name: "waitTimeInSecondsBetweenClaims", type: "uint256" }, { internalType: "bytes32", name: "merkleRoot", type: "bytes32" }, { internalType: "uint256", name: "pricePerToken", type: "uint256" }, { internalType: "address", name: "currency", type: "address" }], internalType: "struct IDropClaimCondition.ClaimCondition", name: "condition", type: "tuple" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "_tokenId", type: "uint256" }, { internalType: "uint256", name: "_conditionId", type: "uint256" }, { internalType: "address", name: "_claimer", type: "address" }], name: "getClaimTimestamp", outputs: [{ internalType: "uint256", name: "lastClaimTimestamp", type: "uint256" }, { internalType: "uint256", name: "nextValidClaimTimestamp", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "getDefaultRoyaltyInfo", outputs: [{ internalType: "address", name: "", type: "address" }, { internalType: "uint16", name: "", type: "uint16" }], stateMutability: "view", type: "function" }, { inputs: [], name: "getPlatformFeeInfo", outputs: [{ internalType: "address", name: "", type: "address" }, { internalType: "uint16", name: "", type: "uint16" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }], name: "getRoleAdmin", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "uint256", name: "index", type: "uint256" }], name: "getRoleMember", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }], name: "getRoleMemberCount", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "_tokenId", type: "uint256" }], name: "getRoyaltyInfoForToken", outputs: [{ internalType: "address", name: "", type: "address" }, { internalType: "uint16", name: "", type: "uint16" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "grantRole", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "hasRole", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_defaultAdmin", type: "address" }, { internalType: "string", name: "_name", type: "string" }, { internalType: "string", name: "_symbol", type: "string" }, { internalType: "string", name: "_contractURI", type: "string" }, { internalType: "address[]", name: "_trustedForwarders", type: "address[]" }, { internalType: "address", name: "_saleRecipient", type: "address" }, { internalType: "address", name: "_royaltyRecipient", type: "address" }, { internalType: "uint128", name: "_royaltyBps", type: "uint128" }, { internalType: "uint128", name: "_platformFeeBps", type: "uint128" }, { internalType: "address", name: "_platformFeeRecipient", type: "address" }], name: "initialize", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "account", type: "address" }, { internalType: "address", name: "operator", type: "address" }], name: "isApprovedForAll", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "forwarder", type: "address" }], name: "isTrustedForwarder", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "_amount", type: "uint256" }, { internalType: "string", name: "_baseURIForTokens", type: "string" }], name: "lazyMint", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "", type: "uint256" }], name: "maxTotalSupply", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "", type: "uint256" }], name: "maxWalletClaimCount", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes[]", name: "data", type: "bytes[]" }], name: "multicall", outputs: [{ internalType: "bytes[]", name: "results", type: "bytes[]" }], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "name", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [], name: "nextTokenIdToMint", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "owner", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [], name: "primarySaleRecipient", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "renounceRole", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "revokeRole", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }, { internalType: "uint256", name: "salePrice", type: "uint256" }], name: "royaltyInfo", outputs: [{ internalType: "address", name: "receiver", type: "address" }, { internalType: "uint256", name: "royaltyAmount", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "from", type: "address" }, { internalType: "address", name: "to", type: "address" }, { internalType: "uint256[]", name: "ids", type: "uint256[]" }, { internalType: "uint256[]", name: "amounts", type: "uint256[]" }, { internalType: "bytes", name: "data", type: "bytes" }], name: "safeBatchTransferFrom", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "from", type: "address" }, { internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "id", type: "uint256" }, { internalType: "uint256", name: "amount", type: "uint256" }, { internalType: "bytes", name: "data", type: "bytes" }], name: "safeTransferFrom", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "", type: "uint256" }], name: "saleRecipient", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "operator", type: "address" }, { internalType: "bool", name: "approved", type: "bool" }], name: "setApprovalForAll", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "_tokenId", type: "uint256" }, { components: [{ internalType: "uint256", name: "startTimestamp", type: "uint256" }, { internalType: "uint256", name: "maxClaimableSupply", type: "uint256" }, { internalType: "uint256", name: "supplyClaimed", type: "uint256" }, { internalType: "uint256", name: "quantityLimitPerTransaction", type: "uint256" }, { internalType: "uint256", name: "waitTimeInSecondsBetweenClaims", type: "uint256" }, { internalType: "bytes32", name: "merkleRoot", type: "bytes32" }, { internalType: "uint256", name: "pricePerToken", type: "uint256" }, { internalType: "address", name: "currency", type: "address" }], internalType: "struct IDropClaimCondition.ClaimCondition[]", name: "_phases", type: "tuple[]" }, { internalType: "bool", name: "_resetClaimEligibility", type: "bool" }], name: "setClaimConditions", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "string", name: "_uri", type: "string" }], name: "setContractURI", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_royaltyRecipient", type: "address" }, { internalType: "uint256", name: "_royaltyBps", type: "uint256" }], name: "setDefaultRoyaltyInfo", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "_tokenId", type: "uint256" }, { internalType: "uint256", name: "_maxTotalSupply", type: "uint256" }], name: "setMaxTotalSupply", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "_tokenId", type: "uint256" }, { internalType: "uint256", name: "_count", type: "uint256" }], name: "setMaxWalletClaimCount", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_newOwner", type: "address" }], name: "setOwner", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_platformFeeRecipient", type: "address" }, { internalType: "uint256", name: "_platformFeeBps", type: "uint256" }], name: "setPlatformFeeInfo", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_saleRecipient", type: "address" }], name: "setPrimarySaleRecipient", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "_tokenId", type: "uint256" }, { internalType: "address", name: "_recipient", type: "address" }, { internalType: "uint256", name: "_bps", type: "uint256" }], name: "setRoyaltyInfoForToken", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "_tokenId", type: "uint256" }, { internalType: "address", name: "_claimer", type: "address" }, { internalType: "uint256", name: "_count", type: "uint256" }], name: "setWalletClaimCount", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }], name: "supportsInterface", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [], name: "symbol", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "", type: "uint256" }], name: "totalSupply", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "_tokenId", type: "uint256" }], name: "uri", outputs: [{ internalType: "string", name: "_tokenURI", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "_conditionId", type: "uint256" }, { internalType: "address", name: "_claimer", type: "address" }, { internalType: "uint256", name: "_tokenId", type: "uint256" }, { internalType: "uint256", name: "_quantity", type: "uint256" }, { internalType: "address", name: "_currency", type: "address" }, { internalType: "uint256", name: "_pricePerToken", type: "uint256" }, { internalType: "bool", name: "verifyMaxQuantityPerTransaction", type: "bool" }], name: "verifyClaim", outputs: [], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "_conditionId", type: "uint256" }, { internalType: "address", name: "_claimer", type: "address" }, { internalType: "uint256", name: "_tokenId", type: "uint256" }, { internalType: "uint256", name: "_quantity", type: "uint256" }, { internalType: "bytes32[]", name: "_proofs", type: "bytes32[]" }, { internalType: "uint256", name: "_proofMaxQuantityPerTransaction", type: "uint256" }], name: "verifyClaimMerkleProof", outputs: [{ internalType: "bool", name: "validMerkleProof", type: "bool" }, { internalType: "uint256", name: "merkleProofIndex", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "", type: "uint256" }, { internalType: "address", name: "", type: "address" }], name: "walletClaimCount", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }];
});
var xi = We((m22, Rp) => {
  Rp.exports = [{ inputs: [{ internalType: "address", name: "_thirdwebFee", type: "address" }], stateMutability: "nonpayable", type: "constructor" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "account", type: "address" }, { indexed: true, internalType: "address", name: "operator", type: "address" }, { indexed: false, internalType: "bool", name: "approved", type: "bool" }], name: "ApprovalForAll", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "newRoyaltyRecipient", type: "address" }, { indexed: false, internalType: "uint256", name: "newRoyaltyBps", type: "uint256" }], name: "DefaultRoyalty", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "prevOwner", type: "address" }, { indexed: false, internalType: "address", name: "newOwner", type: "address" }], name: "OwnerUpdated", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "platformFeeRecipient", type: "address" }, { indexed: false, internalType: "uint256", name: "platformFeeBps", type: "uint256" }], name: "PlatformFeeInfoUpdated", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "recipient", type: "address" }], name: "PrimarySaleRecipientUpdated", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "role", type: "bytes32" }, { indexed: true, internalType: "bytes32", name: "previousAdminRole", type: "bytes32" }, { indexed: true, internalType: "bytes32", name: "newAdminRole", type: "bytes32" }], name: "RoleAdminChanged", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "role", type: "bytes32" }, { indexed: true, internalType: "address", name: "account", type: "address" }, { indexed: true, internalType: "address", name: "sender", type: "address" }], name: "RoleGranted", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "role", type: "bytes32" }, { indexed: true, internalType: "address", name: "account", type: "address" }, { indexed: true, internalType: "address", name: "sender", type: "address" }], name: "RoleRevoked", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "uint256", name: "tokenId", type: "uint256" }, { indexed: false, internalType: "address", name: "royaltyRecipient", type: "address" }, { indexed: false, internalType: "uint256", name: "royaltyBps", type: "uint256" }], name: "RoyaltyForToken", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "mintedTo", type: "address" }, { indexed: true, internalType: "uint256", name: "tokenIdMinted", type: "uint256" }, { indexed: false, internalType: "string", name: "uri", type: "string" }, { indexed: false, internalType: "uint256", name: "quantityMinted", type: "uint256" }], name: "TokensMinted", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "signer", type: "address" }, { indexed: true, internalType: "address", name: "mintedTo", type: "address" }, { indexed: true, internalType: "uint256", name: "tokenIdMinted", type: "uint256" }, { components: [{ internalType: "address", name: "to", type: "address" }, { internalType: "address", name: "royaltyRecipient", type: "address" }, { internalType: "uint256", name: "royaltyBps", type: "uint256" }, { internalType: "address", name: "primarySaleRecipient", type: "address" }, { internalType: "uint256", name: "tokenId", type: "uint256" }, { internalType: "string", name: "uri", type: "string" }, { internalType: "uint256", name: "quantity", type: "uint256" }, { internalType: "uint256", name: "pricePerToken", type: "uint256" }, { internalType: "address", name: "currency", type: "address" }, { internalType: "uint128", name: "validityStartTimestamp", type: "uint128" }, { internalType: "uint128", name: "validityEndTimestamp", type: "uint128" }, { internalType: "bytes32", name: "uid", type: "bytes32" }], indexed: false, internalType: "struct ITokenERC1155.MintRequest", name: "mintRequest", type: "tuple" }], name: "TokensMintedWithSignature", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "operator", type: "address" }, { indexed: true, internalType: "address", name: "from", type: "address" }, { indexed: true, internalType: "address", name: "to", type: "address" }, { indexed: false, internalType: "uint256[]", name: "ids", type: "uint256[]" }, { indexed: false, internalType: "uint256[]", name: "values", type: "uint256[]" }], name: "TransferBatch", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "operator", type: "address" }, { indexed: true, internalType: "address", name: "from", type: "address" }, { indexed: true, internalType: "address", name: "to", type: "address" }, { indexed: false, internalType: "uint256", name: "id", type: "uint256" }, { indexed: false, internalType: "uint256", name: "value", type: "uint256" }], name: "TransferSingle", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "string", name: "value", type: "string" }, { indexed: true, internalType: "uint256", name: "id", type: "uint256" }], name: "URI", type: "event" }, { inputs: [], name: "DEFAULT_ADMIN_ROLE", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "account", type: "address" }, { internalType: "uint256", name: "id", type: "uint256" }], name: "balanceOf", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address[]", name: "accounts", type: "address[]" }, { internalType: "uint256[]", name: "ids", type: "uint256[]" }], name: "balanceOfBatch", outputs: [{ internalType: "uint256[]", name: "", type: "uint256[]" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "account", type: "address" }, { internalType: "uint256", name: "id", type: "uint256" }, { internalType: "uint256", name: "value", type: "uint256" }], name: "burn", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "account", type: "address" }, { internalType: "uint256[]", name: "ids", type: "uint256[]" }, { internalType: "uint256[]", name: "values", type: "uint256[]" }], name: "burnBatch", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "contractType", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "pure", type: "function" }, { inputs: [], name: "contractURI", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [], name: "contractVersion", outputs: [{ internalType: "uint8", name: "", type: "uint8" }], stateMutability: "pure", type: "function" }, { inputs: [], name: "getDefaultRoyaltyInfo", outputs: [{ internalType: "address", name: "", type: "address" }, { internalType: "uint16", name: "", type: "uint16" }], stateMutability: "view", type: "function" }, { inputs: [], name: "getPlatformFeeInfo", outputs: [{ internalType: "address", name: "", type: "address" }, { internalType: "uint16", name: "", type: "uint16" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }], name: "getRoleAdmin", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "uint256", name: "index", type: "uint256" }], name: "getRoleMember", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }], name: "getRoleMemberCount", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "_tokenId", type: "uint256" }], name: "getRoyaltyInfoForToken", outputs: [{ internalType: "address", name: "", type: "address" }, { internalType: "uint16", name: "", type: "uint16" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "grantRole", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "hasRole", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_defaultAdmin", type: "address" }, { internalType: "string", name: "_name", type: "string" }, { internalType: "string", name: "_symbol", type: "string" }, { internalType: "string", name: "_contractURI", type: "string" }, { internalType: "address[]", name: "_trustedForwarders", type: "address[]" }, { internalType: "address", name: "_primarySaleRecipient", type: "address" }, { internalType: "address", name: "_royaltyRecipient", type: "address" }, { internalType: "uint128", name: "_royaltyBps", type: "uint128" }, { internalType: "uint128", name: "_platformFeeBps", type: "uint128" }, { internalType: "address", name: "_platformFeeRecipient", type: "address" }], name: "initialize", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "account", type: "address" }, { internalType: "address", name: "operator", type: "address" }], name: "isApprovedForAll", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "forwarder", type: "address" }], name: "isTrustedForwarder", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_to", type: "address" }, { internalType: "uint256", name: "_tokenId", type: "uint256" }, { internalType: "string", name: "_uri", type: "string" }, { internalType: "uint256", name: "_amount", type: "uint256" }], name: "mintTo", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ components: [{ internalType: "address", name: "to", type: "address" }, { internalType: "address", name: "royaltyRecipient", type: "address" }, { internalType: "uint256", name: "royaltyBps", type: "uint256" }, { internalType: "address", name: "primarySaleRecipient", type: "address" }, { internalType: "uint256", name: "tokenId", type: "uint256" }, { internalType: "string", name: "uri", type: "string" }, { internalType: "uint256", name: "quantity", type: "uint256" }, { internalType: "uint256", name: "pricePerToken", type: "uint256" }, { internalType: "address", name: "currency", type: "address" }, { internalType: "uint128", name: "validityStartTimestamp", type: "uint128" }, { internalType: "uint128", name: "validityEndTimestamp", type: "uint128" }, { internalType: "bytes32", name: "uid", type: "bytes32" }], internalType: "struct ITokenERC1155.MintRequest", name: "_req", type: "tuple" }, { internalType: "bytes", name: "_signature", type: "bytes" }], name: "mintWithSignature", outputs: [], stateMutability: "payable", type: "function" }, { inputs: [{ internalType: "bytes[]", name: "data", type: "bytes[]" }], name: "multicall", outputs: [{ internalType: "bytes[]", name: "results", type: "bytes[]" }], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "name", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [], name: "nextTokenIdToMint", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "owner", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [], name: "platformFeeBps", outputs: [{ internalType: "uint128", name: "", type: "uint128" }], stateMutability: "view", type: "function" }, { inputs: [], name: "platformFeeRecipient", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [], name: "primarySaleRecipient", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "renounceRole", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "revokeRole", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }, { internalType: "uint256", name: "salePrice", type: "uint256" }], name: "royaltyInfo", outputs: [{ internalType: "address", name: "receiver", type: "address" }, { internalType: "uint256", name: "royaltyAmount", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "from", type: "address" }, { internalType: "address", name: "to", type: "address" }, { internalType: "uint256[]", name: "ids", type: "uint256[]" }, { internalType: "uint256[]", name: "amounts", type: "uint256[]" }, { internalType: "bytes", name: "data", type: "bytes" }], name: "safeBatchTransferFrom", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "from", type: "address" }, { internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "id", type: "uint256" }, { internalType: "uint256", name: "amount", type: "uint256" }, { internalType: "bytes", name: "data", type: "bytes" }], name: "safeTransferFrom", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "", type: "uint256" }], name: "saleRecipientForToken", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "operator", type: "address" }, { internalType: "bool", name: "approved", type: "bool" }], name: "setApprovalForAll", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "string", name: "_uri", type: "string" }], name: "setContractURI", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_royaltyRecipient", type: "address" }, { internalType: "uint256", name: "_royaltyBps", type: "uint256" }], name: "setDefaultRoyaltyInfo", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_newOwner", type: "address" }], name: "setOwner", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_platformFeeRecipient", type: "address" }, { internalType: "uint256", name: "_platformFeeBps", type: "uint256" }], name: "setPlatformFeeInfo", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_saleRecipient", type: "address" }], name: "setPrimarySaleRecipient", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "_tokenId", type: "uint256" }, { internalType: "address", name: "_recipient", type: "address" }, { internalType: "uint256", name: "_bps", type: "uint256" }], name: "setRoyaltyInfoForToken", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }], name: "supportsInterface", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [], name: "symbol", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [], name: "thirdwebFee", outputs: [{ internalType: "contract ITWFee", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "", type: "uint256" }], name: "totalSupply", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "_tokenId", type: "uint256" }], name: "uri", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [{ components: [{ internalType: "address", name: "to", type: "address" }, { internalType: "address", name: "royaltyRecipient", type: "address" }, { internalType: "uint256", name: "royaltyBps", type: "uint256" }, { internalType: "address", name: "primarySaleRecipient", type: "address" }, { internalType: "uint256", name: "tokenId", type: "uint256" }, { internalType: "string", name: "uri", type: "string" }, { internalType: "uint256", name: "quantity", type: "uint256" }, { internalType: "uint256", name: "pricePerToken", type: "uint256" }, { internalType: "address", name: "currency", type: "address" }, { internalType: "uint128", name: "validityStartTimestamp", type: "uint128" }, { internalType: "uint128", name: "validityEndTimestamp", type: "uint128" }, { internalType: "bytes32", name: "uid", type: "bytes32" }], internalType: "struct ITokenERC1155.MintRequest", name: "_req", type: "tuple" }, { internalType: "bytes", name: "_signature", type: "bytes" }], name: "verify", outputs: [{ internalType: "bool", name: "", type: "bool" }, { internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }];
});
var Mi = We((I22, _p) => {
  _p.exports = [{ inputs: [{ internalType: "address", name: "_thirdwebFee", type: "address" }], stateMutability: "nonpayable", type: "constructor" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "owner", type: "address" }, { indexed: true, internalType: "address", name: "spender", type: "address" }, { indexed: false, internalType: "uint256", name: "value", type: "uint256" }], name: "Approval", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "delegator", type: "address" }, { indexed: true, internalType: "address", name: "fromDelegate", type: "address" }, { indexed: true, internalType: "address", name: "toDelegate", type: "address" }], name: "DelegateChanged", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "delegate", type: "address" }, { indexed: false, internalType: "uint256", name: "previousBalance", type: "uint256" }, { indexed: false, internalType: "uint256", name: "newBalance", type: "uint256" }], name: "DelegateVotesChanged", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "account", type: "address" }], name: "Paused", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "platformFeeRecipient", type: "address" }, { indexed: false, internalType: "uint256", name: "platformFeeBps", type: "uint256" }], name: "PlatformFeeInfoUpdated", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "recipient", type: "address" }], name: "PrimarySaleRecipientUpdated", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "role", type: "bytes32" }, { indexed: true, internalType: "bytes32", name: "previousAdminRole", type: "bytes32" }, { indexed: true, internalType: "bytes32", name: "newAdminRole", type: "bytes32" }], name: "RoleAdminChanged", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "role", type: "bytes32" }, { indexed: true, internalType: "address", name: "account", type: "address" }, { indexed: true, internalType: "address", name: "sender", type: "address" }], name: "RoleGranted", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "role", type: "bytes32" }, { indexed: true, internalType: "address", name: "account", type: "address" }, { indexed: true, internalType: "address", name: "sender", type: "address" }], name: "RoleRevoked", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "mintedTo", type: "address" }, { indexed: false, internalType: "uint256", name: "quantityMinted", type: "uint256" }], name: "TokensMinted", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "signer", type: "address" }, { indexed: true, internalType: "address", name: "mintedTo", type: "address" }, { components: [{ internalType: "address", name: "to", type: "address" }, { internalType: "address", name: "primarySaleRecipient", type: "address" }, { internalType: "uint256", name: "quantity", type: "uint256" }, { internalType: "uint256", name: "price", type: "uint256" }, { internalType: "address", name: "currency", type: "address" }, { internalType: "uint128", name: "validityStartTimestamp", type: "uint128" }, { internalType: "uint128", name: "validityEndTimestamp", type: "uint128" }, { internalType: "bytes32", name: "uid", type: "bytes32" }], indexed: false, internalType: "struct ITokenERC20.MintRequest", name: "mintRequest", type: "tuple" }], name: "TokensMintedWithSignature", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "from", type: "address" }, { indexed: true, internalType: "address", name: "to", type: "address" }, { indexed: false, internalType: "uint256", name: "value", type: "uint256" }], name: "Transfer", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "account", type: "address" }], name: "Unpaused", type: "event" }, { inputs: [], name: "DEFAULT_ADMIN_ROLE", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "view", type: "function" }, { inputs: [], name: "DOMAIN_SEPARATOR", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "owner", type: "address" }, { internalType: "address", name: "spender", type: "address" }], name: "allowance", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "spender", type: "address" }, { internalType: "uint256", name: "amount", type: "uint256" }], name: "approve", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "account", type: "address" }], name: "balanceOf", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "amount", type: "uint256" }], name: "burn", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "account", type: "address" }, { internalType: "uint256", name: "amount", type: "uint256" }], name: "burnFrom", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "account", type: "address" }, { internalType: "uint32", name: "pos", type: "uint32" }], name: "checkpoints", outputs: [{ components: [{ internalType: "uint32", name: "fromBlock", type: "uint32" }, { internalType: "uint224", name: "votes", type: "uint224" }], internalType: "struct ERC20VotesUpgradeable.Checkpoint", name: "", type: "tuple" }], stateMutability: "view", type: "function" }, { inputs: [], name: "contractType", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "pure", type: "function" }, { inputs: [], name: "contractURI", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [], name: "contractVersion", outputs: [{ internalType: "uint8", name: "", type: "uint8" }], stateMutability: "pure", type: "function" }, { inputs: [], name: "decimals", outputs: [{ internalType: "uint8", name: "", type: "uint8" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "spender", type: "address" }, { internalType: "uint256", name: "subtractedValue", type: "uint256" }], name: "decreaseAllowance", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "delegatee", type: "address" }], name: "delegate", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "delegatee", type: "address" }, { internalType: "uint256", name: "nonce", type: "uint256" }, { internalType: "uint256", name: "expiry", type: "uint256" }, { internalType: "uint8", name: "v", type: "uint8" }, { internalType: "bytes32", name: "r", type: "bytes32" }, { internalType: "bytes32", name: "s", type: "bytes32" }], name: "delegateBySig", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "account", type: "address" }], name: "delegates", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "blockNumber", type: "uint256" }], name: "getPastTotalSupply", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "account", type: "address" }, { internalType: "uint256", name: "blockNumber", type: "uint256" }], name: "getPastVotes", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "getPlatformFeeInfo", outputs: [{ internalType: "address", name: "", type: "address" }, { internalType: "uint16", name: "", type: "uint16" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }], name: "getRoleAdmin", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "uint256", name: "index", type: "uint256" }], name: "getRoleMember", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }], name: "getRoleMemberCount", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "account", type: "address" }], name: "getVotes", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "grantRole", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "hasRole", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "spender", type: "address" }, { internalType: "uint256", name: "addedValue", type: "uint256" }], name: "increaseAllowance", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_defaultAdmin", type: "address" }, { internalType: "string", name: "_name", type: "string" }, { internalType: "string", name: "_symbol", type: "string" }, { internalType: "string", name: "_contractURI", type: "string" }, { internalType: "address[]", name: "_trustedForwarders", type: "address[]" }, { internalType: "address", name: "_primarySaleRecipient", type: "address" }, { internalType: "address", name: "_platformFeeRecipient", type: "address" }, { internalType: "uint256", name: "_platformFeeBps", type: "uint256" }], name: "initialize", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "forwarder", type: "address" }], name: "isTrustedForwarder", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "amount", type: "uint256" }], name: "mintTo", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ components: [{ internalType: "address", name: "to", type: "address" }, { internalType: "address", name: "primarySaleRecipient", type: "address" }, { internalType: "uint256", name: "quantity", type: "uint256" }, { internalType: "uint256", name: "price", type: "uint256" }, { internalType: "address", name: "currency", type: "address" }, { internalType: "uint128", name: "validityStartTimestamp", type: "uint128" }, { internalType: "uint128", name: "validityEndTimestamp", type: "uint128" }, { internalType: "bytes32", name: "uid", type: "bytes32" }], internalType: "struct ITokenERC20.MintRequest", name: "_req", type: "tuple" }, { internalType: "bytes", name: "_signature", type: "bytes" }], name: "mintWithSignature", outputs: [], stateMutability: "payable", type: "function" }, { inputs: [{ internalType: "bytes[]", name: "data", type: "bytes[]" }], name: "multicall", outputs: [{ internalType: "bytes[]", name: "results", type: "bytes[]" }], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "name", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "owner", type: "address" }], name: "nonces", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "account", type: "address" }], name: "numCheckpoints", outputs: [{ internalType: "uint32", name: "", type: "uint32" }], stateMutability: "view", type: "function" }, { inputs: [], name: "pause", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "paused", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "owner", type: "address" }, { internalType: "address", name: "spender", type: "address" }, { internalType: "uint256", name: "value", type: "uint256" }, { internalType: "uint256", name: "deadline", type: "uint256" }, { internalType: "uint8", name: "v", type: "uint8" }, { internalType: "bytes32", name: "r", type: "bytes32" }, { internalType: "bytes32", name: "s", type: "bytes32" }], name: "permit", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "primarySaleRecipient", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "renounceRole", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "revokeRole", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "string", name: "_uri", type: "string" }], name: "setContractURI", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_platformFeeRecipient", type: "address" }, { internalType: "uint256", name: "_platformFeeBps", type: "uint256" }], name: "setPlatformFeeInfo", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_saleRecipient", type: "address" }], name: "setPrimarySaleRecipient", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }], name: "supportsInterface", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [], name: "symbol", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [], name: "totalSupply", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "amount", type: "uint256" }], name: "transfer", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "from", type: "address" }, { internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "amount", type: "uint256" }], name: "transferFrom", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "unpause", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ components: [{ internalType: "address", name: "to", type: "address" }, { internalType: "address", name: "primarySaleRecipient", type: "address" }, { internalType: "uint256", name: "quantity", type: "uint256" }, { internalType: "uint256", name: "price", type: "uint256" }, { internalType: "address", name: "currency", type: "address" }, { internalType: "uint128", name: "validityStartTimestamp", type: "uint128" }, { internalType: "uint128", name: "validityEndTimestamp", type: "uint128" }, { internalType: "bytes32", name: "uid", type: "bytes32" }], internalType: "struct ITokenERC20.MintRequest", name: "_req", type: "tuple" }, { internalType: "bytes", name: "_signature", type: "bytes" }], name: "verify", outputs: [{ internalType: "bool", name: "", type: "bool" }, { internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }];
});
var _i = We((G22, Ep) => {
  Ep.exports = [{ inputs: [{ internalType: "address", name: "_thirdwebFee", type: "address" }], stateMutability: "nonpayable", type: "constructor" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "owner", type: "address" }, { indexed: true, internalType: "address", name: "spender", type: "address" }, { indexed: false, internalType: "uint256", name: "value", type: "uint256" }], name: "Approval", type: "event" }, { anonymous: false, inputs: [{ components: [{ internalType: "uint256", name: "startTimestamp", type: "uint256" }, { internalType: "uint256", name: "maxClaimableSupply", type: "uint256" }, { internalType: "uint256", name: "supplyClaimed", type: "uint256" }, { internalType: "uint256", name: "quantityLimitPerTransaction", type: "uint256" }, { internalType: "uint256", name: "waitTimeInSecondsBetweenClaims", type: "uint256" }, { internalType: "bytes32", name: "merkleRoot", type: "bytes32" }, { internalType: "uint256", name: "pricePerToken", type: "uint256" }, { internalType: "address", name: "currency", type: "address" }], indexed: false, internalType: "struct IDropClaimCondition.ClaimCondition[]", name: "claimConditions", type: "tuple[]" }], name: "ClaimConditionsUpdated", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "delegator", type: "address" }, { indexed: true, internalType: "address", name: "fromDelegate", type: "address" }, { indexed: true, internalType: "address", name: "toDelegate", type: "address" }], name: "DelegateChanged", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "delegate", type: "address" }, { indexed: false, internalType: "uint256", name: "previousBalance", type: "uint256" }, { indexed: false, internalType: "uint256", name: "newBalance", type: "uint256" }], name: "DelegateVotesChanged", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "uint256", name: "maxTotalSupply", type: "uint256" }], name: "MaxTotalSupplyUpdated", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "uint256", name: "count", type: "uint256" }], name: "MaxWalletClaimCountUpdated", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "platformFeeRecipient", type: "address" }, { indexed: false, internalType: "uint256", name: "platformFeeBps", type: "uint256" }], name: "PlatformFeeInfoUpdated", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "recipient", type: "address" }], name: "PrimarySaleRecipientUpdated", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "role", type: "bytes32" }, { indexed: true, internalType: "bytes32", name: "previousAdminRole", type: "bytes32" }, { indexed: true, internalType: "bytes32", name: "newAdminRole", type: "bytes32" }], name: "RoleAdminChanged", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "role", type: "bytes32" }, { indexed: true, internalType: "address", name: "account", type: "address" }, { indexed: true, internalType: "address", name: "sender", type: "address" }], name: "RoleGranted", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "role", type: "bytes32" }, { indexed: true, internalType: "address", name: "account", type: "address" }, { indexed: true, internalType: "address", name: "sender", type: "address" }], name: "RoleRevoked", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "uint256", name: "claimConditionIndex", type: "uint256" }, { indexed: true, internalType: "address", name: "claimer", type: "address" }, { indexed: true, internalType: "address", name: "receiver", type: "address" }, { indexed: false, internalType: "uint256", name: "quantityClaimed", type: "uint256" }], name: "TokensClaimed", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "from", type: "address" }, { indexed: true, internalType: "address", name: "to", type: "address" }, { indexed: false, internalType: "uint256", name: "value", type: "uint256" }], name: "Transfer", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "wallet", type: "address" }, { indexed: false, internalType: "uint256", name: "count", type: "uint256" }], name: "WalletClaimCountUpdated", type: "event" }, { inputs: [], name: "DEFAULT_ADMIN_ROLE", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "view", type: "function" }, { inputs: [], name: "DOMAIN_SEPARATOR", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "owner", type: "address" }, { internalType: "address", name: "spender", type: "address" }], name: "allowance", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "spender", type: "address" }, { internalType: "uint256", name: "amount", type: "uint256" }], name: "approve", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "account", type: "address" }], name: "balanceOf", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "amount", type: "uint256" }], name: "burn", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "account", type: "address" }, { internalType: "uint256", name: "amount", type: "uint256" }], name: "burnFrom", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "account", type: "address" }, { internalType: "uint32", name: "pos", type: "uint32" }], name: "checkpoints", outputs: [{ components: [{ internalType: "uint32", name: "fromBlock", type: "uint32" }, { internalType: "uint224", name: "votes", type: "uint224" }], internalType: "struct ERC20VotesUpgradeable.Checkpoint", name: "", type: "tuple" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_receiver", type: "address" }, { internalType: "uint256", name: "_quantity", type: "uint256" }, { internalType: "address", name: "_currency", type: "address" }, { internalType: "uint256", name: "_pricePerToken", type: "uint256" }, { internalType: "bytes32[]", name: "_proofs", type: "bytes32[]" }, { internalType: "uint256", name: "_proofMaxQuantityPerTransaction", type: "uint256" }], name: "claim", outputs: [], stateMutability: "payable", type: "function" }, { inputs: [], name: "claimCondition", outputs: [{ internalType: "uint256", name: "currentStartId", type: "uint256" }, { internalType: "uint256", name: "count", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "contractType", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "pure", type: "function" }, { inputs: [], name: "contractURI", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [], name: "contractVersion", outputs: [{ internalType: "uint8", name: "", type: "uint8" }], stateMutability: "pure", type: "function" }, { inputs: [], name: "decimals", outputs: [{ internalType: "uint8", name: "", type: "uint8" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "spender", type: "address" }, { internalType: "uint256", name: "subtractedValue", type: "uint256" }], name: "decreaseAllowance", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "delegatee", type: "address" }], name: "delegate", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "delegatee", type: "address" }, { internalType: "uint256", name: "nonce", type: "uint256" }, { internalType: "uint256", name: "expiry", type: "uint256" }, { internalType: "uint8", name: "v", type: "uint8" }, { internalType: "bytes32", name: "r", type: "bytes32" }, { internalType: "bytes32", name: "s", type: "bytes32" }], name: "delegateBySig", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "account", type: "address" }], name: "delegates", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [], name: "getActiveClaimConditionId", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "_conditionId", type: "uint256" }], name: "getClaimConditionById", outputs: [{ components: [{ internalType: "uint256", name: "startTimestamp", type: "uint256" }, { internalType: "uint256", name: "maxClaimableSupply", type: "uint256" }, { internalType: "uint256", name: "supplyClaimed", type: "uint256" }, { internalType: "uint256", name: "quantityLimitPerTransaction", type: "uint256" }, { internalType: "uint256", name: "waitTimeInSecondsBetweenClaims", type: "uint256" }, { internalType: "bytes32", name: "merkleRoot", type: "bytes32" }, { internalType: "uint256", name: "pricePerToken", type: "uint256" }, { internalType: "address", name: "currency", type: "address" }], internalType: "struct IDropClaimCondition.ClaimCondition", name: "condition", type: "tuple" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "_conditionId", type: "uint256" }, { internalType: "address", name: "_claimer", type: "address" }], name: "getClaimTimestamp", outputs: [{ internalType: "uint256", name: "lastClaimTimestamp", type: "uint256" }, { internalType: "uint256", name: "nextValidClaimTimestamp", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "blockNumber", type: "uint256" }], name: "getPastTotalSupply", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "account", type: "address" }, { internalType: "uint256", name: "blockNumber", type: "uint256" }], name: "getPastVotes", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "getPlatformFeeInfo", outputs: [{ internalType: "address", name: "", type: "address" }, { internalType: "uint16", name: "", type: "uint16" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }], name: "getRoleAdmin", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "uint256", name: "index", type: "uint256" }], name: "getRoleMember", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }], name: "getRoleMemberCount", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "account", type: "address" }], name: "getVotes", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "grantRole", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "hasRole", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "spender", type: "address" }, { internalType: "uint256", name: "addedValue", type: "uint256" }], name: "increaseAllowance", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_defaultAdmin", type: "address" }, { internalType: "string", name: "_name", type: "string" }, { internalType: "string", name: "_symbol", type: "string" }, { internalType: "string", name: "_contractURI", type: "string" }, { internalType: "address[]", name: "_trustedForwarders", type: "address[]" }, { internalType: "address", name: "_primarySaleRecipient", type: "address" }, { internalType: "address", name: "_platformFeeRecipient", type: "address" }, { internalType: "uint256", name: "_platformFeeBps", type: "uint256" }], name: "initialize", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "forwarder", type: "address" }], name: "isTrustedForwarder", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [], name: "maxTotalSupply", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "maxWalletClaimCount", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes[]", name: "data", type: "bytes[]" }], name: "multicall", outputs: [{ internalType: "bytes[]", name: "results", type: "bytes[]" }], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "name", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "owner", type: "address" }], name: "nonces", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "account", type: "address" }], name: "numCheckpoints", outputs: [{ internalType: "uint32", name: "", type: "uint32" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "owner", type: "address" }, { internalType: "address", name: "spender", type: "address" }, { internalType: "uint256", name: "value", type: "uint256" }, { internalType: "uint256", name: "deadline", type: "uint256" }, { internalType: "uint8", name: "v", type: "uint8" }, { internalType: "bytes32", name: "r", type: "bytes32" }, { internalType: "bytes32", name: "s", type: "bytes32" }], name: "permit", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "primarySaleRecipient", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "renounceRole", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "revokeRole", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ components: [{ internalType: "uint256", name: "startTimestamp", type: "uint256" }, { internalType: "uint256", name: "maxClaimableSupply", type: "uint256" }, { internalType: "uint256", name: "supplyClaimed", type: "uint256" }, { internalType: "uint256", name: "quantityLimitPerTransaction", type: "uint256" }, { internalType: "uint256", name: "waitTimeInSecondsBetweenClaims", type: "uint256" }, { internalType: "bytes32", name: "merkleRoot", type: "bytes32" }, { internalType: "uint256", name: "pricePerToken", type: "uint256" }, { internalType: "address", name: "currency", type: "address" }], internalType: "struct IDropClaimCondition.ClaimCondition[]", name: "_phases", type: "tuple[]" }, { internalType: "bool", name: "_resetClaimEligibility", type: "bool" }], name: "setClaimConditions", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "string", name: "_uri", type: "string" }], name: "setContractURI", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "_maxTotalSupply", type: "uint256" }], name: "setMaxTotalSupply", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "_count", type: "uint256" }], name: "setMaxWalletClaimCount", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_platformFeeRecipient", type: "address" }, { internalType: "uint256", name: "_platformFeeBps", type: "uint256" }], name: "setPlatformFeeInfo", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_saleRecipient", type: "address" }], name: "setPrimarySaleRecipient", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_claimer", type: "address" }, { internalType: "uint256", name: "_count", type: "uint256" }], name: "setWalletClaimCount", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }], name: "supportsInterface", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [], name: "symbol", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [], name: "totalSupply", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "amount", type: "uint256" }], name: "transfer", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "from", type: "address" }, { internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "amount", type: "uint256" }], name: "transferFrom", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "_conditionId", type: "uint256" }, { internalType: "address", name: "_claimer", type: "address" }, { internalType: "uint256", name: "_quantity", type: "uint256" }, { internalType: "address", name: "_currency", type: "address" }, { internalType: "uint256", name: "_pricePerToken", type: "uint256" }, { internalType: "bool", name: "verifyMaxQuantityPerTransaction", type: "bool" }], name: "verifyClaim", outputs: [], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "_conditionId", type: "uint256" }, { internalType: "address", name: "_claimer", type: "address" }, { internalType: "uint256", name: "_quantity", type: "uint256" }, { internalType: "bytes32[]", name: "_proofs", type: "bytes32[]" }, { internalType: "uint256", name: "_proofMaxQuantityPerTransaction", type: "uint256" }], name: "verifyClaimMerkleProof", outputs: [{ internalType: "bool", name: "validMerkleProof", type: "bool" }, { internalType: "uint256", name: "merkleProofIndex", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "", type: "address" }], name: "walletClaimCount", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }];
});
var Si = We((X22, Wp) => {
  Wp.exports = [{ inputs: [], stateMutability: "nonpayable", type: "constructor" }, { anonymous: false, inputs: [{ indexed: false, internalType: "uint256", name: "proposalId", type: "uint256" }], name: "ProposalCanceled", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "uint256", name: "proposalId", type: "uint256" }, { indexed: false, internalType: "address", name: "proposer", type: "address" }, { indexed: false, internalType: "address[]", name: "targets", type: "address[]" }, { indexed: false, internalType: "uint256[]", name: "values", type: "uint256[]" }, { indexed: false, internalType: "string[]", name: "signatures", type: "string[]" }, { indexed: false, internalType: "bytes[]", name: "calldatas", type: "bytes[]" }, { indexed: false, internalType: "uint256", name: "startBlock", type: "uint256" }, { indexed: false, internalType: "uint256", name: "endBlock", type: "uint256" }, { indexed: false, internalType: "string", name: "description", type: "string" }], name: "ProposalCreated", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "uint256", name: "proposalId", type: "uint256" }], name: "ProposalExecuted", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "uint256", name: "oldProposalThreshold", type: "uint256" }, { indexed: false, internalType: "uint256", name: "newProposalThreshold", type: "uint256" }], name: "ProposalThresholdSet", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "uint256", name: "oldQuorumNumerator", type: "uint256" }, { indexed: false, internalType: "uint256", name: "newQuorumNumerator", type: "uint256" }], name: "QuorumNumeratorUpdated", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "voter", type: "address" }, { indexed: false, internalType: "uint256", name: "proposalId", type: "uint256" }, { indexed: false, internalType: "uint8", name: "support", type: "uint8" }, { indexed: false, internalType: "uint256", name: "weight", type: "uint256" }, { indexed: false, internalType: "string", name: "reason", type: "string" }], name: "VoteCast", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "uint256", name: "oldVotingDelay", type: "uint256" }, { indexed: false, internalType: "uint256", name: "newVotingDelay", type: "uint256" }], name: "VotingDelaySet", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "uint256", name: "oldVotingPeriod", type: "uint256" }, { indexed: false, internalType: "uint256", name: "newVotingPeriod", type: "uint256" }], name: "VotingPeriodSet", type: "event" }, { inputs: [], name: "BALLOT_TYPEHASH", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "view", type: "function" }, { inputs: [], name: "COUNTING_MODE", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "pure", type: "function" }, { inputs: [{ internalType: "uint256", name: "proposalId", type: "uint256" }, { internalType: "uint8", name: "support", type: "uint8" }], name: "castVote", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "proposalId", type: "uint256" }, { internalType: "uint8", name: "support", type: "uint8" }, { internalType: "uint8", name: "v", type: "uint8" }, { internalType: "bytes32", name: "r", type: "bytes32" }, { internalType: "bytes32", name: "s", type: "bytes32" }], name: "castVoteBySig", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "proposalId", type: "uint256" }, { internalType: "uint8", name: "support", type: "uint8" }, { internalType: "string", name: "reason", type: "string" }], name: "castVoteWithReason", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "contractType", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "pure", type: "function" }, { inputs: [], name: "contractURI", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [], name: "contractVersion", outputs: [{ internalType: "uint8", name: "", type: "uint8" }], stateMutability: "pure", type: "function" }, { inputs: [{ internalType: "address[]", name: "targets", type: "address[]" }, { internalType: "uint256[]", name: "values", type: "uint256[]" }, { internalType: "bytes[]", name: "calldatas", type: "bytes[]" }, { internalType: "bytes32", name: "descriptionHash", type: "bytes32" }], name: "execute", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "payable", type: "function" }, { inputs: [], name: "getAllProposals", outputs: [{ components: [{ internalType: "uint256", name: "proposalId", type: "uint256" }, { internalType: "address", name: "proposer", type: "address" }, { internalType: "address[]", name: "targets", type: "address[]" }, { internalType: "uint256[]", name: "values", type: "uint256[]" }, { internalType: "string[]", name: "signatures", type: "string[]" }, { internalType: "bytes[]", name: "calldatas", type: "bytes[]" }, { internalType: "uint256", name: "startBlock", type: "uint256" }, { internalType: "uint256", name: "endBlock", type: "uint256" }, { internalType: "string", name: "description", type: "string" }], internalType: "struct VoteERC20.Proposal[]", name: "allProposals", type: "tuple[]" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "account", type: "address" }, { internalType: "uint256", name: "blockNumber", type: "uint256" }], name: "getVotes", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "proposalId", type: "uint256" }, { internalType: "address", name: "account", type: "address" }], name: "hasVoted", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address[]", name: "targets", type: "address[]" }, { internalType: "uint256[]", name: "values", type: "uint256[]" }, { internalType: "bytes[]", name: "calldatas", type: "bytes[]" }, { internalType: "bytes32", name: "descriptionHash", type: "bytes32" }], name: "hashProposal", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "pure", type: "function" }, { inputs: [{ internalType: "string", name: "_name", type: "string" }, { internalType: "string", name: "_contractURI", type: "string" }, { internalType: "address[]", name: "_trustedForwarders", type: "address[]" }, { internalType: "address", name: "_token", type: "address" }, { internalType: "uint256", name: "_initialVotingDelay", type: "uint256" }, { internalType: "uint256", name: "_initialVotingPeriod", type: "uint256" }, { internalType: "uint256", name: "_initialProposalThreshold", type: "uint256" }, { internalType: "uint256", name: "_initialVoteQuorumFraction", type: "uint256" }], name: "initialize", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "forwarder", type: "address" }], name: "isTrustedForwarder", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [], name: "name", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "", type: "address" }, { internalType: "address", name: "", type: "address" }, { internalType: "uint256[]", name: "", type: "uint256[]" }, { internalType: "uint256[]", name: "", type: "uint256[]" }, { internalType: "bytes", name: "", type: "bytes" }], name: "onERC1155BatchReceived", outputs: [{ internalType: "bytes4", name: "", type: "bytes4" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "", type: "address" }, { internalType: "address", name: "", type: "address" }, { internalType: "uint256", name: "", type: "uint256" }, { internalType: "uint256", name: "", type: "uint256" }, { internalType: "bytes", name: "", type: "bytes" }], name: "onERC1155Received", outputs: [{ internalType: "bytes4", name: "", type: "bytes4" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "", type: "address" }, { internalType: "address", name: "", type: "address" }, { internalType: "uint256", name: "", type: "uint256" }, { internalType: "bytes", name: "", type: "bytes" }], name: "onERC721Received", outputs: [{ internalType: "bytes4", name: "", type: "bytes4" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "proposalId", type: "uint256" }], name: "proposalDeadline", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "proposalIndex", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "proposalId", type: "uint256" }], name: "proposalSnapshot", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "proposalThreshold", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "proposalId", type: "uint256" }], name: "proposalVotes", outputs: [{ internalType: "uint256", name: "againstVotes", type: "uint256" }, { internalType: "uint256", name: "forVotes", type: "uint256" }, { internalType: "uint256", name: "abstainVotes", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "", type: "uint256" }], name: "proposals", outputs: [{ internalType: "uint256", name: "proposalId", type: "uint256" }, { internalType: "address", name: "proposer", type: "address" }, { internalType: "uint256", name: "startBlock", type: "uint256" }, { internalType: "uint256", name: "endBlock", type: "uint256" }, { internalType: "string", name: "description", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address[]", name: "targets", type: "address[]" }, { internalType: "uint256[]", name: "values", type: "uint256[]" }, { internalType: "bytes[]", name: "calldatas", type: "bytes[]" }, { internalType: "string", name: "description", type: "string" }], name: "propose", outputs: [{ internalType: "uint256", name: "proposalId", type: "uint256" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "blockNumber", type: "uint256" }], name: "quorum", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "quorumDenominator", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "quorumNumerator", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "target", type: "address" }, { internalType: "uint256", name: "value", type: "uint256" }, { internalType: "bytes", name: "data", type: "bytes" }], name: "relay", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "string", name: "uri", type: "string" }], name: "setContractURI", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "newProposalThreshold", type: "uint256" }], name: "setProposalThreshold", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "newVotingDelay", type: "uint256" }], name: "setVotingDelay", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "newVotingPeriod", type: "uint256" }], name: "setVotingPeriod", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "proposalId", type: "uint256" }], name: "state", outputs: [{ internalType: "enum IGovernorUpgradeable.ProposalState", name: "", type: "uint8" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }], name: "supportsInterface", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [], name: "token", outputs: [{ internalType: "contract IVotesUpgradeable", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "newQuorumNumerator", type: "uint256" }], name: "updateQuorumNumerator", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "version", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [], name: "votingDelay", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "votingPeriod", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { stateMutability: "payable", type: "receive" }];
});
var ki = We((mm, Op) => {
  Op.exports = [{ inputs: [{ internalType: "address", name: "_thirdwebFee", type: "address" }], stateMutability: "nonpayable", type: "constructor" }, { anonymous: false, inputs: [{ indexed: true, internalType: "contract IERC20Upgradeable", name: "token", type: "address" }, { indexed: false, internalType: "address", name: "to", type: "address" }, { indexed: false, internalType: "uint256", name: "amount", type: "uint256" }], name: "ERC20PaymentReleased", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "account", type: "address" }, { indexed: false, internalType: "uint256", name: "shares", type: "uint256" }], name: "PayeeAdded", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "from", type: "address" }, { indexed: false, internalType: "uint256", name: "amount", type: "uint256" }], name: "PaymentReceived", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "to", type: "address" }, { indexed: false, internalType: "uint256", name: "amount", type: "uint256" }], name: "PaymentReleased", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "role", type: "bytes32" }, { indexed: true, internalType: "bytes32", name: "previousAdminRole", type: "bytes32" }, { indexed: true, internalType: "bytes32", name: "newAdminRole", type: "bytes32" }], name: "RoleAdminChanged", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "role", type: "bytes32" }, { indexed: true, internalType: "address", name: "account", type: "address" }, { indexed: true, internalType: "address", name: "sender", type: "address" }], name: "RoleGranted", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "role", type: "bytes32" }, { indexed: true, internalType: "address", name: "account", type: "address" }, { indexed: true, internalType: "address", name: "sender", type: "address" }], name: "RoleRevoked", type: "event" }, { inputs: [], name: "DEFAULT_ADMIN_ROLE", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "view", type: "function" }, { inputs: [], name: "contractType", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "pure", type: "function" }, { inputs: [], name: "contractURI", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [], name: "contractVersion", outputs: [{ internalType: "uint8", name: "", type: "uint8" }], stateMutability: "pure", type: "function" }, { inputs: [{ internalType: "contract IERC20Upgradeable", name: "token", type: "address" }], name: "distribute", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "distribute", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }], name: "getRoleAdmin", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "uint256", name: "index", type: "uint256" }], name: "getRoleMember", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }], name: "getRoleMemberCount", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "grantRole", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "hasRole", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_defaultAdmin", type: "address" }, { internalType: "string", name: "_contractURI", type: "string" }, { internalType: "address[]", name: "_trustedForwarders", type: "address[]" }, { internalType: "address[]", name: "_payees", type: "address[]" }, { internalType: "uint256[]", name: "_shares", type: "uint256[]" }], name: "initialize", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "forwarder", type: "address" }], name: "isTrustedForwarder", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes[]", name: "data", type: "bytes[]" }], name: "multicall", outputs: [{ internalType: "bytes[]", name: "results", type: "bytes[]" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "index", type: "uint256" }], name: "payee", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [], name: "payeeCount", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address payable", name: "account", type: "address" }], name: "release", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "contract IERC20Upgradeable", name: "token", type: "address" }, { internalType: "address", name: "account", type: "address" }], name: "release", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "contract IERC20Upgradeable", name: "token", type: "address" }, { internalType: "address", name: "account", type: "address" }], name: "released", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "account", type: "address" }], name: "released", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "renounceRole", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "revokeRole", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "string", name: "_uri", type: "string" }], name: "setContractURI", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "account", type: "address" }], name: "shares", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }], name: "supportsInterface", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [], name: "thirdwebFee", outputs: [{ internalType: "contract ITWFee", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "contract IERC20Upgradeable", name: "token", type: "address" }], name: "totalReleased", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "totalReleased", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "totalShares", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { stateMutability: "payable", type: "receive" }];
});
var Pi = We((_m, Up) => {
  Up.exports = [{ inputs: [{ internalType: "address", name: "_nativeTokenWrapper", type: "address" }, { internalType: "address", name: "_thirdwebFee", type: "address" }], stateMutability: "nonpayable", type: "constructor" }, { anonymous: false, inputs: [{ indexed: false, internalType: "uint256", name: "timeBuffer", type: "uint256" }, { indexed: false, internalType: "uint256", name: "bidBufferBps", type: "uint256" }], name: "AuctionBuffersUpdated", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "uint256", name: "listingId", type: "uint256" }, { indexed: true, internalType: "address", name: "closer", type: "address" }, { indexed: true, internalType: "bool", name: "cancelled", type: "bool" }, { indexed: false, internalType: "address", name: "auctionCreator", type: "address" }, { indexed: false, internalType: "address", name: "winningBidder", type: "address" }], name: "AuctionClosed", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "uint256", name: "listingId", type: "uint256" }, { indexed: true, internalType: "address", name: "assetContract", type: "address" }, { indexed: true, internalType: "address", name: "lister", type: "address" }, { components: [{ internalType: "uint256", name: "listingId", type: "uint256" }, { internalType: "address", name: "tokenOwner", type: "address" }, { internalType: "address", name: "assetContract", type: "address" }, { internalType: "uint256", name: "tokenId", type: "uint256" }, { internalType: "uint256", name: "startTime", type: "uint256" }, { internalType: "uint256", name: "endTime", type: "uint256" }, { internalType: "uint256", name: "quantity", type: "uint256" }, { internalType: "address", name: "currency", type: "address" }, { internalType: "uint256", name: "reservePricePerToken", type: "uint256" }, { internalType: "uint256", name: "buyoutPricePerToken", type: "uint256" }, { internalType: "enum IMarketplace.TokenType", name: "tokenType", type: "uint8" }, { internalType: "enum IMarketplace.ListingType", name: "listingType", type: "uint8" }], indexed: false, internalType: "struct IMarketplace.Listing", name: "listing", type: "tuple" }], name: "ListingAdded", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "uint256", name: "listingId", type: "uint256" }, { indexed: true, internalType: "address", name: "listingCreator", type: "address" }], name: "ListingRemoved", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "uint256", name: "listingId", type: "uint256" }, { indexed: true, internalType: "address", name: "listingCreator", type: "address" }], name: "ListingUpdated", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "uint256", name: "listingId", type: "uint256" }, { indexed: true, internalType: "address", name: "offeror", type: "address" }, { indexed: true, internalType: "enum IMarketplace.ListingType", name: "listingType", type: "uint8" }, { indexed: false, internalType: "uint256", name: "quantityWanted", type: "uint256" }, { indexed: false, internalType: "uint256", name: "totalOfferAmount", type: "uint256" }, { indexed: false, internalType: "address", name: "currency", type: "address" }], name: "NewOffer", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "uint256", name: "listingId", type: "uint256" }, { indexed: true, internalType: "address", name: "assetContract", type: "address" }, { indexed: true, internalType: "address", name: "lister", type: "address" }, { indexed: false, internalType: "address", name: "buyer", type: "address" }, { indexed: false, internalType: "uint256", name: "quantityBought", type: "uint256" }, { indexed: false, internalType: "uint256", name: "totalPricePaid", type: "uint256" }], name: "NewSale", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "platformFeeRecipient", type: "address" }, { indexed: false, internalType: "uint256", name: "platformFeeBps", type: "uint256" }], name: "PlatformFeeInfoUpdated", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "role", type: "bytes32" }, { indexed: true, internalType: "bytes32", name: "previousAdminRole", type: "bytes32" }, { indexed: true, internalType: "bytes32", name: "newAdminRole", type: "bytes32" }], name: "RoleAdminChanged", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "role", type: "bytes32" }, { indexed: true, internalType: "address", name: "account", type: "address" }, { indexed: true, internalType: "address", name: "sender", type: "address" }], name: "RoleGranted", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "role", type: "bytes32" }, { indexed: true, internalType: "address", name: "account", type: "address" }, { indexed: true, internalType: "address", name: "sender", type: "address" }], name: "RoleRevoked", type: "event" }, { inputs: [], name: "DEFAULT_ADMIN_ROLE", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "view", type: "function" }, { inputs: [], name: "MAX_BPS", outputs: [{ internalType: "uint64", name: "", type: "uint64" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "_listingId", type: "uint256" }, { internalType: "address", name: "_offeror", type: "address" }, { internalType: "address", name: "_currency", type: "address" }, { internalType: "uint256", name: "_pricePerToken", type: "uint256" }], name: "acceptOffer", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "bidBufferBps", outputs: [{ internalType: "uint64", name: "", type: "uint64" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "_listingId", type: "uint256" }, { internalType: "address", name: "_buyFor", type: "address" }, { internalType: "uint256", name: "_quantityToBuy", type: "uint256" }, { internalType: "address", name: "_currency", type: "address" }, { internalType: "uint256", name: "_totalPrice", type: "uint256" }], name: "buy", outputs: [], stateMutability: "payable", type: "function" }, { inputs: [{ internalType: "uint256", name: "_listingId", type: "uint256" }], name: "cancelDirectListing", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "_listingId", type: "uint256" }, { internalType: "address", name: "_closeFor", type: "address" }], name: "closeAuction", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "contractType", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "pure", type: "function" }, { inputs: [], name: "contractURI", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [], name: "contractVersion", outputs: [{ internalType: "uint8", name: "", type: "uint8" }], stateMutability: "pure", type: "function" }, { inputs: [{ components: [{ internalType: "address", name: "assetContract", type: "address" }, { internalType: "uint256", name: "tokenId", type: "uint256" }, { internalType: "uint256", name: "startTime", type: "uint256" }, { internalType: "uint256", name: "secondsUntilEndTime", type: "uint256" }, { internalType: "uint256", name: "quantityToList", type: "uint256" }, { internalType: "address", name: "currencyToAccept", type: "address" }, { internalType: "uint256", name: "reservePricePerToken", type: "uint256" }, { internalType: "uint256", name: "buyoutPricePerToken", type: "uint256" }, { internalType: "enum IMarketplace.ListingType", name: "listingType", type: "uint8" }], internalType: "struct IMarketplace.ListingParameters", name: "_params", type: "tuple" }], name: "createListing", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "getPlatformFeeInfo", outputs: [{ internalType: "address", name: "", type: "address" }, { internalType: "uint16", name: "", type: "uint16" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }], name: "getRoleAdmin", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "uint256", name: "index", type: "uint256" }], name: "getRoleMember", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }], name: "getRoleMemberCount", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "grantRole", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "hasRole", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_defaultAdmin", type: "address" }, { internalType: "string", name: "_contractURI", type: "string" }, { internalType: "address[]", name: "_trustedForwarders", type: "address[]" }, { internalType: "address", name: "_platformFeeRecipient", type: "address" }, { internalType: "uint256", name: "_platformFeeBps", type: "uint256" }], name: "initialize", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "forwarder", type: "address" }], name: "isTrustedForwarder", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "", type: "uint256" }], name: "listings", outputs: [{ internalType: "uint256", name: "listingId", type: "uint256" }, { internalType: "address", name: "tokenOwner", type: "address" }, { internalType: "address", name: "assetContract", type: "address" }, { internalType: "uint256", name: "tokenId", type: "uint256" }, { internalType: "uint256", name: "startTime", type: "uint256" }, { internalType: "uint256", name: "endTime", type: "uint256" }, { internalType: "uint256", name: "quantity", type: "uint256" }, { internalType: "address", name: "currency", type: "address" }, { internalType: "uint256", name: "reservePricePerToken", type: "uint256" }, { internalType: "uint256", name: "buyoutPricePerToken", type: "uint256" }, { internalType: "enum IMarketplace.TokenType", name: "tokenType", type: "uint8" }, { internalType: "enum IMarketplace.ListingType", name: "listingType", type: "uint8" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes[]", name: "data", type: "bytes[]" }], name: "multicall", outputs: [{ internalType: "bytes[]", name: "results", type: "bytes[]" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "_listingId", type: "uint256" }, { internalType: "uint256", name: "_quantityWanted", type: "uint256" }, { internalType: "address", name: "_currency", type: "address" }, { internalType: "uint256", name: "_pricePerToken", type: "uint256" }, { internalType: "uint256", name: "_expirationTimestamp", type: "uint256" }], name: "offer", outputs: [], stateMutability: "payable", type: "function" }, { inputs: [{ internalType: "uint256", name: "", type: "uint256" }, { internalType: "address", name: "", type: "address" }], name: "offers", outputs: [{ internalType: "uint256", name: "listingId", type: "uint256" }, { internalType: "address", name: "offeror", type: "address" }, { internalType: "uint256", name: "quantityWanted", type: "uint256" }, { internalType: "address", name: "currency", type: "address" }, { internalType: "uint256", name: "pricePerToken", type: "uint256" }, { internalType: "uint256", name: "expirationTimestamp", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "", type: "address" }, { internalType: "address", name: "", type: "address" }, { internalType: "uint256[]", name: "", type: "uint256[]" }, { internalType: "uint256[]", name: "", type: "uint256[]" }, { internalType: "bytes", name: "", type: "bytes" }], name: "onERC1155BatchReceived", outputs: [{ internalType: "bytes4", name: "", type: "bytes4" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "", type: "address" }, { internalType: "address", name: "", type: "address" }, { internalType: "uint256", name: "", type: "uint256" }, { internalType: "uint256", name: "", type: "uint256" }, { internalType: "bytes", name: "", type: "bytes" }], name: "onERC1155Received", outputs: [{ internalType: "bytes4", name: "", type: "bytes4" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "", type: "address" }, { internalType: "address", name: "", type: "address" }, { internalType: "uint256", name: "", type: "uint256" }, { internalType: "bytes", name: "", type: "bytes" }], name: "onERC721Received", outputs: [{ internalType: "bytes4", name: "", type: "bytes4" }], stateMutability: "pure", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "renounceRole", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "revokeRole", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "_timeBuffer", type: "uint256" }, { internalType: "uint256", name: "_bidBufferBps", type: "uint256" }], name: "setAuctionBuffers", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "string", name: "_uri", type: "string" }], name: "setContractURI", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_platformFeeRecipient", type: "address" }, { internalType: "uint256", name: "_platformFeeBps", type: "uint256" }], name: "setPlatformFeeInfo", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }], name: "supportsInterface", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [], name: "thirdwebFee", outputs: [{ internalType: "contract ITWFee", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [], name: "timeBuffer", outputs: [{ internalType: "uint64", name: "", type: "uint64" }], stateMutability: "view", type: "function" }, { inputs: [], name: "totalListings", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "_listingId", type: "uint256" }, { internalType: "uint256", name: "_quantityToList", type: "uint256" }, { internalType: "uint256", name: "_reservePricePerToken", type: "uint256" }, { internalType: "uint256", name: "_buyoutPricePerToken", type: "uint256" }, { internalType: "address", name: "_currencyToAccept", type: "address" }, { internalType: "uint256", name: "_startTime", type: "uint256" }, { internalType: "uint256", name: "_secondsUntilEndTime", type: "uint256" }], name: "updateListing", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "", type: "uint256" }], name: "winningBid", outputs: [{ internalType: "uint256", name: "listingId", type: "uint256" }, { internalType: "address", name: "offeror", type: "address" }, { internalType: "uint256", name: "quantityWanted", type: "uint256" }, { internalType: "address", name: "currency", type: "address" }, { internalType: "uint256", name: "pricePerToken", type: "uint256" }, { internalType: "uint256", name: "expirationTimestamp", type: "uint256" }], stateMutability: "view", type: "function" }, { stateMutability: "payable", type: "receive" }];
});
var Wi = We(($m, Lp) => {
  Lp.exports = [{ inputs: [{ internalType: "address", name: "_vrfCoordinator", type: "address" }, { internalType: "address", name: "_linkToken", type: "address" }, { internalType: "address", name: "_thirdwebFee", type: "address" }], stateMutability: "nonpayable", type: "constructor" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "account", type: "address" }, { indexed: true, internalType: "address", name: "operator", type: "address" }, { indexed: false, internalType: "bool", name: "approved", type: "bool" }], name: "ApprovalForAll", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "newRoyaltyRecipient", type: "address" }, { indexed: false, internalType: "uint256", name: "newRoyaltyBps", type: "uint256" }], name: "DefaultRoyalty", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "prevOwner", type: "address" }, { indexed: false, internalType: "address", name: "newOwner", type: "address" }], name: "OwnerUpdated", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "uint256", name: "packId", type: "uint256" }, { indexed: true, internalType: "address", name: "rewardContract", type: "address" }, { indexed: true, internalType: "address", name: "creator", type: "address" }, { indexed: false, internalType: "uint256", name: "packTotalSupply", type: "uint256" }, { components: [{ internalType: "string", name: "uri", type: "string" }, { internalType: "address", name: "creator", type: "address" }, { internalType: "uint256", name: "openStart", type: "uint256" }], indexed: false, internalType: "struct Pack.PackState", name: "packState", type: "tuple" }, { components: [{ internalType: "address", name: "source", type: "address" }, { internalType: "uint256[]", name: "tokenIds", type: "uint256[]" }, { internalType: "uint256[]", name: "amountsPacked", type: "uint256[]" }, { internalType: "uint256", name: "rewardsPerOpen", type: "uint256" }], indexed: false, internalType: "struct Pack.Rewards", name: "rewards", type: "tuple" }], name: "PackAdded", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "uint256", name: "packId", type: "uint256" }, { indexed: true, internalType: "address", name: "opener", type: "address" }, { indexed: false, internalType: "bytes32", name: "requestId", type: "bytes32" }, { indexed: true, internalType: "address", name: "rewardContract", type: "address" }, { indexed: false, internalType: "uint256[]", name: "rewardIds", type: "uint256[]" }], name: "PackOpenFulfilled", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "uint256", name: "packId", type: "uint256" }, { indexed: true, internalType: "address", name: "opener", type: "address" }, { indexed: false, internalType: "bytes32", name: "requestId", type: "bytes32" }], name: "PackOpenRequested", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "account", type: "address" }], name: "Paused", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "role", type: "bytes32" }, { indexed: true, internalType: "bytes32", name: "previousAdminRole", type: "bytes32" }, { indexed: true, internalType: "bytes32", name: "newAdminRole", type: "bytes32" }], name: "RoleAdminChanged", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "role", type: "bytes32" }, { indexed: true, internalType: "address", name: "account", type: "address" }, { indexed: true, internalType: "address", name: "sender", type: "address" }], name: "RoleGranted", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "role", type: "bytes32" }, { indexed: true, internalType: "address", name: "account", type: "address" }, { indexed: true, internalType: "address", name: "sender", type: "address" }], name: "RoleRevoked", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "uint256", name: "tokenId", type: "uint256" }, { indexed: false, internalType: "address", name: "royaltyRecipient", type: "address" }, { indexed: false, internalType: "uint256", name: "royaltyBps", type: "uint256" }], name: "RoyaltyForToken", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "operator", type: "address" }, { indexed: true, internalType: "address", name: "from", type: "address" }, { indexed: true, internalType: "address", name: "to", type: "address" }, { indexed: false, internalType: "uint256[]", name: "ids", type: "uint256[]" }, { indexed: false, internalType: "uint256[]", name: "values", type: "uint256[]" }], name: "TransferBatch", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "operator", type: "address" }, { indexed: true, internalType: "address", name: "from", type: "address" }, { indexed: true, internalType: "address", name: "to", type: "address" }, { indexed: false, internalType: "uint256", name: "id", type: "uint256" }, { indexed: false, internalType: "uint256", name: "value", type: "uint256" }], name: "TransferSingle", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "string", name: "value", type: "string" }, { indexed: true, internalType: "uint256", name: "id", type: "uint256" }], name: "URI", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "account", type: "address" }], name: "Unpaused", type: "event" }, { inputs: [], name: "DEFAULT_ADMIN_ROLE", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "account", type: "address" }, { internalType: "uint256", name: "id", type: "uint256" }], name: "balanceOf", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address[]", name: "accounts", type: "address[]" }, { internalType: "uint256[]", name: "ids", type: "uint256[]" }], name: "balanceOfBatch", outputs: [{ internalType: "uint256[]", name: "", type: "uint256[]" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "account", type: "address" }, { internalType: "uint256", name: "id", type: "uint256" }, { internalType: "uint256", name: "value", type: "uint256" }], name: "burn", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "account", type: "address" }, { internalType: "uint256[]", name: "ids", type: "uint256[]" }, { internalType: "uint256[]", name: "values", type: "uint256[]" }], name: "burnBatch", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "contractType", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "pure", type: "function" }, { inputs: [], name: "contractURI", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [], name: "contractVersion", outputs: [{ internalType: "uint8", name: "", type: "uint8" }], stateMutability: "pure", type: "function" }, { inputs: [{ internalType: "uint256", name: "", type: "uint256" }, { internalType: "address", name: "", type: "address" }], name: "currentRequestId", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "view", type: "function" }, { inputs: [], name: "getDefaultRoyaltyInfo", outputs: [{ internalType: "address", name: "", type: "address" }, { internalType: "uint16", name: "", type: "uint16" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "_packId", type: "uint256" }], name: "getPackWithRewards", outputs: [{ components: [{ internalType: "string", name: "uri", type: "string" }, { internalType: "address", name: "creator", type: "address" }, { internalType: "uint256", name: "openStart", type: "uint256" }], internalType: "struct Pack.PackState", name: "pack", type: "tuple" }, { internalType: "uint256", name: "packTotalSupply", type: "uint256" }, { internalType: "address", name: "source", type: "address" }, { internalType: "uint256[]", name: "tokenIds", type: "uint256[]" }, { internalType: "uint256[]", name: "amountsPacked", type: "uint256[]" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }], name: "getRoleAdmin", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "uint256", name: "index", type: "uint256" }], name: "getRoleMember", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }], name: "getRoleMemberCount", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "_tokenId", type: "uint256" }], name: "getRoyaltyInfoForToken", outputs: [{ internalType: "address", name: "", type: "address" }, { internalType: "uint16", name: "", type: "uint16" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "grantRole", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "hasRole", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_defaultAdmin", type: "address" }, { internalType: "string", name: "_name", type: "string" }, { internalType: "string", name: "_symbol", type: "string" }, { internalType: "string", name: "_contractURI", type: "string" }, { internalType: "address[]", name: "_trustedForwarders", type: "address[]" }, { internalType: "address", name: "_royaltyRecipient", type: "address" }, { internalType: "uint128", name: "_royaltyBps", type: "uint128" }, { internalType: "uint128", name: "_fees", type: "uint128" }, { internalType: "bytes32", name: "_keyHash", type: "bytes32" }], name: "initialize", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "account", type: "address" }, { internalType: "address", name: "operator", type: "address" }], name: "isApprovedForAll", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "forwarder", type: "address" }], name: "isTrustedForwarder", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "", type: "address" }, { internalType: "uint256", name: "", type: "uint256" }, { internalType: "uint256", name: "", type: "uint256" }, { internalType: "bytes", name: "", type: "bytes" }], name: "mint", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "", type: "address" }, { internalType: "uint256[]", name: "", type: "uint256[]" }, { internalType: "uint256[]", name: "", type: "uint256[]" }, { internalType: "bytes", name: "", type: "bytes" }], name: "mintBatch", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes[]", name: "data", type: "bytes[]" }], name: "multicall", outputs: [{ internalType: "bytes[]", name: "results", type: "bytes[]" }], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "name", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [], name: "nextTokenId", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_operator", type: "address" }, { internalType: "address", name: "", type: "address" }, { internalType: "uint256[]", name: "_ids", type: "uint256[]" }, { internalType: "uint256[]", name: "_values", type: "uint256[]" }, { internalType: "bytes", name: "_data", type: "bytes" }], name: "onERC1155BatchReceived", outputs: [{ internalType: "bytes4", name: "", type: "bytes4" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "", type: "address" }, { internalType: "address", name: "", type: "address" }, { internalType: "uint256", name: "", type: "uint256" }, { internalType: "uint256", name: "", type: "uint256" }, { internalType: "bytes", name: "", type: "bytes" }], name: "onERC1155Received", outputs: [{ internalType: "bytes4", name: "", type: "bytes4" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "", type: "address" }, { internalType: "address", name: "", type: "address" }, { internalType: "uint256", name: "", type: "uint256" }, { internalType: "bytes", name: "", type: "bytes" }], name: "onERC721Received", outputs: [{ internalType: "bytes4", name: "", type: "bytes4" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "_packId", type: "uint256" }], name: "openPack", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "owner", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "", type: "uint256" }], name: "packs", outputs: [{ internalType: "string", name: "uri", type: "string" }, { internalType: "address", name: "creator", type: "address" }, { internalType: "uint256", name: "openStart", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "pause", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "paused", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], name: "randomnessRequests", outputs: [{ internalType: "uint256", name: "packId", type: "uint256" }, { internalType: "address", name: "opener", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "requestId", type: "bytes32" }, { internalType: "uint256", name: "randomness", type: "uint256" }], name: "rawFulfillRandomness", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "renounceRole", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "revokeRole", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "", type: "uint256" }], name: "rewards", outputs: [{ internalType: "address", name: "source", type: "address" }, { internalType: "uint256", name: "rewardsPerOpen", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }, { internalType: "uint256", name: "salePrice", type: "uint256" }], name: "royaltyInfo", outputs: [{ internalType: "address", name: "receiver", type: "address" }, { internalType: "uint256", name: "royaltyAmount", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "from", type: "address" }, { internalType: "address", name: "to", type: "address" }, { internalType: "uint256[]", name: "ids", type: "uint256[]" }, { internalType: "uint256[]", name: "amounts", type: "uint256[]" }, { internalType: "bytes", name: "data", type: "bytes" }], name: "safeBatchTransferFrom", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "from", type: "address" }, { internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "id", type: "uint256" }, { internalType: "uint256", name: "amount", type: "uint256" }, { internalType: "bytes", name: "data", type: "bytes" }], name: "safeTransferFrom", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "operator", type: "address" }, { internalType: "bool", name: "approved", type: "bool" }], name: "setApprovalForAll", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "_newFees", type: "uint256" }], name: "setChainlinkFees", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "string", name: "_uri", type: "string" }], name: "setContractURI", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_royaltyRecipient", type: "address" }, { internalType: "uint256", name: "_royaltyBps", type: "uint256" }], name: "setDefaultRoyaltyInfo", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_newOwner", type: "address" }], name: "setOwner", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "_tokenId", type: "uint256" }, { internalType: "address", name: "_recipient", type: "address" }, { internalType: "uint256", name: "_bps", type: "uint256" }], name: "setRoyaltyInfoForToken", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }], name: "supportsInterface", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [], name: "symbol", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [], name: "thirdwebFee", outputs: [{ internalType: "contract ITWFee", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "id", type: "uint256" }], name: "totalSupply", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "unpause", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "_id", type: "uint256" }], name: "uri", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_to", type: "address" }, { internalType: "uint256", name: "_amount", type: "uint256" }], name: "withdrawLink", outputs: [], stateMutability: "nonpayable", type: "function" }];
});
var Bi = We((lf, $p) => {
  $p.exports = [{ inputs: [{ internalType: "address", name: "_thirdwebFee", type: "address" }], stateMutability: "nonpayable", type: "constructor" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "owner", type: "address" }, { indexed: true, internalType: "address", name: "approved", type: "address" }, { indexed: true, internalType: "uint256", name: "tokenId", type: "uint256" }], name: "Approval", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "owner", type: "address" }, { indexed: true, internalType: "address", name: "operator", type: "address" }, { indexed: false, internalType: "bool", name: "approved", type: "bool" }], name: "ApprovalForAll", type: "event" }, { anonymous: false, inputs: [{ components: [{ internalType: "uint256", name: "startTimestamp", type: "uint256" }, { internalType: "uint256", name: "maxClaimableSupply", type: "uint256" }, { internalType: "uint256", name: "supplyClaimed", type: "uint256" }, { internalType: "uint256", name: "quantityLimitPerTransaction", type: "uint256" }, { internalType: "uint256", name: "waitTimeInSecondsBetweenClaims", type: "uint256" }, { internalType: "bytes32", name: "merkleRoot", type: "bytes32" }, { internalType: "uint256", name: "pricePerToken", type: "uint256" }, { internalType: "address", name: "currency", type: "address" }], indexed: false, internalType: "struct IDropClaimCondition.ClaimCondition[]", name: "claimConditions", type: "tuple[]" }], name: "ClaimConditionsUpdated", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "newRoyaltyRecipient", type: "address" }, { indexed: false, internalType: "uint256", name: "newRoyaltyBps", type: "uint256" }], name: "DefaultRoyalty", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "uint256", name: "maxTotalSupply", type: "uint256" }], name: "MaxTotalSupplyUpdated", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "uint256", name: "count", type: "uint256" }], name: "MaxWalletClaimCountUpdated", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "uint256", name: "endTokenId", type: "uint256" }, { indexed: false, internalType: "string", name: "revealedURI", type: "string" }], name: "NFTRevealed", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "prevOwner", type: "address" }, { indexed: false, internalType: "address", name: "newOwner", type: "address" }], name: "OwnerUpdated", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "platformFeeRecipient", type: "address" }, { indexed: false, internalType: "uint256", name: "platformFeeBps", type: "uint256" }], name: "PlatformFeeInfoUpdated", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "recipient", type: "address" }], name: "PrimarySaleRecipientUpdated", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "role", type: "bytes32" }, { indexed: true, internalType: "bytes32", name: "previousAdminRole", type: "bytes32" }, { indexed: true, internalType: "bytes32", name: "newAdminRole", type: "bytes32" }], name: "RoleAdminChanged", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "role", type: "bytes32" }, { indexed: true, internalType: "address", name: "account", type: "address" }, { indexed: true, internalType: "address", name: "sender", type: "address" }], name: "RoleGranted", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "role", type: "bytes32" }, { indexed: true, internalType: "address", name: "account", type: "address" }, { indexed: true, internalType: "address", name: "sender", type: "address" }], name: "RoleRevoked", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "uint256", name: "tokenId", type: "uint256" }, { indexed: false, internalType: "address", name: "royaltyRecipient", type: "address" }, { indexed: false, internalType: "uint256", name: "royaltyBps", type: "uint256" }], name: "RoyaltyForToken", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "uint256", name: "claimConditionIndex", type: "uint256" }, { indexed: true, internalType: "address", name: "claimer", type: "address" }, { indexed: true, internalType: "address", name: "receiver", type: "address" }, { indexed: false, internalType: "uint256", name: "startTokenId", type: "uint256" }, { indexed: false, internalType: "uint256", name: "quantityClaimed", type: "uint256" }], name: "TokensClaimed", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "uint256", name: "startTokenId", type: "uint256" }, { indexed: false, internalType: "uint256", name: "endTokenId", type: "uint256" }, { indexed: false, internalType: "string", name: "baseURI", type: "string" }, { indexed: false, internalType: "bytes", name: "encryptedBaseURI", type: "bytes" }], name: "TokensLazyMinted", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "from", type: "address" }, { indexed: true, internalType: "address", name: "to", type: "address" }, { indexed: true, internalType: "uint256", name: "tokenId", type: "uint256" }], name: "Transfer", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "wallet", type: "address" }, { indexed: false, internalType: "uint256", name: "count", type: "uint256" }], name: "WalletClaimCountUpdated", type: "event" }, { inputs: [], name: "DEFAULT_ADMIN_ROLE", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "tokenId", type: "uint256" }], name: "approve", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "owner", type: "address" }], name: "balanceOf", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "", type: "uint256" }], name: "baseURIIndices", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }], name: "burn", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_receiver", type: "address" }, { internalType: "uint256", name: "_quantity", type: "uint256" }, { internalType: "address", name: "_currency", type: "address" }, { internalType: "uint256", name: "_pricePerToken", type: "uint256" }, { internalType: "bytes32[]", name: "_proofs", type: "bytes32[]" }, { internalType: "uint256", name: "_proofMaxQuantityPerTransaction", type: "uint256" }], name: "claim", outputs: [], stateMutability: "payable", type: "function" }, { inputs: [], name: "claimCondition", outputs: [{ internalType: "uint256", name: "currentStartId", type: "uint256" }, { internalType: "uint256", name: "count", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "contractType", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "pure", type: "function" }, { inputs: [], name: "contractURI", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [], name: "contractVersion", outputs: [{ internalType: "uint8", name: "", type: "uint8" }], stateMutability: "pure", type: "function" }, { inputs: [{ internalType: "bytes", name: "data", type: "bytes" }, { internalType: "bytes", name: "key", type: "bytes" }], name: "encryptDecrypt", outputs: [{ internalType: "bytes", name: "result", type: "bytes" }], stateMutability: "pure", type: "function" }, { inputs: [{ internalType: "uint256", name: "", type: "uint256" }], name: "encryptedBaseURI", outputs: [{ internalType: "bytes", name: "", type: "bytes" }], stateMutability: "view", type: "function" }, { inputs: [], name: "getActiveClaimConditionId", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }], name: "getApproved", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [], name: "getBaseURICount", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "_conditionId", type: "uint256" }], name: "getClaimConditionById", outputs: [{ components: [{ internalType: "uint256", name: "startTimestamp", type: "uint256" }, { internalType: "uint256", name: "maxClaimableSupply", type: "uint256" }, { internalType: "uint256", name: "supplyClaimed", type: "uint256" }, { internalType: "uint256", name: "quantityLimitPerTransaction", type: "uint256" }, { internalType: "uint256", name: "waitTimeInSecondsBetweenClaims", type: "uint256" }, { internalType: "bytes32", name: "merkleRoot", type: "bytes32" }, { internalType: "uint256", name: "pricePerToken", type: "uint256" }, { internalType: "address", name: "currency", type: "address" }], internalType: "struct IDropClaimCondition.ClaimCondition", name: "condition", type: "tuple" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "_conditionId", type: "uint256" }, { internalType: "address", name: "_claimer", type: "address" }], name: "getClaimTimestamp", outputs: [{ internalType: "uint256", name: "lastClaimTimestamp", type: "uint256" }, { internalType: "uint256", name: "nextValidClaimTimestamp", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "getDefaultRoyaltyInfo", outputs: [{ internalType: "address", name: "", type: "address" }, { internalType: "uint16", name: "", type: "uint16" }], stateMutability: "view", type: "function" }, { inputs: [], name: "getPlatformFeeInfo", outputs: [{ internalType: "address", name: "", type: "address" }, { internalType: "uint16", name: "", type: "uint16" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }], name: "getRoleAdmin", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "uint256", name: "index", type: "uint256" }], name: "getRoleMember", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }], name: "getRoleMemberCount", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "_tokenId", type: "uint256" }], name: "getRoyaltyInfoForToken", outputs: [{ internalType: "address", name: "", type: "address" }, { internalType: "uint16", name: "", type: "uint16" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "grantRole", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "hasRole", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_defaultAdmin", type: "address" }, { internalType: "string", name: "_name", type: "string" }, { internalType: "string", name: "_symbol", type: "string" }, { internalType: "string", name: "_contractURI", type: "string" }, { internalType: "address[]", name: "_trustedForwarders", type: "address[]" }, { internalType: "address", name: "_saleRecipient", type: "address" }, { internalType: "address", name: "_royaltyRecipient", type: "address" }, { internalType: "uint128", name: "_royaltyBps", type: "uint128" }, { internalType: "uint128", name: "_platformFeeBps", type: "uint128" }, { internalType: "address", name: "_platformFeeRecipient", type: "address" }], name: "initialize", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "owner", type: "address" }, { internalType: "address", name: "operator", type: "address" }], name: "isApprovedForAll", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "forwarder", type: "address" }], name: "isTrustedForwarder", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "_amount", type: "uint256" }, { internalType: "string", name: "_baseURIForTokens", type: "string" }, { internalType: "bytes", name: "_encryptedBaseURI", type: "bytes" }], name: "lazyMint", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "maxTotalSupply", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "maxWalletClaimCount", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes[]", name: "data", type: "bytes[]" }], name: "multicall", outputs: [{ internalType: "bytes[]", name: "results", type: "bytes[]" }], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "name", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [], name: "nextTokenIdToClaim", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "nextTokenIdToMint", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "owner", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }], name: "ownerOf", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [], name: "primarySaleRecipient", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "renounceRole", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "index", type: "uint256" }, { internalType: "bytes", name: "_key", type: "bytes" }], name: "reveal", outputs: [{ internalType: "string", name: "revealedURI", type: "string" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "revokeRole", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }, { internalType: "uint256", name: "salePrice", type: "uint256" }], name: "royaltyInfo", outputs: [{ internalType: "address", name: "receiver", type: "address" }, { internalType: "uint256", name: "royaltyAmount", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "from", type: "address" }, { internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "tokenId", type: "uint256" }], name: "safeTransferFrom", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "from", type: "address" }, { internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "tokenId", type: "uint256" }, { internalType: "bytes", name: "_data", type: "bytes" }], name: "safeTransferFrom", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "operator", type: "address" }, { internalType: "bool", name: "approved", type: "bool" }], name: "setApprovalForAll", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ components: [{ internalType: "uint256", name: "startTimestamp", type: "uint256" }, { internalType: "uint256", name: "maxClaimableSupply", type: "uint256" }, { internalType: "uint256", name: "supplyClaimed", type: "uint256" }, { internalType: "uint256", name: "quantityLimitPerTransaction", type: "uint256" }, { internalType: "uint256", name: "waitTimeInSecondsBetweenClaims", type: "uint256" }, { internalType: "bytes32", name: "merkleRoot", type: "bytes32" }, { internalType: "uint256", name: "pricePerToken", type: "uint256" }, { internalType: "address", name: "currency", type: "address" }], internalType: "struct IDropClaimCondition.ClaimCondition[]", name: "_phases", type: "tuple[]" }, { internalType: "bool", name: "_resetClaimEligibility", type: "bool" }], name: "setClaimConditions", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "string", name: "_uri", type: "string" }], name: "setContractURI", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_royaltyRecipient", type: "address" }, { internalType: "uint256", name: "_royaltyBps", type: "uint256" }], name: "setDefaultRoyaltyInfo", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "_maxTotalSupply", type: "uint256" }], name: "setMaxTotalSupply", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "_count", type: "uint256" }], name: "setMaxWalletClaimCount", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_newOwner", type: "address" }], name: "setOwner", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_platformFeeRecipient", type: "address" }, { internalType: "uint256", name: "_platformFeeBps", type: "uint256" }], name: "setPlatformFeeInfo", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_saleRecipient", type: "address" }], name: "setPrimarySaleRecipient", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "_tokenId", type: "uint256" }, { internalType: "address", name: "_recipient", type: "address" }, { internalType: "uint256", name: "_bps", type: "uint256" }], name: "setRoyaltyInfoForToken", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_claimer", type: "address" }, { internalType: "uint256", name: "_count", type: "uint256" }], name: "setWalletClaimCount", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }], name: "supportsInterface", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [], name: "symbol", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "index", type: "uint256" }], name: "tokenByIndex", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "owner", type: "address" }, { internalType: "uint256", name: "index", type: "uint256" }], name: "tokenOfOwnerByIndex", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "_tokenId", type: "uint256" }], name: "tokenURI", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [], name: "totalSupply", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "from", type: "address" }, { internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "tokenId", type: "uint256" }], name: "transferFrom", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "_conditionId", type: "uint256" }, { internalType: "address", name: "_claimer", type: "address" }, { internalType: "uint256", name: "_quantity", type: "uint256" }, { internalType: "address", name: "_currency", type: "address" }, { internalType: "uint256", name: "_pricePerToken", type: "uint256" }, { internalType: "bool", name: "verifyMaxQuantityPerTransaction", type: "bool" }], name: "verifyClaim", outputs: [], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "_conditionId", type: "uint256" }, { internalType: "address", name: "_claimer", type: "address" }, { internalType: "uint256", name: "_quantity", type: "uint256" }, { internalType: "bytes32[]", name: "_proofs", type: "bytes32[]" }, { internalType: "uint256", name: "_proofMaxQuantityPerTransaction", type: "uint256" }], name: "verifyClaimMerkleProof", outputs: [{ internalType: "bool", name: "validMerkleProof", type: "bool" }, { internalType: "uint256", name: "merkleProofIndex", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "", type: "address" }], name: "walletClaimCount", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }];
});
var $e = p2(() => typeof window < "u", "isBrowser");
globalThis.File || (globalThis.File = v0("@web-std/file").File);
var xa = 1e4;
var Ki = $e() ? [mod.instanceof(File), mod.string()] : [mod.instanceof(Buffer), mod.string()];
var mt = mod.union(Ki);
var x0 = mod.union([mod.array(mod.number()), mod.string()]);
var x = mod.union([mod.string(), mod.number(), mod.bigint(), mod.custom((r6) => BigNumber.isBigNumber(r6))]).transform((r6) => BigNumber.from(r6));
var we = x.transform((r6) => r6.toString());
var Ge = mod.number().max(xa, "Cannot exeed 100%").min(0, "Cannot be below 0%");
var M0 = mod.number().max(100, "Cannot exeed 100%").min(0, "Cannot be below 0%");
var Ji = mod.union([mod.string(), mod.number(), mod.boolean(), mod.null()]);
var De = mod.lazy(() => mod.union([Ji, mod.array(De), mod.record(De)]));
var Ma = mod.record(De);
var R0 = mod.union([mod.string().regex(/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/, "Invalid hex color").transform((r6) => r6.replace("#", "")), mod.string().length(0)]);
var oe = mod.string().refine((r6) => utils_exports.isAddress(r6), (r6) => ({ message: `${r6} is not a valid address` }));
var Q = mod.union([mod.string().regex(/^([0-9]+\.?[0-9]*|\.[0-9]+)$/, "Invalid price"), mod.number().min(0, "Price cannot be negative")]).transform((r6) => typeof r6 == "number" ? r6.toString() : r6);
var A0 = mod.date().transform((r6) => BigNumber.from(Math.floor(r6.getTime() / 1e3)));
var Dn = A0.default(new Date(0));
var _0 = A0.default(new Date(Date.now() + 1e3 * 60 * 60 * 24 * 365 * 10));
var T;
(function(r6) {
  r6[r6.Mainnet = 1] = "Mainnet", r6[r6.Ropsten = 3] = "Ropsten", r6[r6.Rinkeby = 4] = "Rinkeby", r6[r6.Goerli = 5] = "Goerli", r6[r6.Kovan = 42] = "Kovan", r6[r6.BSC = 56] = "BSC", r6[r6.xDai = 100] = "xDai", r6[r6.Polygon = 137] = "Polygon", r6[r6.Moonriver = 1285] = "Moonriver", r6[r6.Mumbai = 80001] = "Mumbai", r6[r6.Harmony = 16666e5] = "Harmony", r6[r6.Localhost = 1337] = "Localhost", r6[r6.Hardhat = 31337] = "Hardhat", r6[r6.Fantom = 250] = "Fantom", r6[r6.FantomTestnet = 4002] = "FantomTestnet", r6[r6.Avalanche = 43114] = "Avalanche", r6[r6.AvalancheFujiTestnet = 43113] = "AvalancheFujiTestnet";
})(T || (T = {}));
var S0 = [T.Mainnet, T.Rinkeby, T.Goerli, T.Polygon, T.Mumbai, T.Fantom, T.FantomTestnet, T.Avalanche, T.AvalancheFujiTestnet];
var Re = "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee";
var Xi = { [T.Mainnet]: { name: "Ether", symbol: "ETH", decimals: 18, wrapped: { address: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", name: "Wrapped Ether", symbol: "WETH" } }, [T.Rinkeby]: { name: "Ether", symbol: "ETH", decimals: 18, wrapped: { address: "0xc778417E063141139Fce010982780140Aa0cD5Ab", name: "Wrapped Ether", symbol: "WETH" } }, [T.Goerli]: { name: "Ether", symbol: "ETH", decimals: 18, wrapped: { address: "0x0bb7509324ce409f7bbc4b701f932eaca9736ab7", name: "Wrapped Ether", symbol: "WETH" } }, [T.Polygon]: { name: "Matic", symbol: "MATIC", decimals: 18, wrapped: { address: "0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270", name: "Wrapped Matic", symbol: "WMATIC" } }, [T.Mumbai]: { name: "Matic", symbol: "MATIC", decimals: 18, wrapped: { address: "0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889", name: "Wrapped Matic", symbol: "WMATIC" } }, [T.Avalanche]: { name: "Avalanche", symbol: "AVAX", decimals: 18, wrapped: { address: "0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7", name: "Wrapped AVAX", symbol: "WAVAX" } }, [T.AvalancheFujiTestnet]: { name: "Avalanche", symbol: "AVAX", decimals: 18, wrapped: { address: "0xd00ae08403B9bbb9124bB305C09058E32C39A48c", name: "Wrapped AVAX", symbol: "WAVAX" } }, [T.Fantom]: { name: "Fantom", symbol: "FTM", decimals: 18, wrapped: { address: "0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83", name: "Wrapped Fantom", symbol: "WFTM" } }, [T.FantomTestnet]: { name: "Fantom", symbol: "FTM", decimals: 18, wrapped: { address: "0xf1277d1Ed8AD466beddF92ef448A132661956621", name: "Wrapped Fantom", symbol: "WFTM" } }, [T.Hardhat]: { name: "Ether", symbol: "ETH", decimals: 18, wrapped: { address: "0x5FbDB2315678afecb367f032d93F642f64180aa3", name: "Wrapped Ether", symbol: "WETH" } } };
function I0(r6) {
  return Xi[r6];
}
p2(I0, "getNativeTokenByChainId");
var es = mod.object({ name: mod.string(), symbol: mod.string(), decimals: mod.number() });
var k0 = es.extend({ value: x, displayValue: mod.string() });
var Ce = mod.object({ merkle: mod.record(mod.string()).default({}) });
var Ra = mod.object({ address: oe, maxClaimable: Q.default(0) });
var ft = mod.union([mod.array(mod.string()).transform((r6) => r6.map((e6) => Ra.parse({ address: e6 }))), mod.array(Ra)]);
var It = mod.object({ merkleRoot: mod.string(), claims: mod.array(Ra.extend({ proof: mod.array(mod.string()) })) });
var c6 = mod.object({ merkleRoot: mod.string(), snapshotUri: mod.string(), snapshot: It });
var Un = mod.union([Q, mod.literal("unlimited")]).default("unlimited");
var kt = mod.object({ startTime: Dn, currencyAddress: mod.string().default(Re), price: Q.default(0), maxQuantity: Un, quantityLimitPerTransaction: Un, waitInSeconds: we.default(0), merkleRootHash: x0.default(utils_exports.hexZeroPad([0], 32)), snapshot: mod.optional(ft) });
var E0 = mod.array(kt);
var w6 = kt.partial();
var Aa = kt.extend({ availableSupply: Un, currentMintSupply: Un, currencyMetadata: k0.default({ value: BigNumber.from("0"), displayValue: "0", symbol: "", decimals: 18, name: "" }), price: x, waitInSeconds: x, startTime: x.transform((r6) => new Date(r6.toNumber() * 1e3)) });
var _a = mod.union([mod.array(Ma), Ma]).optional();
var W0 = mod.object({ name: mod.string().optional(), description: mod.string().nullable().optional(), image: mt.nullable().optional(), external_url: mt.nullable().optional() }).catchall(mod.lazy(() => De));
var as = W0.extend({ id: x, uri: mod.string(), image: mod.string().nullable().optional(), external_url: mod.string().nullable().optional() });
var le = W0.extend({ animation_url: mt.optional(), background_color: R0.optional(), properties: _a, attributes: _a });
var Et = mod.union([le, mod.string()]);
var Nn = as.extend({ animation_url: mod.string().nullable().optional() });
function F0(r6) {
  if (r6 === void 0) {
    let e6 = Buffer.alloc(16);
    return v4_default({}, e6), utils_exports.hexlify(utils_exports.toUtf8Bytes(e6.toString("hex")));
  } else
    return utils_exports.hexlify(r6);
}
p2(F0, "resolveOrGenerateId");
var B0 = mod.object({ to: mod.string().default(lib_exports7.AddressZero), price: Q.default(0), currencyAddress: mod.string().default(Re), mintStartTime: Dn, mintEndTime: _0, uid: mod.string().optional().transform((r6) => F0(r6)), primarySaleRecipient: mod.string().default(lib_exports7.AddressZero) });
var ka = B0.extend({ quantity: Q });
var O0 = ka.extend({ mintStartTime: x, mintEndTime: x });
var Ln = B0.extend({ metadata: Et, royaltyRecipient: mod.string().default(lib_exports7.AddressZero), royaltyBps: Ge.default(0) });
var Ea = Ln.extend({ uri: mod.string(), royaltyBps: x, mintStartTime: x, mintEndTime: x });
var D0 = Ln.extend({ metadata: Et.default(""), tokenId: we.default(ethers_exports.constants.MaxUint256), quantity: we });
var U0 = Ea.extend({ tokenId: x, quantity: x });
var N0 = [{ name: "to", type: "address" }, { name: "primarySaleRecipient", type: "address" }, { name: "quantity", type: "uint256" }, { name: "price", type: "uint256" }, { name: "currency", type: "address" }, { name: "validityStartTimestamp", type: "uint128" }, { name: "validityEndTimestamp", type: "uint128" }, { name: "uid", type: "bytes32" }];
var L0 = [{ name: "to", type: "address" }, { name: "royaltyRecipient", type: "address" }, { name: "royaltyBps", type: "uint256" }, { name: "primarySaleRecipient", type: "address" }, { name: "uri", type: "string" }, { name: "price", type: "uint256" }, { name: "currency", type: "address" }, { name: "validityStartTimestamp", type: "uint128" }, { name: "validityEndTimestamp", type: "uint128" }, { name: "uid", type: "bytes32" }];
var V0 = [{ name: "to", type: "address" }, { name: "royaltyRecipient", type: "address" }, { name: "royaltyBps", type: "uint256" }, { name: "primarySaleRecipient", type: "address" }, { name: "tokenId", type: "uint256" }, { name: "uri", type: "string" }, { name: "quantity", type: "uint256" }, { name: "pricePerToken", type: "uint256" }, { name: "currency", type: "address" }, { name: "validityStartTimestamp", type: "uint128" }, { name: "validityEndTimestamp", type: "uint128" }, { name: "uid", type: "bytes32" }];
var I = mod.object({ name: mod.string(), description: mod.string().optional(), image: mt.optional(), external_link: mod.string().url().optional() });
var O = I.extend({ image: mod.string().optional() }).catchall(mod.lazy(() => De));
var N2 = mod.object({ seller_fee_basis_points: Ge.default(0), fee_recipient: oe.default(lib_exports7.AddressZero) });
var ue = mod.object({ primary_sale_recipient: oe });
var L = mod.object({ platform_fee_basis_points: Ge.default(0), platform_fee_recipient: oe.default(lib_exports7.AddressZero) });
var D = mod.object({ trusted_forwarders: mod.array(oe).default([]) });
var k2 = mod.object({ symbol: mod.string().optional().default("") });
var Y6 = mod.object({ toAddress: oe, amount: Q });
var Pa = mod.object({ supply: x, metadata: Nn });
var e1 = Pa.extend({ owner: mod.string(), quantityOwned: x });
var t1 = mod.object({ supply: we, metadata: le });
var n1 = mod.object({ supply: we, metadata: Et });
var Ae = class extends Error {
  constructor(e6) {
    super(e6 ? `Object with id ${e6} NOT FOUND` : "NOT_FOUND");
  }
};
p2(Ae, "NotFoundError");
var Wa = class extends Error {
  constructor(e6) {
    super(e6 ? `'${e6}' is an invalid address` : "Invalid address passed");
  }
};
p2(Wa, "InvalidAddressError");
var Ft = class extends Error {
  constructor(e6, t6) {
    super(`MISSING ROLE: ${e6} does not have the '${t6}' role`);
  }
};
p2(Ft, "MissingRoleError");
var Fa = class extends Error {
  constructor(e6 = "The asset you're trying to use could not be found.") {
    super(`message: ${e6}`);
  }
};
p2(Fa, "AssetNotFoundError");
var Bt = class extends Error {
  constructor(e6) {
    super(`UPLOAD_FAILED: ${e6}`);
  }
};
p2(Bt, "UploadError");
var Ba = class extends Error {
  constructor() {
    super("File name is required when object is not a `File` type object.");
  }
};
p2(Ba, "FileNameMissingError");
var Ot = class extends Error {
  constructor(e6) {
    super(`DUPLICATE_FILE_NAME_ERROR: File name ${e6} was passed for more than one file.`);
  }
};
p2(Ot, "DuplicateFileNameError");
var Oa = class extends Error {
  constructor(e6, t6, n4) {
    super(`BALANCE ERROR: you do not have enough balance on contract ${e6} to use ${t6} tokens. You have ${n4} tokens available.`);
  }
};
p2(Oa, "NotEnoughTokensError");
var Da = class extends Error {
  constructor() {
    super("LIST ERROR: you should be the owner of the token to list it.");
  }
};
p2(Da, "MissingOwnerRoleError");
var Ua = class extends Error {
  constructor(e6) {
    super(`BUY ERROR: You cannot buy more than ${e6} tokens`);
  }
};
p2(Ua, "QuantityAboveLimitError");
var Dt = class extends Error {
  constructor(e6, t6) {
    super(`FETCH_FAILED: ${e6}`), this.innerError = t6;
  }
};
p2(Dt, "FetchError");
var Ut = class extends Error {
  constructor(e6) {
    super(`DUPLICATE_LEAFS${e6 ? ` : ${e6}` : ""}`);
  }
};
p2(Ut, "DuplicateLeafsError");
var Nt = class extends Error {
  constructor(e6) {
    super(`Auction already started with existing bid${e6 ? `, id: ${e6}` : ""}`);
  }
};
p2(Nt, "AuctionAlreadyStartedError");
var Na = class extends Error {
  constructor(e6) {
    super(`FUNCTION DEPRECATED. ${e6 ? `Use ${e6} instead` : ""}`);
  }
};
p2(Na, "FunctionDeprecatedError");
var Be = class extends Error {
  constructor(e6, t6) {
    super(`Could not find listing.${e6 ? ` marketplace address: ${e6}` : ""}${t6 ? ` listing id: ${t6}` : ""}`);
  }
};
p2(Be, "ListingNotFoundError");
var at = class extends Error {
  constructor(e6, t6, n4, a5) {
    super(`Incorrect listing type. Are you sure you're using the right method?.${e6 ? ` marketplace address: ${e6}` : ""}${t6 ? ` listing id: ${t6}` : ""}${a5 ? ` expected type: ${a5}` : ""}${n4 ? ` actual type: ${n4}` : ""}`);
  }
};
p2(at, "WrongListingTypeError");
var La = class extends Error {
  constructor(e6) {
    super(`Failed to transfer asset, transfer is restricted.${e6 ? ` Address : ${e6}` : ""}`);
  }
};
p2(La, "RestrictedTransferError");
var Va = class extends Error {
  constructor(e6, t6, n4 = "Failed to execute transaction") {
    super(`${n4}, admin role is missing${e6 ? ` on address: ${e6}` : ""}${t6 ? ` on contract: ${t6}` : ""}`);
  }
};
p2(Va, "AdminRoleMissingError");
var Lt = class extends Error {
  constructor(e6, t6) {
    super(`Auction has not ended yet${e6 ? `, id: ${e6}` : ""}${t6 ? `, end time: ${t6.toString()}` : ""}`);
  }
};
p2(Lt, "AuctionHasNotEndedError");
var qn = class extends Error {
  constructor(e6, t6, n4, a5, i6, s6, o6) {
    let y5 = `Contract transaction failed

`;
    y5 += `Message: ${e6}`, y5 += `

| Transaction info |
`, y5 += Pt("from", t6), y5 += Pt("to", n4), y5 += Pt("data", a5), y5 += Pt("chain", `${i6.name} (${i6.chainId})`);
    try {
      let d6 = new URL(s6);
      y5 += Pt("RPC", d6.hostname);
    } catch {
    }
    y5 += `

`, y5 += "Need help with this error? Join our community: https://discord.gg/thirdweb", y5 += `



`, y5 += "| Raw error |", y5 += `

`, y5 += o6, super(y5), this.reason = e6, this.from = t6, this.to = n4, this.data = a5, this.chain = i6, this.rpcUrl = s6;
  }
};
p2(qn, "TransactionError");
async function $0(r6, e6, t6, n4) {
  let a5;
  if (r6.data)
    a5 = JSON.stringify(r6.data);
  else if (r6 instanceof Error)
    a5 = r6.message;
  else
    return r6;
  let i6 = Wt(/.*?"message[^a-zA-Z0-9]*([^"\\]*).*?/, a5), s6 = Wt(/.*?"data[^a-zA-Z0-9]*([^"\\]*).*?/, a5), o6 = Wt(/.*?"url[^a-zA-Z0-9]*([^"\\]*).*?/, a5), y5 = Wt(/.*?"from[^a-zA-Z0-9]*([^"\\]*).*?/, a5), d6 = Wt(/.*?"to[^a-zA-Z0-9]*([^"\\]*).*?/, a5);
  return d6 === "" && (d6 = n4), y5 === "" && (y5 = t6), new qn(i6, y5, d6, s6, e6, o6, a5);
}
p2($0, "convertToTWError");
function Pt(r6, e6) {
  if (e6 === "")
    return e6;
  let t6 = Array(10 - r6.length).fill(" ").join("");
  return `
${r6}:${t6}${e6}`;
}
p2(Pt, "withSpaces");
function Wt(r6, e6) {
  let t6 = e6.match(r6) || [], n4 = "";
  return (t6 == null ? void 0 : t6.length) > 0 && (n4 += t6[1]), n4;
}
p2(Wt, "parseMessageParts");
function Tt(r6, e6) {
  return r6 && r6.toString().includes(e6) || r6.message && r6.message.toString().includes(e6) || r6.error && r6.error.toString().includes(e6);
}
p2(Tt, "includesErrorMessage");
var G0 = "https://gateway.ipfscdn.io/ipfs/";
var z0 = ["https://gateway.ipfscdn.io/ipfs/", "https://gateway2.ipfscdn.io/ipfs/"];
var H0 = "https://upload.nftlabs.co";
var Z0 = "https://api.pinata.cloud/pinning/pinFileToIPFS";
function qa(r6, e6) {
  let t6 = Object.keys(r6);
  for (let n4 in t6) {
    let a5 = r6[t6[n4]], i6 = a5 instanceof File || a5 instanceof Buffer;
    if (typeof a5 == "object" && !i6) {
      qa(a5, e6);
      continue;
    }
    !i6 || (r6[t6[n4]] = `ipfs://${e6.splice(0, 1)[0]}`);
  }
  return r6;
}
p2(qa, "replaceFilePropertiesWithHashes");
function $n(r6, e6, t6) {
  if (r6 === null || !r6)
    return {};
  let n4 = Object.keys(r6);
  for (let a5 in n4) {
    let i6 = r6[n4[a5]];
    r6[n4[a5]] = Gn(i6, e6, t6), Array.isArray(i6) && (r6[n4[a5]] = i6.map((s6) => typeof s6 == "object" ? $n(s6, e6, t6) : Gn(s6, e6, t6))), typeof i6 == "object" && $n(i6, e6, t6);
  }
  return r6;
}
p2($n, "replaceHashWithGatewayUrl");
function Gn(r6, e6, t6) {
  return typeof r6 == "string" && r6 && r6.toLowerCase().includes(e6) ? r6.replace(e6, t6) : r6;
}
p2(Gn, "resolveGatewayUrl");
globalThis.FormData || (globalThis.FormData = v0("form-data"));
var Vt = class {
  constructor(e6 = G0) {
    __publicField(this, "failedUrls", []);
    this.gatewayUrl = `${e6.replace(/\/$/, "")}/`;
  }
  getNextPublicGateway() {
    let e6 = z0.filter((t6) => !this.failedUrls.includes(t6)).filter((t6) => t6 !== this.gatewayUrl);
    if (e6.length > 0)
      return e6[0];
    this.failedUrls = [];
  }
  async upload(e6, t6, n4) {
    return `${await this.uploadBatch([e6], 0, t6, n4)}0`;
  }
  async uploadBatch(e6, t6 = 0, n4, a5) {
    let { cid: i6 } = await this.uploadBatchWithCid(e6, t6, n4, a5);
    return `ipfs://${i6}/`;
  }
  async getUploadToken(e6) {
    let t6 = { "X-App-Name": `CONSOLE-TS-SDK-${e6}` }, n4 = await fetch(`${H0}/grant`, { method: "GET", headers: t6 });
    if (!n4.ok)
      throw new Dt("Failed to get upload token");
    return await n4.text();
  }
  async get(e6) {
    let n4 = await (await this._get(e6)).json();
    return $n(n4, "ipfs://", this.gatewayUrl);
  }
  async getRaw(e6) {
    return await (await this._get(e6)).text();
  }
  async uploadMetadata(e6, t6, n4) {
    let { metadataUris: a5 } = await this.uploadMetadataBatch([e6], 0, t6, n4);
    return a5[0];
  }
  async uploadMetadataBatch(e6, t6, n4, a5) {
    let i6 = (await this.batchUploadProperties(e6)).map((u7) => JSON.stringify(u7)), { cid: s6, fileNames: o6 } = await this.uploadBatchWithCid(i6, t6, n4, a5), y5 = `ipfs://${s6}/`, d6 = o6.map((u7) => `${y5}${u7}`);
    return { baseUri: y5, metadataUris: d6 };
  }
  async _get(e6) {
    let t6 = e6;
    e6 && (t6 = Gn(e6, "ipfs://", this.gatewayUrl));
    let n4 = await fetch(t6);
    if (!n4.ok && n4.status !== 404) {
      let a5 = this.getNextPublicGateway();
      if (a5)
        return this.failedUrls.push(this.gatewayUrl), this.gatewayUrl = a5, this._get(e6);
      throw new Error(`Error fetching ${t6} - Status code ${n4.status}`);
    }
    return n4;
  }
  async batchUploadProperties(e6) {
    let t6 = e6.flatMap((o6) => this.buildFilePropertiesMap(o6, []));
    if (t6.length === 0)
      return e6;
    let { cid: n4, fileNames: a5 } = await this.uploadBatchWithCid(t6), i6 = [];
    for (let o6 of a5)
      i6.push(`${n4}/${o6}`);
    return await qa(e6, i6);
  }
  buildFilePropertiesMap(e6, t6 = []) {
    if (Array.isArray(e6))
      e6.forEach((n4) => {
        this.buildFilePropertiesMap(n4, t6);
      });
    else if (e6) {
      let n4 = Object.values(e6);
      for (let a5 of n4)
        a5 instanceof File || a5 instanceof Buffer ? t6.push(a5) : typeof a5 == "object" && this.buildFilePropertiesMap(a5, t6);
    }
    return t6;
  }
  async uploadBatchWithCid(e6, t6 = 0, n4, a5) {
    let i6 = await this.getUploadToken(n4 || ""), s6 = { name: `CONSOLE-TS-SDK-${n4}`, keyvalues: { sdk: "typescript", contractAddress: n4, signerAddress: a5 } }, o6 = new FormData(), y5 = [];
    e6.forEach((m6, b4) => {
      let h6 = "", v9 = m6;
      if (m6 instanceof File) {
        let ce2 = "";
        if (m6.name) {
          let ge2 = m6.name.lastIndexOf(".");
          ge2 > -1 && (ce2 = m6.name.substring(ge2));
        }
        h6 = `${b4 + t6}${ce2}`;
      } else
        m6 instanceof Buffer || typeof m6 == "string" ? h6 = `${b4 + t6}` : m6 && m6.name && (m6 == null ? void 0 : m6.data) ? (v9 = m6 == null ? void 0 : m6.data, h6 = `${m6.name}`) : h6 = `${b4 + t6}`;
      let F5 = `files/${h6}`;
      if (y5.indexOf(h6) > -1)
        throw new Ot(h6);
      y5.push(h6), typeof window > "u" ? o6.append("file", v9, { filepath: F5 }) : o6.append("file", new Blob([v9]), F5);
    }), o6.append("pinataMetadata", JSON.stringify(s6));
    let d6 = await fetch(Z0, { method: "POST", headers: { Authorization: `Bearer ${i6}` }, body: o6 }), u7 = await d6.json();
    if (!d6.ok)
      throw console.log(u7), new Bt("Failed to upload files to IPFS");
    return { cid: u7.IpfsHash, fileNames: y5 };
  }
};
p2(Vt, "IpfsStorage");
var P = class {
  constructor(e6) {
    this.contractWrapper = e6;
  }
  encode(e6, t6) {
    return this.contractWrapper.readContract.interface.encodeFunctionData(e6, t6);
  }
  decode(e6, t6) {
    return this.contractWrapper.readContract.interface.decodeFunctionData(e6, t6);
  }
};
p2(P, "ContractEncoder");
var M = class {
  constructor(e6, t6, n4) {
    this.contractWrapper = e6, this.schema = t6, this.storage = n4;
  }
  parseOutputMetadata(e6) {
    return this.schema.output.parse(e6);
  }
  parseInputMetadata(e6) {
    return this.schema.input.parse(e6);
  }
  async get() {
    let e6 = await this.contractWrapper.readContract.contractURI(), t6 = await this.storage.get(e6);
    return this.parseOutputMetadata(t6);
  }
  async set(e6) {
    let t6 = await this._parseAndUploadMetadata(e6), n4 = this.contractWrapper;
    if (this.canUpdateContractUri(n4))
      return { receipt: await n4.sendTransaction("setContractURI", [t6]), data: this.get };
    throw new Error("Contract does not support updating contractURI");
  }
  async update(e6) {
    return await this.set(w(w({}, await this.get()), e6));
  }
  async _parseAndUploadMetadata(e6) {
    let t6 = this.parseInputMetadata(e6);
    return this.storage.uploadMetadata(t6);
  }
  canUpdateContractUri(e6) {
    return "setContractURI" in e6.readContract.functions;
  }
};
p2(M, "ContractMetadata");
var Y0 = { admin: "", transfer: "TRANSFER_ROLE", minter: "MINTER_ROLE", pauser: "PAUSER_ROLE", editor: "EDITOR_ROLE", lister: "LISTER_ROLE", asset: "ASSET_ROLE" };
var Q0 = Object.keys(Y0);
function E(r6) {
  return r6 === "admin" ? ethers_exports.utils.hexZeroPad([0], 32) : ethers_exports.utils.id(Y0[r6]);
}
p2(E, "getRoleHash");
var K0 = [{ anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "recipient", type: "address" }], name: "PrimarySaleRecipientUpdated", type: "event" }, { inputs: [], name: "primarySaleRecipient", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_saleRecipient", type: "address" }], name: "setPrimarySaleRecipient", outputs: [], stateMutability: "nonpayable", type: "function" }];
var J0 = [{ anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "platformFeeRecipient", type: "address" }, { indexed: false, internalType: "uint256", name: "platformFeeBps", type: "uint256" }], name: "PlatformFeeInfoUpdated", type: "event" }, { inputs: [], name: "getPlatformFeeInfo", outputs: [{ internalType: "address", name: "", type: "address" }, { internalType: "uint16", name: "", type: "uint16" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_platformFeeRecipient", type: "address" }, { internalType: "uint256", name: "_platformFeeBps", type: "uint256" }], name: "setPlatformFeeInfo", outputs: [], stateMutability: "nonpayable", type: "function" }];
var X0 = [{ anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "newRoyaltyRecipient", type: "address" }, { indexed: false, internalType: "uint256", name: "newRoyaltyBps", type: "uint256" }], name: "DefaultRoyalty", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "uint256", name: "tokenId", type: "uint256" }, { indexed: false, internalType: "address", name: "royaltyRecipient", type: "address" }, { indexed: false, internalType: "uint256", name: "royaltyBps", type: "uint256" }], name: "RoyaltyForToken", type: "event" }, { inputs: [], name: "getDefaultRoyaltyInfo", outputs: [{ internalType: "address", name: "", type: "address" }, { internalType: "uint16", name: "", type: "uint16" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }], name: "getRoyaltyInfoForToken", outputs: [{ internalType: "address", name: "", type: "address" }, { internalType: "uint16", name: "", type: "uint16" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }, { internalType: "uint256", name: "salePrice", type: "uint256" }], name: "royaltyInfo", outputs: [{ internalType: "address", name: "receiver", type: "address" }, { internalType: "uint256", name: "royaltyAmount", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_royaltyRecipient", type: "address" }, { internalType: "uint256", name: "_royaltyBps", type: "uint256" }], name: "setDefaultRoyaltyInfo", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }, { internalType: "address", name: "recipient", type: "address" }, { internalType: "uint256", name: "bps", type: "uint256" }], name: "setRoyaltyInfoForToken", outputs: [], stateMutability: "nonpayable", type: "function" }];
var er = [{ anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "role", type: "bytes32" }, { indexed: true, internalType: "bytes32", name: "previousAdminRole", type: "bytes32" }, { indexed: true, internalType: "bytes32", name: "newAdminRole", type: "bytes32" }], name: "RoleAdminChanged", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "role", type: "bytes32" }, { indexed: true, internalType: "address", name: "account", type: "address" }, { indexed: true, internalType: "address", name: "sender", type: "address" }], name: "RoleGranted", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "role", type: "bytes32" }, { indexed: true, internalType: "address", name: "account", type: "address" }, { indexed: true, internalType: "address", name: "sender", type: "address" }], name: "RoleRevoked", type: "event" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }], name: "getRoleAdmin", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "uint256", name: "index", type: "uint256" }], name: "getRoleMember", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }], name: "getRoleMemberCount", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "grantRole", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "hasRole", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "renounceRole", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "revokeRole", outputs: [], stateMutability: "nonpayable", type: "function" }];
var qt = { name: "Royalty", namespace: "sales", docLinks: { sdk: "sdk.contractroyalty", contracts: "IThirdwebPrimarySale" }, abis: [X0], features: {} };
var $t = { name: "PrimarySale", namespace: "sales", docLinks: { sdk: "sdk.contractprimarysale", contracts: "IThirdwebPrimarySale" }, abis: [K0], features: {} };
var Gt = { name: "PlatformFee", namespace: "platformFee", docLinks: { sdk: "sdk.platformfee", contracts: "IThirdwebPlatformFee" }, abis: [J0], features: {} };
var zt = { name: "Permissions", namespace: "roles", docLinks: { sdk: "sdk.contractroles", contracts: "IPermissionsEnumerable" }, abis: [er], features: {} };
var V = class {
  constructor(e6, t6) {
    __publicField(this, "featureName", zt.name);
    this.contractWrapper = e6, this.roles = t6;
  }
  async getAll() {
    invariant(this.roles.length, "this contract has no support for roles");
    let e6 = {};
    for (let t6 of this.roles)
      e6[t6] = await this.get(t6);
    return e6;
  }
  async get(e6) {
    invariant(this.roles.includes(e6), `this contract does not support the "${e6}" role`);
    let t6 = E(e6), n4 = (await this.contractWrapper.readContract.getRoleMemberCount(t6)).toNumber();
    return await Promise.all(Array.from(Array(n4).keys()).map((a5) => this.contractWrapper.readContract.getRoleMember(t6, a5)));
  }
  async setAll(e6) {
    let t6 = Object.keys(e6);
    invariant(t6.length, "you must provide at least one role to set"), invariant(t6.every((s6) => this.roles.includes(s6)), "this contract does not support the given role");
    let n4 = await this.getAll(), a5 = [], i6 = t6.sort((s6) => s6 === "admin" ? 1 : -1);
    for (let s6 = 0; s6 < i6.length; s6++) {
      let o6 = i6[s6], y5 = e6[o6] || [], d6 = n4[o6] || [], u7 = y5.filter((b4) => !d6.includes(b4)), m6 = d6.filter((b4) => !y5.includes(b4));
      if (u7.length && u7.forEach((b4) => {
        a5.push(this.contractWrapper.readContract.interface.encodeFunctionData("grantRole", [E(o6), b4]));
      }), m6.length)
        for (let b4 = 0; b4 < m6.length; b4++) {
          let h6 = m6[b4], v9 = await this.getRevokeRoleFunctionName(h6);
          a5.push(this.contractWrapper.readContract.interface.encodeFunctionData(v9, [E(o6), h6]));
        }
    }
    return { receipt: await this.contractWrapper.multiCall(a5) };
  }
  async verify(e6, t6) {
    await Promise.all(e6.map(async (n4) => {
      if (!(await this.get(n4)).map((i6) => i6.toLowerCase()).includes(t6.toLowerCase()))
        throw new Ft(t6, n4);
    }));
  }
  async grant(e6, t6) {
    return invariant(this.roles.includes(e6), `this contract does not support the "${e6}" role`), { receipt: await this.contractWrapper.sendTransaction("grantRole", [E(e6), t6]) };
  }
  async revoke(e6, t6) {
    invariant(this.roles.includes(e6), `this contract does not support the "${e6}" role`);
    let n4 = await this.getRevokeRoleFunctionName(t6);
    return { receipt: await this.contractWrapper.sendTransaction(n4, [E(e6), t6]) };
  }
  async getRevokeRoleFunctionName(e6) {
    return (await this.contractWrapper.getSignerAddress()).toLowerCase() === e6.toLowerCase() ? "renounceRole" : "revokeRole";
  }
};
p2(V, "ContractRoles");
var ye = class {
  constructor(e6, t6) {
    __publicField(this, "featureName", qt.name);
    this.contractWrapper = e6, this.metadata = t6;
  }
  async getDefaultRoyaltyInfo() {
    let [e6, t6] = await this.contractWrapper.readContract.getDefaultRoyaltyInfo();
    return N2.parse({ fee_recipient: e6, seller_fee_basis_points: t6 });
  }
  async getTokenRoyaltyInfo(e6) {
    let [t6, n4] = await this.contractWrapper.readContract.getRoyaltyInfoForToken(e6);
    return N2.parse({ fee_recipient: t6, seller_fee_basis_points: n4 });
  }
  async setDefaultRoyaltyInfo(e6) {
    let t6 = await this.metadata.get(), n4 = this.metadata.parseInputMetadata(w(w({}, t6), e6)), a5 = await this.metadata._parseAndUploadMetadata(n4), i6 = [this.contractWrapper.readContract.interface.encodeFunctionData("setDefaultRoyaltyInfo", [n4.fee_recipient, n4.seller_fee_basis_points]), this.contractWrapper.readContract.interface.encodeFunctionData("setContractURI", [a5])];
    return { receipt: await this.contractWrapper.multiCall(i6), data: () => this.getDefaultRoyaltyInfo() };
  }
  async setTokenRoyaltyInfo(e6, t6) {
    return { receipt: await this.contractWrapper.sendTransaction("setRoyaltyInfoForToken", [e6, t6.fee_recipient, t6.seller_fee_basis_points]), data: () => this.getDefaultRoyaltyInfo() };
  }
};
p2(ye, "ContractRoyalty");
var de = class {
  constructor(e6) {
    __publicField(this, "featureName", $t.name);
    this.contractWrapper = e6;
  }
  async getRecipient() {
    return await this.contractWrapper.readContract.primarySaleRecipient();
  }
  async setRecipient(e6) {
    return { receipt: await this.contractWrapper.sendTransaction("setPrimarySaleRecipient", [e6]) };
  }
};
p2(de, "ContractPrimarySale");
var Ht = "0xc82BbE41f2cF04e3a8efA18F7032BDD7f6d98a81";
var Ue = "0x7c487845f98938Bb955B1D5AD069d9a30e4131fd";
var ze = "0x5DBC7B840baa9daBcBe9D2492E45D7244B54A2A0";
var us = "0x61Bb02795b4fF5248169A54D9f149C4557B0B7de";
var $a = { [T.Mainnet]: { biconomyForwarder: "0x84a0856b038eaAd1cC7E297cF34A7e72685A8693", twFactory: ze, twRegistry: Ue, twBYOCRegistry: lib_exports7.AddressZero, byocFactory: lib_exports7.AddressZero }, [T.Rinkeby]: { biconomyForwarder: "0xFD4973FeB2031D4409fB57afEE5dF2051b171104", twFactory: ze, twRegistry: Ue, twBYOCRegistry: "0x3E6eE864f850F5e5A98bc950B68E181Cf4010F23", byocFactory: "0xd1b313C4fb83d979f0d842Afd97cDc93AFE4ab61" }, [T.Goerli]: { biconomyForwarder: lib_exports7.AddressZero, twFactory: ze, twRegistry: Ue, twBYOCRegistry: "0xB1Bd9d7942A250BA2Dce27DD601F2ED4211A60C4", byocFactory: "0xd1b313C4fb83d979f0d842Afd97cDc93AFE4ab61" }, [T.Polygon]: { biconomyForwarder: "0x86C80a8aa58e0A4fa09A69624c31Ab2a6CAD56b8", twFactory: ze, twRegistry: Ue, twBYOCRegistry: lib_exports7.AddressZero, byocFactory: lib_exports7.AddressZero }, [T.Mumbai]: { biconomyForwarder: "0x9399BB24DBB5C4b782C70c2969F58716Ebbd6a3b", twFactory: ze, twRegistry: Ue, twBYOCRegistry: "0x3F17972CB27506eb4a6a3D59659e0B57a43fd16C", byocFactory: "0x4ca9932786541D142bAe8a39483050D1D7AD664a" }, [T.Avalanche]: { biconomyForwarder: "0x64CD353384109423a966dCd3Aa30D884C9b2E057", twFactory: ze, twRegistry: Ue, twBYOCRegistry: lib_exports7.AddressZero, byocFactory: lib_exports7.AddressZero }, [T.AvalancheFujiTestnet]: { biconomyForwarder: "0x6271Ca63D30507f2Dcbf99B52787032506D75BBF", twFactory: ze, twRegistry: Ue, twBYOCRegistry: "0x3E6eE864f850F5e5A98bc950B68E181Cf4010F23", byocFactory: "0xd1b313C4fb83d979f0d842Afd97cDc93AFE4ab61" }, [T.Fantom]: { biconomyForwarder: lib_exports7.AddressZero, twFactory: "0x97EA0Fcc552D5A8Fb5e9101316AAd0D62Ea0876B", twRegistry: Ue, twBYOCRegistry: lib_exports7.AddressZero, byocFactory: lib_exports7.AddressZero }, [T.FantomTestnet]: { biconomyForwarder: lib_exports7.AddressZero, twFactory: ze, twRegistry: Ue, twBYOCRegistry: "0x3E6eE864f850F5e5A98bc950B68E181Cf4010F23", byocFactory: "0xd1b313C4fb83d979f0d842Afd97cDc93AFE4ab61" } };
function He(r6, e6) {
  return r6 === T.Hardhat ? e6 === "twFactory" ? process.env.factoryAddress : e6 === "twRegistry" ? process.env.registryAddress : e6 === "twBYOCRegistry" ? process.env.byocRegistryAddress : e6 === "byocFactory" ? process.env.byocFactoryAddress : lib_exports7.AddressZero : $a[r6][e6];
}
p2(He, "getContractAddressByChainId");
function tr() {
  return process.env.byocRegistryAddress ? process.env.byocRegistryAddress : us;
}
p2(tr, "getBYOCRegistryAddress");
var xe = mod.object({ readonlySettings: mod.object({ rpcUrl: mod.string().url(), chainId: mod.number().optional() }).optional(), gasSettings: mod.object({ maxPriceInGwei: mod.number().min(1, "gas price cannot be less than 1").default(300), speed: mod.enum(["standard", "fast", "fastest"]).default("fastest") }).default({ maxPriceInGwei: 300, speed: "fastest" }), gasless: mod.union([mod.object({ openzeppelin: mod.object({ relayerUrl: mod.string().url(), relayerForwarderAddress: mod.string().default(Ht) }) }), mod.object({ biconomy: mod.object({ apiId: mod.string(), apiKey: mod.string(), deadlineSeconds: mod.number().min(1, "deadlineSeconds cannot be les than 1").default(3600) }) })]).optional() }).default({ gasSettings: { maxPriceInGwei: 300, speed: "fastest" } });
var fe = class extends import_eventemitter2.EventEmitter2 {
  constructor(e6, t6) {
    super();
    let [n4, a5] = this.getSignerAndProvider(e6, t6);
    this.signer = n4, this.provider = a5;
    try {
      this.options = xe.parse(t6);
    } catch (i6) {
      console.error("invalid sdk options object passed, falling back to default options", i6), this.options = xe.parse({});
    }
  }
  updateSignerOrProvider(e6) {
    let [t6, n4] = this.getSignerAndProvider(e6, this.options);
    this.signer = t6, this.provider = n4;
  }
  isReadOnly() {
    return !Signer.isSigner(this.signer);
  }
  getSigner() {
    return this.signer;
  }
  getProvider() {
    return this.provider;
  }
  getSignerOrProvider() {
    return this.getSigner() || this.getProvider();
  }
  getSignerAndProvider(e6, t6) {
    var i6;
    let n4, a5;
    return Signer.isSigner(e6) && (n4 = e6, e6.provider && (a5 = e6.provider)), t6 != null && t6.readonlySettings && (a5 = this.getReadOnlyProvider(t6.readonlySettings.rpcUrl, t6.readonlySettings.chainId)), a5 || (lib_exports21.Provider.isProvider(e6) ? a5 = e6 : Signer.isSigner(e6) || (typeof e6 == "string" ? a5 = this.getReadOnlyProvider(e6, (i6 = t6 == null ? void 0 : t6.readonlySettings) == null ? void 0 : i6.chainId) : a5 = ethers_exports.getDefaultProvider(e6))), a5 || (a5 = ethers_exports.getDefaultProvider(), console.error("No provider found, using default provider on default chain!")), [n4, a5];
  }
  getReadOnlyProvider(e6, t6) {
    try {
      let n4 = e6.match(/^(ws|http)s?:/i);
      if (n4)
        switch (n4[1]) {
          case "http":
            return new lib_exports21.JsonRpcBatchProvider(e6, t6);
          case "ws":
            return new lib_exports21.WebSocketProvider(e6, t6);
          default:
            return ethers_exports.getDefaultProvider(e6);
        }
      else
        return ethers_exports.getDefaultProvider(e6);
    } catch {
      return ethers_exports.getDefaultProvider(e6);
    }
  }
};
p2(fe, "RPCConnectionHandler");
var be;
(function(r6) {
  r6.Transaction = "transaction", r6.Signature = "signature";
})(be || (be = {}));
var ar = [{ name: "from", type: "address" }, { name: "to", type: "address" }, { name: "value", type: "uint256" }, { name: "gas", type: "uint256" }, { name: "nonce", type: "uint256" }, { name: "data", type: "bytes" }];
var rr = [{ inputs: [{ internalType: "address", name: "from", type: "address" }, { internalType: "uint256", name: "batchId", type: "uint256" }], name: "getNonce", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }];
var gt = {};
var nr = {};
async function Za(r6, e6, t6) {
  let n4 = t6.join("|"), a5 = nr[n4], i6 = Date.now() - a5 >= 2e3;
  if (!(n4 in gt) || i6) {
    let o6 = await r6.functions[e6](...t6);
    Array.isArray(o6) && o6.length > 0 ? gt[n4] = BigNumber.from(o6[0]) : gt[n4] = BigNumber.from(o6), nr[n4] = Date.now();
  }
  let s6 = gt[n4];
  return gt[n4] = BigNumber.from(gt[n4]).add(1), s6;
}
p2(Za, "getAndIncrementNonce");
var zn = [{ inputs: [{ internalType: "address", name: "_twRegistry", type: "address" }, { internalType: "address", name: "_trustedForwarder", type: "address" }], stateMutability: "nonpayable", type: "constructor" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "deployer", type: "address" }, { indexed: true, internalType: "address", name: "publisher", type: "address" }, { indexed: false, internalType: "address", name: "deployedContract", type: "address" }], name: "ContractDeployed", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "prevOwner", type: "address" }, { indexed: false, internalType: "address", name: "newOwner", type: "address" }], name: "OwnerUpdated", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "bool", name: "isPaused", type: "bool" }], name: "Paused", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "role", type: "bytes32" }, { indexed: true, internalType: "bytes32", name: "previousAdminRole", type: "bytes32" }, { indexed: true, internalType: "bytes32", name: "newAdminRole", type: "bytes32" }], name: "RoleAdminChanged", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "role", type: "bytes32" }, { indexed: true, internalType: "address", name: "account", type: "address" }, { indexed: true, internalType: "address", name: "sender", type: "address" }], name: "RoleGranted", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "role", type: "bytes32" }, { indexed: true, internalType: "address", name: "account", type: "address" }, { indexed: true, internalType: "address", name: "sender", type: "address" }], name: "RoleRevoked", type: "event" }, { inputs: [], name: "DEFAULT_ADMIN_ROLE", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "view", type: "function" }, { inputs: [], name: "contractURI", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_publisher", type: "address" }, { internalType: "bytes", name: "_contractBytecode", type: "bytes" }, { internalType: "bytes", name: "_constructorArgs", type: "bytes" }, { internalType: "bytes32", name: "_salt", type: "bytes32" }, { internalType: "uint256", name: "_value", type: "uint256" }, { components: [{ internalType: "string", name: "publishMetadataUri", type: "string" }, { internalType: "string", name: "contractURI", type: "string" }, { internalType: "address", name: "owner", type: "address" }], internalType: "struct ThirdwebContract.ThirdwebInfo", name: "_thirdwebInfo", type: "tuple" }], name: "deployInstance", outputs: [{ internalType: "address", name: "deployedAddress", type: "address" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_publisher", type: "address" }, { internalType: "address", name: "_implementation", type: "address" }, { internalType: "bytes", name: "_initializeData", type: "bytes" }, { internalType: "bytes32", name: "_salt", type: "bytes32" }, { internalType: "uint256", name: "_value", type: "uint256" }, { components: [{ internalType: "string", name: "publishMetadataUri", type: "string" }, { internalType: "string", name: "contractURI", type: "string" }, { internalType: "address", name: "owner", type: "address" }], internalType: "struct ThirdwebContract.ThirdwebInfo", name: "_thirdwebInfo", type: "tuple" }], name: "deployInstanceProxy", outputs: [{ internalType: "address", name: "deployedAddress", type: "address" }], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "getPublishMetadataUri", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }], name: "getRoleAdmin", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "uint256", name: "index", type: "uint256" }], name: "getRoleMember", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }], name: "getRoleMemberCount", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "grantRole", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "hasRole", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [], name: "isPaused", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "forwarder", type: "address" }], name: "isTrustedForwarder", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [], name: "owner", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "renounceRole", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "revokeRole", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "string", name: "_uri", type: "string" }], name: "setContractURI", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_newOwner", type: "address" }], name: "setOwner", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bool", name: "_pause", type: "bool" }], name: "setPause", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ components: [{ internalType: "string", name: "publishMetadataUri", type: "string" }, { internalType: "string", name: "contractURI", type: "string" }, { internalType: "address", name: "owner", type: "address" }], internalType: "struct ThirdwebContract.ThirdwebInfo", name: "_thirdwebInfo", type: "tuple" }], name: "setThirdwebInfo", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }], name: "supportsInterface", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }];
var ir = "0x60c06040523480156200001157600080fd5b50604051620022fd380380620022fd833981016040819052620000349162000242565b6001600160a01b03808216608052821660a0526200005d60006200005762000065565b62000081565b50506200027a565b60006200007c6200009160201b62000eee1760201c565b905090565b6200008d8282620000ca565b5050565b6080516000906001600160a01b0316331415620000b5575060131936013560601c90565b6200007c6200010d60201b62000f381760201c565b620000e182826200011160201b62000f3c1760201c565b60008281526001602090815260409091206200010891839062000fdb620001b3821b17901c565b505050565b3390565b6000828152602081815260408083206001600160a01b038516845290915290205460ff166200008d576000828152602081815260408083206001600160a01b03851684529091529020805460ff191660011790556200016f62000065565b6001600160a01b0316816001600160a01b0316837f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45050565b6000620001ca836001600160a01b038416620001d3565b90505b92915050565b60008181526001830160205260408120546200021c57508154600181810184556000848152602080822090930184905584548482528286019093526040902091909155620001cd565b506000620001cd565b80516001600160a01b03811681146200023d57600080fd5b919050565b600080604083850312156200025657600080fd5b620002618362000225565b9150620002716020840162000225565b90509250929050565b60805160a05161204f620002ae600039600081816107300152610e320152600081816102150152610ef2015261204f6000f3fe608060405234801561001057600080fd5b506004361061016c5760003560e01c8063938e3d7b116100cd578063ca15c87311610081578063d547741f11610066578063d547741f14610343578063e8a3d48514610356578063ffc6beac1461035e57600080fd5b8063ca15c8731461031b578063d3684f401461032e57600080fd5b8063b187bd26116100b2578063b187bd26146102e8578063bba53cba146102f5578063bedb86fb1461030857600080fd5b8063938e3d7b146102cd578063a217fddf146102e057600080fd5b8063572b6c05116101245780638da5cb5b116101095780638da5cb5b146102705780639010d07c1461028357806391d148541461029657600080fd5b8063572b6c05146102055780637efa414f1461024557600080fd5b8063248a9ca311610155578063248a9ca3146101ae5780632f2ff15d146101df57806336568abe146101f257600080fd5b806301ffc9a71461017157806313af403514610199575b600080fd5b61018461017f366004611943565b610371565b60405190151581526020015b60405180910390f35b6101ac6101a7366004611989565b61039c565b005b6101d16101bc3660046119a4565b60009081526020819052604090206001015490565b604051908152602001610190565b6101ac6101ed3660046119bd565b61045a565b6101ac6102003660046119bd565b61048c565b610184610213366004611989565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0390811691161490565b610258610253366004611b49565b610528565b6040516001600160a01b039091168152602001610190565b600254610258906001600160a01b031681565b610258610291366004611be0565b610802565b6101846102a43660046119bd565b6000918252602082815260408084206001600160a01b0393909316845291905290205460ff1690565b6101ac6102db366004611c02565b610821565b6101d1600081565b6005546101849060ff1681565b6101ac610303366004611c74565b610878565b6101ac610316366004611ca9565b6109b3565b6101d16103293660046119a4565b610a53565b610336610a6a565b6040516101909190611d27565b6101ac6103513660046119bd565b610afc565b610336610b24565b61025861036c366004611d3a565b610bb2565b60006001600160e01b03198216635a05180f60e01b1480610396575061039682610ff0565b92915050565b6002546001600160a01b031633146103ec5760405162461bcd60e51b815260206004820152600e60248201526d139bdd08185d5d1a1bdc9a5e995960921b60448201526064015b60405180910390fd5b600280546001600160a01b0383811673ffffffffffffffffffffffffffffffffffffffff1983168117909355604080519190921680825260208201939093527f8292fce18fa69edf4db7b94ea2e58241df0ae57f97e0a6c9b29067028bf92d76910160405180910390a15050565b60008281526020819052604090206001015461047d81610478611025565b61102f565b61048783836110ad565b505050565b610494611025565b6001600160a01b0316816001600160a01b03161461051a5760405162461bcd60e51b815260206004820152602f60248201527f416363657373436f6e74726f6c3a2063616e206f6e6c792072656e6f756e636560448201527f20726f6c657320666f722073656c66000000000000000000000000000000000060648201526084016103e3565b61052482826110cf565b5050565b60055460009060ff161580610545575061054560006102a4611025565b6105835760405162461bcd60e51b815260206004820152600f60248201526e1c9959da5cdd1c9e481c185d5cd959608a1b60448201526064016103e3565b6000841561059157846105d6565b610599611025565b60405160609190911b6bffffffffffffffffffffffff19166020820152436034820152605401604051602081830303815290604052805190602001205b90506105e287826110f1565b604051635dd29e5d60e11b81529092506001600160a01b0383169063bba53cba90610611908690600401611d9b565b600060405180830381600087803b15801561062b57600080fd5b505af115801561063f573d6000803e3d6000fd5b50505050826000015180519060200120826001600160a01b031663d3684f406040518163ffffffff1660e01b8152600401600060405180830381865afa15801561068d573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526106b59190810190611df4565b80519060200120146107095760405162461bcd60e51b815260206004820152601760248201527f4e6f74206120746869726477656220636f6e747261637400000000000000000060448201526064016103e3565b6040516352c28fab60e01b81526001600160a01b03898116600483015283811660248301527f000000000000000000000000000000000000000000000000000000000000000016906352c28fab90604401600060405180830381600087803b15801561077457600080fd5b505af1158015610788573d6000803e3d6000fd5b505050506000865111156107a3576107a18287866111a8565b505b876001600160a01b03166107b5611025565b6040516001600160a01b03858116825291909116907f8a14d1d7200360982eafa429b53edf408f7f589e6da6558f3c116c7f708327b39060200160405180910390a3509695505050505050565b600082815260016020526040812061081a90836111d6565b9392505050565b6002546001600160a01b0316331461086c5760405162461bcd60e51b815260206004820152600e60248201526d139bdd08185d5d1a1bdc9a5e995960921b60448201526064016103e3565b61048760038383611836565b6004805461088590611e6b565b1590506108fa5760405162461bcd60e51b815260206004820152602660248201527f5075626c6973686564206d6574616461746120616c726561647920696e69746960448201527f616c697a6564000000000000000000000000000000000000000000000000000060648201526084016103e3565b6002546001600160a01b0316156109535760405162461bcd60e51b815260206004820152601960248201527f4f776e657220616c726561647920696e697469616c697a65640000000000000060448201526064016103e3565b80518051610969916004916020909101906118ba565b5060208082015180516109809260039201906118ba565b50604001516002805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b03909216919091179055565b6109c060006102a4611025565b610a0c5760405162461bcd60e51b815260206004820152601160248201527f756e617070726f7665642063616c6c657200000000000000000000000000000060448201526064016103e3565b6005805460ff19168215159081179091556040519081527f0e2fb031ee032dc02d8011dc50b816eb450cf856abd8261680dac74f72165bd29060200160405180910390a150565b6000818152600160205260408120610396906111e2565b606060048054610a7990611e6b565b80601f0160208091040260200160405190810160405280929190818152602001828054610aa590611e6b565b8015610af25780601f10610ac757610100808354040283529160200191610af2565b820191906000526020600020905b815481529060010190602001808311610ad557829003601f168201915b5050505050905090565b600082815260208190526040902060010154610b1a81610478611025565b61048783836110cf565b60038054610b3190611e6b565b80601f0160208091040260200160405190810160405280929190818152602001828054610b5d90611e6b565b8015610baa5780601f10610b7f57610100808354040283529160200191610baa565b820191906000526020600020905b815481529060010190602001808311610b8d57829003601f168201915b505050505081565b60055460009060ff161580610bcf5750610bcf60006102a4611025565b610c0d5760405162461bcd60e51b815260206004820152600f60248201526e1c9959da5cdd1c9e481c185d5cd959608a1b60448201526064016103e3565b815151610c5c5760405162461bcd60e51b815260206004820152601360248201527f4e6f207075626c697368206d657461646174610000000000000000000000000060448201526064016103e3565b60008686604051602001610c71929190611ea6565b6040516020818303038152906040529050600085600014610c925785610cd7565b610c9a611025565b60405160609190911b6bffffffffffffffffffffffff19166020820152436034820152605401604051602081830303815290604052805190602001205b9050610ce48582846111ec565b604051635dd29e5d60e11b81529093506001600160a01b0384169063bba53cba90610d13908790600401611d9b565b600060405180830381600087803b158015610d2d57600080fd5b505af1158015610d41573d6000803e3d6000fd5b50505050836000015180519060200120836001600160a01b031663d3684f406040518163ffffffff1660e01b8152600401600060405180830381865afa158015610d8f573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610db79190810190611df4565b8051906020012014610e0b5760405162461bcd60e51b815260206004820152601760248201527f4e6f74206120746869726477656220636f6e747261637400000000000000000060448201526064016103e3565b6040516352c28fab60e01b81526001600160a01b038a8116600483015284811660248301527f000000000000000000000000000000000000000000000000000000000000000016906352c28fab90604401600060405180830381600087803b158015610e7657600080fd5b505af1158015610e8a573d6000803e3d6000fd5b50505050886001600160a01b0316610ea0611025565b6040516001600160a01b03868116825291909116907f8a14d1d7200360982eafa429b53edf408f7f589e6da6558f3c116c7f708327b39060200160405180910390a350509695505050505050565b60007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316331415610f2e575060131936013560601c90565b503390565b905090565b3390565b6000828152602081815260408083206001600160a01b038516845290915290205460ff16610524576000828152602081815260408083206001600160a01b03851684529091529020805460ff19166001179055610f97611025565b6001600160a01b0316816001600160a01b0316837f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45050565b600061081a836001600160a01b0384166112ee565b60006001600160e01b03198216637965db0b60e01b148061039657506301ffc9a760e01b6001600160e01b0319831614610396565b6000610f33610eee565b6000828152602081815260408083206001600160a01b038516845290915290205460ff166105245761106b816001600160a01b0316601461133d565b61107683602061133d565b604051602001611087929190611ed5565b60408051601f198184030181529082905262461bcd60e51b82526103e391600401611d27565b6110b78282610f3c565b60008281526001602052604090206104879082610fdb565b6110d982826114e6565b60008281526001602052604090206104879082611583565b60006040517f3d602d80600a3d3981f3363d3d373d3d3d363d7300000000000000000000000081528360601b60148201527f5af43d82803e903d91602b57fd5bf300000000000000000000000000000000006028820152826037826000f59150506001600160a01b0381166103965760405162461bcd60e51b815260206004820152601760248201527f455243313136373a2063726561746532206661696c656400000000000000000060448201526064016103e3565b60606111ce84848460405180606001604052806029815260200161201a60299139611598565b949350505050565b600061081a83836116e0565b6000610396825490565b6000808447101561123f5760405162461bcd60e51b815260206004820152601d60248201527f437265617465323a20696e73756666696369656e742062616c616e636500000060448201526064016103e3565b825161128d5760405162461bcd60e51b815260206004820181905260248201527f437265617465323a2062797465636f6465206c656e677468206973207a65726f60448201526064016103e3565b8383516020850187f590506001600160a01b0381166111ce5760405162461bcd60e51b815260206004820152601960248201527f437265617465323a204661696c6564206f6e206465706c6f790000000000000060448201526064016103e3565b600081815260018301602052604081205461133557508154600181810184556000848152602080822090930184905584548482528286019093526040902091909155610396565b506000610396565b6060600061134c836002611f6c565b611357906002611f8b565b67ffffffffffffffff81111561136f5761136f6119e9565b6040519080825280601f01601f191660200182016040528015611399576020820181803683370190505b509050600360fc1b816000815181106113b4576113b4611fa3565b60200101906001600160f81b031916908160001a905350600f60fb1b816001815181106113e3576113e3611fa3565b60200101906001600160f81b031916908160001a9053506000611407846002611f6c565b611412906001611f8b565b90505b6001811115611497577f303132333435363738396162636465660000000000000000000000000000000085600f166010811061145357611453611fa3565b1a60f81b82828151811061146957611469611fa3565b60200101906001600160f81b031916908160001a90535060049490941c9361149081611fb9565b9050611415565b50831561081a5760405162461bcd60e51b815260206004820181905260248201527f537472696e67733a20686578206c656e67746820696e73756666696369656e7460448201526064016103e3565b6000828152602081815260408083206001600160a01b038516845290915290205460ff1615610524576000828152602081815260408083206001600160a01b03851684529091529020805460ff1916905561153f611025565b6001600160a01b0316816001600160a01b0316837ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b60405160405180910390a45050565b600061081a836001600160a01b03841661170a565b6060824710156116105760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f60448201527f722063616c6c000000000000000000000000000000000000000000000000000060648201526084016103e3565b6001600160a01b0385163b6116675760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016103e3565b600080866001600160a01b031685876040516116839190611fd0565b60006040518083038185875af1925050503d80600081146116c0576040519150601f19603f3d011682016040523d82523d6000602084013e6116c5565b606091505b50915091506116d58282866117fd565b979650505050505050565b60008260000182815481106116f7576116f7611fa3565b9060005260206000200154905092915050565b600081815260018301602052604081205480156117f357600061172e600183611fec565b855490915060009061174290600190611fec565b90508181146117a757600086600001828154811061176257611762611fa3565b906000526020600020015490508087600001848154811061178557611785611fa3565b6000918252602080832090910192909255918252600188019052604090208390555b85548690806117b8576117b8612003565b600190038181906000526020600020016000905590558560010160008681526020019081526020016000206000905560019350505050610396565b6000915050610396565b6060831561180c57508161081a565b82511561181c5782518084602001fd5b8160405162461bcd60e51b81526004016103e39190611d27565b82805461184290611e6b565b90600052602060002090601f01602090048101928261186457600085556118aa565b82601f1061187d5782800160ff198235161785556118aa565b828001600101855582156118aa579182015b828111156118aa57823582559160200191906001019061188f565b506118b692915061192e565b5090565b8280546118c690611e6b565b90600052602060002090601f0160209004810192826118e857600085556118aa565b82601f1061190157805160ff19168380011785556118aa565b828001600101855582156118aa579182015b828111156118aa578251825591602001919060010190611913565b5b808211156118b6576000815560010161192f565b60006020828403121561195557600080fd5b81356001600160e01b03198116811461081a57600080fd5b80356001600160a01b038116811461198457600080fd5b919050565b60006020828403121561199b57600080fd5b61081a8261196d565b6000602082840312156119b657600080fd5b5035919050565b600080604083850312156119d057600080fd5b823591506119e06020840161196d565b90509250929050565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f1916810167ffffffffffffffff81118282101715611a2857611a286119e9565b604052919050565b600067ffffffffffffffff821115611a4a57611a4a6119e9565b50601f01601f191660200190565b600082601f830112611a6957600080fd5b8135611a7c611a7782611a30565b6119ff565b818152846020838601011115611a9157600080fd5b816020850160208301376000918101602001919091529392505050565b600060608284031215611ac057600080fd5b6040516060810167ffffffffffffffff8282108183111715611ae457611ae46119e9565b816040528293508435915080821115611afc57600080fd5b611b0886838701611a58565b83526020850135915080821115611b1e57600080fd5b50611b2b85828601611a58565b602083015250611b3d6040840161196d565b60408201525092915050565b60008060008060008060c08789031215611b6257600080fd5b611b6b8761196d565b9550611b796020880161196d565b9450604087013567ffffffffffffffff80821115611b9657600080fd5b611ba28a838b01611a58565b9550606089013594506080890135935060a0890135915080821115611bc657600080fd5b50611bd389828a01611aae565b9150509295509295509295565b60008060408385031215611bf357600080fd5b50508035926020909101359150565b60008060208385031215611c1557600080fd5b823567ffffffffffffffff80821115611c2d57600080fd5b818501915085601f830112611c4157600080fd5b813581811115611c5057600080fd5b866020828501011115611c6257600080fd5b60209290920196919550909350505050565b600060208284031215611c8657600080fd5b813567ffffffffffffffff811115611c9d57600080fd5b6111ce84828501611aae565b600060208284031215611cbb57600080fd5b8135801515811461081a57600080fd5b60005b83811015611ce6578181015183820152602001611cce565b83811115611cf5576000848401525b50505050565b60008151808452611d13816020860160208601611ccb565b601f01601f19169290920160200192915050565b60208152600061081a6020830184611cfb565b60008060008060008060c08789031215611d5357600080fd5b611d5c8761196d565b9550602087013567ffffffffffffffff80821115611d7957600080fd5b611d858a838b01611a58565b96506040890135915080821115611b9657600080fd5b602081526000825160606020840152611db76080840182611cfb565b90506020840151601f19848303016040850152611dd48282611cfb565b9150506001600160a01b0360408501511660608401528091505092915050565b600060208284031215611e0657600080fd5b815167ffffffffffffffff811115611e1d57600080fd5b8201601f81018413611e2e57600080fd5b8051611e3c611a7782611a30565b818152856020838501011115611e5157600080fd5b611e62826020830160208601611ccb565b95945050505050565b600181811c90821680611e7f57607f821691505b60208210811415611ea057634e487b7160e01b600052602260045260246000fd5b50919050565b60008351611eb8818460208801611ccb565b835190830190611ecc818360208801611ccb565b01949350505050565b7f416363657373436f6e74726f6c3a206163636f756e7420000000000000000000815260008351611f0d816017850160208801611ccb565b7f206973206d697373696e6720726f6c65200000000000000000000000000000006017918401918201528351611f4a816028840160208801611ccb565b01602801949350505050565b634e487b7160e01b600052601160045260246000fd5b6000816000190483118215151615611f8657611f86611f56565b500290565b60008219821115611f9e57611f9e611f56565b500190565b634e487b7160e01b600052603260045260246000fd5b600081611fc857611fc8611f56565b506000190190565b60008251611fe2818460208701611ccb565b9190910192915050565b600082821015611ffe57611ffe611f56565b500390565b634e487b7160e01b600052603160045260246000fdfe416464726573733a206c6f772d6c6576656c2063616c6c20776974682076616c7565206661696c6564a164736f6c634300080c000a";
var bs = p2((r6) => r6.length > 1, "isSuperArgs");
var Ze = class extends ContractFactory {
  constructor(...e6) {
    bs(e6) ? super(...e6) : super(zn, ir, e6[0]);
  }
  deploy(e6, t6, n4) {
    return super.deploy(e6, t6, n4 || {});
  }
  getDeployTransaction(e6, t6, n4) {
    return super.getDeployTransaction(e6, t6, n4 || {});
  }
  attach(e6) {
    return super.attach(e6);
  }
  connect(e6) {
    return super.connect(e6);
  }
  static createInterface() {
    return new utils_exports.Interface(zn);
  }
  static connect(e6, t6) {
    return new Contract(e6, zn, t6);
  }
};
p2(Ze, "ByocFactory__factory"), f2(Ze, "bytecode", ir), f2(Ze, "abi", zn);
var Hn = [{ inputs: [{ internalType: "address", name: "_trustedForwarder", type: "address" }], stateMutability: "nonpayable", type: "constructor" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "publisher", type: "address" }, { indexed: true, internalType: "string", name: "contractId", type: "string" }], name: "AddedContractToPublicList", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "publisher", type: "address" }, { indexed: true, internalType: "address", name: "operator", type: "address" }, { indexed: false, internalType: "bool", name: "isApproved", type: "bool" }], name: "Approved", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "operator", type: "address" }, { indexed: true, internalType: "address", name: "publisher", type: "address" }, { components: [{ internalType: "string", name: "contractId", type: "string" }, { internalType: "uint256", name: "publishTimestamp", type: "uint256" }, { internalType: "string", name: "publishMetadataUri", type: "string" }, { internalType: "bytes32", name: "bytecodeHash", type: "bytes32" }, { internalType: "address", name: "implementation", type: "address" }], indexed: false, internalType: "struct IByocRegistry.CustomContractInstance", name: "publishedContract", type: "tuple" }], name: "ContractPublished", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "operator", type: "address" }, { indexed: true, internalType: "address", name: "publisher", type: "address" }, { indexed: true, internalType: "string", name: "contractId", type: "string" }], name: "ContractUnpublished", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "bool", name: "isPaused", type: "bool" }], name: "Paused", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "publisher", type: "address" }, { indexed: true, internalType: "string", name: "contractId", type: "string" }], name: "RemovedContractToPublicList", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "role", type: "bytes32" }, { indexed: true, internalType: "bytes32", name: "previousAdminRole", type: "bytes32" }, { indexed: true, internalType: "bytes32", name: "newAdminRole", type: "bytes32" }], name: "RoleAdminChanged", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "role", type: "bytes32" }, { indexed: true, internalType: "address", name: "account", type: "address" }, { indexed: true, internalType: "address", name: "sender", type: "address" }], name: "RoleGranted", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "role", type: "bytes32" }, { indexed: true, internalType: "address", name: "account", type: "address" }, { indexed: true, internalType: "address", name: "sender", type: "address" }], name: "RoleRevoked", type: "event" }, { inputs: [], name: "DEFAULT_ADMIN_ROLE", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_publisher", type: "address" }, { internalType: "string", name: "_contractId", type: "string" }], name: "addToPublicList", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_operator", type: "address" }, { internalType: "bool", name: "_toApprove", type: "bool" }], name: "approveOperator", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "getAllPublicPublishedContracts", outputs: [{ components: [{ internalType: "string", name: "contractId", type: "string" }, { internalType: "uint256", name: "publishTimestamp", type: "uint256" }, { internalType: "string", name: "publishMetadataUri", type: "string" }, { internalType: "bytes32", name: "bytecodeHash", type: "bytes32" }, { internalType: "address", name: "implementation", type: "address" }], internalType: "struct IByocRegistry.CustomContractInstance[]", name: "published", type: "tuple[]" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_publisher", type: "address" }], name: "getAllPublishedContracts", outputs: [{ components: [{ internalType: "string", name: "contractId", type: "string" }, { internalType: "uint256", name: "publishTimestamp", type: "uint256" }, { internalType: "string", name: "publishMetadataUri", type: "string" }, { internalType: "bytes32", name: "bytecodeHash", type: "bytes32" }, { internalType: "address", name: "implementation", type: "address" }], internalType: "struct IByocRegistry.CustomContractInstance[]", name: "published", type: "tuple[]" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_publisher", type: "address" }, { internalType: "string", name: "_contractId", type: "string" }], name: "getPublicId", outputs: [{ internalType: "uint256", name: "publicId", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_publisher", type: "address" }, { internalType: "string", name: "_contractId", type: "string" }], name: "getPublishedContract", outputs: [{ components: [{ internalType: "string", name: "contractId", type: "string" }, { internalType: "uint256", name: "publishTimestamp", type: "uint256" }, { internalType: "string", name: "publishMetadataUri", type: "string" }, { internalType: "bytes32", name: "bytecodeHash", type: "bytes32" }, { internalType: "address", name: "implementation", type: "address" }], internalType: "struct IByocRegistry.CustomContractInstance", name: "published", type: "tuple" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_publisher", type: "address" }, { internalType: "string", name: "_contractId", type: "string" }], name: "getPublishedContractVersions", outputs: [{ components: [{ internalType: "string", name: "contractId", type: "string" }, { internalType: "uint256", name: "publishTimestamp", type: "uint256" }, { internalType: "string", name: "publishMetadataUri", type: "string" }, { internalType: "bytes32", name: "bytecodeHash", type: "bytes32" }, { internalType: "address", name: "implementation", type: "address" }], internalType: "struct IByocRegistry.CustomContractInstance[]", name: "published", type: "tuple[]" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }], name: "getRoleAdmin", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "uint256", name: "index", type: "uint256" }], name: "getRoleMember", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }], name: "getRoleMemberCount", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "grantRole", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "hasRole", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "", type: "address" }, { internalType: "address", name: "", type: "address" }], name: "isApprovedByPublisher", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [], name: "isPaused", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "forwarder", type: "address" }], name: "isTrustedForwarder", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes[]", name: "data", type: "bytes[]" }], name: "multicall", outputs: [{ internalType: "bytes[]", name: "results", type: "bytes[]" }], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "nextPublicId", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_publisher", type: "address" }, { internalType: "string", name: "_publishMetadataUri", type: "string" }, { internalType: "bytes32", name: "_bytecodeHash", type: "bytes32" }, { internalType: "address", name: "_implementation", type: "address" }, { internalType: "string", name: "_contractId", type: "string" }], name: "publishContract", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_publisher", type: "address" }, { internalType: "string", name: "_contractId", type: "string" }], name: "removeFromPublicList", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "renounceRole", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "revokeRole", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bool", name: "_pause", type: "bool" }], name: "setPause", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }], name: "supportsInterface", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_publisher", type: "address" }, { internalType: "string", name: "_contractId", type: "string" }], name: "unpublishContract", outputs: [], stateMutability: "nonpayable", type: "function" }];
var sr = "0x60a060405260016002553480156200001657600080fd5b5060405162002b3438038062002b34833981016040819052620000399162000223565b6001600160a01b0381166080526200005c60006200005662000063565b6200007f565b5062000255565b60006200007a6200008f60201b620019a91760201c565b905090565b6200008b8282620000c8565b5050565b6080516000906001600160a01b0316331415620000b3575060131936013560601c90565b6200007a6200010b60201b620019f31760201c565b620000df82826200010f60201b620019f71760201c565b60008281526001602090815260409091206200010691839062001a96620001b1821b17901c565b505050565b3390565b6000828152602081815260408083206001600160a01b038516845290915290205460ff166200008b576000828152602081815260408083206001600160a01b03851684529091529020805460ff191660011790556200016d62000063565b6001600160a01b0316816001600160a01b0316837f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45050565b6000620001c8836001600160a01b038416620001d1565b90505b92915050565b60008181526001830160205260408120546200021a57508154600181810184556000848152602080822090930184905584548482528286019093526040902091909155620001cb565b506000620001cb565b6000602082840312156200023657600080fd5b81516001600160a01b03811681146200024e57600080fd5b9392505050565b6080516128bc62000278600039600081816102b101526119ad01526128bc6000f3fe608060405234801561001057600080fd5b50600436106101a35760003560e01c80639010d07c116100ee578063af8db69011610097578063bedb86fb11610071578063bedb86fb1461041d578063ca15c87314610430578063d547741f14610443578063ed4b98ff1461045657600080fd5b8063af8db690146103f5578063b187bd2614610408578063baee20211461041557600080fd5b8063a2620c89116100c8578063a2620c89146103b9578063a5d28bda146103c2578063ac9650d8146103d557600080fd5b80639010d07c1461034f57806391d148541461037a578063a217fddf146103b157600080fd5b80632f2ff15d116101505780637468a5d01161012a5780637468a5d0146102e15780637ec047fa1461030f57806380251dac1461032f57600080fd5b80632f2ff15d1461027b57806336568abe1461028e578063572b6c05146102a157600080fd5b8063248a9ca311610181578063248a9ca3146101f85780632866e4b21461022957806329b35ab61461026857600080fd5b806301ffc9a7146101a857806306eb56cc146101d057806309e5d614146101e5575b600080fd5b6101bb6101b63660046121c9565b610469565b60405190151581526020015b60405180910390f35b6101e36101de3660046122b2565b610494565b005b6101e36101f3366004612300565b6106ea565b61021b61020636600461238f565b60009081526020819052604090206001015490565b6040519081526020016101c7565b61021b6102373660046122b2565b80516020918201206001600160a01b0390921660009081526006825260408082209382526002909301909152205490565b6101e36102763660046123b8565b6109f2565b6101e36102893660046123eb565b610a8b565b6101e361029c3660046123eb565b610abd565b6101bb6102af36600461240e565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0390811691161490565b6101bb6102ef366004612429565b600460209081526000928352604080842090915290825290205460ff1681565b61032261031d3660046122b2565b610b59565b6040516101c79190612511565b61034261033d3660046122b2565b610d0f565b6040516101c79190612524565b61036261035d366004612586565b610f89565b6040516001600160a01b0390911681526020016101c7565b6101bb6103883660046123eb565b6000918252602082815260408084206001600160a01b0393909316845291905290205460ff1690565b61021b600081565b61021b60025481565b6101e36103d03660046122b2565b610fa8565b6103e86103e33660046125a8565b611056565b6040516101c7919061261d565b61034261040336600461240e565b61114b565b6003546101bb9060ff1681565b6103426113d2565b6101e361042b366004612672565b6117ec565b61021b61043e36600461238f565b611880565b6101e36104513660046123eb565b611897565b6101e36104643660046122b2565b6118bf565b60006001600160e01b03198216635a05180f60e01b148061048e575061048e82611aab565b92915050565b81806001600160a01b03166104a7611ae0565b6001600160a01b031614806104f657506001600160a01b0381166000908152600460205260408120906104d8611ae0565b6001600160a01b0316815260208101919091526040016000205460ff165b61053b5760405162461bcd60e51b81526020600482015260116024820152703ab730b8383937bb32b21031b0b63632b960791b60448201526064015b60405180910390fd5b60035460ff16158061055557506105556000610388611ae0565b6105935760405162461bcd60e51b815260206004820152600f60248201526e1c9959da5cdd1c9e481c185d5cd959608a1b6044820152606401610532565b81516020808401919091206001600160a01b03851660009081526006909252604082209091906105c39083611aea565b9050806106125760405162461bcd60e51b815260206004820152601460248201527f676976656e20636f6e7472616374496420444e450000000000000000000000006044820152606401610532565b6001600160a01b03851660009081526006602090815260408083208584526002908101909252822082815560018101839055919082018161065382826120f3565b600182016000905560028201600061066b91906120f3565b506000600382015560040180546001600160a01b0319169055505060405161069490859061268d565b6040518091039020856001600160a01b03166106ae611ae0565b6001600160a01b03167f4c934c8014c81bef7c9b5296daec96b8a63f02365b7dd6eb15ff0f231728a8d560405160405180910390a45050505050565b84806001600160a01b03166106fd611ae0565b6001600160a01b0316148061074c57506001600160a01b03811660009081526004602052604081209061072e611ae0565b6001600160a01b0316815260208101919091526040016000205460ff165b61078c5760405162461bcd60e51b81526020600482015260116024820152703ab730b8383937bb32b21031b0b63632b960791b6044820152606401610532565b60035460ff1615806107a657506107a66000610388611ae0565b6107e45760405162461bcd60e51b815260206004820152600f60248201526e1c9959da5cdd1c9e481c185d5cd959608a1b6044820152606401610532565b6040805160a08101825283815242602080830191909152818301889052606082018790526001600160a01b038087166080840152855182870120908a166000908152600690925292902090919061083b9082611af6565b506001600160a01b0388166000908152600660209081526040808320848452600290810183529220845180518694929092019261087d92849290910190612130565b506020828101516001830155604083015180516108a09260028501920190612130565b5060608201516003820155608090910151600490910180546001600160a01b0319166001600160a01b03928316179055881660009081526006602090815260408083208484526002019091528120600190810180549261090083856126bf565b90915550506001600160a01b03891660009081526006602090815260408083208584526002018252808320848452600701825290912084518051869361094a928492910190612130565b5060208281015160018301556040830151805161096d9260028501920190612130565b5060608201516003820155608090910151600490910180546001600160a01b0319166001600160a01b0392831617905589166109a7611ae0565b6001600160a01b03167f4c0484c23e4ea73b4cb562e1868ba93ccba2c9151ac4148fa1b91d9cb17b4581856040516109df9190612511565b60405180910390a3505050505050505050565b80600460006109ff611ae0565b6001600160a01b03908116825260208083019390935260409182016000908120918716808252919093529120805460ff191692151592909217909155610a43611ae0565b6001600160a01b03167f1299be4ab334acdc5747f03ba508209acf422601c7ee3040dc8ff385b0aca98983604051610a7f911515815260200190565b60405180910390a35050565b600082815260208190526040902060010154610aae81610aa9611ae0565b611b02565b610ab88383611b80565b505050565b610ac5611ae0565b6001600160a01b0316816001600160a01b031614610b4b5760405162461bcd60e51b815260206004820152602f60248201527f416363657373436f6e74726f6c3a2063616e206f6e6c792072656e6f756e636560448201527f20726f6c657320666f722073656c6600000000000000000000000000000000006064820152608401610532565b610b558282611ba2565b5050565b6040805160a0810182526060808252600060208301819052928201819052810182905260808101919091526001600160a01b03831660009081526006602090815260408083208551868401208452600290810190925291829020825160a0810190935201805482908290610bcc906126d7565b80601f0160208091040260200160405190810160405280929190818152602001828054610bf8906126d7565b8015610c455780601f10610c1a57610100808354040283529160200191610c45565b820191906000526020600020905b815481529060010190602001808311610c2857829003601f168201915b5050505050815260200160018201548152602001600282018054610c68906126d7565b80601f0160208091040260200160405190810160405280929190818152602001828054610c94906126d7565b8015610ce15780601f10610cb657610100808354040283529160200191610ce1565b820191906000526020600020905b815481529060010190602001808311610cc457829003601f168201915b5050509183525050600382015460208201526004909101546001600160a01b03166040909101529392505050565b80516020808301919091206001600160a01b03841660009081526006835260408082208383526002019093529190912060010154606091908067ffffffffffffffff811115610d6057610d6061220f565b604051908082528060200260200182016040528015610dba57816020015b6040805160a08101825260608082526000602080840182905293830182905290820181905260808201528252600019909201910181610d7e5790505b50925060005b81811015610f80576001600160a01b0386166000908152600660209081526040808320868452600201825280832084845260070190915290819020815160a08101909252805482908290610e13906126d7565b80601f0160208091040260200160405190810160405280929190818152602001828054610e3f906126d7565b8015610e8c5780601f10610e6157610100808354040283529160200191610e8c565b820191906000526020600020905b815481529060010190602001808311610e6f57829003601f168201915b5050505050815260200160018201548152602001600282018054610eaf906126d7565b80601f0160208091040260200160405190810160405280929190818152602001828054610edb906126d7565b8015610f285780601f10610efd57610100808354040283529160200191610f28565b820191906000526020600020905b815481529060010190602001808311610f0b57829003601f168201915b5050509183525050600382015460208201526004909101546001600160a01b03166040909101528451859083908110610f6357610f63612712565b6020908102919091010152610f796001826126bf565b9050610dc0565b50505092915050565b6000828152600160205260408120610fa19083611bc4565b9392505050565b80516020808301919091206001600160a01b038416600090815260068352604080822083835260020184528082208054908390558083526005909452812080546001600160a01b03191681559192919061100560018301826120f3565b505082604051611015919061268d565b604051908190038120906001600160a01b038616907fa6dc3dd821b921fabed8dda809ab13ff41ade49a18cdb6510f95ac6a324fffab90600090a350505050565b60608167ffffffffffffffff8111156110715761107161220f565b6040519080825280602002602001820160405280156110a457816020015b606081526020019060019003908161108f5790505b50905060005b8281101561114457611114308585848181106110c8576110c8612712565b90506020028101906110da9190612728565b8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250611bd092505050565b82828151811061112657611126612712565b6020026020010181905250808061113c90612776565b9150506110aa565b5092915050565b6001600160a01b03811660009081526006602052604081206060919061117090611bf5565b90508067ffffffffffffffff81111561118b5761118b61220f565b6040519080825280602002602001820160405280156111e557816020015b6040805160a081018252606080825260006020808401829052938301829052908201819052608082015282526000199092019101816111a95790505b50915060005b818110156113cb576001600160a01b03841660009081526006602052604081206112159083611bc4565b6001600160a01b0386166000908152600660209081526040808320848452600290810190925291829020825160a0810190935201805492935090918290829061125d906126d7565b80601f0160208091040260200160405190810160405280929190818152602001828054611289906126d7565b80156112d65780601f106112ab576101008083540402835291602001916112d6565b820191906000526020600020905b8154815290600101906020018083116112b957829003601f168201915b50505050508152602001600182015481526020016002820180546112f9906126d7565b80601f0160208091040260200160405190810160405280929190818152602001828054611325906126d7565b80156113725780601f1061134757610100808354040283529160200191611372565b820191906000526020600020905b81548152906001019060200180831161135557829003601f168201915b5050509183525050600382015460208201526004909101546001600160a01b031660409091015284518590849081106113ad576113ad612712565b6020908102919091010152506113c46001826126bf565b90506111eb565b5050919050565b60606000805b6002548110156114d6576000818152600560209081526040808320815180830190925280546001600160a01b03168252600181018054929391929184019161141f906126d7565b80601f016020809104026020016040519081016040528092919081815260200182805461144b906126d7565b80156114985780601f1061146d57610100808354040283529160200191611498565b820191906000526020600020905b81548152906001019060200180831161147b57829003601f168201915b5050509190925250508151919250506001600160a01b0316156114c3576114c06001846126bf565b92505b506114cf6001826126bf565b90506113d8565b508067ffffffffffffffff8111156114f0576114f061220f565b60405190808252806020026020018201604052801561154a57816020015b6040805160a0810182526060808252600060208084018290529383018290529082018190526080820152825260001990920191018161150e5790505b50915060005b818110156117e7576000818152600560209081526040808320815180830190925280546001600160a01b031682526001810180549293919291840191611595906126d7565b80601f01602080910402602001604051908101604052809291908181526020018280546115c1906126d7565b801561160e5780601f106115e35761010080835404028352916020019161160e565b820191906000526020600020905b8154815290600101906020018083116115f157829003601f168201915b5050509190925250508151919250506001600160a01b0316156117d45780516001600160a01b03166000908152600660209081526040808320828501518051908401208452600290810190925291829020825160a0810190935201805482908290611678906126d7565b80601f01602080910402602001604051908101604052809291908181526020018280546116a4906126d7565b80156116f15780601f106116c6576101008083540402835291602001916116f1565b820191906000526020600020905b8154815290600101906020018083116116d457829003601f168201915b5050505050815260200160018201548152602001600282018054611714906126d7565b80601f0160208091040260200160405190810160405280929190818152602001828054611740906126d7565b801561178d5780601f106117625761010080835404028352916020019161178d565b820191906000526020600020905b81548152906001019060200180831161177057829003601f168201915b5050509183525050600382015460208201526004909101546001600160a01b031660409091015284518590849081106117c8576117c8612712565b60200260200101819052505b506117e06001826126bf565b9050611550565b505090565b6117f96000610388611ae0565b6118395760405162461bcd60e51b81526020600482015260116024820152703ab730b8383937bb32b21031b0b63632b960791b6044820152606401610532565b6003805460ff19168215159081179091556040519081527f0e2fb031ee032dc02d8011dc50b816eb450cf856abd8261680dac74f72165bd29060200160405180910390a150565b600081815260016020526040812061048e90611bf5565b6000828152602081905260409020600101546118b581610aa9611ae0565b610ab88383611ba2565b600280549060019060006118d383856126bf565b909155505081516020808401919091206040805180820182526001600160a01b03878116808352828601888152600091825260068752848220868352600201875284822088905587825260058752939020825181546001600160a01b03191692169190911781559151805193949193849392611956926001850192910190612130565b50506040516119679150859061268d565b604051908190038120906001600160a01b038716907f67c52f1a5ffa258663904eb8850e0dc217b6532579cd12cc3e3c9d167ff68d1190600090a35050505050565b60007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03163314156119e9575060131936013560601c90565b503390565b905090565b3390565b6000828152602081815260408083206001600160a01b038516845290915290205460ff16610b55576000828152602081815260408083206001600160a01b03851684529091529020805460ff19166001179055611a52611ae0565b6001600160a01b0316816001600160a01b0316837f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45050565b6000610fa1836001600160a01b038416611bff565b60006001600160e01b03198216637965db0b60e01b148061048e57506301ffc9a760e01b6001600160e01b031983161461048e565b60006119ee6119a9565b6000610fa18383611c4e565b6000610fa18383611bff565b6000828152602081815260408083206001600160a01b038516845290915290205460ff16610b5557611b3e816001600160a01b03166014611d41565b611b49836020611d41565b604051602001611b5a929190612791565b60408051601f198184030181529082905262461bcd60e51b825261053291600401612812565b611b8a82826119f7565b6000828152600160205260409020610ab89082611a96565b611bac8282611eea565b6000828152600160205260409020610ab89082611f87565b6000610fa18383611f9c565b6060610fa1838360405180606001604052806027815260200161288960279139611fc6565b600061048e825490565b6000818152600183016020526040812054611c465750815460018181018455600084815260208082209093018490558454848252828601909352604090209190915561048e565b50600061048e565b60008181526001830160205260408120548015611d37576000611c72600183612825565b8554909150600090611c8690600190612825565b9050818114611ceb576000866000018281548110611ca657611ca6612712565b9060005260206000200154905080876000018481548110611cc957611cc9612712565b6000918252602080832090910192909255918252600188019052604090208390555b8554869080611cfc57611cfc61283c565b60019003818190600052602060002001600090559055856001016000868152602001908152602001600020600090556001935050505061048e565b600091505061048e565b60606000611d50836002612852565b611d5b9060026126bf565b67ffffffffffffffff811115611d7357611d7361220f565b6040519080825280601f01601f191660200182016040528015611d9d576020820181803683370190505b509050600360fc1b81600081518110611db857611db8612712565b60200101906001600160f81b031916908160001a905350600f60fb1b81600181518110611de757611de7612712565b60200101906001600160f81b031916908160001a9053506000611e0b846002612852565b611e169060016126bf565b90505b6001811115611e9b577f303132333435363738396162636465660000000000000000000000000000000085600f1660108110611e5757611e57612712565b1a60f81b828281518110611e6d57611e6d612712565b60200101906001600160f81b031916908160001a90535060049490941c93611e9481612871565b9050611e19565b508315610fa15760405162461bcd60e51b815260206004820181905260248201527f537472696e67733a20686578206c656e67746820696e73756666696369656e746044820152606401610532565b6000828152602081815260408083206001600160a01b038516845290915290205460ff1615610b55576000828152602081815260408083206001600160a01b03851684529091529020805460ff19169055611f43611ae0565b6001600160a01b0316816001600160a01b0316837ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b60405160405180910390a45050565b6000610fa1836001600160a01b038416611c4e565b6000826000018281548110611fb357611fb3612712565b9060005260206000200154905092915050565b60606001600160a01b0384163b6120455760405162461bcd60e51b815260206004820152602660248201527f416464726573733a2064656c65676174652063616c6c20746f206e6f6e2d636f60448201527f6e747261637400000000000000000000000000000000000000000000000000006064820152608401610532565b600080856001600160a01b031685604051612060919061268d565b600060405180830381855af49150503d806000811461209b576040519150601f19603f3d011682016040523d82523d6000602084013e6120a0565b606091505b50915091506120b08282866120ba565b9695505050505050565b606083156120c9575081610fa1565b8251156120d95782518084602001fd5b8160405162461bcd60e51b81526004016105329190612812565b5080546120ff906126d7565b6000825580601f1061210f575050565b601f01602090049060005260206000209081019061212d91906121b4565b50565b82805461213c906126d7565b90600052602060002090601f01602090048101928261215e57600085556121a4565b82601f1061217757805160ff19168380011785556121a4565b828001600101855582156121a4579182015b828111156121a4578251825591602001919060010190612189565b506121b09291506121b4565b5090565b5b808211156121b057600081556001016121b5565b6000602082840312156121db57600080fd5b81356001600160e01b031981168114610fa157600080fd5b80356001600160a01b038116811461220a57600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b600082601f83011261223657600080fd5b813567ffffffffffffffff808211156122515761225161220f565b604051601f8301601f19908116603f011681019082821181831017156122795761227961220f565b8160405283815286602085880101111561229257600080fd5b836020870160208301376000602085830101528094505050505092915050565b600080604083850312156122c557600080fd5b6122ce836121f3565b9150602083013567ffffffffffffffff8111156122ea57600080fd5b6122f685828601612225565b9150509250929050565b600080600080600060a0868803121561231857600080fd5b612321866121f3565b9450602086013567ffffffffffffffff8082111561233e57600080fd5b61234a89838a01612225565b95506040880135945061235f606089016121f3565b9350608088013591508082111561237557600080fd5b5061238288828901612225565b9150509295509295909350565b6000602082840312156123a157600080fd5b5035919050565b8035801515811461220a57600080fd5b600080604083850312156123cb57600080fd5b6123d4836121f3565b91506123e2602084016123a8565b90509250929050565b600080604083850312156123fe57600080fd5b823591506123e2602084016121f3565b60006020828403121561242057600080fd5b610fa1826121f3565b6000806040838503121561243c57600080fd5b612445836121f3565b91506123e2602084016121f3565b60005b8381101561246e578181015183820152602001612456565b8381111561247d576000848401525b50505050565b6000815180845261249b816020860160208601612453565b601f01601f19169290920160200192915050565b6000815160a084526124c460a0850182612483565b905060208301516020850152604083015184820360408601526124e78282612483565b915050606083015160608501526001600160a01b0360808401511660808501528091505092915050565b602081526000610fa160208301846124af565b6000602080830181845280855180835260408601915060408160051b870101925083870160005b8281101561257957603f198886030184526125678583516124af565b9450928501929085019060010161254b565b5092979650505050505050565b6000806040838503121561259957600080fd5b50508035926020909101359150565b600080602083850312156125bb57600080fd5b823567ffffffffffffffff808211156125d357600080fd5b818501915085601f8301126125e757600080fd5b8135818111156125f657600080fd5b8660208260051b850101111561260b57600080fd5b60209290920196919550909350505050565b6000602080830181845280855180835260408601915060408160051b870101925083870160005b8281101561257957603f19888603018452612660858351612483565b94509285019290850190600101612644565b60006020828403121561268457600080fd5b610fa1826123a8565b6000825161269f818460208701612453565b9190910192915050565b634e487b7160e01b600052601160045260246000fd5b600082198211156126d2576126d26126a9565b500190565b600181811c908216806126eb57607f821691505b6020821081141561270c57634e487b7160e01b600052602260045260246000fd5b50919050565b634e487b7160e01b600052603260045260246000fd5b6000808335601e1984360301811261273f57600080fd5b83018035915067ffffffffffffffff82111561275a57600080fd5b60200191503681900382131561276f57600080fd5b9250929050565b600060001982141561278a5761278a6126a9565b5060010190565b7f416363657373436f6e74726f6c3a206163636f756e74200000000000000000008152600083516127c9816017850160208801612453565b7f206973206d697373696e6720726f6c65200000000000000000000000000000006017918401918201528351612806816028840160208801612453565b01602801949350505050565b602081526000610fa16020830184612483565b600082821015612837576128376126a9565b500390565b634e487b7160e01b600052603160045260246000fd5b600081600019048311821515161561286c5761286c6126a9565b500290565b600081612880576128806126a9565b50600019019056fe416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a164736f6c634300080c000a";
var ws = p2((r6) => r6.length > 1, "isSuperArgs");
var je = class extends ContractFactory {
  constructor(...e6) {
    ws(e6) ? super(...e6) : super(Hn, sr, e6[0]);
  }
  deploy(e6, t6) {
    return super.deploy(e6, t6 || {});
  }
  getDeployTransaction(e6, t6) {
    return super.getDeployTransaction(e6, t6 || {});
  }
  attach(e6) {
    return super.attach(e6);
  }
  connect(e6) {
    return super.connect(e6);
  }
  static createInterface() {
    return new utils_exports.Interface(Hn);
  }
  static connect(e6, t6) {
    return new Contract(e6, Hn, t6);
  }
};
p2(je, "ByocRegistry__factory"), f2(je, "bytecode", sr), f2(je, "abi", Hn);
var Zn = [{ inputs: [], stateMutability: "nonpayable", type: "constructor" }, { inputs: [{ components: [{ internalType: "address", name: "from", type: "address" }, { internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "value", type: "uint256" }, { internalType: "uint256", name: "gas", type: "uint256" }, { internalType: "uint256", name: "nonce", type: "uint256" }, { internalType: "bytes", name: "data", type: "bytes" }], internalType: "struct MinimalForwarder.ForwardRequest", name: "req", type: "tuple" }, { internalType: "bytes", name: "signature", type: "bytes" }], name: "execute", outputs: [{ internalType: "bool", name: "", type: "bool" }, { internalType: "bytes", name: "", type: "bytes" }], stateMutability: "payable", type: "function" }, { inputs: [{ internalType: "address", name: "from", type: "address" }], name: "getNonce", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ components: [{ internalType: "address", name: "from", type: "address" }, { internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "value", type: "uint256" }, { internalType: "uint256", name: "gas", type: "uint256" }, { internalType: "uint256", name: "nonce", type: "uint256" }, { internalType: "bytes", name: "data", type: "bytes" }], internalType: "struct MinimalForwarder.ForwardRequest", name: "req", type: "tuple" }, { internalType: "bytes", name: "signature", type: "bytes" }], name: "verify", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }];
var or = "0x61014060405234801561001157600080fd5b50604080518082018252601081526f26b4b734b6b0b62337b93bb0b93232b960811b602080830191825283518085019094526005845264302e302e3160d81b908401528151902060e08190527fae209a0b48f21c054280f2455d32cf309387644879d9acbd8ffc1991638118856101008190524660a0529192917f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f6100fb8184846040805160208101859052908101839052606081018290524660808201523060a082015260009060c0016040516020818303038152906040528051906020012090509392505050565b6080523060c052610120525061011092505050565b60805160a05160c05160e0516101005161012051610b4061015f60003960006104f701526000610546015260006105210152600061047a015260006104a4015260006104ce0152610b406000f3fe6080604052600436106100345760003560e01c80632d0335ab1461003957806347153f8214610082578063bf5d3bdb146100a3575b600080fd5b34801561004557600080fd5b5061006f610054366004610901565b6001600160a01b031660009081526020819052604090205490565b6040519081526020015b60405180910390f35b610095610090366004610931565b6100d3565b604051610079929190610a00565b3480156100af57600080fd5b506100c36100be366004610931565b610277565b6040519015158152602001610079565b600060606100e2858585610277565b6101595760405162461bcd60e51b815260206004820152603260248201527f4d696e696d616c466f727761726465723a207369676e617475726520646f657360448201527f206e6f74206d617463682072657175657374000000000000000000000000000060648201526084015b60405180910390fd5b61016860808601356001610a3c565b6000806101786020890189610901565b6001600160a01b03166001600160a01b03168152602001908152602001600020819055506000808660200160208101906101b29190610901565b6001600160a01b0316606088013560408901356101d260a08b018b610a62565b6101df60208d018d610901565b6040516020016101f193929190610aa9565b60408051601f198184030181529082905261020b91610acf565b600060405180830381858888f193505050503d8060008114610249576040519150601f19603f3d011682016040523d82523d6000602084013e61024e565b606091505b509092509050610263603f6060890135610aeb565b5a1161026b57fe5b90969095509350505050565b60008061038a84848080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061038492507fdd8f4b70b0f4393e889bd39128a30628a78b61816a9eb8199759e7a349657e4891506102e7905060208a018a610901565b6102f760408b0160208c01610901565b60408b013560608c013560808d013561031360a08f018f610a62565b604051610321929190610b0d565b6040805191829003822060208301989098526001600160a01b0396871690820152949093166060850152608084019190915260a083015260c082015260e081019190915261010001604051602081830303815290604052805190602001206103f5565b90610449565b905060808501356000806103a16020890189610901565b6001600160a01b03166001600160a01b03168152602001908152602001600020541480156103ec57506103d76020860186610901565b6001600160a01b0316816001600160a01b0316145b95945050505050565b600061044361040261046d565b8360405161190160f01b6020820152602281018390526042810182905260009060620160405160208183030381529060405280519060200120905092915050565b92915050565b60008060006104588585610594565b9150915061046581610604565b509392505050565b6000306001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000161480156104c657507f000000000000000000000000000000000000000000000000000000000000000046145b156104f057507f000000000000000000000000000000000000000000000000000000000000000090565b50604080517f00000000000000000000000000000000000000000000000000000000000000006020808301919091527f0000000000000000000000000000000000000000000000000000000000000000828401527f000000000000000000000000000000000000000000000000000000000000000060608301524660808301523060a0808401919091528351808403909101815260c0909201909252805191012090565b6000808251604114156105cb5760208301516040840151606085015160001a6105bf878285856107c2565b945094505050506105fd565b8251604014156105f557602083015160408401516105ea8683836108af565b9350935050506105fd565b506000905060025b9250929050565b600081600481111561061857610618610b1d565b14156106215750565b600181600481111561063557610635610b1d565b14156106835760405162461bcd60e51b815260206004820152601860248201527f45434453413a20696e76616c6964207369676e617475726500000000000000006044820152606401610150565b600281600481111561069757610697610b1d565b14156106e55760405162461bcd60e51b815260206004820152601f60248201527f45434453413a20696e76616c6964207369676e6174757265206c656e677468006044820152606401610150565b60038160048111156106f9576106f9610b1d565b14156107525760405162461bcd60e51b815260206004820152602260248201527f45434453413a20696e76616c6964207369676e6174757265202773272076616c604482015261756560f01b6064820152608401610150565b600481600481111561076657610766610b1d565b14156107bf5760405162461bcd60e51b815260206004820152602260248201527f45434453413a20696e76616c6964207369676e6174757265202776272076616c604482015261756560f01b6064820152608401610150565b50565b6000807f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a08311156107f957506000905060036108a6565b8460ff16601b1415801561081157508460ff16601c14155b1561082257506000905060046108a6565b6040805160008082526020820180845289905260ff881692820192909252606081018690526080810185905260019060a0016020604051602081039080840390855afa158015610876573d6000803e3d6000fd5b5050604051601f1901519150506001600160a01b03811661089f576000600192509250506108a6565b9150600090505b94509492505050565b6000807f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8316816108e560ff86901c601b610a3c565b90506108f3878288856107c2565b935093505050935093915050565b60006020828403121561091357600080fd5b81356001600160a01b038116811461092a57600080fd5b9392505050565b60008060006040848603121561094657600080fd5b833567ffffffffffffffff8082111561095e57600080fd5b9085019060c0828803121561097257600080fd5b9093506020850135908082111561098857600080fd5b818601915086601f83011261099c57600080fd5b8135818111156109ab57600080fd5b8760208285010111156109bd57600080fd5b6020830194508093505050509250925092565b60005b838110156109eb5781810151838201526020016109d3565b838111156109fa576000848401525b50505050565b82151581526040602082015260008251806040840152610a278160608501602087016109d0565b601f01601f1916919091016060019392505050565b60008219821115610a5d57634e487b7160e01b600052601160045260246000fd5b500190565b6000808335601e19843603018112610a7957600080fd5b83018035915067ffffffffffffffff821115610a9457600080fd5b6020019150368190038213156105fd57600080fd5b8284823760609190911b6bffffffffffffffffffffffff19169101908152601401919050565b60008251610ae18184602087016109d0565b9190910192915050565b600082610b0857634e487b7160e01b600052601260045260246000fd5b500490565b8183823760009101908152919050565b634e487b7160e01b600052602160045260246000fdfea164736f6c634300080c000a";
var Ms = p2((r6) => r6.length > 1, "isSuperArgs");
var Ye = class extends ContractFactory {
  constructor(...e6) {
    Ms(e6) ? super(...e6) : super(Zn, or, e6[0]);
  }
  deploy(e6) {
    return super.deploy(e6 || {});
  }
  getDeployTransaction(e6) {
    return super.getDeployTransaction(e6 || {});
  }
  attach(e6) {
    return super.attach(e6);
  }
  connect(e6) {
    return super.connect(e6);
  }
  static createInterface() {
    return new utils_exports.Interface(Zn);
  }
  static connect(e6, t6) {
    return new Contract(e6, Zn, t6);
  }
};
p2(Ye, "Forwarder__factory"), f2(Ye, "bytecode", or), f2(Ye, "abi", Zn);
var ja = [{ anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "owner", type: "address" }, { indexed: true, internalType: "address", name: "spender", type: "address" }, { indexed: false, internalType: "uint256", name: "value", type: "uint256" }], name: "Approval", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "from", type: "address" }, { indexed: true, internalType: "address", name: "to", type: "address" }, { indexed: false, internalType: "uint256", name: "value", type: "uint256" }], name: "Transfer", type: "event" }, { inputs: [{ internalType: "address", name: "owner", type: "address" }, { internalType: "address", name: "spender", type: "address" }], name: "allowance", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "spender", type: "address" }, { internalType: "uint256", name: "value", type: "uint256" }], name: "approve", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "who", type: "address" }], name: "balanceOf", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "totalSupply", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "value", type: "uint256" }], name: "transfer", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "from", type: "address" }, { internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "value", type: "uint256" }], name: "transferFrom", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }];
var rt = class {
  static createInterface() {
    return new utils_exports.Interface(ja);
  }
  static connect(e6, t6) {
    return new Contract(e6, ja, t6);
  }
};
p2(rt, "IERC20__factory"), f2(rt, "abi", ja);
var Ya = [{ inputs: [], name: "contractType", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "pure", type: "function" }, { inputs: [], name: "contractURI", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [], name: "contractVersion", outputs: [{ internalType: "uint8", name: "", type: "uint8" }], stateMutability: "pure", type: "function" }, { inputs: [{ internalType: "string", name: "_uri", type: "string" }], name: "setContractURI", outputs: [], stateMutability: "nonpayable", type: "function" }];
var it = class {
  static createInterface() {
    return new utils_exports.Interface(Ya);
  }
  static connect(e6, t6) {
    return new Contract(e6, Ya, t6);
  }
};
p2(it, "IThirdwebContract__factory"), f2(it, "abi", Ya);
var jn = [{ inputs: [{ internalType: "address", name: "_trustedForwarder", type: "address" }, { internalType: "address", name: "_registry", type: "address" }], stateMutability: "nonpayable", type: "constructor" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "implementation", type: "address" }, { indexed: true, internalType: "bytes32", name: "contractType", type: "bytes32" }, { indexed: false, internalType: "uint256", name: "version", type: "uint256" }], name: "ImplementationAdded", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "implementation", type: "address" }, { indexed: false, internalType: "bool", name: "isApproved", type: "bool" }], name: "ImplementationApproved", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "implementation", type: "address" }, { indexed: false, internalType: "address", name: "proxy", type: "address" }, { indexed: true, internalType: "address", name: "deployer", type: "address" }], name: "ProxyDeployed", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "role", type: "bytes32" }, { indexed: true, internalType: "bytes32", name: "previousAdminRole", type: "bytes32" }, { indexed: true, internalType: "bytes32", name: "newAdminRole", type: "bytes32" }], name: "RoleAdminChanged", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "role", type: "bytes32" }, { indexed: true, internalType: "address", name: "account", type: "address" }, { indexed: true, internalType: "address", name: "sender", type: "address" }], name: "RoleGranted", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "role", type: "bytes32" }, { indexed: true, internalType: "address", name: "account", type: "address" }, { indexed: true, internalType: "address", name: "sender", type: "address" }], name: "RoleRevoked", type: "event" }, { inputs: [], name: "DEFAULT_ADMIN_ROLE", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "view", type: "function" }, { inputs: [], name: "FACTORY_ROLE", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_implementation", type: "address" }], name: "addImplementation", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "", type: "address" }], name: "approval", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_implementation", type: "address" }, { internalType: "bool", name: "_toApprove", type: "bool" }], name: "approveImplementation", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], name: "currentVersion", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "_type", type: "bytes32" }, { internalType: "bytes", name: "_data", type: "bytes" }], name: "deployProxy", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_implementation", type: "address" }, { internalType: "bytes", name: "_data", type: "bytes" }, { internalType: "bytes32", name: "_salt", type: "bytes32" }], name: "deployProxyByImplementation", outputs: [{ internalType: "address", name: "deployedProxy", type: "address" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes32", name: "_type", type: "bytes32" }, { internalType: "bytes", name: "_data", type: "bytes" }, { internalType: "bytes32", name: "_salt", type: "bytes32" }], name: "deployProxyDeterministic", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "", type: "address" }], name: "deployer", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "_type", type: "bytes32" }, { internalType: "uint256", name: "_version", type: "uint256" }], name: "getImplementation", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "_type", type: "bytes32" }], name: "getLatestImplementation", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }], name: "getRoleAdmin", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "uint256", name: "index", type: "uint256" }], name: "getRoleMember", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }], name: "getRoleMemberCount", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "grantRole", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "hasRole", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "", type: "bytes32" }, { internalType: "uint256", name: "", type: "uint256" }], name: "implementation", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "forwarder", type: "address" }], name: "isTrustedForwarder", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes[]", name: "data", type: "bytes[]" }], name: "multicall", outputs: [{ internalType: "bytes[]", name: "results", type: "bytes[]" }], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "registry", outputs: [{ internalType: "contract TWRegistry", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "renounceRole", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "revokeRole", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }], name: "supportsInterface", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }];
var pr = "0x60c06040523480156200001157600080fd5b5060405162001f6738038062001f67833981016040819052620000349162000276565b6001600160a01b0382166080526200005760006200005162000099565b620000b5565b620000867fdfbefbf47cfe66b701d8cfdbce1de81c821590819cb07e71cb01b6602fb0ee276200005162000099565b6001600160a01b031660a05250620002ae565b6000620000b0620000c560201b62000d211760201c565b905090565b620000c18282620000fe565b5050565b6080516000906001600160a01b0316331415620000e9575060131936013560601c90565b620000b06200014160201b62000d6b1760201c565b6200011582826200014560201b62000d6f1760201c565b60008281526001602090815260409091206200013c91839062000e0e620001e7821b17901c565b505050565b3390565b6000828152602081815260408083206001600160a01b038516845290915290205460ff16620000c1576000828152602081815260408083206001600160a01b03851684529091529020805460ff19166001179055620001a362000099565b6001600160a01b0316816001600160a01b0316837f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45050565b6000620001fe836001600160a01b03841662000207565b90505b92915050565b6000818152600183016020526040812054620002505750815460018181018455600084815260208082209093018490558454848252828601909352604090209190915562000201565b50600062000201565b80516001600160a01b03811681146200027157600080fd5b919050565b600080604083850312156200028a57600080fd5b620002958362000259565b9150620002a56020840162000259565b90509250929050565b60805160a051611c7e620002e960003960008181610336015281816106510152610c6f0152600081816103010152610d250152611c7e6000f3fe608060405234801561001057600080fd5b50600436106101985760003560e01c80639010d07c116100e3578063c6e2a4001161008c578063dd47595a11610066578063dd47595a1461044f578063e92016a414610483578063ec54d72f146104b757600080fd5b8063c6e2a40014610416578063ca15c87314610429578063d547741f1461043c57600080fd5b8063a217fddf116100bd578063a217fddf146103c5578063ac9650d8146103cd578063b9caf9d9146103ed57600080fd5b80639010d07c1461035857806391d148541461036b5780639430b496146103a257600080fd5b806336568abe1161014557806356fb09581161011f57806356fb0958146102de578063572b6c05146102f15780637b1039991461033157600080fd5b806336568abe146102705780633b426d3f1461028357806344ab6680146102a357600080fd5b80631e5e1e99116101765780631e5e1e9914610225578063248a9ca3146102385780632f2ff15d1461025b57600080fd5b806301ffc9a71461019d57806304a0fb17146101c557806311b804ab146101fa575b600080fd5b6101b06101ab3660046116a3565b6104ca565b60405190151581526020015b60405180910390f35b6101ec7fdfbefbf47cfe66b701d8cfdbce1de81c821590819cb07e71cb01b6602fb0ee2781565b6040519081526020016101bc565b61020d61020836600461178c565b6104f5565b6040516001600160a01b0390911681526020016101bc565b61020d6102333660046117e3565b610705565b6101ec610246366004611816565b60009081526020819052604090206001015490565b61026e61026936600461182f565b610745565b005b61026e61027e36600461182f565b610777565b6101ec610291366004611816565b60036020526000908152604090205481565b61020d6102b1366004611816565b6000908152600460209081526040808320600383528184205484529091529020546001600160a01b031690565b61026e6102ec36600461185b565b610813565b6101b06102ff366004611897565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0390811691161490565b61020d7f000000000000000000000000000000000000000000000000000000000000000081565b61020d6103663660046118b2565b6108db565b6101b061037936600461182f565b6000918252602082815260408084206001600160a01b0393909316845291905290205460ff1690565b6101b06103b0366004611897565b60026020526000908152604090205460ff1681565b6101ec600081565b6103e06103db3660046118d4565b6108f3565b6040516101bc91906119a5565b61020d6103fb366004611897565b6005602052600090815260409020546001600160a01b031681565b61026e610424366004611897565b6109e8565b6101ec610437366004611816565b610c2b565b61026e61044a36600461182f565b610c42565b61020d61045d3660046118b2565b60009182526004602090815260408084209284529190529020546001600160a01b031690565b61020d6104913660046118b2565b60046020908152600092835260408084209091529082529020546001600160a01b031681565b61020d6104c5366004611a07565b610c6a565b60006001600160e01b03198216635a05180f60e01b14806104ef57506104ef82610e23565b92915050565b6001600160a01b03831660009081526002602052604081205460ff166105625760405162461bcd60e51b815260206004820152601b60248201527f696d706c656d656e746174696f6e206e6f7420617070726f766564000000000060448201526064015b60405180910390fd5b600061056c610e58565b8360405160200161059b92919060609290921b6bffffffffffffffffffffffff19168252601482015260340190565b6040516020818303038152906040528051906020012090506105bd8582610e62565b91506105c7610e58565b6001600160a01b038381166000908152600560205260409020805473ffffffffffffffffffffffffffffffffffffffff19169290911691909117905561060b610e58565b6040516001600160a01b038481168252918216918716907f9e0862c4ebff2150fbbfd3f8547483f55bdec0c34fd977d3fccaa55d6c4ce7849060200160405180910390a37f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166352c28fab610686610e58565b6040516001600160e01b031960e084901b1681526001600160a01b0391821660048201529085166024820152604401600060405180830381600087803b1580156106cf57600080fd5b505af11580156106e3573d6000803e3d6000fd5b505050506000845111156106fd576106fb8285610f19565b505b509392505050565b6000838152600460209081526040808320600383528184205484529091528120546001600160a01b031661073a8185856104f5565b9150505b9392505050565b60008281526020819052604090206001015461076881610763610e58565b610f5b565b6107728383610fd9565b505050565b61077f610e58565b6001600160a01b0316816001600160a01b0316146108055760405162461bcd60e51b815260206004820152602f60248201527f416363657373436f6e74726f6c3a2063616e206f6e6c792072656e6f756e636560448201527f20726f6c657320666f722073656c6600000000000000000000000000000000006064820152608401610559565b61080f8282610ffb565b5050565b61083f7fdfbefbf47cfe66b701d8cfdbce1de81c821590819cb07e71cb01b6602fb0ee27610379610e58565b6108785760405162461bcd60e51b815260206004820152600a6024820152693737ba1030b236b4b71760b11b6044820152606401610559565b6001600160a01b038216600081815260026020908152604091829020805460ff19168515159081179091558251938452908301527f46c2f0868ef35772e9324a42eb6fa484490cca8494538a909cf05c897d7d4108910160405180910390a15050565b600082815260016020526040812061073e908361101d565b60608167ffffffffffffffff81111561090e5761090e6116e9565b60405190808252806020026020018201604052801561094157816020015b606081526020019060019003908161092c5790505b50905060005b828110156109e1576109b13085858481811061096557610965611a4e565b90506020028101906109779190611a64565b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061102992505050565b8282815181106109c3576109c3611a4e565b602002602001018190525080806109d990611ac8565b915050610947565b5092915050565b610a147fdfbefbf47cfe66b701d8cfdbce1de81c821590819cb07e71cb01b6602fb0ee27610379610e58565b610a4d5760405162461bcd60e51b815260206004820152600a6024820152693737ba1030b236b4b71760b11b6044820152606401610559565b60008190506000816001600160a01b031663cb2ef6f76040518163ffffffff1660e01b8152600401602060405180830381865afa158015610a92573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ab69190611ae3565b90506000826001600160a01b031663a0a8e4606040518163ffffffff1660e01b8152600401602060405180830381865afa158015610af8573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b1c9190611afc565b60008381526003602052604090205490915060ff8082169083161015610b845760405162461bcd60e51b815260206004820152601460248201527f77726f6e67206d6f64756c652076657273696f6e0000000000000000000000006044820152606401610559565b600083815260036020908152604080832060ff861690819055600483528184208185528352818420805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b038b169081179091558085526002845293829020805460ff1916600117905581519384529183019190915284917fc39db2d47bafbb20367a9c840abffa57a2bc243c1f1e67c939ea0e89e59ed01a910160405180910390a25050505050565b60008181526001602052604081206104ef9061104e565b600082815260208190526040902060010154610c6081610763610e58565b6107728383610ffb565b6000807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166305d85eda610ca4610e58565b6040516001600160e01b031960e084901b1681526001600160a01b039091166004820152602401602060405180830381865afa158015610ce8573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d0c9190611ae3565b9050610d19848483610705565b949350505050565b60007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316331415610d61575060131936013560601c90565b503390565b905090565b3390565b6000828152602081815260408083206001600160a01b038516845290915290205460ff1661080f576000828152602081815260408083206001600160a01b03851684529091529020805460ff19166001179055610dca610e58565b6001600160a01b0316816001600160a01b0316837f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45050565b600061073e836001600160a01b038416611058565b60006001600160e01b03198216637965db0b60e01b14806104ef57506301ffc9a760e01b6001600160e01b03198316146104ef565b6000610d66610d21565b60006040517f3d602d80600a3d3981f3363d3d373d3d3d363d7300000000000000000000000081528360601b60148201527f5af43d82803e903d91602b57fd5bf300000000000000000000000000000000006028820152826037826000f59150506001600160a01b0381166104ef5760405162461bcd60e51b815260206004820152601760248201527f455243313136373a2063726561746532206661696c65640000000000000000006044820152606401610559565b606061073e83836040518060400160405280601e81526020017f416464726573733a206c6f772d6c6576656c2063616c6c206661696c656400008152506110a7565b6000828152602081815260408083206001600160a01b038516845290915290205460ff1661080f57610f97816001600160a01b031660146110b6565b610fa28360206110b6565b604051602001610fb3929190611b1f565b60408051601f198184030181529082905262461bcd60e51b825261055991600401611ba0565b610fe38282610d6f565b60008281526001602052604090206107729082610e0e565b611005828261125f565b600082815260016020526040902061077290826112fc565b600061073e8383611311565b606061073e8383604051806060016040528060278152602001611c4b6027913961133b565b60006104ef825490565b600081815260018301602052604081205461109f575081546001818101845560008481526020808220909301849055845484825282860190935260409020919091556104ef565b5060006104ef565b6060610d19848460008561142f565b606060006110c5836002611bb3565b6110d0906002611bd2565b67ffffffffffffffff8111156110e8576110e86116e9565b6040519080825280601f01601f191660200182016040528015611112576020820181803683370190505b509050600360fc1b8160008151811061112d5761112d611a4e565b60200101906001600160f81b031916908160001a905350600f60fb1b8160018151811061115c5761115c611a4e565b60200101906001600160f81b031916908160001a9053506000611180846002611bb3565b61118b906001611bd2565b90505b6001811115611210577f303132333435363738396162636465660000000000000000000000000000000085600f16601081106111cc576111cc611a4e565b1a60f81b8282815181106111e2576111e2611a4e565b60200101906001600160f81b031916908160001a90535060049490941c9361120981611bea565b905061118e565b50831561073e5760405162461bcd60e51b815260206004820181905260248201527f537472696e67733a20686578206c656e67746820696e73756666696369656e746044820152606401610559565b6000828152602081815260408083206001600160a01b038516845290915290205460ff161561080f576000828152602081815260408083206001600160a01b03851684529091529020805460ff191690556112b8610e58565b6001600160a01b0316816001600160a01b0316837ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b60405160405180910390a45050565b600061073e836001600160a01b038416611577565b600082600001828154811061132857611328611a4e565b9060005260206000200154905092915050565b60606001600160a01b0384163b6113ba5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a2064656c65676174652063616c6c20746f206e6f6e2d636f60448201527f6e747261637400000000000000000000000000000000000000000000000000006064820152608401610559565b600080856001600160a01b0316856040516113d59190611c01565b600060405180830381855af49150503d8060008114611410576040519150601f19603f3d011682016040523d82523d6000602084013e611415565b606091505b509150915061142582828661166a565b9695505050505050565b6060824710156114a75760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f60448201527f722063616c6c00000000000000000000000000000000000000000000000000006064820152608401610559565b6001600160a01b0385163b6114fe5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401610559565b600080866001600160a01b0316858760405161151a9190611c01565b60006040518083038185875af1925050503d8060008114611557576040519150601f19603f3d011682016040523d82523d6000602084013e61155c565b606091505b509150915061156c82828661166a565b979650505050505050565b6000818152600183016020526040812054801561166057600061159b600183611c1d565b85549091506000906115af90600190611c1d565b90508181146116145760008660000182815481106115cf576115cf611a4e565b90600052602060002001549050808760000184815481106115f2576115f2611a4e565b6000918252602080832090910192909255918252600188019052604090208390555b855486908061162557611625611c34565b6001900381819060005260206000200160009055905585600101600086815260200190815260200160002060009055600193505050506104ef565b60009150506104ef565b6060831561167957508161073e565b8251156116895782518084602001fd5b8160405162461bcd60e51b81526004016105599190611ba0565b6000602082840312156116b557600080fd5b81356001600160e01b03198116811461073e57600080fd5b80356001600160a01b03811681146116e457600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b600082601f83011261171057600080fd5b813567ffffffffffffffff8082111561172b5761172b6116e9565b604051601f8301601f19908116603f01168101908282118183101715611753576117536116e9565b8160405283815286602085880101111561176c57600080fd5b836020870160208301376000602085830101528094505050505092915050565b6000806000606084860312156117a157600080fd5b6117aa846116cd565b9250602084013567ffffffffffffffff8111156117c657600080fd5b6117d2868287016116ff565b925050604084013590509250925092565b6000806000606084860312156117f857600080fd5b83359250602084013567ffffffffffffffff8111156117c657600080fd5b60006020828403121561182857600080fd5b5035919050565b6000806040838503121561184257600080fd5b82359150611852602084016116cd565b90509250929050565b6000806040838503121561186e57600080fd5b611877836116cd565b91506020830135801515811461188c57600080fd5b809150509250929050565b6000602082840312156118a957600080fd5b61073e826116cd565b600080604083850312156118c557600080fd5b50508035926020909101359150565b600080602083850312156118e757600080fd5b823567ffffffffffffffff808211156118ff57600080fd5b818501915085601f83011261191357600080fd5b81358181111561192257600080fd5b8660208260051b850101111561193757600080fd5b60209290920196919550909350505050565b60005b8381101561196457818101518382015260200161194c565b83811115611973576000848401525b50505050565b60008151808452611991816020860160208601611949565b601f01601f19169290920160200192915050565b6000602080830181845280855180835260408601915060408160051b870101925083870160005b828110156119fa57603f198886030184526119e8858351611979565b945092850192908501906001016119cc565b5092979650505050505050565b60008060408385031215611a1a57600080fd5b82359150602083013567ffffffffffffffff811115611a3857600080fd5b611a44858286016116ff565b9150509250929050565b634e487b7160e01b600052603260045260246000fd5b6000808335601e19843603018112611a7b57600080fd5b83018035915067ffffffffffffffff821115611a9657600080fd5b602001915036819003821315611aab57600080fd5b9250929050565b634e487b7160e01b600052601160045260246000fd5b6000600019821415611adc57611adc611ab2565b5060010190565b600060208284031215611af557600080fd5b5051919050565b600060208284031215611b0e57600080fd5b815160ff8116811461073e57600080fd5b7f416363657373436f6e74726f6c3a206163636f756e7420000000000000000000815260008351611b57816017850160208801611949565b7f206973206d697373696e6720726f6c65200000000000000000000000000000006017918401918201528351611b94816028840160208801611949565b01602801949350505050565b60208152600061073e6020830184611979565b6000816000190483118215151615611bcd57611bcd611ab2565b500290565b60008219821115611be557611be5611ab2565b500190565b600081611bf957611bf9611ab2565b506000190190565b60008251611c13818460208701611949565b9190910192915050565b600082821015611c2f57611c2f611ab2565b500390565b634e487b7160e01b600052603160045260246000fdfe416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a164736f6c634300080c000a";
var Ps = p2((r6) => r6.length > 1, "isSuperArgs");
var Qe = class extends ContractFactory {
  constructor(...e6) {
    Ps(e6) ? super(...e6) : super(jn, pr, e6[0]);
  }
  deploy(e6, t6, n4) {
    return super.deploy(e6, t6, n4 || {});
  }
  getDeployTransaction(e6, t6, n4) {
    return super.getDeployTransaction(e6, t6, n4 || {});
  }
  attach(e6) {
    return super.attach(e6);
  }
  connect(e6) {
    return super.connect(e6);
  }
  static createInterface() {
    return new utils_exports.Interface(jn);
  }
  static connect(e6, t6) {
    return new Contract(e6, jn, t6);
  }
};
p2(Qe, "TWFactory__factory"), f2(Qe, "bytecode", pr), f2(Qe, "abi", jn);
var Yn = [{ inputs: [{ internalType: "address", name: "_trustedForwarder", type: "address" }], stateMutability: "nonpayable", type: "constructor" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "deployer", type: "address" }, { indexed: true, internalType: "address", name: "deployment", type: "address" }], name: "Added", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "deployer", type: "address" }, { indexed: true, internalType: "address", name: "deployment", type: "address" }], name: "Deleted", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "role", type: "bytes32" }, { indexed: true, internalType: "bytes32", name: "previousAdminRole", type: "bytes32" }, { indexed: true, internalType: "bytes32", name: "newAdminRole", type: "bytes32" }], name: "RoleAdminChanged", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "role", type: "bytes32" }, { indexed: true, internalType: "address", name: "account", type: "address" }, { indexed: true, internalType: "address", name: "sender", type: "address" }], name: "RoleGranted", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "role", type: "bytes32" }, { indexed: true, internalType: "address", name: "account", type: "address" }, { indexed: true, internalType: "address", name: "sender", type: "address" }], name: "RoleRevoked", type: "event" }, { inputs: [], name: "DEFAULT_ADMIN_ROLE", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "view", type: "function" }, { inputs: [], name: "OPERATOR_ROLE", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_deployer", type: "address" }, { internalType: "address", name: "_deployment", type: "address" }], name: "add", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_deployer", type: "address" }], name: "count", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_deployer", type: "address" }], name: "getAll", outputs: [{ internalType: "address[]", name: "", type: "address[]" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }], name: "getRoleAdmin", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "uint256", name: "index", type: "uint256" }], name: "getRoleMember", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }], name: "getRoleMemberCount", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "grantRole", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "hasRole", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "forwarder", type: "address" }], name: "isTrustedForwarder", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes[]", name: "data", type: "bytes[]" }], name: "multicall", outputs: [{ internalType: "bytes[]", name: "results", type: "bytes[]" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_deployer", type: "address" }, { internalType: "address", name: "_deployment", type: "address" }], name: "remove", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "renounceRole", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }, { internalType: "address", name: "account", type: "address" }], name: "revokeRole", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }], name: "supportsInterface", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }];
var yr = "0x60a06040523480156200001157600080fd5b50604051620016b4380380620016b483398101604081905262000034916200021e565b6001600160a01b038116608052620000576000620000516200005e565b6200007a565b5062000250565b6000620000756200008a60201b6200082e1760201c565b905090565b620000868282620000c3565b5050565b6080516000906001600160a01b0316331415620000ae575060131936013560601c90565b620000756200010660201b620008781760201c565b620000da82826200010a60201b6200087c1760201c565b6000828152600160209081526040909120620001019183906200091b620001ac821b17901c565b505050565b3390565b6000828152602081815260408083206001600160a01b038516845290915290205460ff1662000086576000828152602081815260408083206001600160a01b03851684529091529020805460ff19166001179055620001686200005e565b6001600160a01b0316816001600160a01b0316837f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45050565b6000620001c3836001600160a01b038416620001cc565b90505b92915050565b60008181526001830160205260408120546200021557508154600181810184556000848152602080822090930184905584548482528286019093526040902091909155620001c6565b506000620001c6565b6000602082840312156200023157600080fd5b81516001600160a01b03811681146200024957600080fd5b9392505050565b60805161144162000273600039600081816101bc015261083201526114416000f3fe608060405234801561001057600080fd5b50600436106101005760003560e01c80639010d07c11610097578063ca15c87311610066578063ca15c87314610289578063d547741f1461029c578063eb077342146102af578063f5b541a6146102cf57600080fd5b80639010d07c146101ff57806391d148541461022a578063a217fddf14610261578063ac9650d81461026957600080fd5b806336568abe116100d357806336568abe1461018657806352c28fab14610199578063572b6c05146101ac5780637f7c1491146101ec57600080fd5b806301ffc9a71461010557806305d85eda1461012d578063248a9ca31461014e5780632f2ff15d14610171575b600080fd5b610118610113366004610fc5565b6102f6565b60405190151581526020015b60405180910390f35b61014061013b36600461100b565b610321565b604051908152602001610124565b61014061015c366004611026565b60009081526020819052604090206001015490565b61018461017f36600461103f565b610342565b005b61018461019436600461103f565b610374565b6101846101a736600461106b565b610415565b6101186101ba36600461100b565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0390811691161490565b6101846101fa36600461106b565b610566565b61021261020d366004611095565b6106b7565b6040516001600160a01b039091168152602001610124565b61011861023836600461103f565b6000918252602082815260408084206001600160a01b0393909316845291905290205460ff1690565b610140600081565b61027c6102773660046110b7565b6106d6565b6040516101249190611188565b610140610297366004611026565b6107cb565b6101846102aa36600461103f565b6107e2565b6102c26102bd36600461100b565b61080a565b60405161012491906111ea565b6101407f97667070c54ef182b0f5858b034beac1b6f3089aa2d3188bb1e8929f4fa9b92981565b60006001600160e01b03198216635a05180f60e01b148061031b575061031b82610930565b92915050565b6001600160a01b038116600090815260026020526040812061031b90610965565b6000828152602081905260409020600101546103658161036061096f565b610979565b61036f83836109f7565b505050565b61037c61096f565b6001600160a01b0316816001600160a01b0316146104075760405162461bcd60e51b815260206004820152602f60248201527f416363657373436f6e74726f6c3a2063616e206f6e6c792072656e6f756e636560448201527f20726f6c657320666f722073656c66000000000000000000000000000000000060648201526084015b60405180910390fd5b6104118282610a19565b5050565b6104417f97667070c54ef182b0f5858b034beac1b6f3089aa2d3188bb1e8929f4fa9b92961023861096f565b80610464575061044f61096f565b6001600160a01b0316826001600160a01b0316145b6104b05760405162461bcd60e51b815260206004820152601960248201527f6e6f74206f70657261746f72206f72206465706c6f7965722e0000000000000060448201526064016103fe565b6001600160a01b03821660009081526002602052604081206104d2908361091b565b9050806105215760405162461bcd60e51b815260206004820152600d60248201527f6661696c656420746f206164640000000000000000000000000000000000000060448201526064016103fe565b816001600160a01b0316836001600160a01b03167f938c63ac3d228b23f6bee7618fefc6790522e338ac202c958a2ea9eb9706c5d160405160405180910390a3505050565b6105927f97667070c54ef182b0f5858b034beac1b6f3089aa2d3188bb1e8929f4fa9b92961023861096f565b806105b557506105a061096f565b6001600160a01b0316826001600160a01b0316145b6106015760405162461bcd60e51b815260206004820152601960248201527f6e6f74206f70657261746f72206f72206465706c6f7965722e0000000000000060448201526064016103fe565b6001600160a01b03821660009081526002602052604081206106239083610a37565b9050806106725760405162461bcd60e51b815260206004820152601060248201527f6661696c656420746f2072656d6f76650000000000000000000000000000000060448201526064016103fe565b816001600160a01b0316836001600160a01b03167ffc5ffe2160301e6b21a86f66febb30fe4e9e6932ac1afc0348fb2fd5daa18b1360405160405180910390a3505050565b60008281526001602052604081206106cf9083610a4c565b9392505050565b60608167ffffffffffffffff8111156106f1576106f1611237565b60405190808252806020026020018201604052801561072457816020015b606081526020019060019003908161070f5790505b50905060005b828110156107c457610794308585848181106107485761074861124d565b905060200281019061075a9190611263565b8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250610a5892505050565b8282815181106107a6576107a661124d565b602002602001018190525080806107bc906112c7565b91505061072a565b5092915050565b600081815260016020526040812061031b90610965565b6000828152602081905260409020600101546108008161036061096f565b61036f8383610a19565b6001600160a01b038116600090815260026020526040902060609061031b90610a7d565b60007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031633141561086e575060131936013560601c90565b503390565b905090565b3390565b6000828152602081815260408083206001600160a01b038516845290915290205460ff16610411576000828152602081815260408083206001600160a01b03851684529091529020805460ff191660011790556108d761096f565b6001600160a01b0316816001600160a01b0316837f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45050565b60006106cf836001600160a01b038416610a8a565b60006001600160e01b03198216637965db0b60e01b148061031b57506301ffc9a760e01b6001600160e01b031983161461031b565b600061031b825490565b600061087361082e565b6000828152602081815260408083206001600160a01b038516845290915290205460ff16610411576109b5816001600160a01b03166014610ad9565b6109c0836020610ad9565b6040516020016109d19291906112e2565b60408051601f198184030181529082905262461bcd60e51b82526103fe91600401611363565b610a01828261087c565b600082815260016020526040902061036f908261091b565b610a238282610c82565b600082815260016020526040902061036f90825b60006106cf836001600160a01b038416610d1f565b60006106cf8383610e12565b60606106cf838360405180606001604052806027815260200161140e60279139610e3c565b606060006106cf83610f30565b6000818152600183016020526040812054610ad15750815460018181018455600084815260208082209093018490558454848252828601909352604090209190915561031b565b50600061031b565b60606000610ae8836002611376565b610af3906002611395565b67ffffffffffffffff811115610b0b57610b0b611237565b6040519080825280601f01601f191660200182016040528015610b35576020820181803683370190505b509050600360fc1b81600081518110610b5057610b5061124d565b60200101906001600160f81b031916908160001a905350600f60fb1b81600181518110610b7f57610b7f61124d565b60200101906001600160f81b031916908160001a9053506000610ba3846002611376565b610bae906001611395565b90505b6001811115610c33577f303132333435363738396162636465660000000000000000000000000000000085600f1660108110610bef57610bef61124d565b1a60f81b828281518110610c0557610c0561124d565b60200101906001600160f81b031916908160001a90535060049490941c93610c2c816113ad565b9050610bb1565b5083156106cf5760405162461bcd60e51b815260206004820181905260248201527f537472696e67733a20686578206c656e67746820696e73756666696369656e7460448201526064016103fe565b6000828152602081815260408083206001600160a01b038516845290915290205460ff1615610411576000828152602081815260408083206001600160a01b03851684529091529020805460ff19169055610cdb61096f565b6001600160a01b0316816001600160a01b0316837ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b60405160405180910390a45050565b60008181526001830160205260408120548015610e08576000610d436001836113c4565b8554909150600090610d57906001906113c4565b9050818114610dbc576000866000018281548110610d7757610d7761124d565b9060005260206000200154905080876000018481548110610d9a57610d9a61124d565b6000918252602080832090910192909255918252600188019052604090208390555b8554869080610dcd57610dcd6113db565b60019003818190600052602060002001600090559055856001016000868152602001908152602001600020600090556001935050505061031b565b600091505061031b565b6000826000018281548110610e2957610e2961124d565b9060005260206000200154905092915050565b60606001600160a01b0384163b610ebb5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a2064656c65676174652063616c6c20746f206e6f6e2d636f60448201527f6e7472616374000000000000000000000000000000000000000000000000000060648201526084016103fe565b600080856001600160a01b031685604051610ed691906113f1565b600060405180830381855af49150503d8060008114610f11576040519150601f19603f3d011682016040523d82523d6000602084013e610f16565b606091505b5091509150610f26828286610f8c565b9695505050505050565b606081600001805480602002602001604051908101604052809291908181526020018280548015610f8057602002820191906000526020600020905b815481526020019060010190808311610f6c575b50505050509050919050565b60608315610f9b5750816106cf565b825115610fab5782518084602001fd5b8160405162461bcd60e51b81526004016103fe9190611363565b600060208284031215610fd757600080fd5b81356001600160e01b0319811681146106cf57600080fd5b80356001600160a01b038116811461100657600080fd5b919050565b60006020828403121561101d57600080fd5b6106cf82610fef565b60006020828403121561103857600080fd5b5035919050565b6000806040838503121561105257600080fd5b8235915061106260208401610fef565b90509250929050565b6000806040838503121561107e57600080fd5b61108783610fef565b915061106260208401610fef565b600080604083850312156110a857600080fd5b50508035926020909101359150565b600080602083850312156110ca57600080fd5b823567ffffffffffffffff808211156110e257600080fd5b818501915085601f8301126110f657600080fd5b81358181111561110557600080fd5b8660208260051b850101111561111a57600080fd5b60209290920196919550909350505050565b60005b8381101561114757818101518382015260200161112f565b83811115611156576000848401525b50505050565b6000815180845261117481602086016020860161112c565b601f01601f19169290920160200192915050565b6000602080830181845280855180835260408601915060408160051b870101925083870160005b828110156111dd57603f198886030184526111cb85835161115c565b945092850192908501906001016111af565b5092979650505050505050565b6020808252825182820181905260009190848201906040850190845b8181101561122b5783516001600160a01b031683529284019291840191600101611206565b50909695505050505050565b634e487b7160e01b600052604160045260246000fd5b634e487b7160e01b600052603260045260246000fd5b6000808335601e1984360301811261127a57600080fd5b83018035915067ffffffffffffffff82111561129557600080fd5b6020019150368190038213156112aa57600080fd5b9250929050565b634e487b7160e01b600052601160045260246000fd5b60006000198214156112db576112db6112b1565b5060010190565b7f416363657373436f6e74726f6c3a206163636f756e742000000000000000000081526000835161131a81601785016020880161112c565b7f206973206d697373696e6720726f6c6520000000000000000000000000000000601791840191820152835161135781602884016020880161112c565b01602801949350505050565b6020815260006106cf602083018461115c565b6000816000190483118215151615611390576113906112b1565b500290565b600082198211156113a8576113a86112b1565b500190565b6000816113bc576113bc6112b1565b506000190190565b6000828210156113d6576113d66112b1565b500390565b634e487b7160e01b600052603160045260246000fd5b6000825161140381846020870161112c565b919091019291505056fe416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a164736f6c634300080c000a";
var Os = p2((r6) => r6.length > 1, "isSuperArgs");
var Ne = class extends ContractFactory {
  constructor(...e6) {
    Os(e6) ? super(...e6) : super(Yn, yr, e6[0]);
  }
  deploy(e6, t6) {
    return super.deploy(e6, t6 || {});
  }
  getDeployTransaction(e6, t6) {
    return super.getDeployTransaction(e6, t6 || {});
  }
  attach(e6) {
    return super.attach(e6);
  }
  connect(e6) {
    return super.connect(e6);
  }
  static createInterface() {
    return new utils_exports.Interface(Yn);
  }
  static connect(e6, t6) {
    return new Contract(e6, Yn, t6);
  }
};
p2(Ne, "TWRegistry__factory"), f2(Ne, "bytecode", yr), f2(Ne, "abi", Yn);
var Qn = [{ anonymous: false, inputs: [{ indexed: false, internalType: "address", name: "prevOwner", type: "address" }, { indexed: false, internalType: "address", name: "newOwner", type: "address" }], name: "OwnerUpdated", type: "event" }, { inputs: [], name: "contractURI", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [], name: "getPublishMetadataUri", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [], name: "owner", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "string", name: "_uri", type: "string" }], name: "setContractURI", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_newOwner", type: "address" }], name: "setOwner", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ components: [{ internalType: "string", name: "publishMetadataUri", type: "string" }, { internalType: "string", name: "contractURI", type: "string" }, { internalType: "address", name: "owner", type: "address" }], internalType: "struct ThirdwebContract.ThirdwebInfo", name: "_thirdwebInfo", type: "tuple" }], name: "setThirdwebInfo", outputs: [], stateMutability: "nonpayable", type: "function" }];
var dr = "0x608060405234801561001057600080fd5b50610829806100206000396000f3fe608060405234801561001057600080fd5b50600436106100725760003560e01c8063bba53cba11610050578063bba53cba146100cf578063d3684f40146100e2578063e8a3d485146100f757600080fd5b806313af4035146100775780638da5cb5b1461008c578063938e3d7b146100bc575b600080fd5b61008a61008536600461059d565b6100ff565b005b60005461009f906001600160a01b031681565b6040516001600160a01b0390911681526020015b60405180910390f35b61008a6100ca3660046105bf565b6101bd565b61008a6100dd3660046106d4565b610219565b6100ea610354565b6040516100b3919061078c565b6100ea6103e6565b6000546001600160a01b0316331461014f5760405162461bcd60e51b815260206004820152600e60248201526d139bdd08185d5d1a1bdc9a5e995960921b60448201526064015b60405180910390fd5b600080546001600160a01b0383811673ffffffffffffffffffffffffffffffffffffffff1983168117909355604080519190921680825260208201939093527f8292fce18fa69edf4db7b94ea2e58241df0ae57f97e0a6c9b29067028bf92d76910160405180910390a15050565b6000546001600160a01b031633146102085760405162461bcd60e51b815260206004820152600e60248201526d139bdd08185d5d1a1bdc9a5e995960921b6044820152606401610146565b61021460018383610474565b505050565b60028054610226906107e1565b15905061029b5760405162461bcd60e51b815260206004820152602660248201527f5075626c6973686564206d6574616461746120616c726561647920696e69746960448201527f616c697a656400000000000000000000000000000000000000000000000000006064820152608401610146565b6000546001600160a01b0316156102f45760405162461bcd60e51b815260206004820152601960248201527f4f776e657220616c726561647920696e697469616c697a6564000000000000006044820152606401610146565b8051805161030a916002916020909101906104f8565b5060208082015180516103219260019201906104f8565b50604001516000805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b03909216919091179055565b606060028054610363906107e1565b80601f016020809104026020016040519081016040528092919081815260200182805461038f906107e1565b80156103dc5780601f106103b1576101008083540402835291602001916103dc565b820191906000526020600020905b8154815290600101906020018083116103bf57829003601f168201915b5050505050905090565b600180546103f3906107e1565b80601f016020809104026020016040519081016040528092919081815260200182805461041f906107e1565b801561046c5780601f106104415761010080835404028352916020019161046c565b820191906000526020600020905b81548152906001019060200180831161044f57829003601f168201915b505050505081565b828054610480906107e1565b90600052602060002090601f0160209004810192826104a257600085556104e8565b82601f106104bb5782800160ff198235161785556104e8565b828001600101855582156104e8579182015b828111156104e85782358255916020019190600101906104cd565b506104f492915061056c565b5090565b828054610504906107e1565b90600052602060002090601f01602090048101928261052657600085556104e8565b82601f1061053f57805160ff19168380011785556104e8565b828001600101855582156104e8579182015b828111156104e8578251825591602001919060010190610551565b5b808211156104f4576000815560010161056d565b80356001600160a01b038116811461059857600080fd5b919050565b6000602082840312156105af57600080fd5b6105b882610581565b9392505050565b600080602083850312156105d257600080fd5b823567ffffffffffffffff808211156105ea57600080fd5b818501915085601f8301126105fe57600080fd5b81358181111561060d57600080fd5b86602082850101111561061f57600080fd5b60209290920196919550909350505050565b634e487b7160e01b600052604160045260246000fd5b600082601f83011261065857600080fd5b813567ffffffffffffffff8082111561067357610673610631565b604051601f8301601f19908116603f0116810190828211818310171561069b5761069b610631565b816040528381528660208588010111156106b457600080fd5b836020870160208301376000602085830101528094505050505092915050565b6000602082840312156106e657600080fd5b813567ffffffffffffffff808211156106fe57600080fd5b908301906060828603121561071257600080fd5b60405160608101818110838211171561072d5761072d610631565b60405282358281111561073f57600080fd5b61074b87828601610647565b82525060208301358281111561076057600080fd5b61076c87828601610647565b60208301525061077e60408401610581565b604082015295945050505050565b600060208083528351808285015260005b818110156107b95785810183015185820160400152820161079d565b818111156107cb576000604083870101525b50601f01601f1916929092016040019392505050565b600181811c908216806107f557607f821691505b6020821081141561081657634e487b7160e01b600052602260045260246000fd5b5091905056fea164736f6c634300080c000a";
var Ls = p2((r6) => r6.length > 1, "isSuperArgs");
var Ke = class extends ContractFactory {
  constructor(...e6) {
    Ls(e6) ? super(...e6) : super(Qn, dr, e6[0]);
  }
  deploy(e6) {
    return super.deploy(e6 || {});
  }
  getDeployTransaction(e6) {
    return super.getDeployTransaction(e6 || {});
  }
  attach(e6) {
    return super.attach(e6);
  }
  connect(e6) {
    return super.connect(e6);
  }
  static createInterface() {
    return new utils_exports.Interface(Qn);
  }
  static connect(e6, t6) {
    return new Contract(e6, Qn, t6);
  }
};
p2(Ke, "ThirdwebContract__factory"), f2(Ke, "bytecode", dr), f2(Ke, "abi", Qn);
async function jt(r6, e6, t6, n4) {
  var o6, y5;
  let a5 = r6 == null ? void 0 : r6.provider;
  if (!a5)
    throw new Error("missing provider");
  let i6 = ethers_exports.utils._TypedDataEncoder.getPayload(e6, t6, n4), s6 = "";
  if ((o6 = a5 == null ? void 0 : a5.provider) != null && o6.isWalletConnect)
    s6 = await a5.send("eth_signTypedData", [(await r6.getAddress()).toLowerCase(), JSON.stringify(i6)]);
  else
    try {
      s6 = await r6._signTypedData(e6, t6, n4);
    } catch (d6) {
      if ((y5 = d6 == null ? void 0 : d6.message) != null && y5.includes("Method eth_signTypedData_v4 not supported"))
        s6 = await a5.send("eth_signTypedData", [(await r6.getAddress()).toLowerCase(), JSON.stringify(i6)]);
      else
        throw d6;
    }
  return { payload: i6, signature: ethers_exports.utils.joinSignature(ethers_exports.utils.splitSignature(s6)) };
}
p2(jt, "signTypedDataInternal");
var qs = [{ inputs: [], name: "name", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }];
var $s = [{ constant: true, inputs: [], name: "DOMAIN_SEPARATOR", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], payable: false, stateMutability: "view", type: "function" }, { inputs: [], name: "getDomainSeperator", outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], stateMutability: "view", type: "function" }];
var Gs = [{ inputs: [{ internalType: "address", name: "owner", type: "address" }], name: "nonces", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "user", type: "address" }], name: "getNonce", outputs: [{ internalType: "uint256", name: "nonce", type: "uint256" }], stateMutability: "view", type: "function" }];
async function zs(r6, e6) {
  let t6 = new Contract(e6, Gs, r6);
  try {
    return await t6.nonces(await r6.getAddress());
  } catch {
    return await t6.getNonce(await r6.getAddress());
  }
}
p2(zs, "getSignerNonce");
async function Hs(r6, e6) {
  let t6 = new Contract(e6, $s, r6);
  try {
    return await t6.DOMAIN_SEPARATOR();
  } catch {
    return await t6.getDomainSeperator();
  }
}
p2(Hs, "getDomainSeperator");
async function Zs(r6, e6) {
  return new Contract(e6, qs, r6).name();
}
p2(Zs, "getTokenName");
async function js(r6, e6) {
  let t6 = await Hs(r6, e6.verifyingContract), n4 = { name: e6.name, version: e6.version, verifyingContract: e6.verifyingContract, salt: ethers_exports.utils.hexZeroPad(BigNumber.from(e6.chainId).toHexString(), 32) };
  return ethers_exports.utils._TypedDataEncoder.hashDomain(n4) === t6 ? n4 : e6;
}
p2(js, "getChainDomainSeperator");
async function ur(r6, e6, t6, n4, a5, i6, s6) {
  let o6 = await js(r6, { name: await Zs(r6, e6), version: "1", chainId: await r6.getChainId(), verifyingContract: e6 });
  s6 = s6 != null ? s6 : (await zs(r6, e6)).toString(), i6 = i6 != null ? i6 : ethers_exports.constants.MaxUint256;
  let y5 = { owner: t6, spender: n4, value: a5, nonce: s6, deadline: i6 }, d6 = { Permit: [{ name: "owner", type: "address" }, { name: "spender", type: "address" }, { name: "value", type: "uint256" }, { name: "nonce", type: "uint256" }, { name: "deadline", type: "uint256" }] }, { signature: u7 } = await jt(r6, o6, d6, y5);
  return { message: y5, signature: u7 };
}
p2(ur, "signEIP2612Permit");
function Ys(r6) {
  switch (r6) {
    case T.Polygon:
      return "https://gasstation-mainnet.matic.network/v2";
    case T.Mumbai:
      return "https://gasstation-mumbai.matic.today/v2";
  }
}
p2(Ys, "getGasStationUrl");
var Qs = ethers_exports.utils.parseUnits("31", "gwei");
var Ks = ethers_exports.utils.parseUnits("1", "gwei");
function Js(r6) {
  switch (r6) {
    case T.Polygon:
      return Qs;
    case T.Mumbai:
      return Ks;
  }
}
p2(Js, "getDefaultGasFee");
async function cr(r6) {
  let e6 = Ys(r6);
  try {
    let n4 = (await (await fetch(e6)).json()).standard.maxPriorityFee;
    if (n4 > 0) {
      let a5 = parseFloat(n4).toFixed(9);
      return ethers_exports.utils.parseUnits(a5, "gwei");
    }
  } catch (t6) {
    console.error("failed to fetch gas", t6);
  }
  return Js(r6);
}
p2(cr, "getPolygonGasPriorityFee");
var Qt = { [T.Polygon]: { vrfCoordinator: "0x3d2341ADb2D31f1c5530cDC622016af293177AE0", linkTokenAddress: "0xb0897686c545045aFc77CF20eC7A532E3120E0F1", keyHash: "0xf86195cf7690c55907b2b611ebb7343a6f649bff128701cc542f0569e2c549da", fees: ethers_exports.utils.parseEther("0.0001") }, [T.Mumbai]: { vrfCoordinator: "0x8C7382F9D8f56b33781fE506E897a4F1e2d17255", linkTokenAddress: "0x326C977E6efc84E512bB9C30f76E30c160eD06FB", keyHash: "0x6e75b569a01ef56d18cab6a8e71e6600d6ce853834d4a5748b720d06f878b3a4", fees: ethers_exports.utils.parseEther("0.0001") }, [T.Rinkeby]: { vrfCoordinator: "0xb3dCcb4Cf7a26f6cf6B120Cf5A73875B7BBc655B", linkTokenAddress: "0x01be23585060835e02b77ef475b0cc51aa1e0709", keyHash: "0x2ed0feb3e7fd2022120aa84fab1945545a9f2ffc9076fd6156fa96eaff4c1311", fees: ethers_exports.utils.parseEther("0.1") }, [T.Mainnet]: { vrfCoordinator: "0xf0d54349aDdcf704F77AE15b96510dEA15cb7952", linkTokenAddress: "0x514910771AF9Ca656af840dff83E8264EcF986CA", keyHash: "0xAA77729D3466CA35AE8D28B3BBAC7CC36A5031EFDC430821C02BC31A238AF445", fees: ethers_exports.utils.parseEther("2") }, [T.Hardhat]: { vrfCoordinator: "0x8C7382F9D8f56b33781fE506E897a4F1e2d17255", linkTokenAddress: "0x326C977E6efc84E512bB9C30f76E30c160eD06FB", keyHash: "0x6e75b569a01ef56d18cab6a8e71e6600d6ce853834d4a5748b720d06f878b3a4", fees: ethers_exports.utils.parseEther("0.0001") } };
var st = utils_exports.arrayify("0x80ac58cd");
var ot = utils_exports.arrayify("0xd9b67a26");
async function fr(r6, e6, t6) {
  let n4 = ft.parse(r6), a5 = n4.map((u7) => u7.address);
  if (new Set(a5).size < a5.length)
    throw new Ut();
  let s6 = n4.map((u7) => no(u7.address, ethers_exports.utils.parseUnits(u7.maxClaimable, e6))), o6 = new import_merkletreejs.default(s6, import_keccak25613.default, { sort: true }), y5 = It.parse({ merkleRoot: o6.getHexRoot(), claims: n4.map((u7, m6) => {
    let b4 = o6.getHexProof(s6[m6]);
    return { address: u7.address, maxClaimable: u7.maxClaimable, proof: b4 };
  }) }), d6 = await t6.uploadMetadata(y5);
  return { merkleRoot: o6.getHexRoot(), snapshotUri: d6, snapshot: y5 };
}
p2(fr, "createSnapshot");
function no(r6, e6) {
  return ethers_exports.utils.solidityKeccak256(["address", "uint256"], [r6, BigNumber.from(e6)]);
}
p2(no, "hashLeafNode");
var ao = I.catchall(mod.lazy(() => De));
var Tr = ao.merge(N2.merge(Ce).merge(k2).partial());
var ro = O.merge(N2.merge(Ce).merge(k2).partial());
var io = Tr.merge(L.merge(ue).merge(D).partial());
var hr = { deploy: io, output: ro, input: Tr };
var Kn = mod.object({ name: mod.string(), abiUri: mod.string(), bytecodeUri: mod.string() });
var br = mod.object({ type: mod.string(), name: mod.string() }).catchall(mod.any());
var so = mod.object({ type: mod.string(), name: mod.string().default(""), inputs: mod.array(br).default([]), outputs: mod.array(br).default([]) }).catchall(mod.any());
var pt = mod.array(so);
var gr = mod.object({ id: mod.string(), timestamp: we, metadataUri: mod.string() });
var _e = [{ anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "_owner", type: "address" }, { indexed: true, internalType: "address", name: "_approved", type: "address" }, { indexed: true, internalType: "uint256", name: "_tokenId", type: "uint256" }], name: "Approval", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "_owner", type: "address" }, { indexed: true, internalType: "address", name: "_operator", type: "address" }, { indexed: false, internalType: "bool", name: "_approved", type: "bool" }], name: "ApprovalForAll", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "_from", type: "address" }, { indexed: true, internalType: "address", name: "_to", type: "address" }, { indexed: true, internalType: "uint256", name: "_tokenId", type: "uint256" }], name: "Transfer", type: "event" }, { inputs: [{ internalType: "address", name: "_approved", type: "address" }, { internalType: "uint256", name: "_tokenId", type: "uint256" }], name: "approve", outputs: [], stateMutability: "payable", type: "function" }, { inputs: [{ internalType: "address", name: "_owner", type: "address" }], name: "balanceOf", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "_tokenId", type: "uint256" }], name: "getApproved", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_owner", type: "address" }, { internalType: "address", name: "_operator", type: "address" }], name: "isApprovedForAll", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "_tokenId", type: "uint256" }], name: "ownerOf", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_from", type: "address" }, { internalType: "address", name: "_to", type: "address" }, { internalType: "uint256", name: "_tokenId", type: "uint256" }], name: "safeTransferFrom", outputs: [], stateMutability: "payable", type: "function" }, { inputs: [{ internalType: "address", name: "_from", type: "address" }, { internalType: "address", name: "_to", type: "address" }, { internalType: "uint256", name: "_tokenId", type: "uint256" }, { internalType: "bytes", name: "data", type: "bytes" }], name: "safeTransferFrom", outputs: [], stateMutability: "payable", type: "function" }, { inputs: [{ internalType: "address", name: "_operator", type: "address" }, { internalType: "bool", name: "_approved", type: "bool" }], name: "setApprovalForAll", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_from", type: "address" }, { internalType: "address", name: "_to", type: "address" }, { internalType: "uint256", name: "_tokenId", type: "uint256" }], name: "transferFrom", outputs: [], stateMutability: "payable", type: "function" }];
var wr = [{ inputs: [{ internalType: "uint256", name: "_index", type: "uint256" }], name: "tokenByIndex", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_owner", type: "address" }, { internalType: "uint256", name: "_index", type: "uint256" }], name: "tokenOfOwnerByIndex", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }];
var Cr = [{ inputs: [], name: "totalSupply", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }];
var e0 = [{ anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "mintedTo", type: "address" }, { indexed: true, internalType: "uint256", name: "tokenIdMinted", type: "uint256" }, { indexed: false, internalType: "string", name: "uri", type: "string" }], name: "TokensMinted", type: "event" }, { inputs: [{ internalType: "address", name: "to", type: "address" }, { internalType: "string", name: "uri", type: "string" }], name: "mintTo", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "nonpayable", type: "function" }];
var wt = [{ inputs: [{ internalType: "bytes[]", name: "data", type: "bytes[]" }], name: "multicall", outputs: [{ internalType: "bytes[]", name: "results", type: "bytes[]" }], stateMutability: "nonpayable", type: "function" }];
var Jn = { name: "ERC721BatchMintable", namespace: "nft.mint.batch", docLinks: { sdk: "sdk.erc721batchmintable", contracts: "IMulticall" }, abis: [_e, e0, wt], features: {} };
var Xn = { name: "ERC721Mintable", namespace: "nft.mint", docLinks: { sdk: "sdk.erc721mintable", contracts: "IMintableERC721" }, abis: [_e, e0], features: { [Jn.name]: Jn } };
var ea = { name: "ERC721Enumerable", namespace: "nft.query.owned", docLinks: { sdk: "sdk.erc721enumerable", contracts: "ERC721Enumerable" }, abis: [_e, wr], features: {} };
var ta = { name: "ERC721Supply", namespace: "nft.query", docLinks: { sdk: "sdk.erc721supply", contracts: "ERC721Supply" }, abis: [_e, Cr], features: { [ea.name]: ea } };
var Kt = { name: "ERC721", namespace: "nft", docLinks: { sdk: "sdk.erc721", contracts: "ERC721" }, abis: [_e], features: { [ta.name]: ta, [Xn.name]: Xn } };
var K2 = [{ anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "owner", type: "address" }, { indexed: true, internalType: "address", name: "spender", type: "address" }, { indexed: false, internalType: "uint256", name: "value", type: "uint256" }], name: "Approval", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "from", type: "address" }, { indexed: true, internalType: "address", name: "to", type: "address" }, { indexed: false, internalType: "uint256", name: "value", type: "uint256" }], name: "Transfer", type: "event" }, { inputs: [{ internalType: "address", name: "owner", type: "address" }, { internalType: "address", name: "spender", type: "address" }], name: "allowance", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "spender", type: "address" }, { internalType: "uint256", name: "value", type: "uint256" }], name: "approve", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "who", type: "address" }], name: "balanceOf", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "totalSupply", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "value", type: "uint256" }], name: "transfer", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "from", type: "address" }, { internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "value", type: "uint256" }], name: "transferFrom", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }];
var t0 = [{ anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "mintedTo", type: "address" }, { indexed: false, internalType: "uint256", name: "quantityMinted", type: "uint256" }], name: "TokensMinted", type: "event" }, { inputs: [{ internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "amount", type: "uint256" }], name: "mintTo", outputs: [], stateMutability: "nonpayable", type: "function" }];
var na = { name: "ERC20BatchMintable", namespace: "token.mint.batch", docLinks: { sdk: "sdk.erc20batchmintable", contracts: "IMulticall" }, abis: [K2, t0, wt], features: {} };
var aa = { name: "ERC20Mintable", namespace: "token.mint", docLinks: { sdk: "sdk.erc20mintable", contracts: "IMintableERC20" }, abis: [K2, t0], features: { [na.name]: na } };
var Jt = { name: "ERC20", namespace: "token", docLinks: { sdk: "sdk.erc20", contracts: "ERC20" }, abis: [K2], features: { [aa.name]: aa } };
var vr = [{ inputs: [], name: "nextTokenIdToMint", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }];
var Me = [{ anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "_owner", type: "address" }, { indexed: true, internalType: "address", name: "_operator", type: "address" }, { indexed: false, internalType: "bool", name: "_approved", type: "bool" }], name: "ApprovalForAll", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "_operator", type: "address" }, { indexed: true, internalType: "address", name: "_from", type: "address" }, { indexed: true, internalType: "address", name: "_to", type: "address" }, { indexed: false, internalType: "uint256[]", name: "_ids", type: "uint256[]" }, { indexed: false, internalType: "uint256[]", name: "_values", type: "uint256[]" }], name: "TransferBatch", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "_operator", type: "address" }, { indexed: true, internalType: "address", name: "_from", type: "address" }, { indexed: true, internalType: "address", name: "_to", type: "address" }, { indexed: false, internalType: "uint256", name: "_id", type: "uint256" }, { indexed: false, internalType: "uint256", name: "_value", type: "uint256" }], name: "TransferSingle", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "string", name: "_value", type: "string" }, { indexed: true, internalType: "uint256", name: "_id", type: "uint256" }], name: "URI", type: "event" }, { inputs: [{ internalType: "address", name: "_owner", type: "address" }, { internalType: "uint256", name: "_id", type: "uint256" }], name: "balanceOf", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address[]", name: "_owners", type: "address[]" }, { internalType: "uint256[]", name: "_ids", type: "uint256[]" }], name: "balanceOfBatch", outputs: [{ internalType: "uint256[]", name: "", type: "uint256[]" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_owner", type: "address" }, { internalType: "address", name: "_operator", type: "address" }], name: "isApprovedForAll", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "_from", type: "address" }, { internalType: "address", name: "_to", type: "address" }, { internalType: "uint256[]", name: "_ids", type: "uint256[]" }, { internalType: "uint256[]", name: "_values", type: "uint256[]" }, { internalType: "bytes", name: "_data", type: "bytes" }], name: "safeBatchTransferFrom", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_from", type: "address" }, { internalType: "address", name: "_to", type: "address" }, { internalType: "uint256", name: "_id", type: "uint256" }, { internalType: "uint256", name: "_value", type: "uint256" }, { internalType: "bytes", name: "_data", type: "bytes" }], name: "safeTransferFrom", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "_operator", type: "address" }, { internalType: "bool", name: "_approved", type: "bool" }], name: "setApprovalForAll", outputs: [], stateMutability: "nonpayable", type: "function" }];
var n0 = [{ anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "mintedTo", type: "address" }, { indexed: true, internalType: "uint256", name: "tokenIdMinted", type: "uint256" }, { indexed: false, internalType: "string", name: "uri", type: "string" }, { indexed: false, internalType: "uint256", name: "quantityMinted", type: "uint256" }], name: "TokensMinted", type: "event" }, { inputs: [{ internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "tokenId", type: "uint256" }, { internalType: "string", name: "uri", type: "string" }, { internalType: "uint256", name: "amount", type: "uint256" }], name: "mintTo", outputs: [], stateMutability: "nonpayable", type: "function" }];
var ra = { name: "ERC1155BatchMintable", namespace: "edition.mint.batch", docLinks: { sdk: "sdk.erc1155batchmintable", contracts: "IMulticall" }, abis: [Me, n0, wt], features: {} };
var ia = { name: "ERC1155Mintable", namespace: "edition.mint", docLinks: { sdk: "sdk.erc1155mintable", contracts: "IMintableERC1155" }, abis: [Me, n0], features: { [ra.name]: ra } };
var sa = { name: "ERC1155Enumerable", namespace: "edition.query", docLinks: { sdk: "sdk.erc1155", contracts: "ERC1155" }, abis: [Me, vr], features: {} };
var Xt = { name: "ERC1155", namespace: "edition", docLinks: { sdk: "sdk.erc1155enumerable", contracts: "ERC1155Enumerable" }, abis: [Me], features: { [sa.name]: sa, [ia.name]: ia } };
var xr = { [Jt.name]: Jt, [Kt.name]: Kt, [Xt.name]: Xt, [qt.name]: qt, [Gt.name]: Gt, [$t.name]: $t, [zt.name]: zt };
function wy(r6, e6) {
  return ho(r6.readContract, e6);
}
p2(wy, "implementsInterface");
function ho(r6, e6) {
  let t6 = r6.interface.functions, n4 = e6.functions;
  return Object.keys(t6).filter((a5) => a5 in n4).length === Object.keys(n4).length;
}
p2(ho, "matchesInterface");
function go(r6, e6) {
  let t6 = en(r6).map((a5) => a5.name), n4 = e6.flatMap((a5) => en(a5)).map((a5) => a5.name);
  return t6.filter((a5) => n4.includes(a5)).length === n4.length;
}
p2(go, "matchesAbiInterface");
async function Rr(r6, e6) {
  let t6 = Kn.parse(await e6.get(r6)), n4 = await e6.get(t6.abiUri), a5 = pt.parse(n4);
  return a0(a5);
}
p2(Rr, "extractConstructorParams");
async function Ar(r6, e6) {
  let t6 = Kn.parse(await e6.get(r6)), n4 = await e6.get(t6.abiUri), a5 = pt.parse(n4);
  return en(a5);
}
p2(Ar, "extractFunctions");
function a0(r6) {
  var e6;
  for (let t6 of r6)
    if (t6.type === "constructor")
      return (e6 = t6.inputs) != null ? e6 : [];
  return [];
}
p2(a0, "extractConstructorParamsFromAbi");
function en(r6) {
  var n4, a5, i6, s6, o6, y5, d6;
  let e6 = r6.filter((u7) => u7.type === "function"), t6 = [];
  for (let u7 of e6) {
    let m6 = ((a5 = (n4 = u7.inputs) == null ? void 0 : n4.map((F5) => `${F5.name || "key"}: ${Mr(F5.type)}`)) == null ? void 0 : a5.join(", ")) || "", b4 = (s6 = (i6 = u7.outputs) == null ? void 0 : i6.map((F5) => Mr(F5.type, true))) == null ? void 0 : s6.join(", "), h6 = b4 ? `: Promise<${b4}>` : "", v9 = `${u7.name}(${m6})${h6}`;
    t6.push({ inputs: (o6 = u7.inputs) != null ? o6 : [], outputs: (y5 = u7.outputs) != null ? y5 : [], name: (d6 = u7.name) != null ? d6 : "unknown", signature: v9 });
  }
  return t6;
}
p2(en, "extractFunctionsFromAbi");
function Mr(r6, e6 = false) {
  let t6 = r6;
  return r6.startsWith("bytes") && (t6 = "BytesLike"), (r6.startsWith("uint") || r6.startsWith("int")) && (t6 = e6 ? "BigNumber" : "BigNumberish"), r6 === "bool" && (t6 = "boolean"), r6 === "address" && (t6 = "string"), r6.endsWith("[]") && (t6 += "[]"), t6;
}
p2(Mr, "toJSType");
async function oa(r6, e6) {
  let t6 = Kn.parse(await e6.get(r6)), n4 = pt.parse(await e6.get(t6.abiUri)), a5 = await e6.getRaw(t6.bytecodeUri);
  return { name: t6.name, abi: n4, bytecode: a5 };
}
p2(oa, "fetchContractMetadata");
function _r(r6, e6 = xr) {
  let t6 = {};
  for (let n4 in e6) {
    let a5 = e6[n4], i6 = go(r6, a5.abis), s6 = _r(r6, a5.features);
    t6[n4] = B(w({}, a5), { features: s6, enabled: i6 });
  }
  return t6;
}
p2(_r, "detectFeatures");
function wo(r6, e6) {
  let t6 = _r(r6);
  return Sr(t6, e6);
}
p2(wo, "isFeatureEnabled");
function R(r6, e6) {
  return wo(pt.parse(r6.abi), e6);
}
p2(R, "detectContractFeature");
function Sr(r6, e6) {
  let t6 = Object.keys(r6);
  if (!t6.includes(e6)) {
    let a5 = false;
    for (let i6 of t6) {
      let s6 = r6[i6];
      if (a5 = Sr(s6.features, e6), a5)
        break;
    }
    return a5;
  }
  return r6[e6].enabled;
}
p2(Sr, "_featureEnabled");
var g2 = class extends fe {
  constructor(e6, t6, n4, a5) {
    super(e6, a5);
    __publicField(this, "isValidContract", false);
    __publicField(this, "customOverrides", () => ({}));
    this.abi = n4, this.writeContract = new Contract(t6, n4, this.getSignerOrProvider()), this.readContract = this.writeContract.connect(this.getProvider());
  }
  updateSignerOrProvider(e6) {
    super.updateSignerOrProvider(e6), this.writeContract = this.writeContract.connect(this.getSignerOrProvider()), this.readContract = this.writeContract.connect(this.getProvider());
  }
  async getChainID() {
    let e6 = this.getProvider(), { chainId: t6 } = await e6.getNetwork();
    return t6;
  }
  async getSignerAddress() {
    let e6 = this.getSigner();
    if (!e6)
      throw new Error("This action requires a connected wallet to sign the transaction. Please pass a valid signer to the SDK.");
    return await e6.getAddress();
  }
  callStatic() {
    return this.writeContract.callStatic;
  }
  async getCallOverrides() {
    if ($e())
      return {};
    let e6 = await this.getProvider().getFeeData();
    if (e6.maxFeePerGas && e6.maxPriorityFeePerGas) {
      let n4 = await this.getChainID(), a5 = await this.getProvider().getBlock("latest"), i6 = a5 && a5.baseFeePerGas ? a5.baseFeePerGas : ethers_exports.utils.parseUnits("1", "gwei"), s6;
      n4 === T.Mumbai || n4 === T.Polygon ? s6 = await cr(n4) : s6 = BigNumber.from(e6.maxPriorityFeePerGas);
      let o6 = this.getPreferredPriorityFee(s6);
      return { maxFeePerGas: i6.mul(2).add(o6), maxPriorityFeePerGas: o6 };
    } else
      return { gasPrice: await this.getPreferredGasPrice() };
  }
  getPreferredPriorityFee(e6) {
    let t6 = this.options.gasSettings.speed, n4 = this.options.gasSettings.maxPriceInGwei, a5;
    switch (t6) {
      case "standard":
        a5 = BigNumber.from(0);
        break;
      case "fast":
        a5 = e6.div(100).mul(5);
        break;
      case "fastest":
        a5 = e6.div(100).mul(10);
        break;
    }
    let i6 = e6.add(a5), s6 = ethers_exports.utils.parseUnits(n4.toString(), "gwei"), o6 = ethers_exports.utils.parseUnits("2.5", "gwei");
    return i6.gt(s6) && (i6 = s6), i6.lt(o6) && (i6 = o6), i6;
  }
  async getPreferredGasPrice() {
    let e6 = await this.getProvider().getGasPrice(), t6 = this.options.gasSettings.speed, n4 = this.options.gasSettings.maxPriceInGwei, a5 = e6, i6;
    switch (t6) {
      case "standard":
        i6 = BigNumber.from(1);
        break;
      case "fast":
        i6 = e6.div(100).mul(5);
        break;
      case "fastest":
        i6 = e6.div(100).mul(10);
        break;
    }
    a5 = a5.add(i6);
    let s6 = ethers_exports.utils.parseUnits(n4.toString(), "gwei");
    return a5.gt(s6) && (a5 = s6), a5;
  }
  emitTransactionEvent(e6, t6) {
    this.emit(be.Transaction, { status: e6, transactionHash: t6 });
  }
  async multiCall(e6) {
    return this.sendTransaction("multicall", [e6]);
  }
  async estimateGas(e6, t6) {
    return this.writeContract.estimateGas[e6](...t6);
  }
  withTransactionOverride(e6) {
    this.customOverrides = e6;
  }
  async sendTransaction(e6, t6, n4) {
    var a5;
    if (!this.isValidContract) {
      let i6 = await this.getProvider().getCode(this.readContract.address);
      if (this.isValidContract = i6 !== "0x", !this.isValidContract)
        throw new Error("The address you're trying to send a transaction to is not a smart contract. Make sure you are on the correct network and the contract address is correct");
    }
    if (n4 || (n4 = await this.getCallOverrides()), n4 = w(w({}, n4), this.customOverrides()), this.customOverrides = () => ({}), ((a5 = this.options) == null ? void 0 : a5.gasless) && ("openzeppelin" in this.options.gasless || "biconomy" in this.options.gasless)) {
      let i6 = this.getProvider(), s6 = await this.sendGaslessTransaction(e6, t6, n4);
      this.emitTransactionEvent("submitted", s6);
      let o6 = await i6.waitForTransaction(s6);
      return this.emitTransactionEvent("completed", s6), o6;
    } else {
      let i6 = await this.sendTransactionByFunction(e6, t6, n4);
      this.emitTransactionEvent("submitted", i6.hash);
      let s6 = i6.wait();
      return this.emitTransactionEvent("completed", i6.hash), s6;
    }
  }
  async sendTransactionByFunction(e6, t6, n4) {
    let a5 = this.writeContract.functions[e6];
    if (!a5)
      throw new Error("invalid function");
    try {
      return await a5(...t6, n4);
    } catch (i6) {
      let s6 = await this.getProvider().getNetwork(), o6 = await this.getSignerAddress(), y5 = await this.readContract.address;
      throw await $0(i6, s6, o6, y5);
    }
  }
  async sendGaslessTransaction(e6, t6 = [], n4) {
    let a5 = this.getSigner();
    invariant(a5, "Cannot execute gasless transaction without valid signer");
    let i6 = await this.getChainID(), s6 = await this.getSignerAddress(), o6 = this.writeContract.address, y5 = (n4 == null ? void 0 : n4.value) || 0;
    if (BigNumber.from(y5).gt(0))
      throw new Error("Cannot send native token value with gasless transaction");
    let d6 = this.writeContract.interface.encodeFunctionData(e6, t6), u7 = await this.writeContract.estimateGas[e6](...t6), m6 = u7.mul(2);
    u7.lt(25e3) && (m6 = BigNumber.from(5e5));
    let b4 = { from: s6, to: o6, data: d6, chainId: i6, gasLimit: m6, functionName: e6.toString(), functionArgs: t6, callOverrides: n4 };
    return await this.defaultGaslessSendFunction(b4);
  }
  async signTypedData(e6, t6, n4, a5) {
    this.emit(be.Signature, { status: "submitted", message: a5, signature: "" });
    let { signature: i6 } = await jt(e6, t6, n4, a5);
    return this.emit(be.Signature, { status: "completed", message: a5, signature: i6 }), i6;
  }
  parseLogs(e6, t6) {
    if (!t6 || t6.length === 0)
      return [];
    let n4 = this.writeContract.interface.getEventTopic(e6);
    return t6.filter((i6) => i6.topics.indexOf(n4) >= 0).map((i6) => this.writeContract.interface.parseLog(i6));
  }
  async defaultGaslessSendFunction(e6) {
    return this.options.gasless && "biconomy" in this.options.gasless ? this.biconomySendFunction(e6) : this.defenderSendFunction(e6);
  }
  async biconomySendFunction(e6) {
    var m6, b4;
    invariant(this.options.gasless && "biconomy" in this.options.gasless, "calling biconomySendFunction without biconomy");
    let t6 = this.getSigner(), n4 = this.getProvider();
    invariant(t6 && n4, "signer and provider must be set");
    let a5 = new ethers_exports.Contract(He(e6.chainId, "biconomyForwarder"), rr, n4), i6 = 0, s6 = await Za(a5, "getNonce", [e6.from, i6]), o6 = { from: e6.from, to: e6.to, token: ethers_exports.constants.AddressZero, txGas: e6.gasLimit.toNumber(), tokenGasPrice: "0", batchId: i6, batchNonce: s6.toNumber(), deadline: Math.floor(Date.now() / 1e3 + (((m6 = this.options) == null ? void 0 : m6.gasless) && "biconomy" in this.options.gasless && ((b4 = this.options.gasless.biconomy) == null ? void 0 : b4.deadlineSeconds) || 3600)), data: e6.data }, y5 = ethers_exports.utils.arrayify(ethers_exports.utils.solidityKeccak256(["address", "address", "address", "uint256", "uint256", "uint256", "uint256", "uint256", "bytes32"], [o6.from, o6.to, o6.token, o6.txGas, o6.tokenGasPrice, o6.batchId, o6.batchNonce, o6.deadline, ethers_exports.utils.keccak256(o6.data)]));
    this.emit(be.Signature, { status: "submitted", message: y5, signature: "" });
    let d6 = await t6.signMessage(y5);
    this.emit(be.Signature, { status: "completed", message: y5, signature: d6 });
    let u7 = await fetch("https://api.biconomy.io/api/v2/meta-tx/native", { method: "POST", body: JSON.stringify({ from: e6.from, apiId: this.options.gasless.biconomy.apiId, params: [o6, d6], to: e6.to, gasLimit: e6.gasLimit.toHexString() }), headers: { "x-api-key": this.options.gasless.biconomy.apiKey, "Content-Type": "application/json;charset=utf-8" } });
    if (u7.ok) {
      let h6 = await u7.json();
      if (!h6.txHash)
        throw new Error(`relay transaction failed: ${h6.log}`);
      return h6.txHash;
    }
    throw new Error(`relay transaction failed with status: ${u7.status} (${u7.statusText})`);
  }
  async defenderSendFunction(e6) {
    invariant(this.options.gasless && "openzeppelin" in this.options.gasless, "calling biconomySendFunction without biconomy");
    let t6 = this.getSigner(), n4 = this.getProvider();
    invariant(t6, "provider is not set"), invariant(n4, "provider is not set");
    let a5 = this.options.gasless.openzeppelin.relayerForwarderAddress, i6 = Ye.connect(a5, n4), s6 = await Za(i6, "getNonce", [e6.from]), o6 = { name: "GSNv2 Forwarder", version: "0.0.1", chainId: e6.chainId, verifyingContract: a5 }, y5 = { ForwardRequest: ar }, d6 = { from: e6.from, to: e6.to, value: BigNumber.from(0).toString(), gas: BigNumber.from(e6.gasLimit).toString(), nonce: BigNumber.from(s6).toString(), data: e6.data }, u7;
    if (this.emit(be.Signature, { status: "submitted", message: d6, signature: "" }), e6.functionName === "approve" && e6.functionArgs.length === 2) {
      let v9 = e6.functionArgs[0], F5 = e6.functionArgs[1], { message: ce2, signature: ge2 } = await ur(t6, this.writeContract.address, e6.from, v9, F5), { r: $i2, s: Gi2, v: zi } = ethers_exports.utils.splitSignature(ge2);
      d6 = { to: this.readContract.address, owner: ce2.owner, spender: ce2.spender, value: BigNumber.from(ce2.value).toString(), nonce: BigNumber.from(ce2.nonce).toString(), deadline: BigNumber.from(ce2.deadline).toString(), r: $i2, s: Gi2, v: zi }, u7 = ge2;
    } else {
      let { signature: v9 } = await jt(t6, o6, y5, d6);
      u7 = v9;
    }
    let m6 = "forward";
    d6 != null && d6.owner && (m6 = "permit");
    let b4 = JSON.stringify({ request: d6, signature: u7, type: m6 });
    this.emit(be.Signature, { status: "completed", message: d6, signature: u7 });
    let h6 = await fetch(this.options.gasless.openzeppelin.relayerUrl, { method: "POST", body: b4 });
    if (h6.ok) {
      let v9 = await h6.json();
      return JSON.parse(v9.result).txHash;
    }
    throw new Error(`relay transaction failed with status: ${h6.status} (${h6.statusText})`);
  }
};
p2(g2, "ContractWrapper");
var Ir = [{ inputs: [], name: "decimals", outputs: [{ internalType: "uint8", name: "", type: "uint8" }], stateMutability: "view", type: "function" }, { inputs: [], name: "name", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [], name: "symbol", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }];
function Te(r6) {
  return r6.toLowerCase() === Re || r6.toLowerCase() === lib_exports7.AddressZero;
}
p2(Te, "isNativeToken");
async function ie(r6, e6, t6) {
  let n4 = await Je(r6, t6);
  return utils_exports.parseUnits(Q.parse(e6), n4.decimals);
}
p2(ie, "normalizePriceValue");
async function Je(r6, e6) {
  if (Te(e6)) {
    let t6 = await r6.getNetwork(), n4 = I0(t6.chainId);
    return { name: n4.name, symbol: n4.symbol, decimals: n4.decimals };
  } else {
    let t6 = new Contract(e6, Ir, r6), [n4, a5, i6] = await Promise.all([t6.name(), t6.symbol(), t6.decimals()]);
    return { name: n4, symbol: a5, decimals: i6 };
  }
}
p2(Je, "fetchCurrencyMetadata");
async function q2(r6, e6, t6) {
  let n4 = await Je(r6, e6);
  return B(w({}, n4), { value: BigNumber.from(t6), displayValue: utils_exports.formatUnits(t6, n4.decimals) });
}
p2(q2, "fetchCurrencyValue");
async function Ie(r6, e6, t6, n4) {
  if (Te(t6))
    n4.value = e6;
  else {
    let a5 = r6.getSigner(), i6 = r6.getProvider(), s6 = new g2(a5 || i6, t6, K2, {}), o6 = await r6.getSignerAddress(), y5 = r6.readContract.address;
    return (await s6.readContract.allowance(o6, y5)).lt(e6) && await s6.sendTransaction("approve", [y5, e6]), n4;
  }
}
p2(Ie, "setErc20Allowance");
async function Er(r6, e6, t6, n4, a5) {
  let i6 = r6.getSigner(), s6 = r6.getProvider(), o6 = new g2(i6 || s6, e6, K2, {}), y5 = await r6.getSignerAddress(), d6 = r6.readContract.address, u7 = await o6.readContract.allowance(y5, d6), m6 = BigNumber.from(t6).mul(BigNumber.from(n4)).div(ethers_exports.utils.parseUnits("1", a5));
  u7.lt(m6) && await o6.sendTransaction("approve", [d6, u7.add(m6)]);
}
p2(Er, "approveErc20Allowance");
var J;
(function(r6) {
  r6[r6.Direct = 0] = "Direct", r6[r6.Auction = 1] = "Auction";
})(J || (J = {}));
var Pr;
(function(r6) {
  r6[r6.Pending = 0] = "Pending", r6[r6.Active = 1] = "Active", r6[r6.Canceled = 2] = "Canceled", r6[r6.Defeated = 3] = "Defeated", r6[r6.Succeeded = 4] = "Succeeded", r6[r6.Queued = 5] = "Queued", r6[r6.Expired = 6] = "Expired", r6[r6.Executed = 7] = "Executed";
})(Pr || (Pr = {}));
var vt;
(function(r6) {
  r6[r6.Against = 0] = "Against", r6[r6.For = 1] = "For", r6[r6.Abstain = 2] = "Abstain";
})(vt || (vt = {}));
var U;
(function(r6) {
  r6.NotEnoughSupply = "There is not enough supply to claim.", r6.AddressNotAllowed = "This address is not on the allowlist.", r6.WaitBeforeNextClaimTransaction = "Not enough time since last claim transaction. Please wait.", r6.AlreadyClaimed = "You have already claimed the token.", r6.NotEnoughTokens = "There are not enough tokens in the wallet to pay for the claim.", r6.NoActiveClaimPhase = "There is no active claim phase at the moment. Please check back in later.", r6.NoClaimConditionSet = "There is no claim condition set.", r6.Unknown = "No claim conditions found.";
})(U || (U = {}));
async function xt(r6, e6, t6, n4, a5, i6, s6 = [utils_exports.hexZeroPad([0], 32)]) {
  let o6 = await a5.getSignerAddress(), y5 = BigNumber.from(0);
  try {
    if (!e6.merkleRootHash.toString().startsWith(lib_exports7.AddressZero)) {
      let b4 = await i0(e6.merkleRootHash.toString(), t6, i6), h6 = b4 && b4.find((v9) => v9.address.toLowerCase() === o6.toLowerCase());
      if (h6 === void 0)
        throw new Error("No claim found for this address");
      s6 = h6.proof, y5 = ethers_exports.utils.parseUnits(h6.maxClaimable, n4);
    }
  } catch (b4) {
    if ((b4 == null ? void 0 : b4.message) === "No claim found for this address")
      throw b4;
    console.warn("failed to check claim condition merkle root hash, continuing anyways", b4);
  }
  let d6 = await a5.getCallOverrides() || {}, u7 = e6.price, m6 = e6.currencyAddress;
  return u7.gt(0) && (Te(m6) ? d6.value = BigNumber.from(u7).mul(r6).div(ethers_exports.utils.parseUnits("1", n4)) : await Er(a5, m6, u7, r6, n4)), { overrides: d6, proofs: s6, maxQuantityPerTransaction: y5, price: u7, currencyAddress: m6 };
}
p2(xt, "prepareClaim");
async function i0(r6, e6, t6) {
  let n4 = e6[r6], a5;
  if (n4) {
    let i6 = await t6.get(n4), s6 = It.parse(i6);
    r6 === s6.merkleRoot && (a5 = s6.claims);
  }
  return a5;
}
p2(i0, "fetchSnapshot");
async function ya(r6, e6, t6) {
  if (r6 >= t6.length)
    throw Error(`Index out of bounds - got index: ${r6} with ${t6.length} conditions`);
  let n4 = t6[r6].currencyMetadata.decimals, a5 = t6[r6].price, i6 = ethers_exports.utils.formatUnits(a5, n4), s6 = kt.parse(w(B(w({}, t6[r6]), { price: i6 }), e6)), o6 = Aa.parse(B(w({}, s6), { price: a5 }));
  return t6.map((y5, d6) => {
    let u7;
    d6 === r6 ? u7 = o6 : u7 = y5;
    let m6 = ethers_exports.utils.formatUnits(u7.price, n4);
    return B(w({}, u7), { price: m6 });
  });
}
p2(ya, "updateExistingClaimConditions");
async function da(r6, e6, t6, n4, a5) {
  let i6 = await i0(e6, n4, a5);
  if (i6 === void 0)
    return { proof: [], maxClaimable: BigNumber.from(0) };
  let s6 = i6.find((o6) => o6.address.toLowerCase() === (r6 == null ? void 0 : r6.toLowerCase()));
  return s6 === void 0 ? { proof: [], maxClaimable: BigNumber.from(0) } : { proof: s6.proof, maxClaimable: ethers_exports.utils.parseUnits(s6.maxClaimable, t6) };
}
p2(da, "getClaimerProofs");
async function ua(r6, e6, t6, n4) {
  let a5 = [], i6 = await Promise.all(r6.map(async (y5) => {
    if (y5.snapshot && y5.snapshot.length > 0) {
      let d6 = await fr(ft.parse(y5.snapshot), e6, n4);
      a5.push(d6), y5.merkleRootHash = d6.merkleRoot;
    } else
      y5.merkleRootHash = utils_exports.hexZeroPad([0], 32);
    return y5;
  })), s6 = E0.parse(i6), o6 = (await Promise.all(s6.map((y5) => Ao(y5, e6, t6)))).sort((y5, d6) => {
    let u7 = BigNumber.from(y5.startTimestamp), m6 = BigNumber.from(d6.startTimestamp);
    return u7.eq(m6) ? 0 : u7.gt(m6) ? 1 : -1;
  });
  return { snapshotInfos: a5, sortedConditions: o6 };
}
p2(ua, "processClaimConditionInputs");
async function Ao(r6, e6, t6) {
  let n4 = r6.currencyAddress === lib_exports7.AddressZero ? Re : r6.currencyAddress, a5, i6;
  return r6.maxQuantity === "unlimited" ? a5 = ethers_exports.constants.MaxUint256.toString() : a5 = ethers_exports.utils.parseUnits(r6.maxQuantity, e6), r6.quantityLimitPerTransaction === "unlimited" ? i6 = ethers_exports.constants.MaxUint256.toString() : i6 = ethers_exports.utils.parseUnits(r6.quantityLimitPerTransaction, e6), { startTimestamp: r6.startTime, maxClaimableSupply: a5, supplyClaimed: 0, quantityLimitPerTransaction: i6, waitTimeInSecondsBetweenClaims: r6.waitInSeconds, pricePerToken: await ie(t6, r6.price, n4), currency: n4, merkleRoot: r6.merkleRootHash };
}
p2(Ao, "convertToContractModel");
async function Mt(r6, e6, t6, n4, a5) {
  let i6 = await q2(t6, r6.currency, r6.pricePerToken), s6 = await i0(r6.merkleRoot, n4, a5), o6 = pa(r6.maxClaimableSupply, e6), y5 = pa(r6.quantityLimitPerTransaction, e6), d6 = pa(BigNumber.from(r6.maxClaimableSupply).sub(r6.supplyClaimed), e6), u7 = pa(r6.supplyClaimed, e6);
  return Aa.parse({ startTime: r6.startTimestamp, maxQuantity: o6, currentMintSupply: u7, availableSupply: d6, quantityLimitPerTransaction: y5, waitInSeconds: r6.waitTimeInSecondsBetweenClaims.toString(), price: BigNumber.from(r6.pricePerToken), currency: r6.currency, currencyAddress: r6.currency, currencyMetadata: i6, merkleRootHash: r6.merkleRoot, snapshot: s6 });
}
p2(Mt, "transformResultToClaimCondition");
function pa(r6, e6) {
  return r6.toString() === ethers_exports.constants.MaxUint256.toString() ? "unlimited" : ethers_exports.utils.formatUnits(r6, e6);
}
p2(pa, "convertToReadableQuantity");
var Br = I.merge(N2).merge(Ce).merge(k2);
var _o = O.merge(N2).merge(Ce).merge(k2);
var So = Br.merge(L).merge(ue).merge(D);
var Or = { deploy: So, output: _o, input: Br };
var Dr = I.merge(N2).merge(Ce).merge(k2);
var Io = O.merge(N2).merge(Ce).merge(k2);
var ko = Dr.merge(L).merge(ue).merge(D);
var Ur = { deploy: ko, output: Io, input: Dr };
var Nr = I;
var Eo = O;
var Po = Nr.merge(L).merge(D);
var Lr = { deploy: Po, output: Eo, input: Nr };
var Vr = I.merge(N2).merge(k2);
var Wo = O.merge(N2).merge(k2);
var Fo = Vr.merge(L).merge(D);
var qr = { deploy: Fo, output: Wo, input: Vr };
var $r = mod.object({ address: oe, sharesBps: Ge.gt(0, "Shares must be greater than 0") });
var Bo = $r.extend({ address: oe, sharesBps: Ge });
var s0 = I.extend({ recipients: mod.array($r).default([]).superRefine((r6, e6) => {
  let t6 = {}, n4 = 0;
  for (let a5 = 0; a5 < r6.length; a5++) {
    let i6 = r6[a5];
    t6[i6.address] && e6.addIssue({ code: mod.ZodIssueCode.custom, message: "Duplicate address.", path: [a5, "address"] }), t6[i6.address] = true, n4 += i6.sharesBps, n4 > 1e4 && e6.addIssue({ code: mod.ZodIssueCode.custom, message: "Total shares cannot go over 100%.", path: [a5, "sharesBps"] });
  }
  n4 !== 1e4 && e6.addIssue({ code: mod.ZodIssueCode.custom, message: `Total shares need to add up to 100%. Total shares are currently ${n4 / 100}%`, path: [] });
}) });
var Oo = O.extend({ recipients: mod.array(Bo) });
var Do = s0.merge(s0).merge(D);
var Gr = { deploy: Do, output: Oo, input: s0 };
var zr = I.merge(k2);
var Uo = O.merge(k2);
var No = zr.merge(L).merge(ue).merge(D);
var Hr = { deploy: No, output: Uo, input: zr };
var Zr = I.merge(N2).merge(k2);
var Lo = O.merge(N2).merge(k2);
var Vo = Zr.merge(L).merge(ue).merge(D);
var jr = { deploy: Vo, output: Lo, input: Zr };
var Yr = I.merge(N2).merge(k2);
var qo = O.merge(N2).merge(k2);
var $o = Yr.merge(L).merge(ue).merge(D);
var Qr = { deploy: $o, output: qo, input: Yr };
var Kr = mod.object({ voting_delay_in_blocks: mod.number().min(0).default(0), voting_period_in_blocks: mod.number().min(1).default(1), voting_token_address: oe, voting_quorum_fraction: M0.default(0), proposal_token_threshold: we.default(1) });
var Go = Kr.extend({ proposal_token_threshold: x });
var Jr = I.merge(Kr);
var zo = O.merge(Go);
var Ho = Jr.merge(D);
var Xr = { deploy: Ho, output: zo, input: Jr };
var Md = mod.object({ proposalId: x, proposer: mod.string(), targets: mod.array(mod.string()), values: mod.array(x), signatures: mod.array(mod.string()), calldatas: mod.array(mod.string()), startBlock: x, endBlock: x, description: mod.string() });
var yt = class {
  constructor(e6, t6, n4) {
    this.storage = n4, this.contractWrapper = e6, this.metadata = t6;
  }
  async getActive() {
    let e6 = await this.contractWrapper.readContract.getActiveClaimConditionId(), t6 = await this.contractWrapper.readContract.getClaimConditionById(e6), n4 = await this.metadata.get();
    return await Mt(t6, await this.getTokenDecimals(), this.contractWrapper.getProvider(), n4.merkle, this.storage);
  }
  async getAll() {
    let e6 = await this.contractWrapper.readContract.claimCondition(), t6 = e6.currentStartId.toNumber(), n4 = e6.count.toNumber(), a5 = [];
    for (let o6 = t6; o6 < t6 + n4; o6++)
      a5.push(await this.contractWrapper.readContract.getClaimConditionById(o6));
    let i6 = await this.metadata.get(), s6 = await this.getTokenDecimals();
    return Promise.all(a5.map((o6) => Mt(o6, s6, this.contractWrapper.getProvider(), i6.merkle, this.storage)));
  }
  async canClaim(e6, t6) {
    return t6 === void 0 && (t6 = await this.contractWrapper.getSignerAddress()), (await this.getClaimIneligibilityReasons(e6, t6)).length === 0;
  }
  async getClaimIneligibilityReasons(e6, t6) {
    let n4 = [], a5, i6, s6 = await this.getTokenDecimals(), o6 = ethers_exports.utils.parseUnits(Q.parse(e6), s6);
    t6 === void 0 && (t6 = await this.contractWrapper.getSignerAddress());
    try {
      [a5, i6] = await Promise.all([this.contractWrapper.readContract.getActiveClaimConditionId(), this.getActive()]);
    } catch (b4) {
      return Tt(b4, "!CONDITION") || Tt(b4, "no active mint condition") ? (n4.push(U.NoClaimConditionSet), n4) : (n4.push(U.Unknown), n4);
    }
    if (i6.availableSupply !== "unlimited" && ethers_exports.utils.parseUnits(i6.availableSupply, s6).lt(o6) && n4.push(U.NotEnoughSupply), ethers_exports.utils.stripZeros(i6.merkleRootHash).length > 0) {
      let b4 = i6.merkleRootHash.toString(), h6 = await this.metadata.get(), v9 = await da(t6, b4, await this.getTokenDecimals(), h6.merkle, this.storage);
      try {
        let [F5] = await this.contractWrapper.readContract.verifyClaimMerkleProof(a5, t6, e6, v9.proof, v9.maxClaimable);
        if (!F5)
          return n4.push(U.AddressNotAllowed), n4;
      } catch {
        return n4.push(U.AddressNotAllowed), n4;
      }
    }
    let [d6, u7] = await this.contractWrapper.readContract.getClaimTimestamp(a5, t6), m6 = BigNumber.from(Date.now()).div(1e3);
    if (d6.gt(0) && m6.lt(u7) && (u7.eq(lib_exports7.MaxUint256) ? n4.push(U.AlreadyClaimed) : n4.push(U.WaitBeforeNextClaimTransaction)), i6.price.gt(0) && !$e()) {
      let b4 = i6.price.mul(BigNumber.from(e6)), h6 = this.contractWrapper.getProvider();
      Te(i6.currencyAddress) ? (await h6.getBalance(t6)).lt(b4) && n4.push(U.NotEnoughTokens) : (await new g2(h6, i6.currencyAddress, K2, {}).readContract.balanceOf(t6)).lt(b4) && n4.push(U.NotEnoughTokens);
    }
    return n4;
  }
  async set(e6, t6 = false) {
    let { snapshotInfos: n4, sortedConditions: a5 } = await ua(e6, await this.getTokenDecimals(), this.contractWrapper.getProvider(), this.storage), i6 = {};
    n4.forEach((y5) => {
      i6[y5.merkleRoot] = y5.snapshotUri;
    });
    let s6 = await this.metadata.get(), o6 = [];
    if (!(0, import_deep_equal.default)(s6.merkle, i6)) {
      let y5 = this.metadata.parseInputMetadata(B(w({}, s6), { merkle: i6 })), d6 = await this.metadata._parseAndUploadMetadata(y5);
      o6.push(this.contractWrapper.readContract.interface.encodeFunctionData("setContractURI", [d6]));
    }
    return o6.push(this.contractWrapper.readContract.interface.encodeFunctionData("setClaimConditions", [a5, t6])), { receipt: await this.contractWrapper.multiCall(o6) };
  }
  async update(e6, t6) {
    let n4 = await this.getAll(), a5 = await ya(e6, t6, n4);
    return await this.set(a5);
  }
  async getTokenDecimals() {
    return R(this.contractWrapper, "ERC20") ? this.contractWrapper.readContract.decimals() : Promise.resolve(0);
  }
};
p2(yt, "DropClaimConditions");
var tn = class {
  constructor(e6, t6, n4) {
    this.storage = n4, this.contractWrapper = e6, this.metadata = t6;
  }
  async getActive(e6) {
    let t6 = await this.contractWrapper.readContract.getActiveClaimConditionId(e6), n4 = await this.contractWrapper.readContract.getClaimConditionById(e6, t6), a5 = await this.metadata.get();
    return await Mt(n4, 0, this.contractWrapper.getProvider(), a5.merkle, this.storage);
  }
  async getAll(e6) {
    let t6 = await this.contractWrapper.readContract.claimCondition(e6), n4 = t6.currentStartId.toNumber(), a5 = t6.count.toNumber(), i6 = [];
    for (let o6 = n4; o6 < n4 + a5; o6++)
      i6.push(await this.contractWrapper.readContract.getClaimConditionById(e6, o6));
    let s6 = await this.metadata.get();
    return Promise.all(i6.map((o6) => Mt(o6, 0, this.contractWrapper.getProvider(), s6.merkle, this.storage)));
  }
  async canClaim(e6, t6, n4) {
    return n4 === void 0 && (n4 = await this.contractWrapper.getSignerAddress()), (await this.getClaimIneligibilityReasons(e6, t6, n4)).length === 0;
  }
  async getClaimIneligibilityReasons(e6, t6, n4) {
    let a5 = [], i6, s6;
    n4 === void 0 && (n4 = await this.contractWrapper.getSignerAddress());
    try {
      [i6, s6] = await Promise.all([this.contractWrapper.readContract.getActiveClaimConditionId(e6), this.getActive(e6)]);
    } catch (m6) {
      return Tt(m6, "!CONDITION") || Tt(m6, "no active mint condition") ? (a5.push(U.NoClaimConditionSet), a5) : (a5.push(U.Unknown), a5);
    }
    if (s6.availableSupply !== "unlimited" && BigNumber.from(s6.availableSupply).lt(t6) && a5.push(U.NotEnoughSupply), ethers_exports.utils.stripZeros(s6.merkleRootHash).length > 0) {
      let m6 = s6.merkleRootHash.toString(), b4 = await this.metadata.get(), h6 = await da(n4, m6, 0, b4.merkle, this.storage);
      try {
        let [v9] = await this.contractWrapper.readContract.verifyClaimMerkleProof(i6, n4, e6, t6, h6.proof, h6.maxClaimable);
        if (!v9)
          return a5.push(U.AddressNotAllowed), a5;
      } catch {
        return a5.push(U.AddressNotAllowed), a5;
      }
    }
    let [y5, d6] = await this.contractWrapper.readContract.getClaimTimestamp(e6, i6, n4), u7 = BigNumber.from(Date.now()).div(1e3);
    if (y5.gt(0) && u7.lt(d6) && (d6.eq(lib_exports7.MaxUint256) ? a5.push(U.AlreadyClaimed) : a5.push(U.WaitBeforeNextClaimTransaction)), s6.price.gt(0) && !$e()) {
      let m6 = s6.price.mul(t6), b4 = this.contractWrapper.getProvider();
      Te(s6.currencyAddress) ? (await b4.getBalance(n4)).lt(m6) && a5.push(U.NotEnoughTokens) : (await new g2(b4, s6.currencyAddress, rt.abi, {}).readContract.balanceOf(n4)).lt(m6) && a5.push(U.NotEnoughTokens);
    }
    return a5;
  }
  async set(e6, t6, n4 = false) {
    let { snapshotInfos: a5, sortedConditions: i6 } = await ua(t6, 0, this.contractWrapper.getProvider(), this.storage), s6 = {};
    a5.forEach((d6) => {
      s6[d6.merkleRoot] = d6.snapshotUri;
    });
    let o6 = await this.metadata.get(), y5 = [];
    for (let d6 of Object.keys(o6.merkle))
      s6[d6] = o6.merkle[d6];
    if (!(0, import_deep_equal2.default)(o6.merkle, s6)) {
      let d6 = this.metadata.parseInputMetadata(B(w({}, o6), { merkle: s6 })), u7 = await this.metadata._parseAndUploadMetadata(d6);
      y5.push(this.contractWrapper.readContract.interface.encodeFunctionData("setContractURI", [u7]));
    }
    return y5.push(this.contractWrapper.readContract.interface.encodeFunctionData("setClaimConditions", [e6, i6, n4])), { receipt: await this.contractWrapper.multiCall(y5) };
  }
  async update(e6, t6, n4) {
    let a5 = await this.getAll(e6), i6 = await ya(t6, n4, a5);
    return await this.set(e6, i6);
  }
};
p2(tn, "DropErc1155ClaimConditions");
var nn = class {
  constructor(e6) {
    this.analytics = e6;
  }
  async getAllClaimerAddresses(e6) {
    let t6 = (await this.analytics.query("TokensClaimed")).filter((n4) => {
      var a5;
      return (a5 = n4.args) == null ? void 0 : a5.tokenId.eq(e6);
    });
    return Array.from(new Set(t6.map((n4) => {
      var a5;
      return (a5 = n4.args) == null ? void 0 : a5.claimer;
    })));
  }
};
p2(nn, "DropErc1155History");
var an = class {
  constructor(e6, t6) {
    __publicField(this, "featureName", na.name);
    this.erc20 = e6, this.contractWrapper = t6;
  }
  async to(e6) {
    let t6 = [];
    for (let n4 of e6)
      t6.push(this.contractWrapper.readContract.interface.encodeFunctionData("mintTo", [n4.toAddress, await this.erc20.normalizeAmount(n4.amount)]));
    return { receipt: await this.contractWrapper.multiCall(t6) };
  }
};
p2(an, "Erc20BatchMintable");
var rn = class {
  constructor(e6, t6) {
    __publicField(this, "featureName", aa.name);
    this.erc20 = e6, this.contractWrapper = t6, this.batch = this.detectErc20BatchMintable();
  }
  async to(e6, t6) {
    return { receipt: await this.contractWrapper.sendTransaction("mintTo", [e6, await this.erc20.normalizeAmount(t6)]) };
  }
  detectErc20BatchMintable() {
    if (R(this.contractWrapper, "ERC20BatchMintable"))
      return new an(this.erc20, this.contractWrapper);
  }
};
p2(rn, "Erc20Mintable");
var Le = class {
  constructor(e6, t6, n4 = {}) {
    __publicField(this, "featureName", Jt.name);
    this.contractWrapper = e6, this.storage = t6;
    try {
      this.options = xe.parse(n4);
    } catch (a5) {
      console.error("invalid contract options object passed, falling back to default options", a5), this.options = xe.parse({});
    }
    this.mint = this.detectErc20Mintable();
  }
  onNetworkUpdated(e6) {
    this.contractWrapper.updateSignerOrProvider(e6);
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  async get() {
    return await Je(this.contractWrapper.getProvider(), this.getAddress());
  }
  async balance() {
    return await this.balanceOf(await this.contractWrapper.getSignerAddress());
  }
  async balanceOf(e6) {
    return this.getValue(await this.contractWrapper.readContract.balanceOf(e6));
  }
  async totalSupply() {
    return await this.getValue(await this.contractWrapper.readContract.totalSupply());
  }
  async allowance(e6) {
    return await this.allowanceOf(await this.contractWrapper.getSignerAddress(), e6);
  }
  async allowanceOf(e6, t6) {
    return await this.getValue(await this.contractWrapper.readContract.allowance(e6, t6));
  }
  async transfer(e6, t6) {
    return { receipt: await this.contractWrapper.sendTransaction("transfer", [e6, await this.normalizeAmount(t6)]) };
  }
  async transferFrom(e6, t6, n4) {
    return { receipt: await this.contractWrapper.sendTransaction("transferFrom", [e6, t6, await this.normalizeAmount(n4)]) };
  }
  async setAllowance(e6, t6) {
    return { receipt: await this.contractWrapper.sendTransaction("approve", [e6, await this.normalizeAmount(t6)]) };
  }
  async transferBatch(e6) {
    let t6 = await Promise.all(e6.map(async (n4) => {
      let a5 = await this.normalizeAmount(n4.amount);
      return this.contractWrapper.readContract.interface.encodeFunctionData("transfer", [n4.toAddress, a5]);
    }));
    await this.contractWrapper.multiCall(t6);
  }
  async getValue(e6) {
    return await q2(this.contractWrapper.getProvider(), this.getAddress(), BigNumber.from(e6));
  }
  async normalizeAmount(e6) {
    let t6 = await this.contractWrapper.readContract.decimals();
    return ethers_exports.utils.parseUnits(Q.parse(e6), t6);
  }
  detectErc20Mintable() {
    if (R(this.contractWrapper, "ERC20"))
      return new rn(this, this.contractWrapper);
  }
};
p2(Le, "Erc20");
var sn = class {
  constructor(e6, t6) {
    this.contractWrapper = e6, this.analytics = t6;
  }
  async getAllHolderBalances() {
    let t6 = (await this.analytics.query("Transfer")).map((a5) => a5.args), n4 = {};
    return t6.forEach((a5) => {
      let i6 = a5 == null ? void 0 : a5.from, s6 = a5 == null ? void 0 : a5.to, o6 = a5 == null ? void 0 : a5.value;
      i6 !== lib_exports7.AddressZero && (i6 in n4 || (n4[i6] = BigNumber.from(0)), n4[i6] = n4[i6].sub(o6)), s6 !== lib_exports7.AddressZero && (s6 in n4 || (n4[s6] = BigNumber.from(0)), n4[s6] = n4[s6].add(o6));
    }), Promise.all(Object.keys(n4).map(async (a5) => ({ holder: a5, balance: await q2(this.contractWrapper.getProvider(), this.contractWrapper.readContract.address, n4[a5]) })));
  }
};
p2(sn, "TokenERC20History");
var on = class {
  constructor(e6, t6) {
    this.contractWrapper = e6, this.roles = t6;
  }
  async mint(e6) {
    let t6 = e6.payload, n4 = e6.signature, a5 = await this.mapPayloadToContractStruct(t6), i6 = await this.contractWrapper.getCallOverrides();
    return await Ie(this.contractWrapper, BigNumber.from(a5.price), t6.currencyAddress, i6), { receipt: await this.contractWrapper.sendTransaction("mintWithSignature", [a5, n4], i6) };
  }
  async mintBatch(e6) {
    let n4 = (await Promise.all(e6.map(async (a5) => {
      let i6 = await this.mapPayloadToContractStruct(a5.payload), s6 = a5.signature, o6 = a5.payload.price;
      if (BigNumber.from(o6).gt(0))
        throw new Error("Can only batch free mints. For mints with a price, use regular mint()");
      return { message: i6, signature: s6 };
    }))).map((a5) => this.contractWrapper.readContract.interface.encodeFunctionData("mintWithSignature", [a5.message, a5.signature]));
    return { receipt: await this.contractWrapper.multiCall(n4) };
  }
  async verify(e6) {
    let t6 = e6.payload, n4 = e6.signature, a5 = await this.mapPayloadToContractStruct(t6);
    return (await this.contractWrapper.readContract.verify(a5, n4))[0];
  }
  async generate(e6) {
    return (await this.generateBatch([e6]))[0];
  }
  async generateBatch(e6) {
    await this.roles.verify(["minter"], await this.contractWrapper.getSignerAddress());
    let t6 = e6.map((s6) => ka.parse(s6)), n4 = await this.contractWrapper.getChainID(), a5 = this.contractWrapper.getSigner();
    invariant(a5, "No signer available");
    let i6 = await this.contractWrapper.readContract.name();
    return await Promise.all(t6.map(async (s6) => {
      let o6 = O0.parse(s6), y5 = await this.contractWrapper.signTypedData(a5, { name: i6, version: "1", chainId: n4, verifyingContract: this.contractWrapper.readContract.address }, { MintRequest: N0 }, await this.mapPayloadToContractStruct(o6));
      return { payload: o6, signature: y5.toString() };
    }));
  }
  async mapPayloadToContractStruct(e6) {
    let t6 = await ie(this.contractWrapper.getProvider(), e6.price, e6.currencyAddress), n4 = ethers_exports.utils.parseUnits(e6.quantity, await this.contractWrapper.readContract.decimals());
    return { to: e6.to, primarySaleRecipient: e6.primarySaleRecipient, quantity: n4, price: t6, currency: e6.currencyAddress, validityEndTimestamp: e6.mintEndTime, validityStartTimestamp: e6.mintStartTime, uid: e6.uid };
  }
};
p2(on, "Erc20SignatureMinting");
var ii = [{ inputs: [], name: "name", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [], name: "symbol", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "_tokenId", type: "uint256" }], name: "tokenURI", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }];
var si = [{ inputs: [{ internalType: "uint256", name: "_id", type: "uint256" }], name: "uri", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }];
var dt = [{ inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }], name: "supportsInterface", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }];
async function ut(r6, e6, t6) {
  let n4 = e6.replace("{id}", BigNumber.from(r6).toHexString().slice(2)), a5 = await t6.get(n4);
  return Nn.parse(w({ id: BigNumber.from(r6), uri: e6 }, a5));
}
p2(ut, "fetchTokenMetadata");
async function et(r6, e6, t6, n4) {
  let a5, i6 = new Contract(r6, dt, e6), s6 = await i6.supportsInterface(st), o6 = await i6.supportsInterface(ot);
  if (s6)
    a5 = await new Contract(r6, ii, e6).tokenURI(t6);
  else if (o6)
    a5 = await new Contract(r6, si, e6).uri(t6);
  else
    throw Error("Contract must implement ERC 1155 or ERC 721.");
  if (!a5)
    throw new Ae();
  return ut(t6, a5, n4);
}
p2(et, "fetchTokenMetadataForContract");
async function ca(r6, e6) {
  return typeof r6 == "string" ? r6 : await e6.uploadMetadata(le.parse(r6));
}
p2(ca, "uploadOrExtractURI");
async function tt(r6, e6) {
  if (ip(r6))
    return r6;
  if (sp(r6)) {
    let { metadataUris: t6 } = await e6.uploadMetadataBatch(r6.map((n4) => le.parse(n4)));
    return t6;
  } else
    throw new Error("NFT metadatas must all be of the same type (all URI or all NFTMetadataInput)");
}
p2(tt, "uploadOrExtractURIs");
function ip(r6) {
  return r6.find((e6) => typeof e6 != "string") === void 0;
}
p2(ip, "isUriList");
function sp(r6) {
  return r6.find((e6) => typeof e6 != "object") === void 0;
}
p2(sp, "isMetadataList");
var pi;
(function(r6) {
  r6[r6.None = 0] = "None", r6[r6.ERC20 = 1] = "ERC20", r6[r6.ERC721 = 2] = "ERC721";
})(pi || (pi = {}));
var yn = class {
  constructor(e6, t6) {
    __publicField(this, "featureName", ea.name);
    this.erc721 = e6, this.contractWrapper = t6;
  }
  async all(e6) {
    let t6 = await this.tokenIds(e6);
    return await Promise.all(t6.map((n4) => this.erc721.get(n4.toString())));
  }
  async tokenIds(e6) {
    let t6 = e6 || await this.contractWrapper.getSignerAddress(), n4 = await this.contractWrapper.readContract.balanceOf(t6), a5 = Array.from(Array(n4.toNumber()).keys());
    return await Promise.all(a5.map((i6) => this.contractWrapper.readContract.tokenOfOwnerByIndex(t6, i6)));
  }
};
p2(yn, "Erc721Enumerable");
var dn = class {
  constructor(e6, t6) {
    __publicField(this, "featureName", ta.name);
    this.erc721 = e6, this.contractWrapper = t6, this.owned = this.detectErc721Owned();
  }
  async all(e6) {
    let t6 = BigNumber.from((e6 == null ? void 0 : e6.start) || 0).toNumber(), n4 = BigNumber.from((e6 == null ? void 0 : e6.count) || 100).toNumber(), a5 = await this.totalCirculatingSupply();
    this.hasNextIdToMint(this.contractWrapper) && (a5 = await this.contractWrapper.readContract.nextTokenIdToMint());
    let i6 = Math.min(a5.toNumber(), t6 + n4);
    return await Promise.all([...Array(i6 - t6).keys()].map((s6) => this.erc721.get((t6 + s6).toString())));
  }
  async totalCirculatingSupply() {
    return await this.contractWrapper.readContract.totalSupply();
  }
  hasNextIdToMint(e6) {
    return "nextTokenIdToMint" in e6.readContract.functions;
  }
  detectErc721Owned() {
    if (R(this.contractWrapper, "ERC721Enumerable"))
      return new yn(this.erc721, this.contractWrapper);
  }
};
p2(dn, "Erc721Supply");
var un = class {
  constructor(e6, t6, n4) {
    __publicField(this, "featureName", Jn.name);
    this.erc721 = e6, this.contractWrapper = t6, this.storage = n4;
  }
  async to(e6, t6) {
    let a5 = (await tt(t6, this.storage)).map((o6) => this.contractWrapper.readContract.interface.encodeFunctionData("mintTo", [e6, o6])), i6 = await this.contractWrapper.multiCall(a5), s6 = this.contractWrapper.parseLogs("TokensMinted", i6.logs);
    if (s6.length === 0 || s6.length < t6.length)
      throw new Error("TokenMinted event not found, minting failed");
    return s6.map((o6) => {
      let y5 = o6.args.tokenIdMinted;
      return { id: y5, receipt: i6, data: () => this.erc721.get(y5) };
    });
  }
};
p2(un, "Erc721BatchMintable");
var cn = class {
  constructor(e6, t6, n4) {
    __publicField(this, "featureName", Xn.name);
    this.erc721 = e6, this.contractWrapper = t6, this.storage = n4, this.batch = this.detectErc721BatchMintable();
  }
  async to(e6, t6) {
    let n4 = await ca(t6, this.storage), a5 = await this.contractWrapper.sendTransaction("mintTo", [e6, n4]), i6 = this.contractWrapper.parseLogs("TokensMinted", a5 == null ? void 0 : a5.logs);
    if (i6.length === 0)
      throw new Error("TokenMinted event not found");
    let s6 = i6[0].args.tokenIdMinted;
    return { id: s6, receipt: a5, data: () => this.erc721.get(s6) };
  }
  detectErc721BatchMintable() {
    if (R(this.contractWrapper, "ERC721BatchMintable"))
      return new un(this.erc721, this.contractWrapper, this.storage);
  }
};
p2(cn, "Erc721Mintable");
var Ve = class {
  constructor(e6, t6, n4 = {}) {
    __publicField(this, "featureName", Kt.name);
    this.contractWrapper = e6, this.storage = t6;
    try {
      this.options = xe.parse(n4);
    } catch (a5) {
      console.error("invalid contract options object passed, falling back to default options", a5), this.options = xe.parse({});
    }
    this.query = this.detectErc721Enumerable(), this.mint = this.detectErc721Mintable();
  }
  onNetworkUpdated(e6) {
    this.contractWrapper.updateSignerOrProvider(e6);
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  async get(e6) {
    let [t6, n4] = await Promise.all([this.ownerOf(e6).catch(() => lib_exports7.AddressZero), this.getTokenMetadata(e6)]);
    return { owner: t6, metadata: n4 };
  }
  async ownerOf(e6) {
    return await this.contractWrapper.readContract.ownerOf(e6);
  }
  async balanceOf(e6) {
    return await this.contractWrapper.readContract.balanceOf(e6);
  }
  async balance() {
    return await this.balanceOf(await this.contractWrapper.getSignerAddress());
  }
  async isApproved(e6, t6) {
    return await this.contractWrapper.readContract.isApprovedForAll(e6, t6);
  }
  async transfer(e6, t6) {
    let n4 = await this.contractWrapper.getSignerAddress();
    return { receipt: await this.contractWrapper.sendTransaction("safeTransferFrom(address,address,uint256)", [n4, e6, t6]) };
  }
  async setApprovalForAll(e6, t6) {
    return { receipt: await this.contractWrapper.sendTransaction("setApprovalForAll", [e6, t6]) };
  }
  async getTokenMetadata(e6) {
    let t6 = await this.contractWrapper.readContract.tokenURI(e6);
    if (!t6)
      throw new Ae();
    return ut(e6, t6, this.storage);
  }
  detectErc721Enumerable() {
    if (R(this.contractWrapper, "ERC721Supply"))
      return new dn(this, this.contractWrapper);
  }
  detectErc721Mintable() {
    if (R(this.contractWrapper, "ERC721Mintable"))
      return new cn(this, this.contractWrapper, this.storage);
  }
};
p2(Ve, "Erc721");
var ln = class {
  constructor(e6, t6, n4) {
    this.contractWrapper = e6, this.storage = n4, this.roles = t6;
  }
  async mint(e6) {
    let t6 = e6.payload, n4 = e6.signature, a5 = await this.mapPayloadToContractStruct(t6), i6 = await this.contractWrapper.getCallOverrides();
    await Ie(this.contractWrapper, BigNumber.from(a5.price), t6.currencyAddress, i6);
    let s6 = await this.contractWrapper.sendTransaction("mintWithSignature", [a5, n4], i6), o6 = this.contractWrapper.parseLogs("TokensMintedWithSignature", s6.logs);
    if (o6.length === 0)
      throw new Error("No MintWithSignature event found");
    return { id: o6[0].args.tokenIdMinted, receipt: s6 };
  }
  async mintBatch(e6) {
    let n4 = (await Promise.all(e6.map(async (s6) => {
      let o6 = await this.mapPayloadToContractStruct(s6.payload), y5 = s6.signature, d6 = s6.payload.price;
      if (BigNumber.from(d6).gt(0))
        throw new Error("Can only batch free mints. For mints with a price, use regular mint()");
      return { message: o6, signature: y5 };
    }))).map((s6) => this.contractWrapper.readContract.interface.encodeFunctionData("mintWithSignature", [s6.message, s6.signature])), a5 = await this.contractWrapper.multiCall(n4), i6 = this.contractWrapper.parseLogs("TokensMintedWithSignature", a5.logs);
    if (i6.length === 0)
      throw new Error("No MintWithSignature event found");
    return i6.map((s6) => ({ id: s6.args.tokenIdMinted, receipt: a5 }));
  }
  async verify(e6) {
    let t6 = e6.payload, n4 = e6.signature, a5 = await this.mapPayloadToContractStruct(t6);
    return (await this.contractWrapper.readContract.verify(a5, n4))[0];
  }
  async generate(e6) {
    return (await this.generateBatch([e6]))[0];
  }
  async generateBatch(e6) {
    await this.roles.verify(["minter"], await this.contractWrapper.getSignerAddress());
    let t6 = e6.map((o6) => Ln.parse(o6)), n4 = t6.map((o6) => o6.metadata), a5 = await tt(n4, this.storage), i6 = await this.contractWrapper.getChainID(), s6 = this.contractWrapper.getSigner();
    return invariant(s6, "No signer available"), await Promise.all(t6.map(async (o6, y5) => {
      let d6 = a5[y5], u7 = Ea.parse(B(w({}, o6), { uri: d6 })), m6 = await this.contractWrapper.signTypedData(s6, { name: "TokenERC721", version: "1", chainId: i6, verifyingContract: this.contractWrapper.readContract.address }, { MintRequest: L0 }, await this.mapPayloadToContractStruct(u7));
      return { payload: u7, signature: m6.toString() };
    }));
  }
  async mapPayloadToContractStruct(e6) {
    let t6 = await ie(this.contractWrapper.getProvider(), e6.price, e6.currencyAddress);
    return { to: e6.to, price: t6, uri: e6.uri, currency: e6.currencyAddress, validityEndTimestamp: e6.mintEndTime, validityStartTimestamp: e6.mintStartTime, uid: e6.uid, royaltyRecipient: e6.royaltyRecipient, royaltyBps: e6.royaltyBps, primarySaleRecipient: e6.primarySaleRecipient };
  }
};
p2(ln, "Erc721SignatureMinting");
var ui = mod.object({ address: oe, quantity: Q.default(1) });
var ci = mod.union([mod.array(mod.string()).transform((r6) => r6.map((e6) => ui.parse({ address: e6 }))), mod.array(ui)]);
var fn = class {
  constructor(e6, t6) {
    __publicField(this, "featureName", sa.name);
    this.erc1155 = e6, this.contractWrapper = t6;
  }
  async all(e6) {
    let t6 = BigNumber.from((e6 == null ? void 0 : e6.start) || 0).toNumber(), n4 = BigNumber.from((e6 == null ? void 0 : e6.count) || 100).toNumber(), a5 = Math.min((await this.getTotalCount()).toNumber(), t6 + n4);
    return await Promise.all([...Array(a5 - t6).keys()].map((i6) => this.erc1155.get((t6 + i6).toString())));
  }
  async getTotalCount() {
    return await this.contractWrapper.readContract.nextTokenIdToMint();
  }
  async owned(e6) {
    let t6 = e6 || await this.contractWrapper.getSignerAddress(), n4 = await this.contractWrapper.readContract.nextTokenIdToMint(), i6 = (await this.contractWrapper.readContract.balanceOfBatch(Array(n4.toNumber()).fill(t6), Array.from(Array(n4.toNumber()).keys()))).map((s6, o6) => ({ tokenId: o6, balance: s6 })).filter((s6) => s6.balance.gt(0));
    return await Promise.all(i6.map(async (s6) => {
      let o6 = await this.erc1155.get(s6.tokenId.toString());
      return B(w({}, o6), { owner: t6, quantityOwned: s6.balance });
    }));
  }
};
p2(fn, "Erc1155Enumerable");
var bn = class {
  constructor(e6, t6, n4) {
    __publicField(this, "featureName", ra.name);
    this.erc1155 = e6, this.contractWrapper = t6, this.storage = n4;
  }
  async to(e6, t6) {
    let n4 = t6.map((d6) => d6.metadata), a5 = t6.map((d6) => d6.supply), s6 = (await tt(n4, this.storage)).map((d6, u7) => this.contractWrapper.readContract.interface.encodeFunctionData("mintTo", [e6, ethers_exports.constants.MaxUint256, d6, a5[u7]])), o6 = await this.contractWrapper.multiCall(s6), y5 = this.contractWrapper.parseLogs("TokensMinted", o6.logs);
    if (y5.length === 0 || y5.length < n4.length)
      throw new Error("TokenMinted event not found, minting failed");
    return y5.map((d6) => {
      let u7 = d6.args.tokenIdMinted;
      return { id: u7, receipt: o6, data: () => this.erc1155.get(u7) };
    });
  }
};
p2(bn, "Erc1155BatchMintable");
var Tn = class {
  constructor(e6, t6, n4) {
    __publicField(this, "featureName", ia.name);
    this.erc1155 = e6, this.contractWrapper = t6, this.storage = n4, this.batch = this.detectErc1155BatchMintable();
  }
  async to(e6, t6) {
    let n4 = await ca(t6.metadata, this.storage), a5 = await this.contractWrapper.sendTransaction("mintTo", [e6, ethers_exports.constants.MaxUint256, n4, t6.supply]), i6 = this.contractWrapper.parseLogs("TokensMinted", a5 == null ? void 0 : a5.logs);
    if (i6.length === 0)
      throw new Error("TokenMinted event not found");
    let s6 = i6[0].args.tokenIdMinted;
    return { id: s6, receipt: a5, data: () => this.erc1155.get(s6.toString()) };
  }
  async additionalSupplyTo(e6, t6, n4) {
    let a5 = await this.erc1155.getTokenMetadata(t6), i6 = await this.contractWrapper.sendTransaction("mintTo", [e6, t6, a5.uri, n4]);
    return { id: BigNumber.from(t6), receipt: i6, data: () => this.erc1155.get(t6) };
  }
  detectErc1155BatchMintable() {
    if (R(this.contractWrapper, "ERC1155BatchMintable"))
      return new bn(this.erc1155, this.contractWrapper, this.storage);
  }
};
p2(Tn, "Erc1155Mintable");
var qe = class {
  constructor(e6, t6, n4 = {}) {
    __publicField(this, "featureName", Xt.name);
    this.contractWrapper = e6, this.storage = t6;
    try {
      this.options = xe.parse(n4);
    } catch (a5) {
      console.error("invalid contract options object passed, falling back to default options", a5), this.options = xe.parse({});
    }
    this.query = this.detectErc1155Enumerable(), this.mint = this.detectErc1155Mintable();
  }
  onNetworkUpdated(e6) {
    this.contractWrapper.updateSignerOrProvider(e6);
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  async get(e6) {
    let [t6, n4] = await Promise.all([this.contractWrapper.readContract.totalSupply(e6).catch(() => BigNumber.from(0)), this.getTokenMetadata(e6)]);
    return Pa.parse({ supply: t6, metadata: n4 });
  }
  async totalSupply(e6) {
    return await this.contractWrapper.readContract.totalSupply(e6);
  }
  async balanceOf(e6, t6) {
    return await this.contractWrapper.readContract.balanceOf(e6, t6);
  }
  async balance(e6) {
    return await this.balanceOf(await this.contractWrapper.getSignerAddress(), e6);
  }
  async isApproved(e6, t6) {
    return await this.contractWrapper.readContract.isApprovedForAll(e6, t6);
  }
  async transfer(e6, t6, n4, a5 = [0]) {
    let i6 = await this.contractWrapper.getSignerAddress();
    return { receipt: await this.contractWrapper.sendTransaction("safeTransferFrom", [i6, e6, t6, n4, a5]) };
  }
  async setApprovalForAll(e6, t6) {
    return { receipt: await this.contractWrapper.sendTransaction("setApprovalForAll", [e6, t6]) };
  }
  async airdrop(e6, t6, n4 = [0]) {
    let a5 = await this.contractWrapper.getSignerAddress(), i6 = await this.balanceOf(a5, e6), s6 = ci.parse(t6), o6 = s6.reduce((d6, u7) => d6 + Number((u7 == null ? void 0 : u7.quantity) || 1), 0);
    if (i6.toNumber() < o6)
      throw new Error(`The caller owns ${i6.toNumber()} NFTs, but wants to airdrop ${o6} NFTs.`);
    let y5 = s6.map(({ address: d6, quantity: u7 }) => this.contractWrapper.readContract.interface.encodeFunctionData("safeTransferFrom", [a5, d6, e6, u7, n4]));
    return { receipt: await this.contractWrapper.multiCall(y5) };
  }
  async getTokenMetadata(e6) {
    let t6 = await this.contractWrapper.readContract.uri(e6);
    if (!t6)
      throw new Ae();
    return ut(e6, t6, this.storage);
  }
  detectErc1155Enumerable() {
    if (R(this.contractWrapper, "ERC1155Enumerable"))
      return new fn(this, this.contractWrapper);
  }
  detectErc1155Mintable() {
    if (R(this.contractWrapper, "ERC1155Mintable"))
      return new Tn(this, this.contractWrapper, this.storage);
  }
};
p2(qe, "Erc1155");
var hn = class {
  constructor(e6, t6, n4) {
    this.contractWrapper = e6, this.storage = n4, this.roles = t6;
  }
  async mint(e6) {
    let t6 = e6.payload, n4 = e6.signature, a5 = await this.mapPayloadToContractStruct(t6), i6 = await this.contractWrapper.getCallOverrides();
    await Ie(this.contractWrapper, a5.pricePerToken.mul(a5.quantity), t6.currencyAddress, i6);
    let s6 = await this.contractWrapper.sendTransaction("mintWithSignature", [a5, n4], i6), o6 = this.contractWrapper.parseLogs("TokensMintedWithSignature", s6.logs);
    if (o6.length === 0)
      throw new Error("No MintWithSignature event found");
    return { id: o6[0].args.tokenIdMinted, receipt: s6 };
  }
  async mintBatch(e6) {
    let n4 = (await Promise.all(e6.map(async (s6) => {
      let o6 = await this.mapPayloadToContractStruct(s6.payload), y5 = s6.signature, d6 = s6.payload.price;
      if (BigNumber.from(d6).gt(0))
        throw new Error("Can only batch free mints. For mints with a price, use regular mint()");
      return { message: o6, signature: y5 };
    }))).map((s6) => this.contractWrapper.readContract.interface.encodeFunctionData("mintWithSignature", [s6.message, s6.signature])), a5 = await this.contractWrapper.multiCall(n4), i6 = this.contractWrapper.parseLogs("TokensMintedWithSignature", a5.logs);
    if (i6.length === 0)
      throw new Error("No MintWithSignature event found");
    return i6.map((s6) => ({ id: s6.args.tokenIdMinted, receipt: a5 }));
  }
  async verify(e6) {
    let t6 = e6.payload, n4 = e6.signature, a5 = await this.mapPayloadToContractStruct(t6);
    return (await this.contractWrapper.readContract.verify(a5, n4))[0];
  }
  async generate(e6) {
    return (await this.generateBatch([e6]))[0];
  }
  async generateBatch(e6) {
    await this.roles.verify(["minter"], await this.contractWrapper.getSignerAddress());
    let t6 = e6.map((o6) => D0.parse(o6)), n4 = t6.map((o6) => o6.metadata), a5 = await tt(n4, this.storage), i6 = await this.contractWrapper.getChainID(), s6 = this.contractWrapper.getSigner();
    return invariant(s6, "No signer available"), await Promise.all(t6.map(async (o6, y5) => {
      let d6 = a5[y5], u7 = U0.parse(B(w({}, o6), { uri: d6 })), m6 = await this.contractWrapper.signTypedData(s6, { name: "TokenERC1155", version: "1", chainId: i6, verifyingContract: this.contractWrapper.readContract.address }, { MintRequest: V0 }, await this.mapPayloadToContractStruct(u7));
      return { payload: u7, signature: m6.toString() };
    }));
  }
  async mapPayloadToContractStruct(e6) {
    let t6 = await ie(this.contractWrapper.getProvider(), e6.price, e6.currencyAddress);
    return { to: e6.to, tokenId: e6.tokenId, uri: e6.uri, quantity: e6.quantity, pricePerToken: t6, currency: e6.currencyAddress, validityStartTimestamp: e6.mintStartTime, validityEndTimestamp: e6.mintEndTime, uid: e6.uid, royaltyRecipient: e6.royaltyRecipient, royaltyBps: e6.royaltyBps, primarySaleRecipient: e6.primarySaleRecipient };
  }
};
p2(hn, "Erc1155SignatureMinting");
async function mi(r6, e6, t6, n4, a5) {
  try {
    let i6 = new Contract(t6, dt, r6), s6 = await i6.supportsInterface(st), o6 = await i6.supportsInterface(ot);
    if (s6) {
      let y5 = new Contract(t6, _e, r6);
      return await y5.isApprovedForAll(a5, e6) ? true : (await y5.getApproved(n4)).toLowerCase() === e6.toLowerCase();
    } else
      return o6 ? await new Contract(t6, Me, r6).isApprovedForAll(a5, e6) : (console.error("Contract does not implement ERC 1155 or ERC 721."), false);
  } catch (i6) {
    return console.error("Failed to check if token is approved", i6), false;
  }
}
p2(mi, "isTokenApprovedForMarketplace");
async function fa(r6, e6, t6, n4, a5) {
  let i6 = new Contract(t6, dt, r6), s6 = await i6.supportsInterface(st), o6 = await i6.supportsInterface(ot);
  if (s6) {
    let y5 = new g2(r6, t6, _e, {});
    await y5.readContract.isApprovedForAll(a5, e6) || (await y5.readContract.getApproved(n4)).toLowerCase() === e6.toLowerCase() || await y5.sendTransaction("setApprovalForAll", [e6, true]);
  } else if (o6) {
    let y5 = new g2(r6, t6, Me, {});
    await y5.readContract.isApprovedForAll(a5, e6) || await y5.sendTransaction("setApprovalForAll", [e6, true]);
  } else
    throw Error("Contract must implement ERC 1155 or ERC 721.");
}
p2(fa, "handleTokenApproval");
function ba(r6) {
  switch (invariant(r6.assetContractAddress !== void 0 && r6.assetContractAddress !== null, "Asset contract address is required"), invariant(r6.buyoutPricePerToken !== void 0 && r6.buyoutPricePerToken !== null, "Buyout price is required"), invariant(r6.listingDurationInSeconds !== void 0 && r6.listingDurationInSeconds !== null, "Listing duration is required"), invariant(r6.startTimestamp !== void 0 && r6.startTimestamp !== null, "Start time is required"), invariant(r6.tokenId !== void 0 && r6.tokenId !== null, "Token ID is required"), invariant(r6.quantity !== void 0 && r6.quantity !== null, "Quantity is required"), r6.type) {
    case "NewAuctionListing":
      invariant(r6.reservePricePerToken !== void 0 && r6.reservePricePerToken !== null, "Reserve price is required");
  }
}
p2(ba, "validateNewListingParam");
async function Ta(r6, e6, t6) {
  return { quantity: t6.quantityDesired, pricePerToken: t6.pricePerToken, currencyContractAddress: t6.currency, buyerAddress: t6.offeror, quantityDesired: t6.quantityWanted, currencyValue: await q2(r6, t6.currency, t6.quantityWanted.mul(t6.pricePerToken)), listingId: e6 };
}
p2(Ta, "mapOffer");
function fi(r6, e6, t6) {
  return t6 = BigNumber.from(t6), r6 = BigNumber.from(r6), e6 = BigNumber.from(e6), r6.eq(BigNumber.from(0)) ? false : e6.sub(r6).mul(xa).div(r6).gte(t6);
}
p2(fi, "isWinningBid");
var gn = class {
  constructor(e6, t6) {
    this.contractWrapper = e6, this.storage = t6;
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  async getListing(e6) {
    let t6 = await this.contractWrapper.readContract.listings(e6);
    if (t6.assetContract === lib_exports7.AddressZero)
      throw new Be(this.getAddress(), e6.toString());
    if (t6.listingType !== J.Direct)
      throw new at(this.getAddress(), e6.toString(), "Auction", "Direct");
    return await this.mapListing(t6);
  }
  async getActiveOffer(e6, t6) {
    await this.validateListing(BigNumber.from(e6)), invariant(utils_exports.isAddress(t6), "Address must be a valid address");
    let n4 = await this.contractWrapper.readContract.offers(e6, t6);
    if (n4.offeror !== lib_exports7.AddressZero)
      return await Ta(this.contractWrapper.getProvider(), BigNumber.from(e6), n4);
  }
  async createListing(e6) {
    ba(e6), await fa(this.contractWrapper.getSignerOrProvider(), this.getAddress(), e6.assetContractAddress, e6.tokenId, await this.contractWrapper.getSignerAddress());
    let t6 = await ie(this.contractWrapper.getProvider(), e6.buyoutPricePerToken, e6.currencyContractAddress), n4 = Math.floor(e6.startTimestamp.getTime() / 1e3), i6 = (await this.contractWrapper.getProvider().getBlock("latest")).timestamp;
    n4 < i6 && (n4 = i6);
    let s6 = await this.contractWrapper.sendTransaction("createListing", [{ assetContract: e6.assetContractAddress, tokenId: e6.tokenId, buyoutPricePerToken: t6, currencyToAccept: e6.currencyContractAddress, listingType: J.Direct, quantityToList: e6.quantity, reservePricePerToken: t6, secondsUntilEndTime: e6.listingDurationInSeconds, startTime: BigNumber.from(n4) }], { gasLimit: 5e5 });
    return { id: this.contractWrapper.parseLogs("ListingAdded", s6 == null ? void 0 : s6.logs)[0].args.listingId, receipt: s6 };
  }
  async makeOffer(e6, t6, n4, a5, i6) {
    if (Te(n4))
      throw new Error("You must use the wrapped native token address when making an offer with a native token");
    let s6 = await ie(this.contractWrapper.getProvider(), a5, n4);
    try {
      await this.getListing(e6);
    } catch (m6) {
      throw console.error("Failed to get listing, err =", m6), new Error(`Error getting the listing with id ${e6}`);
    }
    let o6 = BigNumber.from(t6), y5 = BigNumber.from(s6).mul(o6), d6 = await this.contractWrapper.getCallOverrides() || {};
    await Ie(this.contractWrapper, y5, n4, d6);
    let u7 = ethers_exports.constants.MaxUint256;
    return i6 && (u7 = BigNumber.from(Math.floor(i6.getTime() / 1e3))), { receipt: await this.contractWrapper.sendTransaction("offer", [e6, t6, n4, s6, u7], d6) };
  }
  async acceptOffer(e6, t6) {
    await this.validateListing(BigNumber.from(e6));
    let n4 = await this.contractWrapper.readContract.offers(e6, t6);
    return { receipt: await this.contractWrapper.sendTransaction("acceptOffer", [e6, t6, n4.currency, n4.pricePerToken]) };
  }
  async buyoutListing(e6, t6, n4) {
    let a5 = await this.validateListing(BigNumber.from(e6));
    if (!await this.isStillValidListing(a5, t6))
      throw new Error("The asset on this listing has been moved from the lister's wallet, this listing is now invalid");
    let s6 = n4 || await this.contractWrapper.getSignerAddress(), o6 = BigNumber.from(t6), y5 = BigNumber.from(a5.buyoutPrice).mul(o6), d6 = await this.contractWrapper.getCallOverrides() || {};
    return await Ie(this.contractWrapper, y5, a5.currencyContractAddress, d6), { receipt: await this.contractWrapper.sendTransaction("buy", [e6, s6, o6, a5.currencyContractAddress, y5], d6) };
  }
  async updateListing(e6) {
    return { receipt: await this.contractWrapper.sendTransaction("updateListing", [e6.id, e6.quantity, e6.buyoutPrice, e6.buyoutPrice, e6.currencyContractAddress, e6.startTimeInSeconds, e6.secondsUntilEnd]) };
  }
  async cancelListing(e6) {
    return { receipt: await this.contractWrapper.sendTransaction("cancelDirectListing", [e6]) };
  }
  async validateListing(e6) {
    try {
      return await this.getListing(e6);
    } catch (t6) {
      throw console.error(`Error getting the listing with id ${e6}`), t6;
    }
  }
  async mapListing(e6) {
    return { assetContractAddress: e6.assetContract, buyoutPrice: BigNumber.from(e6.buyoutPricePerToken), currencyContractAddress: e6.currency, buyoutCurrencyValuePerToken: await q2(this.contractWrapper.getProvider(), e6.currency, e6.buyoutPricePerToken), id: e6.listingId.toString(), tokenId: e6.tokenId, quantity: e6.quantity, startTimeInSeconds: e6.startTime, asset: await et(e6.assetContract, this.contractWrapper.getProvider(), e6.tokenId, this.storage), secondsUntilEnd: e6.endTime, sellerAddress: e6.tokenOwner, type: J.Direct };
  }
  async isStillValidListing(e6, t6) {
    if (!await mi(this.contractWrapper.getProvider(), this.getAddress(), e6.assetContractAddress, e6.tokenId, e6.sellerAddress))
      return false;
    let a5 = this.contractWrapper.getProvider(), i6 = new Contract(e6.assetContractAddress, dt, a5), s6 = await i6.supportsInterface(st), o6 = await i6.supportsInterface(ot);
    return s6 ? (await new Contract(e6.assetContractAddress, _e, a5).ownerOf(e6.tokenId)).toLowerCase() === e6.sellerAddress.toLowerCase() : o6 ? (await new Contract(e6.assetContractAddress, Me, a5).balanceOf(e6.sellerAddress, e6.tokenId)).gte(t6 || e6.quantity) : (console.error("Contract does not implement ERC 1155 or ERC 721."), false);
  }
};
p2(gn, "MarketplaceDirect");
var wn = class {
  constructor(e6, t6) {
    this.contractWrapper = e6, this.storage = t6;
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  async getListing(e6) {
    let t6 = await this.contractWrapper.readContract.listings(e6);
    if (t6.listingId.toString() !== e6.toString())
      throw new Be(this.getAddress(), e6.toString());
    if (t6.listingType !== J.Auction)
      throw new at(this.getAddress(), e6.toString(), "Direct", "Auction");
    return await this.mapListing(t6);
  }
  async getWinningBid(e6) {
    await this.validateListing(BigNumber.from(e6));
    let t6 = await this.contractWrapper.readContract.winningBid(e6);
    if (t6.offeror !== lib_exports7.AddressZero)
      return await Ta(this.contractWrapper.getProvider(), BigNumber.from(e6), t6);
  }
  async getWinner(e6) {
    let n4 = (await this.contractWrapper.readContract.queryFilter(this.contractWrapper.readContract.filters.AuctionClosed())).find((a5) => a5.args.listingId.eq(BigNumber.from(e6)));
    if (!n4)
      throw new Error(`Could not find auction with listingId ${e6} in closed auctions`);
    return n4.args.winningBidder;
  }
  async createListing(e6) {
    ba(e6), await fa(this.contractWrapper.getSignerOrProvider(), this.getAddress(), e6.assetContractAddress, e6.tokenId, await this.contractWrapper.getSignerAddress());
    let t6 = await ie(this.contractWrapper.getProvider(), e6.buyoutPricePerToken, e6.currencyContractAddress), n4 = await ie(this.contractWrapper.getProvider(), e6.reservePricePerToken, e6.currencyContractAddress), a5 = Math.floor(e6.startTimestamp.getTime() / 1e3), s6 = (await this.contractWrapper.getProvider().getBlock("latest")).timestamp;
    a5 < s6 && (a5 = s6);
    let o6 = await this.contractWrapper.sendTransaction("createListing", [{ assetContract: e6.assetContractAddress, tokenId: e6.tokenId, buyoutPricePerToken: t6, currencyToAccept: e6.currencyContractAddress, listingType: J.Auction, quantityToList: e6.quantity, reservePricePerToken: n4, secondsUntilEndTime: e6.listingDurationInSeconds, startTime: BigNumber.from(a5) }], { gasLimit: 5e5 });
    return { id: this.contractWrapper.parseLogs("ListingAdded", o6 == null ? void 0 : o6.logs)[0].args.listingId, receipt: o6 };
  }
  async buyoutListing(e6) {
    let t6 = await this.validateListing(BigNumber.from(e6)), n4 = await Je(this.contractWrapper.getProvider(), t6.currencyContractAddress);
    return this.makeBid(e6, ethers_exports.utils.formatUnits(t6.buyoutPrice, n4.decimals));
  }
  async makeBid(e6, t6) {
    let n4 = await this.validateListing(BigNumber.from(e6)), a5 = await ie(this.contractWrapper.getProvider(), t6, n4.currencyContractAddress);
    if (a5.eq(BigNumber.from(0)))
      throw new Error("Cannot make a bid with 0 value");
    let i6 = await this.contractWrapper.readContract.bidBufferBps(), s6 = await this.getWinningBid(e6);
    if (s6) {
      let u7 = fi(s6.pricePerToken, a5, i6);
      invariant(u7, "Bid price is too low based on the current winning bid and the bid buffer");
    } else {
      let u7 = a5, m6 = BigNumber.from(n4.reservePrice);
      invariant(u7.gte(m6), "Bid price is too low based on reserve price");
    }
    let o6 = BigNumber.from(n4.quantity), y5 = a5.mul(o6), d6 = await this.contractWrapper.getCallOverrides() || {};
    return await Ie(this.contractWrapper, y5, n4.currencyContractAddress, d6), { receipt: await this.contractWrapper.sendTransaction("offer", [e6, n4.quantity, n4.currencyContractAddress, a5, ethers_exports.constants.MaxUint256], d6) };
  }
  async cancelListing(e6) {
    let t6 = await this.validateListing(BigNumber.from(e6)), n4 = BigNumber.from(Math.floor(Date.now() / 1e3)), a5 = BigNumber.from(t6.startTimeInEpochSeconds), i6 = await this.contractWrapper.readContract.winningBid(e6);
    if (n4.gt(a5) && i6.offeror !== lib_exports7.AddressZero)
      throw new Nt(e6.toString());
    return { receipt: await this.contractWrapper.sendTransaction("closeAuction", [BigNumber.from(e6), await this.contractWrapper.getSignerAddress()]) };
  }
  async closeListing(e6, t6) {
    t6 || (t6 = await this.contractWrapper.getSignerAddress());
    let n4 = await this.validateListing(BigNumber.from(e6));
    try {
      return { receipt: await this.contractWrapper.sendTransaction("closeAuction", [BigNumber.from(e6), t6]) };
    } catch (a5) {
      throw a5.message.includes("cannot close auction before it has ended") ? new Lt(e6.toString(), n4.endTimeInEpochSeconds.toString()) : a5;
    }
  }
  async updateListing(e6) {
    return { receipt: await this.contractWrapper.sendTransaction("updateListing", [e6.id, e6.quantity, e6.reservePrice, e6.buyoutPrice, e6.currencyContractAddress, e6.startTimeInEpochSeconds, e6.endTimeInEpochSeconds]) };
  }
  async validateListing(e6) {
    try {
      return await this.getListing(e6);
    } catch (t6) {
      throw console.error(`Error getting the listing with id ${e6}`), t6;
    }
  }
  async mapListing(e6) {
    return { assetContractAddress: e6.assetContract, buyoutPrice: BigNumber.from(e6.buyoutPricePerToken), currencyContractAddress: e6.currency, buyoutCurrencyValuePerToken: await q2(this.contractWrapper.getProvider(), e6.currency, e6.buyoutPricePerToken), id: e6.listingId.toString(), tokenId: e6.tokenId, quantity: e6.quantity, startTimeInEpochSeconds: e6.startTime, asset: await et(e6.assetContract, this.contractWrapper.getProvider(), e6.tokenId, this.storage), reservePriceCurrencyValuePerToken: await q2(this.contractWrapper.getProvider(), e6.currency, e6.reservePricePerToken), reservePrice: BigNumber.from(e6.reservePricePerToken), endTimeInEpochSeconds: e6.endTime, sellerAddress: e6.tokenOwner, type: J.Auction };
  }
};
p2(wn, "MarketplaceAuction");
var Cn = class extends g2 {
  constructor(e6, t6, n4, a5) {
    super(n4, e6, Ne.abi, a5), this.byocRegistry = new g2(n4, t6, Ne.abi, a5);
  }
  async getContractAddresses(e6) {
    let t6 = [];
    try {
      t6 = await this.byocRegistry.readContract.getAll(e6);
    } catch {
    }
    return (await this.readContract.getAll(e6)).concat(t6).filter((n4) => utils_exports.isAddress(n4) && n4.toLowerCase() !== lib_exports7.AddressZero);
  }
  async addContract(e6) {
    return await this.addContracts([e6]);
  }
  async addContracts(e6) {
    let t6 = await this.getSignerAddress(), n4 = [];
    return e6.forEach((a5) => {
      n4.push(this.readContract.interface.encodeFunctionData("add", [t6, a5]));
    }), { receipt: await this.multiCall(n4) };
  }
  async addCustomContract(e6) {
    return await this.addCustomContracts([e6]);
  }
  async addCustomContracts(e6) {
    let t6 = await this.getSignerAddress(), n4 = [];
    return e6.forEach((a5) => {
      n4.push(this.byocRegistry.readContract.interface.encodeFunctionData("add", [t6, a5]));
    }), { receipt: await this.byocRegistry.multiCall(n4) };
  }
  async removeContract(e6) {
    return await this.removeContracts([e6]);
  }
  async removeContracts(e6) {
    let t6 = await this.getSignerAddress(), n4 = [];
    return e6.forEach((a5) => {
      n4.push(this.readContract.interface.encodeFunctionData("remove", [t6, a5]));
    }), { receipt: await this.multiCall(n4) };
  }
  async removeCustomContract(e6) {
    return await this.removeCustomContracts([e6]);
  }
  async removeCustomContracts(e6) {
    let t6 = await this.getSignerAddress(), n4 = [];
    return e6.forEach((a5) => {
      n4.push(this.byocRegistry.readContract.interface.encodeFunctionData("remove", [t6, a5]));
    }), { receipt: await this.byocRegistry.multiCall(n4) };
  }
};
p2(Cn, "ContractRegistry");
var A = class {
  constructor(e6) {
    this.contractWrapper = e6;
  }
  overrideNextTransaction(e6) {
    this.contractWrapper.withTransactionOverride(e6);
  }
};
p2(A, "ContractInterceptor");
var W = class {
  constructor(e6) {
    this.contractWrapper = e6;
  }
  addTransactionListener(e6) {
    this.contractWrapper.addListener(be.Transaction, e6);
  }
  removeTransactionListener(e6) {
    this.contractWrapper.off(be.Transaction, e6);
  }
  addEventListener(e6, t6) {
    let n4 = this.contractWrapper.readContract.interface.getEvent(e6);
    this.contractWrapper.readContract.on(n4.name, (...a5) => {
      let i6 = {};
      n4.inputs.forEach((s6, o6) => {
        if (Array.isArray(a5[o6])) {
          let y5 = {}, d6 = s6.components;
          if (d6) {
            let u7 = a5[o6];
            for (let m6 = 0; m6 < d6.length; m6++) {
              let b4 = d6[m6].name;
              y5[b4] = u7[m6];
            }
            i6[s6.name] = y5;
          }
        } else
          i6[s6.name] = a5[o6];
      }), t6(i6);
    });
  }
  removeEventListener(e6, t6) {
    let n4 = this.contractWrapper.readContract.interface.getEvent(e6);
    this.contractWrapper.readContract.off(n4.name, t6);
  }
  removeAllListeners() {
    this.contractWrapper.readContract.removeAllListeners();
  }
};
p2(W, "ContractEvents");
var z2 = class {
  constructor(e6) {
    __publicField(this, "featureName", Gt.name);
    this.contractWrapper = e6;
  }
  async get() {
    let [e6, t6] = await this.contractWrapper.readContract.getPlatformFeeInfo();
    return L.parse({ platform_fee_recipient: e6, platform_fee_basis_points: t6 });
  }
  async set(e6) {
    let t6 = L.parse(e6);
    return { receipt: await this.contractWrapper.sendTransaction("setPlatformFeeInfo", [t6.platform_fee_recipient, t6.platform_fee_basis_points]) };
  }
};
p2(z2, "ContractPlatformFee");
var _ = class {
  constructor(e6) {
    this.contractWrapper = e6;
  }
  async gasCostOf(e6, t6) {
    let n4 = await this.contractWrapper.getPreferredGasPrice(), a5 = await this.contractWrapper.estimateGas(e6, t6);
    return ethers_exports.utils.formatEther(a5.mul(n4));
  }
  async currentGasPriceInGwei() {
    let e6 = await this.contractWrapper.getProvider().getGasPrice();
    return ethers_exports.utils.formatUnits(e6, "gwei");
  }
};
p2(_, "GasCostEstimator");
var S = class {
  constructor(e6) {
    this.contractWrapper = e6;
  }
  async query(e6) {
    let t6 = this.contractWrapper.readContract.interface.getEvent(e6), n4 = this.contractWrapper.readContract.filters[t6.name], a5 = 0, i6 = await this.contractWrapper.readContract.provider.getBlockNumber(), s6 = await this.contractWrapper.readContract.provider.getNetwork(), o6 = new g2(s6.chainId === T.Localhost || s6.chainId === T.Hardhat ? this.contractWrapper.readContract.provider : new ethers_exports.providers.AlchemyProvider(s6.name), this.contractWrapper.readContract.address, this.contractWrapper.abi, {}), y5 = [];
    return y5 = await o6.readContract.queryFilter(n4(), a5, i6), y5;
  }
};
p2(S, "ContractAnalytics");
var vn = class extends Ve {
  constructor(e6, t6, n4, a5 = {}, i6 = new g2(e6, t6, vn.contractAbi, a5)) {
    super(i6, n4, a5);
    __publicField(this, "_mint", this.mint);
    __publicField(this, "_batchMint", this._mint.batch);
    __publicField(this, "_query", this.query);
    __publicField(this, "_owned", this._query.owned);
    this.metadata = new M(this.contractWrapper, vn.schema, this.storage), this.roles = new V(this.contractWrapper, vn.contractRoles), this.royalty = new ye(this.contractWrapper, this.metadata), this.primarySale = new de(this.contractWrapper), this.encoder = new P(this.contractWrapper), this.estimator = new _(this.contractWrapper), this.signature = new ln(this.contractWrapper, this.roles, this.storage), this.analytics = new S(this.contractWrapper), this.events = new W(this.contractWrapper), this.platformFee = new z2(this.contractWrapper), this.interceptor = new A(this.contractWrapper);
  }
  async getAll(e6) {
    return this._query.all(e6);
  }
  async getOwned(e6) {
    return this._owned.all(e6);
  }
  async getOwnedTokenIds(e6) {
    return this._owned.tokenIds(e6);
  }
  async totalSupply() {
    return this._query.totalCirculatingSupply();
  }
  async isTransferRestricted() {
    return !await this.contractWrapper.readContract.hasRole(E("transfer"), lib_exports7.AddressZero);
  }
  async mintToSelf(e6) {
    let t6 = await this.contractWrapper.getSignerAddress();
    return this._mint.to(t6, e6);
  }
  async mintTo(e6, t6) {
    return this._mint.to(e6, t6);
  }
  async mintBatch(e6) {
    let t6 = await this.contractWrapper.getSignerAddress();
    return this._batchMint.to(t6, e6);
  }
  async mintBatchTo(e6, t6) {
    return this._batchMint.to(e6, t6);
  }
  async burn(e6) {
    return { receipt: await this.contractWrapper.sendTransaction("burn", [e6]) };
  }
};
var X = vn;
p2(X, "NFTCollection"), f2(X, "contractType", "nft-collection"), f2(X, "contractRoles", ["admin", "minter", "transfer"]), f2(X, "contractAbi", Ci()), f2(X, "schema", jr);
var xn = class extends qe {
  constructor(e6, t6, n4, a5 = {}, i6 = new g2(e6, t6, xn.contractAbi, a5)) {
    super(i6, n4, a5);
    __publicField(this, "_query", this.query);
    this.metadata = new M(this.contractWrapper, xn.schema, this.storage), this.roles = new V(this.contractWrapper, xn.contractRoles), this.royalty = new ye(this.contractWrapper, this.metadata), this.primarySale = new de(this.contractWrapper), this.claimConditions = new tn(this.contractWrapper, this.metadata, this.storage), this.analytics = new S(this.contractWrapper), this.history = new nn(this.analytics), this.encoder = new P(this.contractWrapper), this.events = new W(this.contractWrapper), this.estimator = new _(this.contractWrapper), this.platformFee = new z2(this.contractWrapper), this.interceptor = new A(this.contractWrapper);
  }
  async getAll(e6) {
    return this._query.all(e6);
  }
  async getOwned(e6) {
    return this._query.owned(e6);
  }
  async getTotalCount() {
    return this._query.getTotalCount();
  }
  async isTransferRestricted() {
    return !await this.contractWrapper.readContract.hasRole(E("transfer"), lib_exports7.AddressZero);
  }
  async createBatch(e6) {
    var d6;
    let t6 = await this.contractWrapper.readContract.nextTokenIdToMint(), n4 = await this.storage.uploadMetadataBatch(e6.map((u7) => le.parse(u7)), t6.toNumber(), this.contractWrapper.readContract.address, await ((d6 = this.contractWrapper.getSigner()) == null ? void 0 : d6.getAddress())), a5 = await this.contractWrapper.sendTransaction("lazyMint", [n4.metadataUris.length, `${n4.baseUri.endsWith("/") ? n4.baseUri : `${n4.baseUri}/`}`]), i6 = this.contractWrapper.parseLogs("TokensLazyMinted", a5 == null ? void 0 : a5.logs), s6 = i6[0].args.startTokenId, o6 = i6[0].args.endTokenId, y5 = [];
    for (let u7 = s6; u7.lte(o6); u7 = u7.add(1))
      y5.push({ id: u7, receipt: a5, data: () => this.getTokenMetadata(u7) });
    return y5;
  }
  async claimTo(e6, t6, n4, a5 = [utils_exports.hexZeroPad([0], 32)]) {
    let i6 = await this.prepareClaim(t6, n4, a5);
    return { receipt: await this.contractWrapper.sendTransaction("claim", [e6, t6, n4, i6.currencyAddress, i6.price, i6.proofs, i6.maxQuantityPerTransaction], i6.overrides) };
  }
  async claim(e6, t6, n4 = [utils_exports.hexZeroPad([0], 32)]) {
    let a5 = await this.contractWrapper.getSignerAddress();
    return this.claimTo(a5, e6, t6, n4);
  }
  async burn(e6, t6) {
    let n4 = await this.contractWrapper.getSignerAddress();
    return { receipt: await this.contractWrapper.sendTransaction("burn", [n4, e6, t6]) };
  }
  async prepareClaim(e6, t6, n4 = [utils_exports.hexZeroPad([0], 32)]) {
    return xt(t6, await this.claimConditions.getActive(e6), (await this.metadata.get()).merkle, 0, this.contractWrapper, this.storage, n4);
  }
};
var $ = xn;
p2($, "EditionDrop"), f2($, "contractType", "edition-drop"), f2($, "contractRoles", ["admin", "minter", "transfer"]), f2($, "contractAbi", vi()), f2($, "schema", Ur);
var Mn = class extends qe {
  constructor(e6, t6, n4, a5 = {}, i6 = new g2(e6, t6, Mn.contractAbi, a5)) {
    super(i6, n4, a5);
    __publicField(this, "_query", this.query);
    __publicField(this, "_mint", this.mint);
    __publicField(this, "_batchMint", this._mint.batch);
    this.metadata = new M(this.contractWrapper, Mn.schema, this.storage), this.roles = new V(this.contractWrapper, Mn.contractRoles), this.royalty = new ye(this.contractWrapper, this.metadata), this.primarySale = new de(this.contractWrapper), this.encoder = new P(this.contractWrapper), this.estimator = new _(this.contractWrapper), this.events = new W(this.contractWrapper), this.platformFee = new z2(this.contractWrapper), this.interceptor = new A(this.contractWrapper), this.analytics = new S(this.contractWrapper), this.signature = new hn(this.contractWrapper, this.roles, this.storage);
  }
  async getAll(e6) {
    return this._query.all(e6);
  }
  async getOwned(e6) {
    return this._query.owned(e6);
  }
  async getTotalCount() {
    return this._query.getTotalCount();
  }
  async isTransferRestricted() {
    return !await this.contractWrapper.readContract.hasRole(E("transfer"), lib_exports7.AddressZero);
  }
  async mintToSelf(e6) {
    return this._mint.to(await this.contractWrapper.getSignerAddress(), e6);
  }
  async mintTo(e6, t6) {
    return this._mint.to(e6, t6);
  }
  async mintAdditionalSupply(e6, t6) {
    return this._mint.additionalSupplyTo(await this.contractWrapper.getSignerAddress(), e6, t6);
  }
  async mintAdditionalSupplyTo(e6, t6, n4) {
    return this._mint.additionalSupplyTo(e6, t6, n4);
  }
  async mintBatch(e6) {
    return this._batchMint.to(await this.contractWrapper.getSignerAddress(), e6);
  }
  async mintBatchTo(e6, t6) {
    return this._batchMint.to(e6, t6);
  }
  async burn(e6, t6) {
    let n4 = await this.contractWrapper.getSignerAddress();
    return { receipt: await this.contractWrapper.sendTransaction("burn", [n4, e6, t6]) };
  }
};
var ee = Mn;
p2(ee, "Edition"), f2(ee, "contractType", "edition"), f2(ee, "contractRoles", ["admin", "minter", "transfer"]), f2(ee, "contractAbi", xi()), f2(ee, "schema", Qr);
var Rn = class extends Le {
  constructor(e6, t6, n4, a5 = {}, i6 = new g2(e6, t6, Rn.contractAbi, a5)) {
    super(i6, n4, a5);
    __publicField(this, "_mint", this.mint);
    __publicField(this, "_batchMint", this._mint.batch);
    this.metadata = new M(this.contractWrapper, Rn.schema, this.storage), this.roles = new V(this.contractWrapper, Rn.contractRoles), this.analytics = new S(this.contractWrapper), this.history = new sn(this.contractWrapper, this.analytics), this.encoder = new P(this.contractWrapper), this.estimator = new _(this.contractWrapper), this.events = new W(this.contractWrapper), this.platformFee = new z2(this.contractWrapper), this.interceptor = new A(this.contractWrapper), this.signature = new on(this.contractWrapper, this.roles);
  }
  async getVoteBalance() {
    return await this.getVoteBalanceOf(await this.contractWrapper.getSignerAddress());
  }
  async getVoteBalanceOf(e6) {
    return await this.getValue(await this.contractWrapper.readContract.getVotes(e6));
  }
  async getDelegation() {
    return await this.getDelegationOf(await this.contractWrapper.getSignerAddress());
  }
  async getDelegationOf(e6) {
    return await this.contractWrapper.readContract.delegates(e6);
  }
  async isTransferRestricted() {
    return !await this.contractWrapper.readContract.hasRole(E("transfer"), lib_exports7.AddressZero);
  }
  async mintToSelf(e6) {
    return this._mint.to(await this.contractWrapper.getSignerAddress(), e6);
  }
  async mintTo(e6, t6) {
    return this._mint.to(e6, t6);
  }
  async mintBatchTo(e6) {
    return this._batchMint.to(e6);
  }
  async delegateTo(e6) {
    return { receipt: await this.contractWrapper.sendTransaction("delegate", [e6]) };
  }
  async burn(e6) {
    return { receipt: await this.contractWrapper.sendTransaction("burn", [await this.normalizeAmount(e6)]) };
  }
  async burnFrom(e6, t6) {
    return { receipt: await this.contractWrapper.sendTransaction("burnFrom", [e6, await this.normalizeAmount(t6)]) };
  }
};
var H = Rn;
p2(H, "Token"), f2(H, "contractType", "token"), f2(H, "contractRoles", ["admin", "minter", "transfer"]), f2(H, "contractAbi", Mi()), f2(H, "schema", Hr);
var Ri = I.merge(Ce).merge(k2);
var Ip = O.merge(Ce).merge(k2);
var kp = Ri.merge(L).merge(ue).merge(D);
var Ai = { deploy: kp, output: Ip, input: Ri };
var An = class extends Le {
  constructor(e6, t6, n4, a5 = {}, i6 = new g2(e6, t6, An.contractAbi, a5)) {
    super(i6, n4, a5), this.metadata = new M(this.contractWrapper, An.schema, this.storage), this.roles = new V(this.contractWrapper, An.contractRoles), this.encoder = new P(this.contractWrapper), this.estimator = new _(this.contractWrapper), this.sales = new de(this.contractWrapper), this.platformFee = new z2(this.contractWrapper), this.interceptor = new A(this.contractWrapper), this.analytics = new S(this.contractWrapper), this.claimConditions = new yt(this.contractWrapper, this.metadata, this.storage);
  }
  async getVoteBalance() {
    return await this.getVoteBalanceOf(await this.contractWrapper.getSignerAddress());
  }
  async getVoteBalanceOf(e6) {
    return await this.getValue(await this.contractWrapper.readContract.getVotes(e6));
  }
  async getDelegation() {
    return await this.getDelegationOf(await this.contractWrapper.getSignerAddress());
  }
  async getDelegationOf(e6) {
    return await this.contractWrapper.readContract.delegates(e6);
  }
  async isTransferRestricted() {
    return !await this.contractWrapper.readContract.hasRole(E("transfer"), lib_exports7.AddressZero);
  }
  async claim(e6, t6 = [utils_exports.hexZeroPad([0], 32)]) {
    return this.claimTo(await this.contractWrapper.getSignerAddress(), e6, t6);
  }
  async claimTo(e6, t6, n4 = [utils_exports.hexZeroPad([0], 32)]) {
    let a5 = await this.normalizeAmount(t6), i6 = await this.prepareClaim(a5, n4);
    return { receipt: await this.contractWrapper.sendTransaction("claim", [e6, a5, i6.currencyAddress, i6.price, i6.proofs, i6.maxQuantityPerTransaction], i6.overrides) };
  }
  async delegateTo(e6) {
    return { receipt: await this.contractWrapper.sendTransaction("delegate", [e6]) };
  }
  async burn(e6) {
    return { receipt: await this.contractWrapper.sendTransaction("burn", [await this.normalizeAmount(e6)]) };
  }
  async burnFrom(e6, t6) {
    return { receipt: await this.contractWrapper.sendTransaction("burnFrom", [e6, await this.normalizeAmount(t6)]) };
  }
  async prepareClaim(e6, t6 = [utils_exports.hexZeroPad([0], 32)]) {
    return xt(e6, await this.claimConditions.getActive(), (await this.metadata.get()).merkle, await this.contractWrapper.readContract.decimals(), this.contractWrapper, this.storage, t6);
  }
};
var te = An;
p2(te, "TokenDrop"), f2(te, "contractType", "token-drop"), f2(te, "contractRoles", ["admin", "transfer"]), f2(te, "contractAbi", _i()), f2(te, "schema", Ai);
var ha = class {
  constructor(e6, t6, n4, a5 = {}, i6 = new g2(e6, t6, ha.contractAbi, a5)) {
    this.contractWrapper = i6, this.storage = n4, this.metadata = new M(this.contractWrapper, ha.schema, this.storage), this.analytics = new S(this.contractWrapper), this.encoder = new P(this.contractWrapper), this.estimator = new _(this.contractWrapper), this.events = new W(this.contractWrapper), this.interceptor = new A(this.contractWrapper);
  }
  onNetworkUpdated(e6) {
    this.contractWrapper.updateSignerOrProvider(e6);
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  async get(e6) {
    let n4 = (await this.getAll()).filter((a5) => (0, import_deep_equal3.default)(BigNumber.from(a5.proposalId), BigNumber.from(e6)));
    if (n4.length === 0)
      throw new Error("proposal not found");
    return n4[0];
  }
  async getAll() {
    return Promise.all((await this.contractWrapper.readContract.getAllProposals()).map(async (e6) => ({ proposalId: e6.proposalId, proposer: e6.proposer, description: e6.description, startBlock: e6.startBlock, endBlock: e6.endBlock, state: await this.contractWrapper.readContract.state(e6.proposalId), votes: await this.getProposalVotes(e6.proposalId), executions: e6[3].map((t6, n4) => ({ toAddress: e6.targets[n4], nativeTokenValue: t6, transactionData: e6.calldatas[n4] })) })));
  }
  async getProposalVotes(e6) {
    let t6 = await this.contractWrapper.readContract.proposalVotes(e6);
    return [{ type: vt.Against, label: "Against", count: t6.againstVotes }, { type: vt.For, label: "For", count: t6.forVotes }, { type: vt.Abstain, label: "Abstain", count: t6.abstainVotes }];
  }
  async hasVoted(e6, t6) {
    return t6 || (t6 = await this.contractWrapper.getSignerAddress()), this.contractWrapper.readContract.hasVoted(e6, t6);
  }
  async canExecute(e6) {
    await this.ensureExists(e6);
    let t6 = await this.get(e6), n4 = t6.executions.map((o6) => o6.toAddress), a5 = t6.executions.map((o6) => o6.nativeTokenValue), i6 = t6.executions.map((o6) => o6.transactionData), s6 = ethers_exports.utils.id(t6.description);
    try {
      return await this.contractWrapper.callStatic().execute(n4, a5, i6, s6), true;
    } catch {
      return false;
    }
  }
  async balance() {
    let e6 = await this.contractWrapper.readContract.provider.getBalance(this.contractWrapper.readContract.address);
    return { name: "", symbol: "", decimals: 18, value: e6, displayValue: ethers_exports.utils.formatUnits(e6, 18) };
  }
  async balanceOfToken(e6) {
    let t6 = new Contract(e6, K2, this.contractWrapper.getProvider());
    return await q2(this.contractWrapper.getProvider(), e6, await t6.balanceOf(this.contractWrapper.readContract.address));
  }
  async ensureExists(e6) {
    try {
      await this.contractWrapper.readContract.state(e6);
    } catch {
      throw Error(`Proposal ${e6} not found`);
    }
  }
  async settings() {
    let [e6, t6, n4, a5, i6] = await Promise.all([this.contractWrapper.readContract.votingDelay(), this.contractWrapper.readContract.votingPeriod(), this.contractWrapper.readContract.token(), this.contractWrapper.readContract.quorumNumerator(), this.contractWrapper.readContract.proposalThreshold()]), s6 = await Je(this.contractWrapper.getProvider(), n4);
    return { votingDelay: e6.toString(), votingPeriod: t6.toString(), votingTokenAddress: n4, votingTokenMetadata: s6, votingQuorumFraction: a5.toString(), proposalTokenThreshold: i6.toString() };
  }
  async propose(e6, t6) {
    t6 || (t6 = [{ toAddress: this.contractWrapper.readContract.address, nativeTokenValue: 0, transactionData: "0x" }]);
    let n4 = t6.map((y5) => y5.toAddress), a5 = t6.map((y5) => y5.nativeTokenValue), i6 = t6.map((y5) => y5.transactionData), s6 = await this.contractWrapper.sendTransaction("propose", [n4, a5, i6, e6]);
    return { id: this.contractWrapper.parseLogs("ProposalCreated", s6 == null ? void 0 : s6.logs)[0].args.proposalId, receipt: s6 };
  }
  async vote(e6, t6, n4 = "") {
    return await this.ensureExists(e6), { receipt: await this.contractWrapper.sendTransaction("castVoteWithReason", [e6, t6, n4]) };
  }
  async execute(e6) {
    await this.ensureExists(e6);
    let t6 = await this.get(e6), n4 = t6.executions.map((o6) => o6.toAddress), a5 = t6.executions.map((o6) => o6.nativeTokenValue), i6 = t6.executions.map((o6) => o6.transactionData), s6 = ethers_exports.utils.id(t6.description);
    return { receipt: await this.contractWrapper.sendTransaction("execute", [n4, a5, i6, s6]) };
  }
};
var ne = ha;
p2(ne, "Vote"), f2(ne, "contractType", "vote"), f2(ne, "contractAbi", Si()), f2(ne, "schema", Xr);
var ga = class {
  constructor(e6, t6, n4, a5 = {}, i6 = new g2(e6, t6, ga.contractAbi, a5)) {
    this.contractWrapper = i6, this.storage = n4, this.metadata = new M(this.contractWrapper, ga.schema, this.storage), this.analytics = new S(this.contractWrapper), this.encoder = new P(this.contractWrapper), this.estimator = new _(this.contractWrapper), this.events = new W(this.contractWrapper), this.interceptor = new A(this.contractWrapper);
  }
  onNetworkUpdated(e6) {
    this.contractWrapper.updateSignerOrProvider(e6);
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  async getAllRecipients() {
    let e6 = [], t6 = BigNumber.from(0), n4 = await this.contractWrapper.readContract.payeeCount();
    for (; t6.lt(n4); )
      try {
        let a5 = await this.contractWrapper.readContract.payee(t6);
        e6.push(await this.getRecipientSplitPercentage(a5)), t6 = t6.add(1);
      } catch (a5) {
        if ("method" in a5 && a5.method.toLowerCase().includes("payee(uint256)"))
          break;
        throw a5;
      }
    return e6;
  }
  async balanceOfAllRecipients() {
    let e6 = await this.getAllRecipients(), t6 = {};
    for (let n4 of e6)
      t6[n4.address] = await this.balanceOf(n4.address);
    return t6;
  }
  async balanceOfTokenAllRecipients(e6) {
    let t6 = await this.getAllRecipients(), n4 = {};
    for (let a5 of t6)
      n4[a5.address] = await this.balanceOfToken(a5.address, e6);
    return n4;
  }
  async balanceOf(e6) {
    let t6 = await this.contractWrapper.readContract.provider.getBalance(this.getAddress()), n4 = await this.contractWrapper.readContract["totalReleased()"](), a5 = t6.add(n4);
    return this._pendingPayment(e6, a5, await this.contractWrapper.readContract["released(address)"](e6));
  }
  async balanceOfToken(e6, t6) {
    let a5 = await new Contract(t6, K2, this.contractWrapper.getProvider()).balanceOf(this.getAddress()), i6 = await this.contractWrapper.readContract["totalReleased(address)"](t6), s6 = a5.add(i6), o6 = await this._pendingPayment(e6, s6, await this.contractWrapper.readContract["released(address,address)"](t6, e6));
    return await q2(this.contractWrapper.getProvider(), t6, o6);
  }
  async getRecipientSplitPercentage(e6) {
    let [t6, n4] = await Promise.all([this.contractWrapper.readContract.totalShares(), this.contractWrapper.readContract.shares(e6)]);
    return { address: e6, splitPercentage: n4.mul(BigNumber.from(1e7)).div(t6).toNumber() / 1e5 };
  }
  async withdraw(e6) {
    return { receipt: await this.contractWrapper.sendTransaction("release(address)", [e6]) };
  }
  async withdrawToken(e6, t6) {
    return { receipt: await this.contractWrapper.sendTransaction("release(address,address)", [t6, e6]) };
  }
  async distribute() {
    return { receipt: await this.contractWrapper.sendTransaction("distribute()", []) };
  }
  async distributeToken(e6) {
    return { receipt: await this.contractWrapper.sendTransaction("distribute(address)", [e6]) };
  }
  async _pendingPayment(e6, t6, n4) {
    return t6.mul(await this.contractWrapper.readContract.shares(e6)).div(await this.contractWrapper.readContract.totalShares()).sub(n4);
  }
};
var ae = ga;
p2(ae, "Split"), f2(ae, "contractType", "split"), f2(ae, "contractAbi", ki()), f2(ae, "schema", Gr);
var Sn = class {
  constructor(e6, t6, n4, a5 = {}, i6 = new g2(e6, t6, Sn.contractAbi, a5)) {
    __publicField(this, "getAll", this.getAllListings);
    this.contractWrapper = i6, this.storage = n4, this.metadata = new M(this.contractWrapper, Sn.schema, this.storage), this.roles = new V(this.contractWrapper, Sn.contractRoles), this.analytics = new S(this.contractWrapper), this.encoder = new P(this.contractWrapper), this.estimator = new _(this.contractWrapper), this.direct = new gn(this.contractWrapper, this.storage), this.auction = new wn(this.contractWrapper, this.storage), this.events = new W(this.contractWrapper), this.platformFee = new z2(this.contractWrapper), this.interceptor = new A(this.contractWrapper);
  }
  onNetworkUpdated(e6) {
    this.contractWrapper.updateSignerOrProvider(e6);
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  async getListing(e6) {
    let t6 = await this.contractWrapper.readContract.listings(e6);
    if (t6.assetContract === lib_exports7.AddressZero)
      throw new Be(this.getAddress(), e6.toString());
    switch (t6.listingType) {
      case J.Auction:
        return await this.auction.mapListing(t6);
      case J.Direct:
        return await this.direct.mapListing(t6);
      default:
        throw new Error(`Unknown listing type: ${t6.listingType}`);
    }
  }
  async getActiveListings(e6) {
    let t6 = await this.getAllListingsNoFilter(), n4 = this.applyFilter(t6, e6), a5 = BigNumber.from(Math.floor(Date.now() / 1e3));
    return n4.filter((i6) => i6.type === J.Auction && BigNumber.from(i6.endTimeInEpochSeconds).gt(a5) && BigNumber.from(i6.startTimeInEpochSeconds).lte(a5) || i6.type === J.Direct && i6.quantity > 0);
  }
  async getAllListings(e6) {
    let t6 = await this.getAllListingsNoFilter();
    return this.applyFilter(t6, e6);
  }
  async getTotalCount() {
    return await this.contractWrapper.readContract.totalListings();
  }
  async isRestrictedToListerRoleOnly() {
    return !await this.contractWrapper.readContract.hasRole(E("lister"), lib_exports7.AddressZero);
  }
  async getBidBufferBps() {
    return this.contractWrapper.readContract.bidBufferBps();
  }
  async getTimeBufferInSeconds() {
    return this.contractWrapper.readContract.timeBuffer();
  }
  async buyoutListing(e6, t6, n4) {
    let a5 = await this.contractWrapper.readContract.listings(e6);
    if (a5.listingId.toString() !== e6.toString())
      throw new Be(this.getAddress(), e6.toString());
    switch (a5.listingType) {
      case J.Direct:
        return invariant(t6 !== void 0, "quantityDesired is required when buying out a direct listing"), await this.direct.buyoutListing(e6, t6, n4);
      case J.Auction:
        return await this.auction.buyoutListing(e6);
      default:
        throw Error(`Unknown listing type: ${a5.listingType}`);
    }
  }
  async setBidBufferBps(e6) {
    await this.roles.verify(["admin"], await this.contractWrapper.getSignerAddress());
    let t6 = await this.getTimeBufferInSeconds();
    await this.contractWrapper.sendTransaction("setAuctionBuffers", [t6, BigNumber.from(e6)]);
  }
  async setTimeBufferInSeconds(e6) {
    await this.roles.verify(["admin"], await this.contractWrapper.getSignerAddress());
    let t6 = await this.getBidBufferBps();
    await this.contractWrapper.sendTransaction("setAuctionBuffers", [BigNumber.from(e6), t6]);
  }
  async allowListingFromSpecificAssetOnly(e6) {
    let t6 = [];
    (await this.roles.get("asset")).includes(lib_exports7.AddressZero) && t6.push(this.encoder.encode("revokeRole", [E("asset"), lib_exports7.AddressZero])), t6.push(this.encoder.encode("grantRole", [E("asset"), e6])), await this.contractWrapper.multiCall(t6);
  }
  async allowListingFromAnyAsset() {
    let e6 = [], t6 = await this.roles.get("asset");
    for (let n4 in t6)
      e6.push(this.encoder.encode("revokeRole", [E("asset"), n4]));
    e6.push(this.encoder.encode("grantRole", [E("asset"), lib_exports7.AddressZero])), await this.contractWrapper.multiCall(e6);
  }
  async getAllListingsNoFilter() {
    return (await Promise.all(Array.from(Array((await this.contractWrapper.readContract.totalListings()).toNumber()).keys()).map(async (t6) => {
      let n4;
      try {
        n4 = await this.getListing(t6);
      } catch (i6) {
        console.log(`Error fetching listing with id: ${t6}`, i6);
        return;
      }
      if (n4.type === J.Auction)
        return n4;
      if (!!await this.direct.isStillValidListing(n4))
        return n4;
    }))).filter((t6) => t6 !== void 0);
  }
  applyFilter(e6, t6) {
    let n4 = [...e6], a5 = BigNumber.from((t6 == null ? void 0 : t6.start) || 0).toNumber(), i6 = BigNumber.from((t6 == null ? void 0 : t6.count) || 100).toNumber();
    return t6 && (t6.seller && (n4 = n4.filter((s6) => {
      var o6;
      return s6.sellerAddress.toString().toLowerCase() === ((o6 = t6 == null ? void 0 : t6.seller) == null ? void 0 : o6.toString().toLowerCase());
    })), t6.tokenContract && (n4 = n4.filter((s6) => {
      var o6;
      return s6.assetContractAddress.toString().toLowerCase() === ((o6 = t6 == null ? void 0 : t6.tokenContract) == null ? void 0 : o6.toString().toLowerCase());
    })), t6.tokenId && (n4 = n4.filter((s6) => {
      var o6;
      return s6.tokenId.toString() === ((o6 = t6 == null ? void 0 : t6.tokenId) == null ? void 0 : o6.toString());
    })), n4 = n4.filter((s6, o6) => o6 >= a5), n4 = n4.slice(0, i6)), n4;
  }
};
var Z = Sn;
p2(Z, "Marketplace"), f2(Z, "contractType", "marketplace"), f2(Z, "contractRoles", ["admin", "lister", "asset"]), f2(Z, "contractAbi", Pi()), f2(Z, "schema", Lr);
var In = class {
  constructor(e6, t6, n4, a5 = {}, i6 = new g2(e6, t6, In.contractAbi, a5)) {
    this.contractWrapper = i6, this.storage = n4, this.metadata = new M(this.contractWrapper, In.schema, this.storage), this.analytics = new S(this.contractWrapper), this.roles = new V(this.contractWrapper, In.contractRoles), this.royalty = new ye(this.contractWrapper, this.metadata), this.encoder = new P(this.contractWrapper), this.estimator = new _(this.contractWrapper), this.events = new W(this.contractWrapper), this.interceptor = new A(this.contractWrapper);
  }
  onNetworkUpdated(e6) {
    this.contractWrapper.updateSignerOrProvider(e6);
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  async get(e6) {
    let [t6, n4, a5] = await Promise.all([et(this.getAddress(), this.contractWrapper.getProvider(), e6, this.storage), this.contractWrapper.readContract.packs(e6), this.contractWrapper.readContract.totalSupply(e6).catch(() => BigNumber.from("0"))]);
    return { id: BigNumber.from(e6).toString(), metadata: t6, creator: n4.creator, currentSupply: a5, openStart: n4.openStart.gt(0) ? new Date(n4.openStart.toNumber() * 1e3) : null };
  }
  async getAll() {
    let e6 = (await this.contractWrapper.readContract.nextTokenId()).toNumber();
    return await Promise.all(Array.from(Array(e6).keys()).map((t6) => this.get(t6.toString())));
  }
  async getNFTs(e6) {
    let t6 = await this.contractWrapper.readContract.getPackWithRewards(e6);
    if (!t6.source)
      throw new Ae();
    return (await Promise.all(t6.tokenIds.map((a5) => et(t6.source, this.contractWrapper.getProvider(), a5.toString(), this.storage)))).map((a5, i6) => ({ supply: t6.amountsPacked[i6], metadata: a5 }));
  }
  async balanceOf(e6, t6) {
    return await this.contractWrapper.readContract.balanceOf(e6, t6);
  }
  async balance(e6) {
    return await this.balanceOf(await this.contractWrapper.getSignerAddress(), e6);
  }
  async isApproved(e6, t6) {
    return await this.contractWrapper.readContract.isApprovedForAll(e6, t6);
  }
  async getLinkBalance() {
    let e6 = await this.contractWrapper.getChainID(), t6 = Qt[e6], n4 = new Contract(t6.linkTokenAddress, K2, this.contractWrapper.getProvider());
    return await q2(this.contractWrapper.getProvider(), t6.linkTokenAddress, await n4.balanceOf(this.getAddress()));
  }
  async getOwned(e6) {
    let t6 = e6 || await this.contractWrapper.getSignerAddress(), n4 = await this.contractWrapper.readContract.nextTokenId(), i6 = (await this.contractWrapper.readContract.balanceOfBatch(Array(n4.toNumber()).fill(t6), Array.from(Array(n4.toNumber()).keys()))).map((s6, o6) => ({ tokenId: o6, balance: s6 })).filter((s6) => s6.balance.gt(0));
    return await Promise.all(i6.map(async ({ tokenId: s6, balance: o6 }) => {
      let y5 = await this.get(s6.toString());
      return B(w({}, y5), { ownedByAddress: o6 });
    }));
  }
  async open(e6) {
    let t6 = await this.contractWrapper.sendTransaction("openPack", [e6]), n4 = this.contractWrapper.parseLogs("PackOpenRequested", t6 == null ? void 0 : t6.logs);
    if (n4.length === 0)
      throw new Error("Failed to open pack");
    let a5 = n4[0], i6 = a5.args.requestId, s6 = a5.args.opener, o6 = await new Promise((u7) => {
      this.contractWrapper.readContract.once(this.contractWrapper.readContract.filters.PackOpenFulfilled(null, s6), (m6, b4, h6, v9, F5) => {
        i6 === h6 && u7({ packId: m6, opener: b4, requestId: i6, rewardContract: v9, rewardIds: F5 });
      });
    }), { rewardIds: y5, rewardContract: d6 } = o6;
    return y5.map((u7) => ({ id: e6, receipt: t6, data: () => et(d6, this.contractWrapper.getProvider(), u7.toString(), this.storage) }));
  }
  async create(e6) {
    let t6 = new Contract(e6.assetContract, Me, this.contractWrapper.getSigner() || this.contractWrapper.getProvider()), n4 = await this.contractWrapper.getSignerAddress(), a5 = e6.assets.map((b4) => b4.tokenId), i6 = e6.assets.map((b4) => b4.amount), s6 = await this.storage.uploadMetadata(e6.metadata), o6 = ethers_exports.utils.defaultAbiCoder.encode(["string", "uint256", "uint256"], [s6, e6.secondsUntilOpenStart || 0, e6.rewardsPerOpen || 1]), d6 = await (await t6.safeBatchTransferFrom(n4, this.getAddress(), a5, i6, o6, await this.contractWrapper.getCallOverrides())).wait(), u7 = this.contractWrapper.parseLogs("PackAdded", d6.logs);
    if (u7.length === 0)
      throw new Error("PackCreated event not found");
    let m6 = u7[0].args.packId;
    return { id: m6, receipt: d6, data: () => this.get(m6.toString()) };
  }
  async transfer(e6, t6, n4) {
    return { receipt: await this.contractWrapper.sendTransaction("safeTransferFrom", [await this.contractWrapper.getSignerAddress(), e6, t6, n4, [0]]) };
  }
  async transferFrom(e6, t6, n4, a5 = [0]) {
    return { receipt: await this.contractWrapper.sendTransaction("safeTransferFrom", [e6, t6, n4.tokenId, n4.amount, a5]) };
  }
  async transferBatchFrom(e6, t6, n4, a5 = [0]) {
    let i6 = n4.map((o6) => o6.tokenId), s6 = n4.map((o6) => o6.amount);
    return { receipt: await this.contractWrapper.sendTransaction("safeBatchTransferFrom", [e6, t6, i6, s6, a5]) };
  }
  async setApproval(e6, t6 = true) {
    return { receipt: await this.contractWrapper.sendTransaction("setApprovalForAll", [e6, t6]) };
  }
  async depositLink(e6) {
    let t6 = await this.contractWrapper.getChainID(), n4 = Qt[t6];
    return { receipt: await (await new Contract(n4.linkTokenAddress, K2, this.contractWrapper.getProvider()).transfer(this.getAddress(), e6, await this.contractWrapper.getCallOverrides())).wait() };
  }
};
var j2 = In;
p2(j2, "Pack"), f2(j2, "contractType", "pack"), f2(j2, "contractRoles", ["admin", "minter", "pauser", "transfer"]), f2(j2, "contractAbi", Wi()), f2(j2, "schema", qr);
var kn = class {
  constructor(e6, t6) {
    this.contractWrapper = e6, this.storage = t6;
  }
  async createDelayedRevealBatch(e6, t6, n4) {
    var F5, ce2;
    if (!n4)
      throw new Error("Password is required");
    let { baseUri: a5 } = await this.storage.uploadMetadataBatch([le.parse(e6)], 0, this.contractWrapper.readContract.address, await ((F5 = this.contractWrapper.getSigner()) == null ? void 0 : F5.getAddress())), i6 = await this.contractWrapper.readContract.nextTokenIdToMint(), s6 = await this.storage.uploadMetadataBatch(t6.map((ge2) => le.parse(ge2)), i6.toNumber(), this.contractWrapper.readContract.address, await ((ce2 = this.contractWrapper.getSigner()) == null ? void 0 : ce2.getAddress())), o6 = s6.baseUri, y5 = await this.contractWrapper.readContract.getBaseURICount(), d6 = await this.contractWrapper.readContract.encryptDecrypt(ethers_exports.utils.toUtf8Bytes(o6.endsWith("/") ? o6 : `${o6}/`), await this.hashDelayRevealPasword(y5, n4)), u7 = await this.contractWrapper.sendTransaction("lazyMint", [s6.metadataUris.length, a5.endsWith("/") ? a5 : `${a5}/`, d6]), m6 = this.contractWrapper.parseLogs("TokensLazyMinted", u7 == null ? void 0 : u7.logs), b4 = m6[0].args.startTokenId, h6 = m6[0].args.endTokenId, v9 = [];
    for (let ge2 = b4; ge2.lte(h6); ge2 = ge2.add(1))
      v9.push({ id: ge2, receipt: u7 });
    return v9;
  }
  async reveal(e6, t6) {
    if (!t6)
      throw new Error("Password is required");
    let n4 = await this.hashDelayRevealPasword(e6, t6);
    try {
      let a5 = await this.contractWrapper.callStatic().reveal(e6, n4);
      if (!a5.includes("://") || !a5.endsWith("/"))
        throw new Error("invalid password");
    } catch {
      throw new Error("invalid password");
    }
    return { receipt: await this.contractWrapper.sendTransaction("reveal", [e6, n4]) };
  }
  async getBatchesToReveal() {
    let e6 = await this.contractWrapper.readContract.getBaseURICount();
    if (e6.isZero())
      return [];
    let t6 = Array.from(Array(e6.toNumber()).keys()), n4 = await Promise.all(t6.map((y5) => this.contractWrapper.readContract.baseURIIndices(y5))), a5 = n4.slice(0, n4.length - 1), i6 = await Promise.all(Array.from([0, ...a5]).map((y5) => this.contractWrapper.readContract.tokenURI(y5))), s6 = await Promise.all(Array.from([0, ...a5]).map((y5) => this.getNftMetadata(y5.toString()))), o6 = await Promise.all(Array.from([...n4]).map((y5) => this.contractWrapper.readContract.encryptedBaseURI(y5)));
    return i6.map((y5, d6) => ({ batchId: BigNumber.from(d6), batchUri: y5, placeholderMetadata: s6[d6] })).filter((y5, d6) => ethers_exports.utils.hexDataLength(o6[d6]) > 0);
  }
  async hashDelayRevealPasword(e6, t6) {
    let n4 = await this.contractWrapper.getChainID(), a5 = this.contractWrapper.readContract.address;
    return ethers_exports.utils.solidityKeccak256(["string", "uint256", "uint256", "address"], [t6, n4, e6, a5]);
  }
  async getNftMetadata(e6) {
    let t6 = await this.contractWrapper.readContract.tokenURI(e6);
    return ut(e6, t6, this.storage);
  }
};
p2(kn, "DelayedReveal");
var En = class extends Ve {
  constructor(e6, t6, n4, a5 = {}, i6 = new g2(e6, t6, En.contractAbi, a5)) {
    super(i6, n4, a5);
    __publicField(this, "_query", this.query);
    __publicField(this, "_owned", this._query.owned);
    this.metadata = new M(this.contractWrapper, En.schema, this.storage), this.roles = new V(this.contractWrapper, En.contractRoles), this.royalty = new ye(this.contractWrapper, this.metadata), this.primarySale = new de(this.contractWrapper), this.claimConditions = new yt(this.contractWrapper, this.metadata, this.storage), this.analytics = new S(this.contractWrapper), this.encoder = new P(this.contractWrapper), this.estimator = new _(this.contractWrapper), this.events = new W(this.contractWrapper), this.platformFee = new z2(this.contractWrapper), this.revealer = new kn(this.contractWrapper, this.storage), this.interceptor = new A(this.contractWrapper);
  }
  async getAll(e6) {
    return this._query.all(e6);
  }
  async getOwned(e6) {
    return this._owned.all(e6);
  }
  async getOwnedTokenIds(e6) {
    return this._owned.tokenIds(e6);
  }
  async totalSupply() {
    let e6 = await this.totalClaimedSupply(), t6 = await this.totalUnclaimedSupply();
    return e6.add(t6);
  }
  async getAllClaimed(e6) {
    let t6 = BigNumber.from((e6 == null ? void 0 : e6.start) || 0).toNumber(), n4 = BigNumber.from((e6 == null ? void 0 : e6.count) || 100).toNumber(), a5 = Math.min((await this.contractWrapper.readContract.nextTokenIdToClaim()).toNumber(), t6 + n4);
    return await Promise.all(Array.from(Array(a5).keys()).map((i6) => this.get(i6.toString())));
  }
  async getAllUnclaimed(e6) {
    let t6 = BigNumber.from((e6 == null ? void 0 : e6.start) || 0).toNumber(), n4 = BigNumber.from((e6 == null ? void 0 : e6.count) || 100).toNumber(), a5 = BigNumber.from(Math.max((await this.contractWrapper.readContract.nextTokenIdToClaim()).toNumber(), t6)), i6 = BigNumber.from(Math.min((await this.contractWrapper.readContract.nextTokenIdToMint()).toNumber(), a5.toNumber() + n4));
    return await Promise.all(Array.from(Array(i6.sub(a5).toNumber()).keys()).map((s6) => this.getTokenMetadata(a5.add(s6).toString())));
  }
  async totalClaimedSupply() {
    return await this.contractWrapper.readContract.nextTokenIdToClaim();
  }
  async totalUnclaimedSupply() {
    return (await this.contractWrapper.readContract.nextTokenIdToMint()).sub(await this.totalClaimedSupply());
  }
  async isTransferRestricted() {
    return !await this.contractWrapper.readContract.hasRole(E("transfer"), lib_exports7.AddressZero);
  }
  async createBatch(e6) {
    var u7;
    let t6 = await this.contractWrapper.readContract.nextTokenIdToMint(), n4 = await this.storage.uploadMetadataBatch(e6.map((m6) => le.parse(m6)), t6.toNumber(), this.contractWrapper.readContract.address, await ((u7 = this.contractWrapper.getSigner()) == null ? void 0 : u7.getAddress())), a5 = n4.baseUri, i6 = await this.contractWrapper.sendTransaction("lazyMint", [n4.metadataUris.length, a5.endsWith("/") ? a5 : `${a5}/`, ethers_exports.utils.toUtf8Bytes("")]), s6 = this.contractWrapper.parseLogs("TokensLazyMinted", i6 == null ? void 0 : i6.logs), o6 = s6[0].args.startTokenId, y5 = s6[0].args.endTokenId, d6 = [];
    for (let m6 = o6; m6.lte(y5); m6 = m6.add(1))
      d6.push({ id: m6, receipt: i6, data: () => this.getTokenMetadata(m6) });
    return d6;
  }
  async claimTo(e6, t6, n4 = [utils_exports.hexZeroPad([0], 32)]) {
    let a5 = await this.prepareClaim(t6, n4), i6 = await this.contractWrapper.sendTransaction("claim", [e6, t6, a5.currencyAddress, a5.price, a5.proofs, a5.maxQuantityPerTransaction], a5.overrides), o6 = this.contractWrapper.parseLogs("TokensClaimed", i6 == null ? void 0 : i6.logs)[0].args.startTokenId, y5 = o6.add(t6), d6 = [];
    for (let u7 = o6; u7.lt(y5); u7 = u7.add(1))
      d6.push({ id: u7, receipt: i6, data: () => this.get(u7) });
    return d6;
  }
  async claim(e6, t6 = [utils_exports.hexZeroPad([0], 32)]) {
    return this.claimTo(await this.contractWrapper.getSignerAddress(), e6, t6);
  }
  async burn(e6) {
    return { receipt: await this.contractWrapper.sendTransaction("burn", [e6]) };
  }
  async prepareClaim(e6, t6 = [utils_exports.hexZeroPad([0], 32)]) {
    return xt(e6, await this.claimConditions.getActive(), (await this.metadata.get()).merkle, 0, this.contractWrapper, this.storage, t6);
  }
};
var Y = En;
p2(Y, "NFTDrop"), f2(Y, "contractType", "nft-drop"), f2(Y, "contractRoles", ["admin", "minter", "transfer"]), f2(Y, "contractAbi", Bi()), f2(Y, "schema", Or);
var Pn = class {
  constructor(e6, t6) {
    this.contractWrapper = e6, this.storage = t6;
  }
  async get() {
    if (this._cachedMetadata)
      return this._cachedMetadata;
    let e6 = await this.contractWrapper.readContract.getPublishMetadataUri();
    return this._cachedMetadata = await oa(e6, this.storage), this._cachedMetadata;
  }
  extractFunctions() {
    return en(pt.parse(this.contractWrapper.abi));
  }
};
p2(Pn, "ContractPublishedMetadata");
var wa = class {
  constructor(e6, t6, n4, a5, i6 = {}, s6 = new g2(e6, t6, n4, i6)) {
    this.options = i6, this.storage = a5, this.contractWrapper = s6, this.functions = s6.writeContract, this.events = new W(this.contractWrapper), this.interceptor = new A(this.contractWrapper), this.estimator = new _(this.contractWrapper), this.publishedMetadata = new Pn(this.contractWrapper, this.storage), this.metadata = new M(this.contractWrapper, wa.schema, this.storage), this.analytics = new S(this.contractWrapper), this.royalties = this.detectRoyalties(), this.roles = this.detectRoles(), this.sales = this.detectPrimarySales(), this.platformFees = this.detectPlatformFees(), this.token = this.detectErc20(), this.nft = this.detectErc721(), this.edition = this.detectErc1155();
  }
  onNetworkUpdated(e6) {
    this.contractWrapper.updateSignerOrProvider(e6);
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  detectRoyalties() {
    if (R(this.contractWrapper, "Royalty")) {
      let e6 = new M(this.contractWrapper, wa.schema, this.storage);
      return new ye(this.contractWrapper, e6);
    }
  }
  detectRoles() {
    if (R(this.contractWrapper, "Permissions"))
      return new V(this.contractWrapper, Q0);
  }
  detectPrimarySales() {
    if (R(this.contractWrapper, "PrimarySale"))
      return new de(this.contractWrapper);
  }
  detectPlatformFees() {
    if (R(this.contractWrapper, "PlatformFee"))
      return new z2(this.contractWrapper);
  }
  detectErc20() {
    if (R(this.contractWrapper, "ERC20"))
      return new Le(this.contractWrapper, this.storage, this.options);
  }
  detectErc721() {
    if (R(this.contractWrapper, "ERC721"))
      return new Ve(this.contractWrapper, this.storage, this.options);
  }
  detectErc1155() {
    if (R(this.contractWrapper, "ERC1155"))
      return new qe(this.contractWrapper, this.storage, this.options);
  }
};
var Pe = wa;
p2(Pe, "SmartContract"), f2(Pe, "contractType", "custom"), f2(Pe, "schema", hr);
var b0 = { [Y.contractType]: Y, [X.contractType]: X, [$.contractType]: $, [ee.contractType]: ee, [te.contractType]: te, [H.contractType]: H, [ne.contractType]: ne, [ae.contractType]: ae, [Z.contractType]: Z, [j2.contractType]: j2 };
var Oi = B(w({}, b0), { [Pe.contractType]: Pe });
var Di = { [Y.contractType]: "DropERC721", [X.contractType]: "TokenERC721", [$.contractType]: "DropERC1155", [ee.contractType]: "TokenERC1155", [te.contractType]: "DropERC20", [H.contractType]: "TokenERC20", [ne.contractType]: "VoteERC20", [ae.contractType]: "Split", [Z.contractType]: "Marketplace", [j2.contractType]: "Pack", [Pe.contractType]: "Custom" };
var T0 = { DropERC721: Y.contractType, TokenERC721: X.contractType, DropERC1155: $.contractType, TokenERC1155: ee.contractType, DropERC20: te.contractType, TokenERC20: H.contractType, VoteERC20: ne.contractType, Split: ae.contractType, Marketplace: Z.contractType, Pack: j2.contractType };
var Wn = class extends g2 {
  constructor(e6, t6, n4, a5) {
    super(t6, e6, Qe.abi, a5), this.storage = n4;
  }
  async deploy(e6, t6) {
    var m6;
    let n4 = Oi[e6], a5 = n4.schema.deploy.parse(t6), i6 = await this.storage.uploadMetadata(a5, this.readContract.address, await ((m6 = this.getSigner()) == null ? void 0 : m6.getAddress())), s6 = Contract.getInterface(n4.contractAbi).encodeFunctionData("initialize", await this.getDeployArguments(e6, a5, i6)), o6 = Di[e6], y5 = ethers_exports.utils.formatBytes32String(o6), d6 = await this.sendTransaction("deployProxy", [y5, s6]), u7 = this.parseLogs("ProxyDeployed", d6.logs);
    if (u7.length < 1)
      throw new Error("No ProxyDeployed event found");
    return u7[0].args.proxy;
  }
  async getDeployArguments(e6, t6, n4) {
    let a5 = await this.getDefaultTrustedForwarders();
    switch (t6.trusted_forwarders && t6.trusted_forwarders.length > 0 && (a5 = t6.trusted_forwarders), e6) {
      case Y.contractType:
      case X.contractType:
        let i6 = Y.schema.deploy.parse(t6);
        return [await this.getSignerAddress(), i6.name, i6.symbol, n4, a5, i6.primary_sale_recipient, i6.fee_recipient, i6.seller_fee_basis_points, i6.platform_fee_basis_points, i6.platform_fee_recipient];
      case $.contractType:
      case ee.contractType:
        let s6 = $.schema.deploy.parse(t6);
        return [await this.getSignerAddress(), s6.name, s6.symbol, n4, a5, s6.primary_sale_recipient, s6.fee_recipient, s6.seller_fee_basis_points, s6.platform_fee_basis_points, s6.platform_fee_recipient];
      case te.contractType:
      case H.contractType:
        let o6 = H.schema.deploy.parse(t6);
        return [await this.getSignerAddress(), o6.name, o6.symbol, n4, a5, o6.primary_sale_recipient, o6.platform_fee_recipient, o6.platform_fee_basis_points];
      case ne.contractType:
        let y5 = ne.schema.deploy.parse(t6);
        return [y5.name, n4, a5, y5.voting_token_address, y5.voting_delay_in_blocks, y5.voting_period_in_blocks, BigNumber.from(y5.proposal_token_threshold), y5.voting_quorum_fraction];
      case ae.contractType:
        let d6 = ae.schema.deploy.parse(t6);
        return [await this.getSignerAddress(), n4, a5, d6.recipients.map((h6) => h6.address), d6.recipients.map((h6) => BigNumber.from(h6.sharesBps))];
      case Z.contractType:
        let u7 = Z.schema.deploy.parse(t6);
        return [await this.getSignerAddress(), n4, a5, u7.platform_fee_recipient, u7.platform_fee_basis_points];
      case j2.contractType:
        let m6 = j2.schema.deploy.parse(t6), b4 = Qt[await this.getChainID()];
        return [await this.getSignerAddress(), m6.name, m6.symbol, n4, a5, m6.fee_recipient, m6.seller_fee_basis_points, b4.fees, b4.keyHash];
      default:
        return [];
    }
  }
  async getDefaultTrustedForwarders() {
    let e6 = await this.getChainID(), t6 = S0.find((a5) => a5 === e6), n4 = t6 ? $a[t6].biconomyForwarder : lib_exports7.AddressZero;
    return n4 !== lib_exports7.AddressZero ? [Ht, n4] : [Ht];
  }
};
p2(Wn, "ContractFactory");
var Fn = class extends fe {
  constructor(e6, t6, n4) {
    super(e6, t6), this.storage = n4;
  }
  async deployNFTCollection(e6) {
    return await this.deployBuiltInContract(X.contractType, e6);
  }
  async deployNFTDrop(e6) {
    return await this.deployBuiltInContract(Y.contractType, e6);
  }
  async deployEdition(e6) {
    return await this.deployBuiltInContract(ee.contractType, e6);
  }
  async deployEditionDrop(e6) {
    let t6 = $.schema.deploy.parse(e6);
    return await this.deployBuiltInContract($.contractType, t6);
  }
  async deployToken(e6) {
    return await this.deployBuiltInContract(H.contractType, e6);
  }
  async deployTokenDrop(e6) {
    return await this.deployBuiltInContract(te.contractType, e6);
  }
  async deployMarketplace(e6) {
    return await this.deployBuiltInContract(Z.contractType, e6);
  }
  async deployPack(e6) {
    return await this.deployBuiltInContract(j2.contractType, e6);
  }
  async deploySplit(e6) {
    return await this.deployBuiltInContract(ae.contractType, e6);
  }
  async deployVote(e6) {
    return await this.deployBuiltInContract(ne.contractType, e6);
  }
  async deployBuiltInContract(e6, t6) {
    return await (await this.getFactory()).deploy(e6, t6);
  }
  async getRegistry() {
    return this._registry ? this._registry : this._registry = this.getProvider().getNetwork().then(async ({ chainId: e6 }) => {
      let t6 = He(e6, "twRegistry"), n4 = He(e6, "twBYOCRegistry");
      return new Cn(t6, n4, this.getSignerOrProvider(), this.options);
    });
  }
  async getFactory() {
    return this._factory ? this._factory : this._factory = this.getProvider().getNetwork().then(async ({ chainId: e6 }) => {
      let t6 = He(e6, "twFactory");
      return new Wn(t6, this.getSignerOrProvider(), this.storage, this.options);
    });
  }
  updateSignerOrProvider(e6) {
    super.updateSignerOrProvider(e6), this.updateContractSignerOrProvider();
  }
  updateContractSignerOrProvider() {
    var e6, t6;
    (e6 = this._factory) == null || e6.then((n4) => {
      n4.updateSignerOrProvider(this.getSignerOrProvider());
    }), (t6 = this._registry) == null || t6.then((n4) => {
      n4.updateSignerOrProvider(this.getSignerOrProvider());
    });
  }
};
p2(Fn, "ContractDeployer");
var Bn = class {
  constructor(e6, t6) {
    this.connection = new fe(e6, t6), this.options = t6;
  }
  onNetworkUpdated(e6) {
    this.connection.updateSignerOrProvider(e6);
  }
  async transfer(e6, t6, n4 = Re) {
    let a5 = await this.connectedWallet(), i6 = await ie(this.connection.getProvider(), t6, n4);
    if (Te(n4)) {
      let s6 = await a5.getAddress();
      return { receipt: await (await a5.sendTransaction({ from: s6, to: e6, value: i6 })).wait() };
    } else
      return { receipt: await this.createErc20(n4).sendTransaction("transfer", [e6, i6]) };
  }
  async balance(e6 = Re) {
    let t6 = this.connection.getSigner();
    invariant(t6, "Wallet not connected");
    let n4;
    return Te(e6) ? n4 = await t6.getBalance() : n4 = await this.createErc20(e6).readContract.balanceOf(await this.address()), await q2(this.connection.getProvider(), e6, n4);
  }
  async address() {
    return await this.connectedWallet().getAddress();
  }
  async sign(e6) {
    return await this.connectedWallet().signMessage(e6);
  }
  async sendRawTransaction(e6) {
    return { receipt: await (await this.connectedWallet().sendTransaction(e6)).wait() };
  }
  connectedWallet() {
    let e6 = this.connection.getSigner();
    return invariant(e6, "Wallet not connected"), e6;
  }
  createErc20(e6) {
    return new g2(this.connection.getSignerOrProvider(), e6, K2, this.options);
  }
};
p2(Bn, "UserWallet");
var On = class extends fe {
  constructor(e6, t6, n4, a5) {
    super(t6, n4), this.storage = a5, this.registry = new g2(t6, tr(), je.abi, n4), this.factory = new g2(t6, e6, Ze.abi, n4);
  }
  updateSignerOrProvider(e6) {
    super.updateSignerOrProvider(e6), this.registry.updateSignerOrProvider(e6), this.factory.updateSignerOrProvider(e6);
  }
  async extractConstructorParams(e6) {
    return Rr(e6, this.storage);
  }
  async extractFunctions(e6) {
    return Ar(e6, this.storage);
  }
  async fetchFullContractMetadata(e6) {
    return oa(e6, this.storage);
  }
  async fetchContractMetadataFromAddress(e6) {
    let n4 = await new Contract(e6, Ke.abi, this.getProvider()).getPublishMetadataUri();
    return await this.fetchFullContractMetadata(n4);
  }
  async getAll(e6) {
    return (await this.registry.readContract.getAllPublishedContracts(e6)).filter((n4) => n4.publishTimestamp).map((n4) => this.toPublishedContract(n4));
  }
  async getAllVersions(e6, t6) {
    let n4 = await this.registry.readContract.getPublishedContractVersions(e6, t6);
    if (n4.length === 0)
      throw Error("Not found");
    return n4.map((a5) => this.toPublishedContract(a5));
  }
  async getLatest(e6, t6) {
    let n4 = await this.registry.readContract.getPublishedContract(e6, t6);
    return this.toPublishedContract(n4);
  }
  async publish(e6) {
    return (await this.publishBatch([e6]))[0];
  }
  async publishBatch(e6) {
    let t6 = this.getSigner();
    invariant(t6, "A signer is required");
    let n4 = await t6.getAddress(), i6 = (await Promise.all(e6.map(async (y5) => ({ uri: y5, fullMetadata: await this.fetchFullContractMetadata(y5) })))).map((y5) => {
      let d6 = utils_exports.solidityKeccak256(["bytes"], [y5.fullMetadata.bytecode]), u7 = y5.fullMetadata.name;
      return this.registry.readContract.interface.encodeFunctionData("publishContract", [n4, y5.uri, d6, lib_exports7.AddressZero, u7]);
    }), s6 = await this.registry.multiCall(i6), o6 = this.registry.parseLogs("ContractPublished", s6.logs);
    if (o6.length < 1)
      throw new Error("No ContractDeployed event found");
    return o6.map((y5) => {
      let d6 = y5.args.publishedContract;
      return { receipt: s6, data: async () => this.toPublishedContract(d6) };
    });
  }
  async deployPublishedContract(e6, t6, n4, a5) {
    let i6 = await this.registry.readContract.getPublishedContract(e6, t6);
    return this.deployContract(i6.publishMetadataUri, n4, a5);
  }
  async deployContract(e6, t6, n4) {
    let a5 = this.getSigner();
    invariant(a5, "A signer is required");
    let i6 = await this.fetchFullContractMetadata(e6), s6 = await a5.getAddress(), o6 = i6.bytecode.startsWith("0x") ? i6.bytecode : `0x${i6.bytecode}`;
    if (!ethers_exports.utils.isHexString(o6))
      throw new Error(`Contract bytecode is invalid.

${o6}`);
    let y5 = ethers_exports.utils.formatBytes32String(Math.random().toString()), d6 = BigNumber.from(0), u7 = a0(i6.abi).map((ce2) => ce2.type), m6 = this.convertParamValues(u7, t6), b4 = ethers_exports.utils.defaultAbiCoder.encode(u7, m6), h6 = "";
    n4 && (h6 = await this.storage.uploadMetadata(n4));
    let v9 = await this.factory.sendTransaction("deployInstance", [s6, o6, b4, y5, d6, { publishMetadataUri: e6, contractURI: h6, owner: s6 }]), F5 = this.factory.parseLogs("ContractDeployed", v9.logs);
    if (F5.length < 1)
      throw new Error("No ContractDeployed event found");
    return F5[0].args.deployedContract;
  }
  convertParamValues(e6, t6) {
    if (e6.length !== t6.length)
      throw Error("Passed the wrong number of constructor arguments");
    return e6.map((n4, a5) => n4.endsWith("[]") ? typeof t6[a5] == "string" ? JSON.parse(t6[a5]) : t6[a5] : n4 === "bytes32" ? ethers_exports.utils.formatBytes32String(t6[a5].toString()) : n4.startsWith("bytes") ? ethers_exports.utils.toUtf8Bytes(t6[a5].toString()) : n4.startsWith("uint") || n4.startsWith("int") ? BigNumber.from(t6[a5].toString()) : t6[a5]);
  }
  async deployContractWithAbi(e6, t6, n4) {
    let a5 = this.getSigner();
    return invariant(a5, "Signer is required to deploy contracts"), (await (await new ethers_exports.ContractFactory(e6, t6).connect(a5).deploy(...n4)).deployed()).address;
  }
  toPublishedContract(e6) {
    return gr.parse({ id: e6.contractId, timestamp: e6.publishTimestamp, metadataUri: e6.publishMetadataUri });
  }
};
p2(On, "ContractPublisher");
var g0 = class extends fe {
  constructor(e6, t6 = {}, n4 = new Vt()) {
    super(e6, t6);
    __publicField(this, "contractCache", /* @__PURE__ */ new Map());
    this.storage = n4, this.deployer = new Fn(e6, t6, n4), this.wallet = new Bn(e6, t6);
  }
  getNFTDrop(e6) {
    return this.getBuiltInContract(e6, Y.contractType);
  }
  getNFTCollection(e6) {
    return this.getBuiltInContract(e6, X.contractType);
  }
  getEditionDrop(e6) {
    return this.getBuiltInContract(e6, $.contractType);
  }
  getEdition(e6) {
    return this.getBuiltInContract(e6, ee.contractType);
  }
  getTokenDrop(e6) {
    return this.getBuiltInContract(e6, te.contractType);
  }
  getToken(e6) {
    return this.getBuiltInContract(e6, H.contractType);
  }
  getVote(e6) {
    return this.getBuiltInContract(e6, ne.contractType);
  }
  getSplit(e6) {
    return this.getBuiltInContract(e6, ae.contractType);
  }
  getMarketplace(e6) {
    return this.getBuiltInContract(e6, Z.contractType);
  }
  getPack(e6) {
    return this.getBuiltInContract(e6, j2.contractType);
  }
  getBuiltInContract(e6, t6) {
    if (this.contractCache.has(e6))
      return this.contractCache.get(e6);
    if (t6 === "custom")
      throw new Error("To get an instance of a custom contract, use getContract(address)");
    let n4 = new b0[t6](this.getSignerOrProvider(), e6, this.storage, this.options);
    return this.contractCache.set(e6, n4), n4;
  }
  async resolveContractType(e6) {
    let t6 = it.connect(e6, this.getSignerOrProvider()), n4 = ethers_exports.utils.toUtf8String(await t6.contractType()).replace(/\x00/g, "");
    return invariant(n4 in T0, `${n4} is not a valid contract type, falling back to custom contract`), T0[n4];
  }
  async getContractList(e6) {
    let t6 = await (await this.deployer.getRegistry()).getContractAddresses(e6);
    return (await Promise.all(t6.map(async (a5) => {
      let i6 = "custom";
      try {
        i6 = await this.resolveContractType(a5);
      } catch {
      }
      let s6;
      if (i6 === "custom")
        try {
          s6 = (await this.getContract(a5)).metadata;
        } catch {
          console.log(`Couldn't get contract metadata for custom contract: ${a5}`);
        }
      else
        s6 = this.getBuiltInContract(a5, i6).metadata;
      return { address: a5, contractType: i6, metadata: s6 };
    }))).filter((a5) => a5.metadata).map(({ address: a5, contractType: i6, metadata: s6 }) => (invariant(s6, "All ThirdwebContracts require metadata"), { address: a5, contractType: i6, metadata: () => s6.get() }));
  }
  updateSignerOrProvider(e6) {
    super.updateSignerOrProvider(e6), this.updateContractSignerOrProvider();
  }
  updateContractSignerOrProvider() {
    var e6;
    this.wallet.onNetworkUpdated(this.getSignerOrProvider()), this.deployer.updateSignerOrProvider(this.getSignerOrProvider()), (e6 = this._publisher) == null || e6.then((t6) => {
      t6.updateSignerOrProvider(this.getSignerOrProvider());
    });
    for (let [, t6] of this.contractCache)
      t6.onNetworkUpdated(this.getSignerOrProvider());
  }
  async getContract(e6) {
    if (this.contractCache.has(e6))
      return this.contractCache.get(e6);
    try {
      let n4 = await (await this.getPublisher()).fetchContractMetadataFromAddress(e6);
      return this.getContractFromAbi(e6, n4.abi);
    } catch (t6) {
      throw new Error(`Error fetching ABI for this contract

${t6}`);
    }
  }
  getContractFromAbi(e6, t6) {
    if (this.contractCache.has(e6))
      return this.contractCache.get(e6);
    let n4 = new Pe(this.getSignerOrProvider(), e6, t6, this.storage, this.options);
    return this.contractCache.set(e6, n4), n4;
  }
  async getPublisher() {
    return this._publisher ? this._publisher : this._publisher = this.getProvider().getNetwork().then(async ({ chainId: e6 }) => {
      let t6 = He(e6, "byocFactory");
      return new On(t6, this.getSignerOrProvider(), this.options, this.storage);
    });
  }
};
p2(g0, "ThirdwebSDK");

// node_modules/wagmi/dist/wagmi.esm.js
var React = __toESM(require_react());

// node_modules/wagmi-core/dist/base-2a0d02bb.esm.js
var import_eventemitter3 = __toESM(require_eventemitter3());
function _checkPrivateRedeclaration(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldInitSpec(obj, privateMap, value2) {
  _checkPrivateRedeclaration(obj, privateMap);
  privateMap.set(obj, value2);
}
function _defineProperty(obj, key2, value2) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value2;
  }
  return obj;
}
function _classApplyDescriptorGet(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classExtractFieldDescriptor(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classPrivateFieldGet(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");
  return _classApplyDescriptorGet(receiver, descriptor);
}
function _classApplyDescriptorSet(receiver, descriptor, value2) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value2);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value2;
  }
}
function _classPrivateFieldSet(receiver, privateMap, value2) {
  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");
  _classApplyDescriptorSet(receiver, descriptor, value2);
  return value2;
}
var chain = {
  mainnet: {
    id: 1,
    name: "Mainnet",
    nativeCurrency: {
      name: "Ether",
      symbol: "ETH",
      decimals: 18
    },
    rpcUrls: ["https://mainnet.infura.io/v3"],
    blockExplorers: [{
      name: "Etherscan",
      url: "https://etherscan.io"
    }]
  },
  ropsten: {
    id: 3,
    name: "Ropsten",
    nativeCurrency: {
      name: "Ropsten Ether",
      symbol: "ropETH",
      decimals: 18
    },
    rpcUrls: ["https://ropsten.infura.io/v3"],
    blockExplorers: [{
      name: "Etherscan",
      url: "https://ropsten.etherscan.io"
    }],
    testnet: true
  },
  rinkeby: {
    id: 4,
    name: "Rinkeby",
    nativeCurrency: {
      name: "Rinkeby Ether",
      symbol: "rETH",
      decimals: 18
    },
    rpcUrls: ["https://rinkeby.infura.io/v3"],
    blockExplorers: [{
      name: "Etherscan",
      url: "https://rinkeby.etherscan.io"
    }],
    testnet: true
  },
  gnosis: {
    id: 100,
    name: "Gnosis Chain",
    nativeCurrency: {
      name: "xDai",
      symbol: "xDAI",
      decimals: 18
    },
    rpcUrls: ["https://rpc.gnosischain.com"],
    blockExplorers: [{
      name: "Blockscout",
      url: "https://blockscout.com"
    }]
  },
  goerli: {
    id: 5,
    name: "Goerli",
    nativeCurrency: {
      name: "Goerli Ether",
      symbol: "gETH",
      decimals: 18
    },
    rpcUrls: ["https://goerli.infura.io/v3"],
    blockExplorers: [{
      name: "Etherscan",
      url: "https://goerli.etherscan.io"
    }],
    testnet: true
  },
  kovan: {
    id: 42,
    name: "Kovan",
    nativeCurrency: {
      name: "Kovan Ether",
      symbol: "kETH",
      decimals: 18
    },
    rpcUrls: ["https://kovan.infura.io/v3"],
    blockExplorers: [{
      name: "Etherscan",
      url: "https://kovan.etherscan.io"
    }],
    testnet: true
  },
  optimism: {
    id: 10,
    name: "Optimism",
    nativeCurrency: {
      name: "Ether",
      symbol: "ETH",
      decimals: 18
    },
    rpcUrls: ["https://mainnet.optimism.io"],
    blockExplorers: [{
      name: "Etherscan",
      url: "https://optimistic.etherscan.io"
    }]
  },
  optimismKovan: {
    id: 69,
    name: "Optimism Kovan",
    nativeCurrency: {
      name: "Kovan Ether",
      symbol: "KOR",
      decimals: 18
    },
    rpcUrls: ["https://kovan.optimism.io"],
    blockExplorers: [{
      name: "Etherscan",
      url: "https://kovan-optimistic.etherscan.io"
    }],
    testnet: true
  },
  polygonMainnet: {
    id: 137,
    name: "Polygon Mainnet",
    nativeCurrency: {
      name: "MATIC",
      symbol: "MATIC",
      decimals: 18
    },
    rpcUrls: ["https://polygon-rpc.com", "https://rpc-mainnet.matic.network", "https://matic-mainnet.chainstacklabs.com", "https://rpc-mainnet.maticvigil.com", "https://rpc-mainnet.matic.quiknode.pro", "https://matic-mainnet-full-rpc.bwarelabs.com"],
    blockExplorers: [{
      name: "Polygonscan",
      url: "https://polygonscan.com"
    }]
  },
  polygonTestnetMumbai: {
    id: 80001,
    name: "Mumbai",
    nativeCurrency: {
      name: "MATIC",
      symbol: "MATIC",
      decimals: 18
    },
    rpcUrls: ["https://matic-mumbai.chainstacklabs.com", "https://rpc-mumbai.maticvigil.com", "https://matic-testnet-archive-rpc.bwarelabs.com"],
    blockExplorers: [{
      name: "Polygonscan",
      url: "https://mumbai.polygonscan.com"
    }],
    testnet: true
  },
  arbitrumOne: {
    id: 42161,
    name: "Arbitrum One",
    nativeCurrency: {
      name: "Ether",
      symbol: "AETH",
      decimals: 18
    },
    rpcUrls: ["https://arb1.arbitrum.io/rpc"],
    blockExplorers: [{
      name: "Arbiscan",
      url: "https://arbiscan.io"
    }, {
      name: "Arbitrum Explorer",
      url: "https://explorer.arbitrum.io"
    }]
  },
  arbitrumRinkeby: {
    id: 421611,
    name: "Arbitrum Rinkeby",
    nativeCurrency: {
      name: "Arbitrum Rinkeby Ether",
      symbol: "ARETH",
      decimals: 18
    },
    rpcUrls: ["https://rinkeby.arbitrum.io/rpc"],
    blockExplorers: [{
      name: "Arbitrum Explorer",
      url: "https://rinkeby-explorer.arbitrum.io"
    }],
    testnet: true
  },
  avalanche: {
    id: 43114,
    name: "Avalanche Mainnet",
    nativeCurrency: {
      name: "Avalanche",
      symbol: "AVAX",
      decimals: 18
    },
    rpcUrls: ["https://api.avax.network/ext/bc/C/rpc"],
    blockExplorers: [{
      name: "SnowTrace",
      url: "https://snowtrace.io"
    }],
    testnet: false
  },
  avalancheFuji: {
    id: 43113,
    name: "Avalanche Fuji Testnet",
    nativeCurrency: {
      name: "Avalanche",
      symbol: "AVAX",
      decimals: 18
    },
    rpcUrls: ["https://api.avax-test.network/ext/bc/C/rpc"],
    blockExplorers: [{
      name: "SnowTrace",
      url: "https://testnet.snowtrace.io"
    }],
    testnet: true
  },
  localhost: {
    id: 1337,
    name: "Localhost",
    rpcUrls: ["https://127.0.0.1:8545"]
  },
  hardhat: {
    id: 31337,
    name: "Hardhat",
    rpcUrls: ["http://127.0.0.1:8545"]
  }
};
var allChains = Object.values(chain);
var defaultChains = [chain.mainnet, chain.ropsten, chain.rinkeby, chain.goerli, chain.kovan];
var defaultL2Chains = [chain.gnosis, chain.optimism, chain.optimismKovan, chain.polygonMainnet, chain.polygonTestnetMumbai, chain.arbitrumOne, chain.arbitrumRinkeby];
var developmentChains = [chain.localhost, chain.hardhat];
var normalizeChainId = (chainId) => {
  if (typeof chainId === "string")
    return Number.parseInt(chainId, chainId.trim().substring(0, 2) === "0x" ? 16 : 10);
  return chainId;
};
var AddChainError = class extends Error {
  constructor() {
    super(...arguments);
    _defineProperty(this, "name", "AddChainError");
    _defineProperty(this, "message", "Error adding chain");
  }
};
var ChainNotConfiguredError = class extends Error {
  constructor() {
    super(...arguments);
    _defineProperty(this, "name", "ChainNotConfigured");
    _defineProperty(this, "message", "Chain not configured");
  }
};
var ConnectorAlreadyConnectedError = class extends Error {
  constructor() {
    super(...arguments);
    _defineProperty(this, "name", "ConnectorAlreadyConnectedError");
    _defineProperty(this, "message", "Connector already connected");
  }
};
var ConnectorNotFoundError = class extends Error {
  constructor() {
    super(...arguments);
    _defineProperty(this, "name", "ConnectorNotFoundError");
    _defineProperty(this, "message", "Connector not found");
  }
};
var SwitchChainError = class extends Error {
  constructor() {
    super(...arguments);
    _defineProperty(this, "name", "SwitchChainError");
    _defineProperty(this, "message", "Error switching chain");
  }
};
var UserRejectedRequestError = class extends Error {
  constructor() {
    super(...arguments);
    _defineProperty(this, "name", "UserRejectedRequestError");
    _defineProperty(this, "message", "User rejected request");
  }
};
var Connector = class extends import_eventemitter3.default {
  constructor(_ref) {
    let {
      chains = defaultChains,
      options
    } = _ref;
    super();
    _defineProperty(this, "id", void 0);
    _defineProperty(this, "name", void 0);
    _defineProperty(this, "chains", void 0);
    _defineProperty(this, "options", void 0);
    _defineProperty(this, "ready", void 0);
    this.chains = chains;
    this.options = options;
  }
  isChainUnsupported(chainId) {
    return !this.chains.some((x6) => x6.id === chainId);
  }
};

// node_modules/wagmi-core/dist/wagmi-core.esm.js
var import_utils3 = __toESM(require_utils2());
var import_eventemitter32 = __toESM(require_eventemitter3());
var getInjectedName = (ethereum) => {
  if (!ethereum)
    return "Injected";
  if (ethereum.isBraveWallet)
    return "Brave Wallet";
  if (ethereum.isMetaMask)
    return "MetaMask";
  if (ethereum.isCoinbaseWallet)
    return "Coinbase Wallet";
  if (ethereum.isFrame)
    return "Frame";
  if (ethereum.isTally)
    return "Tally";
  return "Injected";
};
var shimKey = "wagmi.shimDisconnect";
var _provider = /* @__PURE__ */ new WeakMap();
var InjectedConnector = class extends Connector {
  constructor(config2) {
    super({
      ...config2,
      options: config2 === null || config2 === void 0 ? void 0 : config2.options
    });
    _defineProperty(this, "id", "injected");
    _defineProperty(this, "name", void 0);
    _defineProperty(this, "ready", typeof window != "undefined" && !!window.ethereum);
    _classPrivateFieldInitSpec(this, _provider, {
      writable: true,
      value: void 0
    });
    _defineProperty(this, "onAccountsChanged", (accounts) => {
      if (accounts.length === 0)
        this.emit("disconnect");
      else
        this.emit("change", {
          account: (0, import_utils3.getAddress)(accounts[0])
        });
    });
    _defineProperty(this, "onChainChanged", (chainId) => {
      const id2 = normalizeChainId(chainId);
      const unsupported = this.isChainUnsupported(id2);
      this.emit("change", {
        chain: {
          id: id2,
          unsupported
        }
      });
    });
    _defineProperty(this, "onDisconnect", () => {
      var _this$options;
      this.emit("disconnect");
      if ((_this$options = this.options) !== null && _this$options !== void 0 && _this$options.shimDisconnect)
        typeof localStorage !== "undefined" && localStorage.removeItem(shimKey);
    });
    let name2 = "Injected";
    if (typeof window !== "undefined")
      name2 = getInjectedName(window.ethereum);
    this.name = name2;
  }
  async connect() {
    try {
      var _this$options3;
      const provider = this.getProvider();
      if (!provider)
        throw new ConnectorNotFoundError();
      if (provider.on) {
        var _this$options2;
        provider.on("accountsChanged", this.onAccountsChanged);
        provider.on("chainChanged", this.onChainChanged);
        if (!((_this$options2 = this.options) !== null && _this$options2 !== void 0 && _this$options2.shimChainChangedDisconnect))
          provider.on("disconnect", this.onDisconnect);
      }
      const account = await this.getAccount();
      const id2 = await this.getChainId();
      const unsupported = this.isChainUnsupported(id2);
      if ((_this$options3 = this.options) !== null && _this$options3 !== void 0 && _this$options3.shimDisconnect)
        typeof localStorage !== "undefined" && localStorage.setItem(shimKey, "true");
      return {
        account,
        chain: {
          id: id2,
          unsupported
        },
        provider
      };
    } catch (error) {
      if (error.code === 4001)
        throw new UserRejectedRequestError();
      throw error;
    }
  }
  async disconnect() {
    var _this$options4;
    const provider = this.getProvider();
    if (!(provider !== null && provider !== void 0 && provider.removeListener))
      return;
    provider.removeListener("accountsChanged", this.onAccountsChanged);
    provider.removeListener("chainChanged", this.onChainChanged);
    provider.removeListener("disconnect", this.onDisconnect);
    if ((_this$options4 = this.options) !== null && _this$options4 !== void 0 && _this$options4.shimDisconnect)
      typeof localStorage !== "undefined" && localStorage.removeItem(shimKey);
  }
  async getAccount() {
    const provider = this.getProvider();
    if (!provider)
      throw new ConnectorNotFoundError();
    const accounts = await provider.request({
      method: "eth_requestAccounts"
    });
    return (0, import_utils3.getAddress)(accounts[0]);
  }
  async getChainId() {
    const provider = this.getProvider();
    if (!provider)
      throw new ConnectorNotFoundError();
    return await provider.request({
      method: "eth_chainId"
    }).then(normalizeChainId);
  }
  getProvider() {
    if (typeof window !== "undefined" && !!window.ethereum)
      _classPrivateFieldSet(this, _provider, window.ethereum);
    return _classPrivateFieldGet(this, _provider);
  }
  async getSigner() {
    const provider = this.getProvider();
    const account = await this.getAccount();
    return new Web3Provider(provider).getSigner(account);
  }
  async isAuthorized() {
    try {
      var _this$options5;
      if ((_this$options5 = this.options) !== null && _this$options5 !== void 0 && _this$options5.shimDisconnect && typeof localStorage !== "undefined" && !localStorage.getItem(shimKey))
        return false;
      const provider = this.getProvider();
      if (!provider)
        throw new ConnectorNotFoundError();
      const accounts = await provider.request({
        method: "eth_accounts"
      });
      const account = accounts[0];
      return !!account;
    } catch {
      return false;
    }
  }
  async switchChain(chainId) {
    const provider = this.getProvider();
    if (!provider)
      throw new ConnectorNotFoundError();
    const id2 = (0, import_utils3.hexValue)(chainId);
    try {
      await provider.request({
        method: "wallet_switchEthereumChain",
        params: [{
          chainId: id2
        }]
      });
      const chains = [...this.chains, ...allChains];
      return chains.find((x6) => x6.id === chainId);
    } catch (error) {
      if (error.code === 4902) {
        try {
          var _chain$blockExplorers;
          const chain2 = this.chains.find((x6) => x6.id === chainId);
          if (!chain2)
            throw new ChainNotConfiguredError();
          await provider.request({
            method: "wallet_addEthereumChain",
            params: [{
              chainId: id2,
              chainName: chain2.name,
              nativeCurrency: chain2.nativeCurrency,
              rpcUrls: chain2.rpcUrls,
              blockExplorerUrls: (_chain$blockExplorers = chain2.blockExplorers) === null || _chain$blockExplorers === void 0 ? void 0 : _chain$blockExplorers.map((x6) => x6.url)
            }]
          });
          return chain2;
        } catch (addError) {
          throw new AddChainError();
        }
      } else if (error.code === 4001)
        throw new UserRejectedRequestError();
      else
        throw new SwitchChainError();
    }
  }
  async watchAsset(_ref) {
    let {
      address,
      decimals = 18,
      image,
      symbol
    } = _ref;
    const provider = this.getProvider();
    if (!provider)
      throw new ConnectorNotFoundError();
    await provider.request({
      method: "wallet_watchAsset",
      params: {
        type: "ERC20",
        options: {
          address,
          decimals,
          image,
          symbol
        }
      }
    });
  }
};

// node_modules/wagmi/dist/wagmi.esm.js
var useProvider = () => {
  const {
    state
  } = useContext2();
  return state.provider;
};
var useCacheBuster = () => {
  const context = useContext2();
  return context.state.cacheBuster;
};
var useCancel = () => {
  const cancelCallback = React.useRef(null);
  React.useEffect(() => {
    return () => {
      var _cancelCallback$curre;
      return (_cancelCallback$curre = cancelCallback.current) === null || _cancelCallback$curre === void 0 ? void 0 : _cancelCallback$curre.call(cancelCallback);
    };
  }, []);
  const cancel = React.useCallback((callback) => {
    var _cancelCallback$curre2;
    (_cancelCallback$curre2 = cancelCallback.current) === null || _cancelCallback$curre2 === void 0 ? void 0 : _cancelCallback$curre2.call(cancelCallback);
    if (callback)
      cancelCallback.current = callback;
  }, []);
  return cancel;
};
var useLocalStorage = function(key2) {
  let defaultState = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  const [value2, setValue] = React.useState(() => {
    if (typeof localStorage === "undefined")
      return defaultState;
    const value3 = localStorage.getItem(key2);
    try {
      return value3 ? JSON.parse(value3) : defaultState;
    } catch (error) {
      console.warn(error);
      return defaultState;
    }
  });
  const setLocalStorage = React.useCallback((newValue) => {
    if (newValue === value2)
      return;
    setValue(newValue);
    if (newValue === null)
      localStorage.removeItem(key2);
    else
      localStorage.setItem(key2, JSON.stringify(newValue));
    if (newValue === null) {
      localStorage.removeItem(key2);
    } else {
      try {
        localStorage.setItem(key2, JSON.stringify(newValue));
      } catch (error) {
        console.error(error);
      }
    }
  }, [value2, setValue, key2]);
  return [value2, setLocalStorage];
};
var initialState$g = {
  loading: false
};
var useEnsAvatar = function() {
  let {
    addressOrName,
    skip: skip2
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const cacheBuster = useCacheBuster();
  const provider = useProvider();
  const [state, setState] = React.useState(initialState$g);
  const cancelQuery = useCancel();
  const getEnsAvatar = React.useCallback(async (config2) => {
    let didCancel = false;
    cancelQuery(() => {
      didCancel = true;
    });
    try {
      const config_ = config2 !== null && config2 !== void 0 ? config2 : {
        addressOrName
      };
      if (!config_.addressOrName)
        throw new Error("addressOrName is required");
      setState((x6) => ({
        ...x6,
        error: void 0,
        loading: true
      }));
      const avatar = await provider.getAvatar(config_.addressOrName);
      if (!didCancel) {
        setState((x6) => ({
          ...x6,
          avatar,
          loading: false
        }));
      }
      return avatar;
    } catch (error_) {
      const error = error_;
      if (!didCancel) {
        setState((x6) => ({
          ...x6,
          error,
          loading: false
        }));
      }
      return error;
    }
  }, [addressOrName, cancelQuery, provider]);
  React.useEffect(() => {
    if (skip2 || !addressOrName)
      return;
    getEnsAvatar({
      addressOrName
    });
    return cancelQuery;
  }, [addressOrName, cacheBuster, cancelQuery, skip2]);
  return [{
    data: state.avatar,
    loading: state.loading,
    error: state.error
  }, getEnsAvatar];
};
var initialState$f = {
  loading: false
};
var useEnsLookup = function() {
  let {
    address,
    skip: skip2
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const cacheBuster = useCacheBuster();
  const provider = useProvider();
  const [state, setState] = React.useState(initialState$f);
  const cancelQuery = useCancel();
  const lookupAddress = React.useCallback(async (config2) => {
    let didCancel = false;
    cancelQuery(() => {
      didCancel = true;
    });
    try {
      const config_ = config2 !== null && config2 !== void 0 ? config2 : {
        address
      };
      if (!config_.address)
        throw new Error("address is required");
      setState((x6) => ({
        ...x6,
        error: void 0,
        loading: true
      }));
      const ens = await provider.lookupAddress(config_.address);
      if (!didCancel) {
        setState((x6) => ({
          ...x6,
          ens,
          loading: false
        }));
      }
      return {
        data: ens,
        error: void 0
      };
    } catch (error_) {
      const error = error_;
      if (!didCancel) {
        setState((x6) => ({
          ...x6,
          error,
          loading: false
        }));
      }
      return {
        data: void 0,
        error
      };
    }
  }, [address, cancelQuery, provider]);
  React.useEffect(() => {
    if (skip2 || !address)
      return;
    lookupAddress({
      address
    });
    return cancelQuery;
  }, [address, cacheBuster, cancelQuery, skip2]);
  return [{
    data: state.ens,
    loading: state.loading,
    error: state.error
  }, lookupAddress];
};
var useAccount = function() {
  var _globalState$data;
  let {
    fetchEns
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const {
    state: globalState,
    setState
  } = useContext2();
  const address = (_globalState$data = globalState.data) === null || _globalState$data === void 0 ? void 0 : _globalState$data.account;
  const [{
    data: ens,
    error: ensError,
    loading: ensLoading
  }] = useEnsLookup({
    address,
    skip: !fetchEns
  });
  const [{
    data: avatar,
    error: avatarError,
    loading: avatarLoading
  }] = useEnsAvatar({
    addressOrName: ens,
    skip: !fetchEns || !ens
  });
  const disconnect = React.useCallback(() => {
    setState((x6) => {
      var _x$connector;
      (_x$connector = x6.connector) === null || _x$connector === void 0 ? void 0 : _x$connector.disconnect();
      return {
        cacheBuster: x6.cacheBuster + 1
      };
    });
  }, [setState]);
  const error = ensError || avatarError;
  const loading = ensLoading || avatarLoading;
  return [{
    data: address ? {
      address,
      connector: globalState.connector,
      ens: ens ? {
        avatar,
        name: ens
      } : void 0
    } : void 0,
    error,
    loading
  }, disconnect];
};
var initialState$9 = {
  loading: false
};
var useConnect = () => {
  var _globalState$data;
  const {
    state: globalState,
    setState: setGlobalState,
    setLastUsedConnector
  } = useContext2();
  const [state, setState] = React.useState(initialState$9);
  const cancelQuery = useCancel();
  const connect = React.useCallback(async (connector) => {
    let didCancel = false;
    cancelQuery(() => {
      didCancel = true;
    });
    try {
      const activeConnector = globalState === null || globalState === void 0 ? void 0 : globalState.connector;
      if (connector === activeConnector)
        throw new ConnectorAlreadyConnectedError();
      setState((x6) => ({
        ...x6,
        loading: true,
        connector,
        error: void 0
      }));
      const data = await connector.connect();
      if (!didCancel) {
        setGlobalState((x6) => ({
          ...x6,
          connector,
          data
        }));
        setLastUsedConnector(connector.name);
        setState((x6) => ({
          ...x6,
          loading: false
        }));
      }
      return {
        data,
        error: void 0
      };
    } catch (error_) {
      const error = error_;
      if (!didCancel) {
        setState((x6) => ({
          ...x6,
          connector: void 0,
          error,
          loading: false
        }));
      }
      return {
        data: void 0,
        error
      };
    }
  }, [cancelQuery, globalState.connector, setGlobalState, setLastUsedConnector]);
  React.useEffect(() => {
    setState((x6) => ({
      ...x6,
      connector: globalState.connector,
      error: void 0
    }));
    return cancelQuery;
  }, [cancelQuery, globalState.connector]);
  return [{
    data: {
      connected: !!((_globalState$data = globalState.data) !== null && _globalState$data !== void 0 && _globalState$data.account),
      connector: state.connector,
      connectors: globalState.connectors
    },
    error: state.error,
    loading: state.loading || globalState.connecting
  }, connect];
};
var initialState$8 = {
  loading: false
};
var useNetwork = () => {
  var _data$chain, _data$chain2, _connector$chains;
  const {
    state: {
      connector,
      data
    }
  } = useContext2();
  const [state, setState] = React.useState(initialState$8);
  const chainId = data === null || data === void 0 ? void 0 : (_data$chain = data.chain) === null || _data$chain === void 0 ? void 0 : _data$chain.id;
  const unsupported = data === null || data === void 0 ? void 0 : (_data$chain2 = data.chain) === null || _data$chain2 === void 0 ? void 0 : _data$chain2.unsupported;
  const activeChains = (_connector$chains = connector === null || connector === void 0 ? void 0 : connector.chains) !== null && _connector$chains !== void 0 ? _connector$chains : [];
  const activeChain = [...activeChains, ...allChains].find((x6) => x6.id === chainId);
  const cancelQuery = useCancel();
  const switchNetwork = React.useCallback(async (chainId2) => {
    let didCancel = false;
    cancelQuery(() => {
      didCancel = true;
    });
    if (!(connector !== null && connector !== void 0 && connector.switchChain))
      return {
        data: void 0,
        error: new SwitchChainError()
      };
    try {
      setState((x6) => ({
        ...x6,
        error: void 0,
        loading: true
      }));
      const chain2 = await connector.switchChain(chainId2);
      if (!didCancel) {
        setState((x6) => ({
          ...x6,
          loading: false
        }));
      }
      return {
        data: chain2,
        error: void 0
      };
    } catch (error_) {
      const error = error_;
      if (!didCancel) {
        setState((x6) => ({
          ...x6,
          error,
          loading: false
        }));
      }
      return {
        data: void 0,
        error
      };
    }
  }, [cancelQuery, connector]);
  return [{
    data: {
      chain: chainId ? {
        ...activeChain,
        id: chainId,
        unsupported
      } : void 0,
      chains: activeChains
    },
    error: state.error,
    loading: state.loading
  }, connector !== null && connector !== void 0 && connector.switchChain ? switchNetwork : void 0];
};
var initialState$7 = {
  data: void 0,
  error: void 0,
  loading: false
};
var useSigner = function() {
  let {
    skip: skip2
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const cacheBuster = useCacheBuster();
  const {
    state: {
      connector
    }
  } = useContext2();
  const [state, setState] = React.useState(initialState$7);
  const cancelQuery = useCancel();
  const getSigner = React.useCallback(async () => {
    let didCancel = false;
    cancelQuery(() => {
      didCancel = true;
    });
    try {
      setState((x6) => ({
        ...x6,
        error: void 0,
        loading: true
      }));
      const signer = await (connector === null || connector === void 0 ? void 0 : connector.getSigner());
      if (!didCancel) {
        setState((x6) => ({
          ...x6,
          data: signer,
          loading: false
        }));
      }
      return signer;
    } catch (error_) {
      const error = error_;
      if (!didCancel) {
        setState((x6) => ({
          ...x6,
          data: void 0,
          error,
          loading: false
        }));
      }
    }
  }, [cancelQuery, connector]);
  React.useEffect(() => {
    if (skip2)
      return;
    getSigner();
    return cancelQuery;
  }, [cacheBuster, connector, cancelQuery, skip2]);
  return [state, getSigner];
};
var Context = React.createContext(null);
var Provider2 = (_ref) => {
  var _state$data2, _state$data2$chain, _state$data4, _state$data4$chain, _state$data6, _state$data6$chain;
  let {
    autoConnect = false,
    children,
    connectors: connectors_ = [new InjectedConnector()],
    connectorStorageKey = "wagmi.wallet",
    provider: provider_ = getDefaultProvider(),
    webSocketProvider: webSocketProvider_
  } = _ref;
  const [lastUsedConnector, setLastUsedConnector] = useLocalStorage(connectorStorageKey);
  const [state, setState] = React.useState({
    cacheBuster: 1,
    connecting: autoConnect
  });
  const connectors = React.useMemo(() => {
    var _state$data, _state$data$chain;
    if (typeof connectors_ !== "function")
      return connectors_;
    return connectors_({
      chainId: (_state$data = state.data) === null || _state$data === void 0 ? void 0 : (_state$data$chain = _state$data.chain) === null || _state$data$chain === void 0 ? void 0 : _state$data$chain.id
    });
  }, [connectors_, (_state$data2 = state.data) === null || _state$data2 === void 0 ? void 0 : (_state$data2$chain = _state$data2.chain) === null || _state$data2$chain === void 0 ? void 0 : _state$data2$chain.id]);
  const provider = React.useMemo(() => {
    var _state$data3, _state$data3$chain;
    if (typeof provider_ !== "function")
      return provider_;
    return provider_({
      chainId: (_state$data3 = state.data) === null || _state$data3 === void 0 ? void 0 : (_state$data3$chain = _state$data3.chain) === null || _state$data3$chain === void 0 ? void 0 : _state$data3$chain.id,
      connector: state.connector
    });
  }, [provider_, (_state$data4 = state.data) === null || _state$data4 === void 0 ? void 0 : (_state$data4$chain = _state$data4.chain) === null || _state$data4$chain === void 0 ? void 0 : _state$data4$chain.id, state.connector]);
  const webSocketProvider = React.useMemo(() => {
    var _state$data5, _state$data5$chain;
    if (!webSocketProvider_)
      return void 0;
    if (typeof webSocketProvider_ !== "function")
      return webSocketProvider_;
    return webSocketProvider_({
      chainId: (_state$data5 = state.data) === null || _state$data5 === void 0 ? void 0 : (_state$data5$chain = _state$data5.chain) === null || _state$data5$chain === void 0 ? void 0 : _state$data5$chain.id,
      connector: state.connector
    });
  }, [webSocketProvider_, (_state$data6 = state.data) === null || _state$data6 === void 0 ? void 0 : (_state$data6$chain = _state$data6.chain) === null || _state$data6$chain === void 0 ? void 0 : _state$data6$chain.id, state.connector]);
  React.useEffect(() => {
    if (!autoConnect)
      return;
    (async () => {
      setState((x6) => ({
        ...x6,
        connecting: true
      }));
      const sorted = lastUsedConnector ? [...connectors].sort((x6) => x6.name === lastUsedConnector ? -1 : 1) : connectors;
      for (const connector of sorted) {
        if (!connector.ready || !connector.isAuthorized)
          continue;
        const isAuthorized = await connector.isAuthorized();
        if (!isAuthorized)
          continue;
        const data = await connector.connect();
        setState((x6) => ({
          ...x6,
          connector,
          data
        }));
        break;
      }
      setState((x6) => ({
        ...x6,
        connecting: false
      }));
    })();
  }, []);
  React.useEffect(() => {
    return () => {
      if (!state.connector)
        return;
      state.connector.disconnect();
    };
  }, [state.connector]);
  React.useEffect(() => {
    if (!state.connector)
      return;
    const onChange = (data) => setState((x6) => ({
      ...x6,
      cacheBuster: x6.cacheBuster + 1,
      data: {
        ...x6.data,
        ...data
      }
    }));
    const onDisconnect = () => setState({
      cacheBuster: 1
    });
    const onError = (error) => setState((x6) => ({
      ...x6,
      error
    }));
    state.connector.on("change", onChange);
    state.connector.on("disconnect", onDisconnect);
    state.connector.on("error", onError);
    return () => {
      if (!state.connector)
        return;
      state.connector.off("change", onChange);
      state.connector.off("disconnect", onDisconnect);
      state.connector.off("error", onError);
    };
  }, [state.connector]);
  const value2 = {
    state: {
      cacheBuster: state.cacheBuster,
      connecting: state.connecting,
      connectors,
      connector: state.connector,
      data: state.data,
      provider,
      webSocketProvider
    },
    setState,
    setLastUsedConnector
  };
  return React.createElement(Context.Provider, {
    value: value2
  }, children);
};
var useContext2 = () => {
  const context = React.useContext(Context);
  if (!context)
    throw Error("Must be used within Provider");
  return context;
};

// node_modules/@thirdweb-dev/react/dist/index.mjs
var import_react11 = __toESM(require_react(), 1);
var import_react12 = __toESM(require_react(), 1);

// node_modules/react-query/lib/core/subscribable.mjs
var Subscribable = class {
  constructor() {
    this.listeners = [];
    this.subscribe = this.subscribe.bind(this);
  }
  subscribe(listener) {
    this.listeners.push(listener);
    this.onSubscribe();
    return () => {
      this.listeners = this.listeners.filter((x6) => x6 !== listener);
      this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.length > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
};

// node_modules/react-query/lib/core/utils.mjs
var isServer = typeof window === "undefined";
function noop() {
  return void 0;
}
function functionalUpdate(updater, input) {
  return typeof updater === "function" ? updater(input) : updater;
}
function isValidTimeout(value2) {
  return typeof value2 === "number" && value2 >= 0 && value2 !== Infinity;
}
function timeUntilStale(updatedAt, staleTime) {
  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);
}
function parseQueryArgs(arg1, arg2, arg3) {
  if (!isQueryKey(arg1)) {
    return arg1;
  }
  if (typeof arg2 === "function") {
    return {
      ...arg3,
      queryKey: arg1,
      queryFn: arg2
    };
  }
  return {
    ...arg2,
    queryKey: arg1
  };
}
function parseMutationArgs(arg1, arg2, arg3) {
  if (isQueryKey(arg1)) {
    if (typeof arg2 === "function") {
      return {
        ...arg3,
        mutationKey: arg1,
        mutationFn: arg2
      };
    }
    return {
      ...arg2,
      mutationKey: arg1
    };
  }
  if (typeof arg1 === "function") {
    return {
      ...arg2,
      mutationFn: arg1
    };
  }
  return {
    ...arg1
  };
}
function parseFilterArgs(arg1, arg2, arg3) {
  return isQueryKey(arg1) ? [{
    ...arg2,
    queryKey: arg1
  }, arg3] : [arg1 || {}, arg2];
}
function matchQuery(filters, query) {
  const {
    type = "all",
    exact,
    fetchStatus,
    predicate,
    queryKey,
    stale
  } = filters;
  if (isQueryKey(queryKey)) {
    if (exact) {
      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {
        return false;
      }
    } else if (!partialMatchKey(query.queryKey, queryKey)) {
      return false;
    }
  }
  if (type !== "all") {
    const isActive = query.isActive();
    if (type === "active" && !isActive) {
      return false;
    }
    if (type === "inactive" && isActive) {
      return false;
    }
  }
  if (typeof stale === "boolean" && query.isStale() !== stale) {
    return false;
  }
  if (typeof fetchStatus !== "undefined" && fetchStatus !== query.state.fetchStatus) {
    return false;
  }
  if (predicate && !predicate(query)) {
    return false;
  }
  return true;
}
function matchMutation(filters, mutation) {
  const {
    exact,
    fetching,
    predicate,
    mutationKey
  } = filters;
  if (isQueryKey(mutationKey)) {
    if (!mutation.options.mutationKey) {
      return false;
    }
    if (exact) {
      if (hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)) {
        return false;
      }
    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {
      return false;
    }
  }
  if (typeof fetching === "boolean" && mutation.state.status === "loading" !== fetching) {
    return false;
  }
  if (predicate && !predicate(mutation)) {
    return false;
  }
  return true;
}
function hashQueryKeyByOptions(queryKey, options) {
  const hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashQueryKey;
  return hashFn(queryKey);
}
function hashQueryKey(queryKey) {
  return JSON.stringify(queryKey, (_8, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key2) => {
    result[key2] = val[key2];
    return result;
  }, {}) : val);
}
function partialMatchKey(a5, b4) {
  return partialDeepEqual(a5, b4);
}
function partialDeepEqual(a5, b4) {
  if (a5 === b4) {
    return true;
  }
  if (typeof a5 !== typeof b4) {
    return false;
  }
  if (a5 && b4 && typeof a5 === "object" && typeof b4 === "object") {
    return !Object.keys(b4).some((key2) => !partialDeepEqual(a5[key2], b4[key2]));
  }
  return false;
}
function replaceEqualDeep(a5, b4) {
  if (a5 === b4) {
    return a5;
  }
  const array = Array.isArray(a5) && Array.isArray(b4);
  if (array || isPlainObject(a5) && isPlainObject(b4)) {
    const aSize = array ? a5.length : Object.keys(a5).length;
    const bItems = array ? b4 : Object.keys(b4);
    const bSize = bItems.length;
    const copy = array ? [] : {};
    let equalItems = 0;
    for (let i6 = 0; i6 < bSize; i6++) {
      const key2 = array ? i6 : bItems[i6];
      copy[key2] = replaceEqualDeep(a5[key2], b4[key2]);
      if (copy[key2] === a5[key2]) {
        equalItems++;
      }
    }
    return aSize === bSize && equalItems === aSize ? a5 : copy;
  }
  return b4;
}
function shallowEqualObjects(a5, b4) {
  if (a5 && !b4 || b4 && !a5) {
    return false;
  }
  for (const key2 in a5) {
    if (a5[key2] !== b4[key2]) {
      return false;
    }
  }
  return true;
}
function isPlainObject(o6) {
  if (!hasObjectPrototype(o6)) {
    return false;
  }
  const ctor = o6.constructor;
  if (typeof ctor === "undefined") {
    return true;
  }
  const prot = ctor.prototype;
  if (!hasObjectPrototype(prot)) {
    return false;
  }
  if (!prot.hasOwnProperty("isPrototypeOf")) {
    return false;
  }
  return true;
}
function hasObjectPrototype(o6) {
  return Object.prototype.toString.call(o6) === "[object Object]";
}
function isQueryKey(value2) {
  return Array.isArray(value2);
}
function sleep(timeout2) {
  return new Promise((resolve) => {
    setTimeout(resolve, timeout2);
  });
}
function scheduleMicrotask(callback) {
  sleep(0).then(callback);
}
function getAbortController() {
  if (typeof AbortController === "function") {
    return new AbortController();
  }
}

// node_modules/react-query/lib/core/focusManager.mjs
var FocusManager = class extends Subscribable {
  constructor() {
    super();
    this.setup = (onFocus) => {
      if (!isServer && window.addEventListener) {
        const listener = () => onFocus();
        window.addEventListener("visibilitychange", listener, false);
        window.addEventListener("focus", listener, false);
        return () => {
          window.removeEventListener("visibilitychange", listener);
          window.removeEventListener("focus", listener);
        };
      }
    };
  }
  onSubscribe() {
    if (!this.cleanup) {
      this.setEventListener(this.setup);
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      var _this$cleanup;
      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);
      this.cleanup = void 0;
    }
  }
  setEventListener(setup) {
    var _this$cleanup2;
    this.setup = setup;
    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);
    this.cleanup = setup((focused) => {
      if (typeof focused === "boolean") {
        this.setFocused(focused);
      } else {
        this.onFocus();
      }
    });
  }
  setFocused(focused) {
    this.focused = focused;
    if (focused) {
      this.onFocus();
    }
  }
  onFocus() {
    this.listeners.forEach((listener) => {
      listener();
    });
  }
  isFocused() {
    if (typeof this.focused === "boolean") {
      return this.focused;
    }
    if (typeof document === "undefined") {
      return true;
    }
    return [void 0, "visible", "prerender"].includes(document.visibilityState);
  }
};
var focusManager = new FocusManager();

// node_modules/react-query/lib/core/onlineManager.mjs
var OnlineManager = class extends Subscribable {
  constructor() {
    super();
    this.setup = (onOnline) => {
      if (!isServer && window.addEventListener) {
        const listener = () => onOnline();
        window.addEventListener("online", listener, false);
        window.addEventListener("offline", listener, false);
        return () => {
          window.removeEventListener("online", listener);
          window.removeEventListener("offline", listener);
        };
      }
    };
  }
  onSubscribe() {
    if (!this.cleanup) {
      this.setEventListener(this.setup);
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      var _this$cleanup;
      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);
      this.cleanup = void 0;
    }
  }
  setEventListener(setup) {
    var _this$cleanup2;
    this.setup = setup;
    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);
    this.cleanup = setup((online) => {
      if (typeof online === "boolean") {
        this.setOnline(online);
      } else {
        this.onOnline();
      }
    });
  }
  setOnline(online) {
    this.online = online;
    if (online) {
      this.onOnline();
    }
  }
  onOnline() {
    this.listeners.forEach((listener) => {
      listener();
    });
  }
  isOnline() {
    if (typeof this.online === "boolean") {
      return this.online;
    }
    if (typeof navigator === "undefined" || typeof navigator.onLine === "undefined") {
      return true;
    }
    return navigator.onLine;
  }
};
var onlineManager = new OnlineManager();

// node_modules/react-query/lib/core/retryer.mjs
function defaultRetryDelay(failureCount) {
  return Math.min(1e3 * 2 ** failureCount, 3e4);
}
function canFetch(networkMode) {
  return (networkMode != null ? networkMode : "online") === "online" ? onlineManager.isOnline() : true;
}
var CancelledError = class {
  constructor(options) {
    this.revert = options == null ? void 0 : options.revert;
    this.silent = options == null ? void 0 : options.silent;
  }
};
function isCancelledError(value2) {
  return value2 instanceof CancelledError;
}
function createRetryer(config2) {
  let isRetryCancelled = false;
  let failureCount = 0;
  let isResolved = false;
  let continueFn;
  let promiseResolve;
  let promiseReject;
  const promise = new Promise((outerResolve, outerReject) => {
    promiseResolve = outerResolve;
    promiseReject = outerReject;
  });
  const cancel = (cancelOptions) => {
    if (!isResolved) {
      reject(new CancelledError(cancelOptions));
      config2.abort == null ? void 0 : config2.abort();
    }
  };
  const cancelRetry = () => {
    isRetryCancelled = true;
  };
  const continueRetry = () => {
    isRetryCancelled = false;
  };
  const shouldPause = () => !focusManager.isFocused() || config2.networkMode !== "always" && !onlineManager.isOnline();
  const resolve = (value2) => {
    if (!isResolved) {
      isResolved = true;
      config2.onSuccess == null ? void 0 : config2.onSuccess(value2);
      continueFn == null ? void 0 : continueFn();
      promiseResolve(value2);
    }
  };
  const reject = (value2) => {
    if (!isResolved) {
      isResolved = true;
      config2.onError == null ? void 0 : config2.onError(value2);
      continueFn == null ? void 0 : continueFn();
      promiseReject(value2);
    }
  };
  const pause = () => {
    return new Promise((continueResolve) => {
      continueFn = (value2) => {
        if (isResolved || !shouldPause()) {
          return continueResolve(value2);
        }
      };
      config2.onPause == null ? void 0 : config2.onPause();
    }).then(() => {
      continueFn = void 0;
      if (!isResolved) {
        config2.onContinue == null ? void 0 : config2.onContinue();
      }
    });
  };
  const run = () => {
    if (isResolved) {
      return;
    }
    let promiseOrValue;
    try {
      promiseOrValue = config2.fn();
    } catch (error) {
      promiseOrValue = Promise.reject(error);
    }
    Promise.resolve(promiseOrValue).then(resolve).catch((error) => {
      var _config$retry, _config$retryDelay;
      if (isResolved) {
        return;
      }
      const retry2 = (_config$retry = config2.retry) != null ? _config$retry : 3;
      const retryDelay = (_config$retryDelay = config2.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;
      const delay2 = typeof retryDelay === "function" ? retryDelay(failureCount, error) : retryDelay;
      const shouldRetry = retry2 === true || typeof retry2 === "number" && failureCount < retry2 || typeof retry2 === "function" && retry2(failureCount, error);
      if (isRetryCancelled || !shouldRetry) {
        reject(error);
        return;
      }
      failureCount++;
      config2.onFail == null ? void 0 : config2.onFail(failureCount, error);
      sleep(delay2).then(() => {
        if (shouldPause()) {
          return pause();
        }
      }).then(() => {
        if (isRetryCancelled) {
          reject(error);
        } else {
          run();
        }
      });
    });
  };
  if (canFetch(config2.networkMode)) {
    run();
  } else {
    pause().then(run);
  }
  return {
    promise,
    cancel,
    continue: () => {
      continueFn == null ? void 0 : continueFn();
    },
    cancelRetry,
    continueRetry
  };
}

// node_modules/react-query/lib/core/logger.mjs
var defaultLogger = console;

// node_modules/react-query/lib/core/notifyManager.mjs
function createNotifyManager() {
  let queue2 = [];
  let transactions = 0;
  let notifyFn = (callback) => {
    callback();
  };
  let batchNotifyFn = (callback) => {
    callback();
  };
  const batch = (callback) => {
    let result;
    transactions++;
    try {
      result = callback();
    } finally {
      transactions--;
      if (!transactions) {
        flush();
      }
    }
    return result;
  };
  const schedule = (callback) => {
    if (transactions) {
      queue2.push(callback);
    } else {
      scheduleMicrotask(() => {
        notifyFn(callback);
      });
    }
  };
  const batchCalls = (callback) => {
    return (...args) => {
      schedule(() => {
        callback(...args);
      });
    };
  };
  const flush = () => {
    const originalQueue = queue2;
    queue2 = [];
    if (originalQueue.length) {
      scheduleMicrotask(() => {
        batchNotifyFn(() => {
          originalQueue.forEach((callback) => {
            notifyFn(callback);
          });
        });
      });
    }
  };
  const setNotifyFunction = (fn2) => {
    notifyFn = fn2;
  };
  const setBatchNotifyFunction = (fn2) => {
    batchNotifyFn = fn2;
  };
  return {
    batch,
    batchCalls,
    schedule,
    setNotifyFunction,
    setBatchNotifyFunction
  };
}
var notifyManager = createNotifyManager();

// node_modules/react-query/lib/core/removable.mjs
var Removable = class {
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout();
    if (isValidTimeout(this.cacheTime)) {
      this.gcTimeout = setTimeout(() => {
        this.optionalRemove();
      }, this.cacheTime);
    }
  }
  updateCacheTime(newCacheTime) {
    this.cacheTime = Math.max(this.cacheTime || 0, newCacheTime != null ? newCacheTime : isServer ? Infinity : 5 * 60 * 1e3);
  }
  clearGcTimeout() {
    clearTimeout(this.gcTimeout);
    this.gcTimeout = void 0;
  }
};

// node_modules/react-query/lib/core/query.mjs
var Query = class extends Removable {
  constructor(config2) {
    super();
    this.abortSignalConsumed = false;
    this.defaultOptions = config2.defaultOptions;
    this.setOptions(config2.options);
    this.observers = [];
    this.cache = config2.cache;
    this.logger = config2.logger || defaultLogger;
    this.queryKey = config2.queryKey;
    this.queryHash = config2.queryHash;
    this.initialState = config2.state || getDefaultState(this.options);
    this.state = this.initialState;
    this.meta = config2.meta;
  }
  setOptions(options) {
    this.options = {
      ...this.defaultOptions,
      ...options
    };
    this.meta = options == null ? void 0 : options.meta;
    this.updateCacheTime(this.options.cacheTime);
  }
  optionalRemove() {
    if (!this.observers.length && this.state.fetchStatus === "idle") {
      this.cache.remove(this);
    }
  }
  setData(data, options) {
    var _this$options$isDataE, _this$options;
    const prevData = this.state.data;
    if ((_this$options$isDataE = (_this$options = this.options).isDataEqual) != null && _this$options$isDataE.call(_this$options, prevData, data)) {
      data = prevData;
    } else if (this.options.structuralSharing !== false) {
      data = replaceEqualDeep(prevData, data);
    }
    this.dispatch({
      data,
      type: "success",
      dataUpdatedAt: options == null ? void 0 : options.updatedAt,
      manual: options == null ? void 0 : options.manual
    });
    return data;
  }
  setState(state, setStateOptions) {
    this.dispatch({
      type: "setState",
      state,
      setStateOptions
    });
  }
  cancel(options) {
    var _this$retryer;
    const promise = this.promise;
    (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.cancel(options);
    return promise ? promise.then(noop).catch(noop) : Promise.resolve();
  }
  destroy() {
    super.destroy();
    this.cancel({
      silent: true
    });
  }
  reset() {
    this.destroy();
    this.setState(this.initialState);
  }
  isActive() {
    return this.observers.some((observer) => observer.options.enabled !== false);
  }
  isDisabled() {
    return this.getObserversCount() > 0 && !this.isActive();
  }
  isStale() {
    return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some((observer) => observer.getCurrentResult().isStale);
  }
  isStaleByTime(staleTime = 0) {
    return this.state.isInvalidated || !this.state.dataUpdatedAt || !timeUntilStale(this.state.dataUpdatedAt, staleTime);
  }
  onFocus() {
    var _this$retryer2;
    const observer = this.observers.find((x6) => x6.shouldFetchOnWindowFocus());
    if (observer) {
      observer.refetch({
        cancelRefetch: false
      });
    }
    (_this$retryer2 = this.retryer) == null ? void 0 : _this$retryer2.continue();
  }
  onOnline() {
    var _this$retryer3;
    const observer = this.observers.find((x6) => x6.shouldFetchOnReconnect());
    if (observer) {
      observer.refetch({
        cancelRefetch: false
      });
    }
    (_this$retryer3 = this.retryer) == null ? void 0 : _this$retryer3.continue();
  }
  addObserver(observer) {
    if (this.observers.indexOf(observer) === -1) {
      this.observers.push(observer);
      this.clearGcTimeout();
      this.cache.notify({
        type: "observerAdded",
        query: this,
        observer
      });
    }
  }
  removeObserver(observer) {
    if (this.observers.indexOf(observer) !== -1) {
      this.observers = this.observers.filter((x6) => x6 !== observer);
      if (!this.observers.length) {
        if (this.retryer) {
          if (this.abortSignalConsumed) {
            this.retryer.cancel({
              revert: true
            });
          } else {
            this.retryer.cancelRetry();
          }
        }
        this.scheduleGc();
      }
      this.cache.notify({
        type: "observerRemoved",
        query: this,
        observer
      });
    }
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    if (!this.state.isInvalidated) {
      this.dispatch({
        type: "invalidate"
      });
    }
  }
  fetch(options, fetchOptions) {
    var _this$options$behavio, _context$fetchOptions;
    if (this.state.fetchStatus !== "idle") {
      if (this.state.dataUpdatedAt && fetchOptions != null && fetchOptions.cancelRefetch) {
        this.cancel({
          silent: true
        });
      } else if (this.promise) {
        var _this$retryer4;
        (_this$retryer4 = this.retryer) == null ? void 0 : _this$retryer4.continueRetry();
        return this.promise;
      }
    }
    if (options) {
      this.setOptions(options);
    }
    if (!this.options.queryFn) {
      const observer = this.observers.find((x6) => x6.options.queryFn);
      if (observer) {
        this.setOptions(observer.options);
      }
    }
    if (!Array.isArray(this.options.queryKey)) {
      if (true) {
        this.logger.error("As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']");
      }
    }
    const abortController = getAbortController();
    const queryFnContext = {
      queryKey: this.queryKey,
      pageParam: void 0,
      meta: this.meta
    };
    const addSignalProperty = (object) => {
      Object.defineProperty(object, "signal", {
        enumerable: true,
        get: () => {
          if (abortController) {
            this.abortSignalConsumed = true;
            return abortController.signal;
          }
          return void 0;
        }
      });
    };
    addSignalProperty(queryFnContext);
    const fetchFn = () => {
      if (!this.options.queryFn) {
        return Promise.reject("Missing queryFn");
      }
      this.abortSignalConsumed = false;
      return this.options.queryFn(queryFnContext);
    };
    const context = {
      fetchOptions,
      options: this.options,
      queryKey: this.queryKey,
      state: this.state,
      fetchFn,
      meta: this.meta
    };
    addSignalProperty(context);
    (_this$options$behavio = this.options.behavior) == null ? void 0 : _this$options$behavio.onFetch(context);
    this.revertState = this.state;
    if (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((_context$fetchOptions = context.fetchOptions) == null ? void 0 : _context$fetchOptions.meta)) {
      var _context$fetchOptions2;
      this.dispatch({
        type: "fetch",
        meta: (_context$fetchOptions2 = context.fetchOptions) == null ? void 0 : _context$fetchOptions2.meta
      });
    }
    const onError = (error) => {
      if (!(isCancelledError(error) && error.silent)) {
        this.dispatch({
          type: "error",
          error
        });
      }
      if (!isCancelledError(error)) {
        var _this$cache$config$on, _this$cache$config;
        (_this$cache$config$on = (_this$cache$config = this.cache.config).onError) == null ? void 0 : _this$cache$config$on.call(_this$cache$config, error, this);
        if (true) {
          this.logger.error(error);
        }
      }
      if (!this.isFetchingOptimistic) {
        this.scheduleGc();
      }
      this.isFetchingOptimistic = false;
    };
    this.retryer = createRetryer({
      fn: context.fetchFn,
      abort: abortController == null ? void 0 : abortController.abort.bind(abortController),
      onSuccess: (data) => {
        var _this$cache$config$on2, _this$cache$config2;
        if (typeof data === "undefined") {
          onError(new Error("Query data cannot be undefined"));
          return;
        }
        this.setData(data);
        (_this$cache$config$on2 = (_this$cache$config2 = this.cache.config).onSuccess) == null ? void 0 : _this$cache$config$on2.call(_this$cache$config2, data, this);
        if (!this.isFetchingOptimistic) {
          this.scheduleGc();
        }
        this.isFetchingOptimistic = false;
      },
      onError,
      onFail: () => {
        this.dispatch({
          type: "failed"
        });
      },
      onPause: () => {
        this.dispatch({
          type: "pause"
        });
      },
      onContinue: () => {
        this.dispatch({
          type: "continue"
        });
      },
      retry: context.options.retry,
      retryDelay: context.options.retryDelay,
      networkMode: context.options.networkMode
    });
    this.promise = this.retryer.promise;
    return this.promise;
  }
  dispatch(action) {
    const reducer = (state) => {
      var _action$meta, _action$dataUpdatedAt;
      switch (action.type) {
        case "failed":
          return {
            ...state,
            fetchFailureCount: state.fetchFailureCount + 1
          };
        case "pause":
          return {
            ...state,
            fetchStatus: "paused"
          };
        case "continue":
          return {
            ...state,
            fetchStatus: "fetching"
          };
        case "fetch":
          return {
            ...state,
            fetchFailureCount: 0,
            fetchMeta: (_action$meta = action.meta) != null ? _action$meta : null,
            fetchStatus: canFetch(this.options.networkMode) ? "fetching" : "paused",
            ...!state.dataUpdatedAt && {
              error: null,
              status: "loading"
            }
          };
        case "success":
          return {
            ...state,
            data: action.data,
            dataUpdateCount: state.dataUpdateCount + 1,
            dataUpdatedAt: (_action$dataUpdatedAt = action.dataUpdatedAt) != null ? _action$dataUpdatedAt : Date.now(),
            error: null,
            isInvalidated: false,
            status: "success",
            ...!action.manual && {
              fetchStatus: "idle",
              fetchFailureCount: 0
            }
          };
        case "error":
          const error = action.error;
          if (isCancelledError(error) && error.revert && this.revertState) {
            return {
              ...this.revertState
            };
          }
          return {
            ...state,
            error,
            errorUpdateCount: state.errorUpdateCount + 1,
            errorUpdatedAt: Date.now(),
            fetchFailureCount: state.fetchFailureCount + 1,
            fetchStatus: "idle",
            status: "error"
          };
        case "invalidate":
          return {
            ...state,
            isInvalidated: true
          };
        case "setState":
          return {
            ...state,
            ...action.state
          };
      }
    };
    this.state = reducer(this.state);
    notifyManager.batch(() => {
      this.observers.forEach((observer) => {
        observer.onQueryUpdate(action);
      });
      this.cache.notify({
        query: this,
        type: "updated",
        action
      });
    });
  }
};
function getDefaultState(options) {
  const data = typeof options.initialData === "function" ? options.initialData() : options.initialData;
  const hasInitialData = typeof options.initialData !== "undefined";
  const initialDataUpdatedAt = hasInitialData ? typeof options.initialDataUpdatedAt === "function" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;
  const hasData = typeof data !== "undefined";
  return {
    data,
    dataUpdateCount: 0,
    dataUpdatedAt: hasData ? initialDataUpdatedAt != null ? initialDataUpdatedAt : Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchMeta: null,
    isInvalidated: false,
    status: hasData ? "success" : "loading",
    fetchStatus: "idle"
  };
}

// node_modules/react-query/lib/core/queryCache.mjs
var QueryCache = class extends Subscribable {
  constructor(config2) {
    super();
    this.config = config2 || {};
    this.queries = [];
    this.queriesMap = {};
  }
  build(client, options, state) {
    var _options$queryHash;
    const queryKey = options.queryKey;
    const queryHash = (_options$queryHash = options.queryHash) != null ? _options$queryHash : hashQueryKeyByOptions(queryKey, options);
    let query = this.get(queryHash);
    if (!query) {
      query = new Query({
        cache: this,
        logger: client.getLogger(),
        queryKey,
        queryHash,
        options: client.defaultQueryOptions(options),
        state,
        defaultOptions: client.getQueryDefaults(queryKey),
        meta: options.meta
      });
      this.add(query);
    }
    return query;
  }
  add(query) {
    if (!this.queriesMap[query.queryHash]) {
      this.queriesMap[query.queryHash] = query;
      this.queries.push(query);
      this.notify({
        type: "added",
        query
      });
    }
  }
  remove(query) {
    const queryInMap = this.queriesMap[query.queryHash];
    if (queryInMap) {
      query.destroy();
      this.queries = this.queries.filter((x6) => x6 !== query);
      if (queryInMap === query) {
        delete this.queriesMap[query.queryHash];
      }
      this.notify({
        type: "removed",
        query
      });
    }
  }
  clear() {
    notifyManager.batch(() => {
      this.queries.forEach((query) => {
        this.remove(query);
      });
    });
  }
  get(queryHash) {
    return this.queriesMap[queryHash];
  }
  getAll() {
    return this.queries;
  }
  find(arg1, arg2) {
    const [filters] = parseFilterArgs(arg1, arg2);
    if (typeof filters.exact === "undefined") {
      filters.exact = true;
    }
    return this.queries.find((query) => matchQuery(filters, query));
  }
  findAll(arg1, arg2) {
    const [filters] = parseFilterArgs(arg1, arg2);
    return Object.keys(filters).length > 0 ? this.queries.filter((query) => matchQuery(filters, query)) : this.queries;
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach((listener) => {
        listener(event);
      });
    });
  }
  onFocus() {
    notifyManager.batch(() => {
      this.queries.forEach((query) => {
        query.onFocus();
      });
    });
  }
  onOnline() {
    notifyManager.batch(() => {
      this.queries.forEach((query) => {
        query.onOnline();
      });
    });
  }
};

// node_modules/react-query/lib/core/mutation.mjs
var Mutation = class extends Removable {
  constructor(config2) {
    super();
    this.options = {
      ...config2.defaultOptions,
      ...config2.options
    };
    this.mutationId = config2.mutationId;
    this.mutationCache = config2.mutationCache;
    this.logger = config2.logger || defaultLogger;
    this.observers = [];
    this.state = config2.state || getDefaultState2();
    this.meta = config2.meta;
    this.updateCacheTime(this.options.cacheTime);
    this.scheduleGc();
  }
  setState(state) {
    this.dispatch({
      type: "setState",
      state
    });
  }
  addObserver(observer) {
    if (this.observers.indexOf(observer) === -1) {
      this.observers.push(observer);
      this.clearGcTimeout();
      this.mutationCache.notify({
        type: "observerAdded",
        mutation: this,
        observer
      });
    }
  }
  removeObserver(observer) {
    this.observers = this.observers.filter((x6) => x6 !== observer);
    this.scheduleGc();
    this.mutationCache.notify({
      type: "observerRemoved",
      mutation: this,
      observer
    });
  }
  optionalRemove() {
    if (!this.observers.length) {
      if (this.state.status === "loading") {
        this.scheduleGc();
      } else {
        this.mutationCache.remove(this);
      }
    }
  }
  continue() {
    if (this.retryer) {
      this.retryer.continue();
      return this.retryer.promise;
    }
    return this.execute();
  }
  async execute() {
    const executeMutation = () => {
      var _this$options$retry;
      this.retryer = createRetryer({
        fn: () => {
          if (!this.options.mutationFn) {
            return Promise.reject("No mutationFn found");
          }
          return this.options.mutationFn(this.state.variables);
        },
        onFail: () => {
          this.dispatch({
            type: "failed"
          });
        },
        onPause: () => {
          this.dispatch({
            type: "pause"
          });
        },
        onContinue: () => {
          this.dispatch({
            type: "continue"
          });
        },
        retry: (_this$options$retry = this.options.retry) != null ? _this$options$retry : 0,
        retryDelay: this.options.retryDelay,
        networkMode: this.options.networkMode
      });
      return this.retryer.promise;
    };
    const restored = this.state.status === "loading";
    try {
      var _this$mutationCache$c3, _this$mutationCache$c4, _this$options$onSucce, _this$options2, _this$options$onSettl, _this$options3;
      if (!restored) {
        var _this$mutationCache$c, _this$mutationCache$c2, _this$options$onMutat, _this$options;
        this.dispatch({
          type: "loading",
          variables: this.options.variables
        });
        (_this$mutationCache$c = (_this$mutationCache$c2 = this.mutationCache.config).onMutate) == null ? void 0 : _this$mutationCache$c.call(_this$mutationCache$c2, this.state.variables, this);
        const context = await ((_this$options$onMutat = (_this$options = this.options).onMutate) == null ? void 0 : _this$options$onMutat.call(_this$options, this.state.variables));
        if (context !== this.state.context) {
          this.dispatch({
            type: "loading",
            context,
            variables: this.state.variables
          });
        }
      }
      const data = await executeMutation();
      (_this$mutationCache$c3 = (_this$mutationCache$c4 = this.mutationCache.config).onSuccess) == null ? void 0 : _this$mutationCache$c3.call(_this$mutationCache$c4, data, this.state.variables, this.state.context, this);
      await ((_this$options$onSucce = (_this$options2 = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options2, data, this.state.variables, this.state.context));
      await ((_this$options$onSettl = (_this$options3 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options3, data, null, this.state.variables, this.state.context));
      this.dispatch({
        type: "success",
        data
      });
      return data;
    } catch (error) {
      try {
        var _this$mutationCache$c5, _this$mutationCache$c6, _this$options$onError, _this$options4, _this$options$onSettl2, _this$options5;
        (_this$mutationCache$c5 = (_this$mutationCache$c6 = this.mutationCache.config).onError) == null ? void 0 : _this$mutationCache$c5.call(_this$mutationCache$c6, error, this.state.variables, this.state.context, this);
        if (true) {
          this.logger.error(error);
        }
        await ((_this$options$onError = (_this$options4 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options4, error, this.state.variables, this.state.context));
        await ((_this$options$onSettl2 = (_this$options5 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options5, void 0, error, this.state.variables, this.state.context));
        throw error;
      } finally {
        this.dispatch({
          type: "error",
          error
        });
      }
    }
  }
  dispatch(action) {
    const reducer = (state) => {
      switch (action.type) {
        case "failed":
          return {
            ...state,
            failureCount: state.failureCount + 1
          };
        case "pause":
          return {
            ...state,
            isPaused: true
          };
        case "continue":
          return {
            ...state,
            isPaused: false
          };
        case "loading":
          return {
            ...state,
            context: action.context,
            data: void 0,
            error: null,
            isPaused: !canFetch(this.options.networkMode),
            status: "loading",
            variables: action.variables
          };
        case "success":
          return {
            ...state,
            data: action.data,
            error: null,
            status: "success",
            isPaused: false
          };
        case "error":
          return {
            ...state,
            data: void 0,
            error: action.error,
            failureCount: state.failureCount + 1,
            isPaused: false,
            status: "error"
          };
        case "setState":
          return {
            ...state,
            ...action.state
          };
      }
    };
    this.state = reducer(this.state);
    notifyManager.batch(() => {
      this.observers.forEach((observer) => {
        observer.onMutationUpdate(action);
      });
      this.mutationCache.notify({
        mutation: this,
        type: "updated",
        action
      });
    });
  }
};
function getDefaultState2() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    isPaused: false,
    status: "idle",
    variables: void 0
  };
}

// node_modules/react-query/lib/core/mutationCache.mjs
var MutationCache = class extends Subscribable {
  constructor(config2) {
    super();
    this.config = config2 || {};
    this.mutations = [];
    this.mutationId = 0;
  }
  build(client, options, state) {
    const mutation = new Mutation({
      mutationCache: this,
      logger: client.getLogger(),
      mutationId: ++this.mutationId,
      options: client.defaultMutationOptions(options),
      state,
      defaultOptions: options.mutationKey ? client.getMutationDefaults(options.mutationKey) : void 0,
      meta: options.meta
    });
    this.add(mutation);
    return mutation;
  }
  add(mutation) {
    this.mutations.push(mutation);
    this.notify({
      type: "added",
      mutation
    });
  }
  remove(mutation) {
    this.mutations = this.mutations.filter((x6) => x6 !== mutation);
    this.notify({
      type: "removed",
      mutation
    });
  }
  clear() {
    notifyManager.batch(() => {
      this.mutations.forEach((mutation) => {
        this.remove(mutation);
      });
    });
  }
  getAll() {
    return this.mutations;
  }
  find(filters) {
    if (typeof filters.exact === "undefined") {
      filters.exact = true;
    }
    return this.mutations.find((mutation) => matchMutation(filters, mutation));
  }
  findAll(filters) {
    return this.mutations.filter((mutation) => matchMutation(filters, mutation));
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach((listener) => {
        listener(event);
      });
    });
  }
  resumePausedMutations() {
    const pausedMutations = this.mutations.filter((x6) => x6.state.isPaused);
    return notifyManager.batch(() => pausedMutations.reduce((promise, mutation) => promise.then(() => mutation.continue().catch(noop)), Promise.resolve()));
  }
};

// node_modules/react-query/lib/core/infiniteQueryBehavior.mjs
function infiniteQueryBehavior() {
  return {
    onFetch: (context) => {
      context.fetchFn = () => {
        var _context$fetchOptions, _context$fetchOptions2, _context$fetchOptions3, _context$fetchOptions4, _context$state$data, _context$state$data2, _context$signal;
        const refetchPage = (_context$fetchOptions = context.fetchOptions) == null ? void 0 : (_context$fetchOptions2 = _context$fetchOptions.meta) == null ? void 0 : _context$fetchOptions2.refetchPage;
        const fetchMore = (_context$fetchOptions3 = context.fetchOptions) == null ? void 0 : (_context$fetchOptions4 = _context$fetchOptions3.meta) == null ? void 0 : _context$fetchOptions4.fetchMore;
        const pageParam = fetchMore == null ? void 0 : fetchMore.pageParam;
        const isFetchingNextPage = (fetchMore == null ? void 0 : fetchMore.direction) === "forward";
        const isFetchingPreviousPage = (fetchMore == null ? void 0 : fetchMore.direction) === "backward";
        const oldPages = ((_context$state$data = context.state.data) == null ? void 0 : _context$state$data.pages) || [];
        const oldPageParams = ((_context$state$data2 = context.state.data) == null ? void 0 : _context$state$data2.pageParams) || [];
        const abortController = getAbortController();
        const abortSignal = abortController == null ? void 0 : abortController.signal;
        let newPageParams = oldPageParams;
        let cancelled = false;
        const queryFn = context.options.queryFn || (() => Promise.reject("Missing queryFn"));
        const buildNewPages = (pages, param, page, previous) => {
          newPageParams = previous ? [param, ...newPageParams] : [...newPageParams, param];
          return previous ? [page, ...pages] : [...pages, page];
        };
        const fetchPage = (pages, manual, param, previous) => {
          if (cancelled) {
            return Promise.reject("Cancelled");
          }
          if (typeof param === "undefined" && !manual && pages.length) {
            return Promise.resolve(pages);
          }
          const queryFnContext = {
            queryKey: context.queryKey,
            signal: abortSignal,
            pageParam: param,
            meta: context.meta
          };
          const queryFnResult = queryFn(queryFnContext);
          const promise2 = Promise.resolve(queryFnResult).then((page) => buildNewPages(pages, param, page, previous));
          return promise2;
        };
        let promise;
        if (!oldPages.length) {
          promise = fetchPage([]);
        } else if (isFetchingNextPage) {
          const manual = typeof pageParam !== "undefined";
          const param = manual ? pageParam : getNextPageParam(context.options, oldPages);
          promise = fetchPage(oldPages, manual, param);
        } else if (isFetchingPreviousPage) {
          const manual = typeof pageParam !== "undefined";
          const param = manual ? pageParam : getPreviousPageParam(context.options, oldPages);
          promise = fetchPage(oldPages, manual, param, true);
        } else {
          newPageParams = [];
          const manual = typeof context.options.getNextPageParam === "undefined";
          const shouldFetchFirstPage = refetchPage && oldPages[0] ? refetchPage(oldPages[0], 0, oldPages) : true;
          promise = shouldFetchFirstPage ? fetchPage([], manual, oldPageParams[0]) : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0]));
          for (let i6 = 1; i6 < oldPages.length; i6++) {
            promise = promise.then((pages) => {
              const shouldFetchNextPage = refetchPage && oldPages[i6] ? refetchPage(oldPages[i6], i6, oldPages) : true;
              if (shouldFetchNextPage) {
                const param = manual ? oldPageParams[i6] : getNextPageParam(context.options, pages);
                return fetchPage(pages, manual, param);
              }
              return Promise.resolve(buildNewPages(pages, oldPageParams[i6], oldPages[i6]));
            });
          }
        }
        const finalPromise = promise.then((pages) => ({
          pages,
          pageParams: newPageParams
        }));
        (_context$signal = context.signal) == null ? void 0 : _context$signal.addEventListener("abort", () => {
          cancelled = true;
          abortController == null ? void 0 : abortController.abort();
        });
        return finalPromise;
      };
    }
  };
}
function getNextPageParam(options, pages) {
  return options.getNextPageParam == null ? void 0 : options.getNextPageParam(pages[pages.length - 1], pages);
}
function getPreviousPageParam(options, pages) {
  return options.getPreviousPageParam == null ? void 0 : options.getPreviousPageParam(pages[0], pages);
}

// node_modules/react-query/lib/core/queryClient.mjs
var QueryClient = class {
  constructor(config2 = {}) {
    this.queryCache = config2.queryCache || new QueryCache();
    this.mutationCache = config2.mutationCache || new MutationCache();
    this.logger = config2.logger || defaultLogger;
    this.defaultOptions = config2.defaultOptions || {};
    this.queryDefaults = [];
    this.mutationDefaults = [];
  }
  mount() {
    this.unsubscribeFocus = focusManager.subscribe(() => {
      if (focusManager.isFocused()) {
        this.resumePausedMutations();
        this.queryCache.onFocus();
      }
    });
    this.unsubscribeOnline = onlineManager.subscribe(() => {
      if (onlineManager.isOnline()) {
        this.resumePausedMutations();
        this.queryCache.onOnline();
      }
    });
  }
  unmount() {
    var _this$unsubscribeFocu, _this$unsubscribeOnli;
    (_this$unsubscribeFocu = this.unsubscribeFocus) == null ? void 0 : _this$unsubscribeFocu.call(this);
    (_this$unsubscribeOnli = this.unsubscribeOnline) == null ? void 0 : _this$unsubscribeOnli.call(this);
  }
  isFetching(arg1, arg2) {
    const [filters] = parseFilterArgs(arg1, arg2);
    filters.fetchStatus = "fetching";
    return this.queryCache.findAll(filters).length;
  }
  isMutating(filters) {
    return this.mutationCache.findAll({
      ...filters,
      fetching: true
    }).length;
  }
  getQueryData(queryKey, filters) {
    var _this$queryCache$find;
    return (_this$queryCache$find = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find.state.data;
  }
  getQueriesData(queryKeyOrFilters) {
    return this.getQueryCache().findAll(queryKeyOrFilters).map(({
      queryKey,
      state
    }) => {
      const data = state.data;
      return [queryKey, data];
    });
  }
  setQueryData(queryKey, updater, options) {
    const query = this.queryCache.find(queryKey);
    const prevData = query == null ? void 0 : query.state.data;
    const data = functionalUpdate(updater, prevData);
    if (typeof data === "undefined") {
      return void 0;
    }
    const parsedOptions = parseQueryArgs(queryKey);
    const defaultedOptions = this.defaultQueryOptions(parsedOptions);
    return this.queryCache.build(this, defaultedOptions).setData(data, {
      ...options,
      manual: true
    });
  }
  setQueriesData(queryKeyOrFilters, updater, options) {
    return notifyManager.batch(() => this.getQueryCache().findAll(queryKeyOrFilters).map(({
      queryKey
    }) => [queryKey, this.setQueryData(queryKey, updater, options)]));
  }
  getQueryState(queryKey, filters) {
    var _this$queryCache$find2;
    return (_this$queryCache$find2 = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find2.state;
  }
  removeQueries(arg1, arg2) {
    const [filters] = parseFilterArgs(arg1, arg2);
    const queryCache = this.queryCache;
    notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        queryCache.remove(query);
      });
    });
  }
  resetQueries(arg1, arg2, arg3) {
    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);
    const queryCache = this.queryCache;
    const refetchFilters = {
      type: "active",
      ...filters
    };
    return notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        query.reset();
      });
      return this.refetchQueries(refetchFilters, options);
    });
  }
  cancelQueries(arg1, arg2, arg3) {
    const [filters, cancelOptions = {}] = parseFilterArgs(arg1, arg2, arg3);
    if (typeof cancelOptions.revert === "undefined") {
      cancelOptions.revert = true;
    }
    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).map((query) => query.cancel(cancelOptions)));
    return Promise.all(promises).then(noop).catch(noop);
  }
  invalidateQueries(arg1, arg2, arg3) {
    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);
    return notifyManager.batch(() => {
      var _ref, _filters$refetchType;
      this.queryCache.findAll(filters).forEach((query) => {
        query.invalidate();
      });
      if (filters.refetchType === "none") {
        return Promise.resolve();
      }
      const refetchFilters = {
        ...filters,
        type: (_ref = (_filters$refetchType = filters.refetchType) != null ? _filters$refetchType : filters.type) != null ? _ref : "active"
      };
      return this.refetchQueries(refetchFilters, options);
    });
  }
  refetchQueries(arg1, arg2, arg3) {
    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);
    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).filter((query) => !query.isDisabled()).map((query) => {
      var _options$cancelRefetc;
      return query.fetch(void 0, {
        ...options,
        cancelRefetch: (_options$cancelRefetc = options == null ? void 0 : options.cancelRefetch) != null ? _options$cancelRefetc : true,
        meta: {
          refetchPage: filters.refetchPage
        }
      });
    }));
    let promise = Promise.all(promises).then(noop);
    if (!(options != null && options.throwOnError)) {
      promise = promise.catch(noop);
    }
    return promise;
  }
  fetchQuery(arg1, arg2, arg3) {
    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);
    const defaultedOptions = this.defaultQueryOptions(parsedOptions);
    if (typeof defaultedOptions.retry === "undefined") {
      defaultedOptions.retry = false;
    }
    const query = this.queryCache.build(this, defaultedOptions);
    return query.isStaleByTime(defaultedOptions.staleTime) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);
  }
  prefetchQuery(arg1, arg2, arg3) {
    return this.fetchQuery(arg1, arg2, arg3).then(noop).catch(noop);
  }
  fetchInfiniteQuery(arg1, arg2, arg3) {
    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);
    parsedOptions.behavior = infiniteQueryBehavior();
    return this.fetchQuery(parsedOptions);
  }
  prefetchInfiniteQuery(arg1, arg2, arg3) {
    return this.fetchInfiniteQuery(arg1, arg2, arg3).then(noop).catch(noop);
  }
  resumePausedMutations() {
    return this.mutationCache.resumePausedMutations();
  }
  getQueryCache() {
    return this.queryCache;
  }
  getMutationCache() {
    return this.mutationCache;
  }
  getLogger() {
    return this.logger;
  }
  getDefaultOptions() {
    return this.defaultOptions;
  }
  setDefaultOptions(options) {
    this.defaultOptions = options;
  }
  setQueryDefaults(queryKey, options) {
    const result = this.queryDefaults.find((x6) => hashQueryKey(queryKey) === hashQueryKey(x6.queryKey));
    if (result) {
      result.defaultOptions = options;
    } else {
      this.queryDefaults.push({
        queryKey,
        defaultOptions: options
      });
    }
  }
  getQueryDefaults(queryKey) {
    if (!queryKey) {
      return void 0;
    }
    const firstMatchingDefaults = this.queryDefaults.find((x6) => partialMatchKey(queryKey, x6.queryKey));
    if (true) {
      const matchingDefaults = this.queryDefaults.filter((x6) => partialMatchKey(queryKey, x6.queryKey));
      if (matchingDefaults.length > 1) {
        if (true) {
          this.logger.error("[QueryClient] Several query defaults match with key '" + JSON.stringify(queryKey) + "'. The first matching query defaults are used. Please check how query defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetquerydefaults.");
        }
      }
    }
    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;
  }
  setMutationDefaults(mutationKey, options) {
    const result = this.mutationDefaults.find((x6) => hashQueryKey(mutationKey) === hashQueryKey(x6.mutationKey));
    if (result) {
      result.defaultOptions = options;
    } else {
      this.mutationDefaults.push({
        mutationKey,
        defaultOptions: options
      });
    }
  }
  getMutationDefaults(mutationKey) {
    if (!mutationKey) {
      return void 0;
    }
    const firstMatchingDefaults = this.mutationDefaults.find((x6) => partialMatchKey(mutationKey, x6.mutationKey));
    if (true) {
      const matchingDefaults = this.mutationDefaults.filter((x6) => partialMatchKey(mutationKey, x6.mutationKey));
      if (matchingDefaults.length > 1) {
        if (true) {
          this.logger.error("[QueryClient] Several mutation defaults match with key '" + JSON.stringify(mutationKey) + "'. The first matching mutation defaults are used. Please check how mutation defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetmutationdefaults.");
        }
      }
    }
    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;
  }
  defaultQueryOptions(options) {
    if (options != null && options._defaulted) {
      return options;
    }
    const defaultedOptions = {
      ...this.defaultOptions.queries,
      ...this.getQueryDefaults(options == null ? void 0 : options.queryKey),
      ...options,
      _defaulted: true
    };
    if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {
      defaultedOptions.queryHash = hashQueryKeyByOptions(defaultedOptions.queryKey, defaultedOptions);
    }
    if (typeof defaultedOptions.refetchOnReconnect === "undefined") {
      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== "always";
    }
    if (typeof defaultedOptions.useErrorBoundary === "undefined") {
      defaultedOptions.useErrorBoundary = !!defaultedOptions.suspense;
    }
    return defaultedOptions;
  }
  defaultMutationOptions(options) {
    if (options != null && options._defaulted) {
      return options;
    }
    return {
      ...this.defaultOptions.mutations,
      ...this.getMutationDefaults(options == null ? void 0 : options.mutationKey),
      ...options,
      _defaulted: true
    };
  }
  clear() {
    this.queryCache.clear();
    this.mutationCache.clear();
  }
};

// node_modules/react-query/lib/core/queryObserver.mjs
var QueryObserver = class extends Subscribable {
  constructor(client, options) {
    super();
    this.client = client;
    this.options = options;
    this.trackedProps = /* @__PURE__ */ new Set();
    this.previousSelectError = null;
    this.bindMethods();
    this.setOptions(options);
  }
  bindMethods() {
    this.remove = this.remove.bind(this);
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    if (this.listeners.length === 1) {
      this.currentQuery.addObserver(this);
      if (shouldFetchOnMount(this.currentQuery, this.options)) {
        this.executeFetch();
      }
      this.updateTimers();
    }
  }
  onUnsubscribe() {
    if (!this.listeners.length) {
      this.destroy();
    }
  }
  shouldFetchOnReconnect() {
    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnReconnect);
  }
  shouldFetchOnWindowFocus() {
    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnWindowFocus);
  }
  destroy() {
    this.listeners = [];
    this.clearStaleTimeout();
    this.clearRefetchInterval();
    this.currentQuery.removeObserver(this);
  }
  setOptions(options, notifyOptions) {
    const prevOptions = this.options;
    const prevQuery = this.currentQuery;
    this.options = this.client.defaultQueryOptions(options);
    if (typeof this.options.enabled !== "undefined" && typeof this.options.enabled !== "boolean") {
      throw new Error("Expected enabled to be a boolean");
    }
    if (!this.options.queryKey) {
      this.options.queryKey = prevOptions.queryKey;
    }
    this.updateQuery();
    const mounted = this.hasListeners();
    if (mounted && shouldFetchOptionally(this.currentQuery, prevQuery, this.options, prevOptions)) {
      this.executeFetch();
    }
    this.updateResult(notifyOptions);
    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime)) {
      this.updateStaleTimeout();
    }
    const nextRefetchInterval = this.computeRefetchInterval();
    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || nextRefetchInterval !== this.currentRefetchInterval)) {
      this.updateRefetchInterval(nextRefetchInterval);
    }
  }
  getOptimisticResult(options) {
    const query = this.client.getQueryCache().build(this.client, options);
    return this.createResult(query, options);
  }
  getCurrentResult() {
    return this.currentResult;
  }
  trackResult(result) {
    const trackedResult = {};
    Object.keys(result).forEach((key2) => {
      Object.defineProperty(trackedResult, key2, {
        configurable: false,
        enumerable: true,
        get: () => {
          this.trackedProps.add(key2);
          return result[key2];
        }
      });
    });
    return trackedResult;
  }
  getCurrentQuery() {
    return this.currentQuery;
  }
  remove() {
    this.client.getQueryCache().remove(this.currentQuery);
  }
  refetch({
    refetchPage,
    ...options
  } = {}) {
    return this.fetch({
      ...options,
      meta: {
        refetchPage
      }
    });
  }
  fetchOptimistic(options) {
    const defaultedOptions = this.client.defaultQueryOptions(options);
    const query = this.client.getQueryCache().build(this.client, defaultedOptions);
    query.isFetchingOptimistic = true;
    return query.fetch().then(() => this.createResult(query, defaultedOptions));
  }
  fetch(fetchOptions) {
    var _fetchOptions$cancelR;
    return this.executeFetch({
      ...fetchOptions,
      cancelRefetch: (_fetchOptions$cancelR = fetchOptions.cancelRefetch) != null ? _fetchOptions$cancelR : true
    }).then(() => {
      this.updateResult();
      return this.currentResult;
    });
  }
  executeFetch(fetchOptions) {
    this.updateQuery();
    let promise = this.currentQuery.fetch(this.options, fetchOptions);
    if (!(fetchOptions != null && fetchOptions.throwOnError)) {
      promise = promise.catch(noop);
    }
    return promise;
  }
  updateStaleTimeout() {
    this.clearStaleTimeout();
    if (isServer || this.currentResult.isStale || !isValidTimeout(this.options.staleTime)) {
      return;
    }
    const time = timeUntilStale(this.currentResult.dataUpdatedAt, this.options.staleTime);
    const timeout2 = time + 1;
    this.staleTimeoutId = setTimeout(() => {
      if (!this.currentResult.isStale) {
        this.updateResult();
      }
    }, timeout2);
  }
  computeRefetchInterval() {
    var _this$options$refetch;
    return typeof this.options.refetchInterval === "function" ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : (_this$options$refetch = this.options.refetchInterval) != null ? _this$options$refetch : false;
  }
  updateRefetchInterval(nextInterval) {
    this.clearRefetchInterval();
    this.currentRefetchInterval = nextInterval;
    if (isServer || this.options.enabled === false || !isValidTimeout(this.currentRefetchInterval) || this.currentRefetchInterval === 0) {
      return;
    }
    this.refetchIntervalId = setInterval(() => {
      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {
        this.executeFetch();
      }
    }, this.currentRefetchInterval);
  }
  updateTimers() {
    this.updateStaleTimeout();
    this.updateRefetchInterval(this.computeRefetchInterval());
  }
  clearStaleTimeout() {
    clearTimeout(this.staleTimeoutId);
    this.staleTimeoutId = void 0;
  }
  clearRefetchInterval() {
    clearInterval(this.refetchIntervalId);
    this.refetchIntervalId = void 0;
  }
  createResult(query, options) {
    const prevQuery = this.currentQuery;
    const prevOptions = this.options;
    const prevResult = this.currentResult;
    const prevResultState = this.currentResultState;
    const prevResultOptions = this.currentResultOptions;
    const queryChange = query !== prevQuery;
    const queryInitialState = queryChange ? query.state : this.currentQueryInitialState;
    const prevQueryResult = queryChange ? this.currentResult : this.previousQueryResult;
    const {
      state
    } = query;
    let {
      dataUpdatedAt,
      error,
      errorUpdatedAt,
      fetchStatus,
      status
    } = state;
    let isPreviousData = false;
    let isPlaceholderData = false;
    let data;
    if (options._optimisticResults) {
      const mounted = this.hasListeners();
      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);
      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);
      if (fetchOnMount || fetchOptionally) {
        fetchStatus = canFetch(query.options.networkMode) ? "fetching" : "paused";
        if (!dataUpdatedAt) {
          status = "loading";
        }
      }
      if (options._optimisticResults === "isRestoring") {
        fetchStatus = "idle";
      }
    }
    if (options.keepPreviousData && !state.dataUpdateCount && prevQueryResult != null && prevQueryResult.isSuccess && status !== "error") {
      data = prevQueryResult.data;
      dataUpdatedAt = prevQueryResult.dataUpdatedAt;
      status = prevQueryResult.status;
      isPreviousData = true;
    } else if (options.select && typeof state.data !== "undefined") {
      var _this$previousSelect;
      if (prevResult && state.data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === ((_this$previousSelect = this.previousSelect) == null ? void 0 : _this$previousSelect.fn) && !this.previousSelectError) {
        data = this.previousSelect.result;
      } else {
        try {
          data = options.select(state.data);
          if (options.structuralSharing !== false) {
            data = replaceEqualDeep(prevResult == null ? void 0 : prevResult.data, data);
          }
          this.previousSelect = {
            fn: options.select,
            result: data
          };
          this.previousSelectError = null;
        } catch (selectError) {
          if (true) {
            this.client.getLogger().error(selectError);
          }
          error = selectError;
          this.previousSelectError = selectError;
          errorUpdatedAt = Date.now();
          status = "error";
        }
      }
    } else {
      data = state.data;
    }
    if (typeof options.placeholderData !== "undefined" && typeof data === "undefined" && status === "loading") {
      let placeholderData;
      if (prevResult != null && prevResult.isPlaceholderData && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {
        placeholderData = prevResult.data;
      } else {
        placeholderData = typeof options.placeholderData === "function" ? options.placeholderData() : options.placeholderData;
        if (options.select && typeof placeholderData !== "undefined") {
          try {
            placeholderData = options.select(placeholderData);
            if (options.structuralSharing !== false) {
              placeholderData = replaceEqualDeep(prevResult == null ? void 0 : prevResult.data, placeholderData);
            }
            this.previousSelectError = null;
          } catch (selectError) {
            if (true) {
              this.client.getLogger().error(selectError);
            }
            error = selectError;
            this.previousSelectError = selectError;
            errorUpdatedAt = Date.now();
            status = "error";
          }
        }
      }
      if (typeof placeholderData !== "undefined") {
        status = "success";
        data = placeholderData;
        isPlaceholderData = true;
      }
    }
    const isFetching = fetchStatus === "fetching";
    const result = {
      status,
      fetchStatus,
      isLoading: status === "loading",
      isSuccess: status === "success",
      isError: status === "error",
      data,
      dataUpdatedAt,
      error,
      errorUpdatedAt,
      failureCount: state.fetchFailureCount,
      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,
      isFetchedAfterMount: state.dataUpdateCount > queryInitialState.dataUpdateCount || state.errorUpdateCount > queryInitialState.errorUpdateCount,
      isFetching,
      isRefetching: isFetching && status !== "loading",
      isLoadingError: status === "error" && state.dataUpdatedAt === 0,
      isPaused: fetchStatus === "paused",
      isPlaceholderData,
      isPreviousData,
      isRefetchError: status === "error" && state.dataUpdatedAt !== 0,
      isStale: isStale(query, options),
      refetch: this.refetch,
      remove: this.remove
    };
    return result;
  }
  updateResult(notifyOptions) {
    const prevResult = this.currentResult;
    const nextResult = this.createResult(this.currentQuery, this.options);
    this.currentResultState = this.currentQuery.state;
    this.currentResultOptions = this.options;
    if (shallowEqualObjects(nextResult, prevResult)) {
      return;
    }
    this.currentResult = nextResult;
    const defaultNotifyOptions = {
      cache: true
    };
    const shouldNotifyListeners = () => {
      if (!prevResult) {
        return true;
      }
      const {
        notifyOnChangeProps
      } = this.options;
      if (notifyOnChangeProps === "all" || !notifyOnChangeProps && !this.trackedProps.size) {
        return true;
      }
      const includedProps = new Set(notifyOnChangeProps != null ? notifyOnChangeProps : this.trackedProps);
      if (this.options.useErrorBoundary) {
        includedProps.add("error");
      }
      return Object.keys(this.currentResult).some((key2) => {
        const typedKey = key2;
        const changed = this.currentResult[typedKey] !== prevResult[typedKey];
        return changed && includedProps.has(typedKey);
      });
    };
    if ((notifyOptions == null ? void 0 : notifyOptions.listeners) !== false && shouldNotifyListeners()) {
      defaultNotifyOptions.listeners = true;
    }
    this.notify({
      ...defaultNotifyOptions,
      ...notifyOptions
    });
  }
  updateQuery() {
    const query = this.client.getQueryCache().build(this.client, this.options);
    if (query === this.currentQuery) {
      return;
    }
    const prevQuery = this.currentQuery;
    this.currentQuery = query;
    this.currentQueryInitialState = query.state;
    this.previousQueryResult = this.currentResult;
    if (this.hasListeners()) {
      prevQuery == null ? void 0 : prevQuery.removeObserver(this);
      query.addObserver(this);
    }
  }
  onQueryUpdate(action) {
    const notifyOptions = {};
    if (action.type === "success") {
      notifyOptions.onSuccess = !action.manual;
    } else if (action.type === "error" && !isCancelledError(action.error)) {
      notifyOptions.onError = true;
    }
    this.updateResult(notifyOptions);
    if (this.hasListeners()) {
      this.updateTimers();
    }
  }
  notify(notifyOptions) {
    notifyManager.batch(() => {
      if (notifyOptions.onSuccess) {
        var _this$options$onSucce, _this$options, _this$options$onSettl, _this$options2;
        (_this$options$onSucce = (_this$options = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options, this.currentResult.data);
        (_this$options$onSettl = (_this$options2 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options2, this.currentResult.data, null);
      } else if (notifyOptions.onError) {
        var _this$options$onError, _this$options3, _this$options$onSettl2, _this$options4;
        (_this$options$onError = (_this$options3 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options3, this.currentResult.error);
        (_this$options$onSettl2 = (_this$options4 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options4, void 0, this.currentResult.error);
      }
      if (notifyOptions.listeners) {
        this.listeners.forEach((listener) => {
          listener(this.currentResult);
        });
      }
      if (notifyOptions.cache) {
        this.client.getQueryCache().notify({
          query: this.currentQuery,
          type: "observerResultsUpdated"
        });
      }
    });
  }
};
function shouldLoadOnMount(query, options) {
  return options.enabled !== false && !query.state.dataUpdatedAt && !(query.state.status === "error" && options.retryOnMount === false);
}
function shouldFetchOnMount(query, options) {
  return shouldLoadOnMount(query, options) || query.state.dataUpdatedAt > 0 && shouldFetchOn(query, options, options.refetchOnMount);
}
function shouldFetchOn(query, options, field) {
  if (options.enabled !== false) {
    const value2 = typeof field === "function" ? field(query) : field;
    return value2 === "always" || value2 !== false && isStale(query, options);
  }
  return false;
}
function shouldFetchOptionally(query, prevQuery, options, prevOptions) {
  return options.enabled !== false && (query !== prevQuery || prevOptions.enabled === false) && (!options.suspense || query.state.status !== "error") && isStale(query, options);
}
function isStale(query, options) {
  return query.isStaleByTime(options.staleTime);
}

// node_modules/react-query/lib/core/mutationObserver.mjs
var MutationObserver = class extends Subscribable {
  constructor(client, options) {
    super();
    this.client = client;
    this.setOptions(options);
    this.bindMethods();
    this.updateResult();
  }
  bindMethods() {
    this.mutate = this.mutate.bind(this);
    this.reset = this.reset.bind(this);
  }
  setOptions(options) {
    this.options = this.client.defaultMutationOptions(options);
  }
  onUnsubscribe() {
    if (!this.listeners.length) {
      var _this$currentMutation;
      (_this$currentMutation = this.currentMutation) == null ? void 0 : _this$currentMutation.removeObserver(this);
    }
  }
  onMutationUpdate(action) {
    this.updateResult();
    const notifyOptions = {
      listeners: true
    };
    if (action.type === "success") {
      notifyOptions.onSuccess = true;
    } else if (action.type === "error") {
      notifyOptions.onError = true;
    }
    this.notify(notifyOptions);
  }
  getCurrentResult() {
    return this.currentResult;
  }
  reset() {
    this.currentMutation = void 0;
    this.updateResult();
    this.notify({
      listeners: true
    });
  }
  mutate(variables, options) {
    this.mutateOptions = options;
    if (this.currentMutation) {
      this.currentMutation.removeObserver(this);
    }
    this.currentMutation = this.client.getMutationCache().build(this.client, {
      ...this.options,
      variables: typeof variables !== "undefined" ? variables : this.options.variables
    });
    this.currentMutation.addObserver(this);
    return this.currentMutation.execute();
  }
  updateResult() {
    const state = this.currentMutation ? this.currentMutation.state : getDefaultState2();
    const result = {
      ...state,
      isLoading: state.status === "loading",
      isSuccess: state.status === "success",
      isError: state.status === "error",
      isIdle: state.status === "idle",
      mutate: this.mutate,
      reset: this.reset
    };
    this.currentResult = result;
  }
  notify(options) {
    notifyManager.batch(() => {
      if (this.mutateOptions) {
        if (options.onSuccess) {
          var _this$mutateOptions$o, _this$mutateOptions, _this$mutateOptions$o2, _this$mutateOptions2;
          (_this$mutateOptions$o = (_this$mutateOptions = this.mutateOptions).onSuccess) == null ? void 0 : _this$mutateOptions$o.call(_this$mutateOptions, this.currentResult.data, this.currentResult.variables, this.currentResult.context);
          (_this$mutateOptions$o2 = (_this$mutateOptions2 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o2.call(_this$mutateOptions2, this.currentResult.data, null, this.currentResult.variables, this.currentResult.context);
        } else if (options.onError) {
          var _this$mutateOptions$o3, _this$mutateOptions3, _this$mutateOptions$o4, _this$mutateOptions4;
          (_this$mutateOptions$o3 = (_this$mutateOptions3 = this.mutateOptions).onError) == null ? void 0 : _this$mutateOptions$o3.call(_this$mutateOptions3, this.currentResult.error, this.currentResult.variables, this.currentResult.context);
          (_this$mutateOptions$o4 = (_this$mutateOptions4 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o4.call(_this$mutateOptions4, void 0, this.currentResult.error, this.currentResult.variables, this.currentResult.context);
        }
      }
      if (options.listeners) {
        this.listeners.forEach((listener) => {
          listener(this.currentResult);
        });
      }
    });
  }
};

// node_modules/react-query/lib/reactjs/reactBatchedUpdates.mjs
var import_react_dom = __toESM(require_react_dom(), 1);
var unstable_batchedUpdates = import_react_dom.default.unstable_batchedUpdates;

// node_modules/react-query/lib/reactjs/setBatchUpdatesFn.mjs
notifyManager.setBatchNotifyFunction(unstable_batchedUpdates);

// node_modules/react-query/lib/reactjs/QueryClientProvider.mjs
var import_react = __toESM(require_react(), 1);
var defaultContext = import_react.default.createContext(void 0);
var QueryClientSharingContext = import_react.default.createContext(false);
function getQueryClientContext(context, contextSharing) {
  if (context) {
    return context;
  }
  if (contextSharing && typeof window !== "undefined") {
    if (!window.ReactQueryClientContext) {
      window.ReactQueryClientContext = defaultContext;
    }
    return window.ReactQueryClientContext;
  }
  return defaultContext;
}
var useQueryClient = ({
  context
} = {}) => {
  const queryClient = import_react.default.useContext(getQueryClientContext(context, import_react.default.useContext(QueryClientSharingContext)));
  if (!queryClient) {
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  }
  return queryClient;
};
var QueryClientProvider = ({
  client,
  children,
  context,
  contextSharing = false
}) => {
  import_react.default.useEffect(() => {
    client.mount();
    return () => {
      client.unmount();
    };
  }, [client]);
  const Context3 = getQueryClientContext(context, contextSharing);
  return import_react.default.createElement(QueryClientSharingContext.Provider, {
    value: !context && contextSharing
  }, import_react.default.createElement(Context3.Provider, {
    value: client
  }, children));
};

// node_modules/react-query/lib/reactjs/QueryErrorResetBoundary.mjs
var import_react2 = __toESM(require_react(), 1);
function createValue() {
  let isReset = false;
  return {
    clearReset: () => {
      isReset = false;
    },
    reset: () => {
      isReset = true;
    },
    isReset: () => {
      return isReset;
    }
  };
}
var QueryErrorResetBoundaryContext = import_react2.default.createContext(createValue());
var useQueryErrorResetBoundary = () => import_react2.default.useContext(QueryErrorResetBoundaryContext);

// node_modules/react-query/lib/reactjs/useIsFetching.mjs
var import_react3 = __toESM(require_react(), 1);

// node_modules/react-query/lib/reactjs/useSyncExternalStore.mjs
var import_shim = __toESM(require_shim4(), 1);

// node_modules/react-query/lib/reactjs/useIsMutating.mjs
var import_react4 = __toESM(require_react(), 1);

// node_modules/react-query/lib/reactjs/useMutation.mjs
var import_react5 = __toESM(require_react(), 1);

// node_modules/react-query/lib/reactjs/utils.mjs
function shouldThrowError(_useErrorBoundary, params) {
  if (typeof _useErrorBoundary === "function") {
    return _useErrorBoundary(...params);
  }
  return !!_useErrorBoundary;
}

// node_modules/react-query/lib/reactjs/useMutation.mjs
function useMutation(arg1, arg2, arg3) {
  const options = parseMutationArgs(arg1, arg2, arg3);
  const queryClient = useQueryClient({
    context: options.context
  });
  const [observer] = import_react5.default.useState(() => new MutationObserver(queryClient, options));
  import_react5.default.useEffect(() => {
    observer.setOptions(options);
  }, [observer, options]);
  const result = (0, import_shim.useSyncExternalStore)(import_react5.default.useCallback((onStoreChange) => observer.subscribe(notifyManager.batchCalls(onStoreChange)), [observer]), () => observer.getCurrentResult(), () => observer.getCurrentResult());
  const mutate = import_react5.default.useCallback((variables, mutateOptions) => {
    observer.mutate(variables, mutateOptions).catch(noop);
  }, [observer]);
  if (result.error && shouldThrowError(observer.options.useErrorBoundary, [result.error])) {
    throw result.error;
  }
  return {
    ...result,
    mutate,
    mutateAsync: result.mutate
  };
}

// node_modules/react-query/lib/reactjs/useBaseQuery.mjs
var import_react7 = __toESM(require_react(), 1);

// node_modules/react-query/lib/reactjs/isRestoring.mjs
var import_react6 = __toESM(require_react(), 1);
var IsRestoringContext = import_react6.default.createContext(false);
var useIsRestoring = () => import_react6.default.useContext(IsRestoringContext);
var IsRestoringProvider = IsRestoringContext.Provider;

// node_modules/react-query/lib/reactjs/useBaseQuery.mjs
function useBaseQuery(options, Observer) {
  const queryClient = useQueryClient({
    context: options.context
  });
  const isRestoring = useIsRestoring();
  const errorResetBoundary = useQueryErrorResetBoundary();
  const defaultedOptions = queryClient.defaultQueryOptions(options);
  defaultedOptions._optimisticResults = isRestoring ? "isRestoring" : "optimistic";
  if (defaultedOptions.onError) {
    defaultedOptions.onError = notifyManager.batchCalls(defaultedOptions.onError);
  }
  if (defaultedOptions.onSuccess) {
    defaultedOptions.onSuccess = notifyManager.batchCalls(defaultedOptions.onSuccess);
  }
  if (defaultedOptions.onSettled) {
    defaultedOptions.onSettled = notifyManager.batchCalls(defaultedOptions.onSettled);
  }
  if (defaultedOptions.suspense) {
    if (typeof defaultedOptions.staleTime !== "number") {
      defaultedOptions.staleTime = 1e3;
    }
  }
  if (defaultedOptions.suspense || defaultedOptions.useErrorBoundary) {
    if (!errorResetBoundary.isReset()) {
      defaultedOptions.retryOnMount = false;
    }
  }
  const [observer] = import_react7.default.useState(() => new Observer(queryClient, defaultedOptions));
  const result = observer.getOptimisticResult(defaultedOptions);
  (0, import_shim.useSyncExternalStore)(import_react7.default.useCallback((onStoreChange) => isRestoring ? () => void 0 : observer.subscribe(notifyManager.batchCalls(onStoreChange)), [observer, isRestoring]), () => observer.getCurrentResult(), () => observer.getCurrentResult());
  import_react7.default.useEffect(() => {
    errorResetBoundary.clearReset();
  }, [errorResetBoundary]);
  import_react7.default.useEffect(() => {
    observer.setOptions(defaultedOptions, {
      listeners: false
    });
  }, [defaultedOptions, observer]);
  if (defaultedOptions.suspense && result.isLoading && result.isFetching && !isRestoring) {
    throw observer.fetchOptimistic(defaultedOptions).then(({
      data
    }) => {
      defaultedOptions.onSuccess == null ? void 0 : defaultedOptions.onSuccess(data);
      defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(data, null);
    }).catch((error) => {
      errorResetBoundary.clearReset();
      defaultedOptions.onError == null ? void 0 : defaultedOptions.onError(error);
      defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(void 0, error);
    });
  }
  if (result.isError && !errorResetBoundary.isReset() && !result.isFetching && shouldThrowError(defaultedOptions.useErrorBoundary, [result.error, observer.getCurrentQuery()])) {
    throw result.error;
  }
  return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;
}

// node_modules/react-query/lib/reactjs/useQuery.mjs
function useQuery(arg1, arg2, arg3) {
  const parsedOptions = parseQueryArgs(arg1, arg2, arg3);
  return useBaseQuery(parsedOptions, QueryObserver);
}

// node_modules/react-query/lib/reactjs/useQueries.mjs
var import_react8 = __toESM(require_react(), 1);

// node_modules/react-query/lib/reactjs/Hydrate.mjs
var import_react9 = __toESM(require_react(), 1);

// node_modules/wagmi-core/connectors/coinbaseWallet/dist/wagmi-core-connectors-coinbaseWallet.esm.js
var import_wallet_sdk = __toESM(require_dist4());
var import_utils24 = __toESM(require_utils2());
var import_eventemitter33 = __toESM(require_eventemitter3());
var _client = /* @__PURE__ */ new WeakMap();
var _provider2 = /* @__PURE__ */ new WeakMap();
var CoinbaseWalletConnector = class extends Connector {
  constructor(config2) {
    var _window$ethereum;
    super(config2);
    _defineProperty(this, "id", "coinbasewallet");
    _defineProperty(this, "name", "Coinbase Wallet");
    _defineProperty(this, "ready", typeof window !== "undefined" && !((_window$ethereum = window.ethereum) !== null && _window$ethereum !== void 0 && _window$ethereum.isCoinbaseWallet));
    _classPrivateFieldInitSpec(this, _client, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _provider2, {
      writable: true,
      value: void 0
    });
    _defineProperty(this, "onAccountsChanged", (accounts) => {
      if (accounts.length === 0)
        this.emit("disconnect");
      else
        this.emit("change", {
          account: (0, import_utils24.getAddress)(accounts[0])
        });
    });
    _defineProperty(this, "onChainChanged", (chainId) => {
      const id2 = normalizeChainId(chainId);
      const unsupported = this.isChainUnsupported(id2);
      this.emit("change", {
        chain: {
          id: id2,
          unsupported
        }
      });
    });
    _defineProperty(this, "onDisconnect", () => {
      this.emit("disconnect");
    });
  }
  async connect() {
    try {
      const provider = this.getProvider();
      provider.on("accountsChanged", this.onAccountsChanged);
      provider.on("chainChanged", this.onChainChanged);
      provider.on("disconnect", this.onDisconnect);
      const accounts = await provider.enable();
      const account = (0, import_utils24.getAddress)(accounts[0]);
      const id2 = await this.getChainId();
      const unsupported = this.isChainUnsupported(id2);
      return {
        account,
        chain: {
          id: id2,
          unsupported
        },
        provider: new Web3Provider(provider)
      };
    } catch (error) {
      if (/user closed modal/i.test(error.message))
        throw new UserRejectedRequestError();
      throw error;
    }
  }
  async disconnect() {
    if (!_classPrivateFieldGet(this, _provider2))
      return;
    const provider = this.getProvider();
    provider.removeListener("accountsChanged", this.onAccountsChanged);
    provider.removeListener("chainChanged", this.onChainChanged);
    provider.removeListener("disconnect", this.onDisconnect);
    provider.disconnect();
    provider.close();
    if (typeof localStorage !== "undefined") {
      let n4 = localStorage.length;
      while (n4--) {
        const key2 = localStorage.key(n4);
        if (!key2)
          continue;
        if (!/-walletlink/.test(key2))
          continue;
        localStorage.removeItem(key2);
      }
    }
  }
  async getAccount() {
    const provider = this.getProvider();
    const accounts = await provider.request({
      method: "eth_accounts"
    });
    return (0, import_utils24.getAddress)(accounts[0]);
  }
  async getChainId() {
    const provider = this.getProvider();
    const chainId = normalizeChainId(provider.chainId);
    return chainId;
  }
  getProvider() {
    if (!_classPrivateFieldGet(this, _provider2)) {
      _classPrivateFieldSet(this, _client, new import_wallet_sdk.CoinbaseWalletSDK(this.options));
      _classPrivateFieldSet(this, _provider2, _classPrivateFieldGet(this, _client).makeWeb3Provider(this.options.jsonRpcUrl));
    }
    return _classPrivateFieldGet(this, _provider2);
  }
  async getSigner() {
    const provider = this.getProvider();
    const account = await this.getAccount();
    return new Web3Provider(provider).getSigner(account);
  }
  async isAuthorized() {
    try {
      const account = await this.getAccount();
      return !!account;
    } catch {
      return false;
    }
  }
  async switchChain(chainId) {
    const provider = this.getProvider();
    const id2 = (0, import_utils24.hexValue)(chainId);
    try {
      await provider.request({
        method: "wallet_switchEthereumChain",
        params: [{
          chainId: id2
        }]
      });
      const chains = [...this.chains, ...allChains];
      return chains.find((x6) => x6.id === chainId);
    } catch (error) {
      if (/user rejected signature request/i.test(error.message))
        throw new UserRejectedRequestError();
      else
        throw new SwitchChainError();
    }
  }
};

// node_modules/@walletconnect/ethereum-provider/dist/esm/index.js
var import_eventemitter35 = __toESM(require_eventemitter3());

// node_modules/@walletconnect/jsonrpc-provider/dist/esm/provider.js
var import_events = __toESM(require_events());

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  IBaseJsonRpcProvider: () => IBaseJsonRpcProvider,
  IEvents: () => IEvents,
  IJsonRpcConnection: () => IJsonRpcConnection,
  IJsonRpcProvider: () => IJsonRpcProvider,
  INTERNAL_ERROR: () => INTERNAL_ERROR,
  INVALID_PARAMS: () => INVALID_PARAMS,
  INVALID_REQUEST: () => INVALID_REQUEST,
  METHOD_NOT_FOUND: () => METHOD_NOT_FOUND,
  PARSE_ERROR: () => PARSE_ERROR,
  RESERVED_ERROR_CODES: () => RESERVED_ERROR_CODES,
  SERVER_ERROR: () => SERVER_ERROR,
  SERVER_ERROR_CODE_RANGE: () => SERVER_ERROR_CODE_RANGE,
  STANDARD_ERROR_MAP: () => STANDARD_ERROR_MAP,
  formatErrorMessage: () => formatErrorMessage,
  formatJsonRpcError: () => formatJsonRpcError,
  formatJsonRpcRequest: () => formatJsonRpcRequest,
  formatJsonRpcResult: () => formatJsonRpcResult,
  getError: () => getError,
  getErrorByCode: () => getErrorByCode,
  isHttpUrl: () => isHttpUrl,
  isJsonRpcError: () => isJsonRpcError,
  isJsonRpcPayload: () => isJsonRpcPayload,
  isJsonRpcRequest: () => isJsonRpcRequest,
  isJsonRpcResponse: () => isJsonRpcResponse,
  isJsonRpcResult: () => isJsonRpcResult,
  isJsonRpcValidationInvalid: () => isJsonRpcValidationInvalid,
  isLocalhostUrl: () => isLocalhostUrl,
  isNodeJs: () => isNodeJs,
  isReservedErrorCode: () => isReservedErrorCode,
  isServerErrorCode: () => isServerErrorCode,
  isValidDefaultRoute: () => isValidDefaultRoute,
  isValidErrorCode: () => isValidErrorCode,
  isValidLeadingWildcardRoute: () => isValidLeadingWildcardRoute,
  isValidRoute: () => isValidRoute,
  isValidTrailingWildcardRoute: () => isValidTrailingWildcardRoute,
  isValidWildcardRoute: () => isValidWildcardRoute,
  isWsUrl: () => isWsUrl,
  parseConnectionError: () => parseConnectionError,
  payloadId: () => payloadId,
  validateJsonRpcError: () => validateJsonRpcError
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/constants.js
var PARSE_ERROR = "PARSE_ERROR";
var INVALID_REQUEST = "INVALID_REQUEST";
var METHOD_NOT_FOUND = "METHOD_NOT_FOUND";
var INVALID_PARAMS = "INVALID_PARAMS";
var INTERNAL_ERROR = "INTERNAL_ERROR";
var SERVER_ERROR = "SERVER_ERROR";
var RESERVED_ERROR_CODES = [-32700, -32600, -32601, -32602, -32603];
var SERVER_ERROR_CODE_RANGE = [-32e3, -32099];
var STANDARD_ERROR_MAP = {
  [PARSE_ERROR]: { code: -32700, message: "Parse error" },
  [INVALID_REQUEST]: { code: -32600, message: "Invalid Request" },
  [METHOD_NOT_FOUND]: { code: -32601, message: "Method not found" },
  [INVALID_PARAMS]: { code: -32602, message: "Invalid params" },
  [INTERNAL_ERROR]: { code: -32603, message: "Internal error" },
  [SERVER_ERROR]: { code: -32e3, message: "Server error" }
};

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/error.js
function isServerErrorCode(code) {
  return code <= SERVER_ERROR_CODE_RANGE[0] && code >= SERVER_ERROR_CODE_RANGE[1];
}
function isReservedErrorCode(code) {
  return RESERVED_ERROR_CODES.includes(code);
}
function isValidErrorCode(code) {
  return typeof code === "number";
}
function getError(type) {
  if (!Object.keys(STANDARD_ERROR_MAP).includes(type)) {
    return STANDARD_ERROR_MAP[INTERNAL_ERROR];
  }
  return STANDARD_ERROR_MAP[type];
}
function getErrorByCode(code) {
  const match = Object.values(STANDARD_ERROR_MAP).find((e6) => e6.code === code);
  if (!match) {
    return STANDARD_ERROR_MAP[INTERNAL_ERROR];
  }
  return match;
}
function validateJsonRpcError(response) {
  if (typeof response.error.code === "undefined") {
    return { valid: false, error: "Missing code for JSON-RPC error" };
  }
  if (typeof response.error.message === "undefined") {
    return { valid: false, error: "Missing message for JSON-RPC error" };
  }
  if (!isValidErrorCode(response.error.code)) {
    return {
      valid: false,
      error: `Invalid error code type for JSON-RPC: ${response.error.code}`
    };
  }
  if (isReservedErrorCode(response.error.code)) {
    const error = getErrorByCode(response.error.code);
    if (error.message !== STANDARD_ERROR_MAP[INTERNAL_ERROR].message && response.error.message === error.message) {
      return {
        valid: false,
        error: `Invalid error code message for JSON-RPC: ${response.error.code}`
      };
    }
  }
  return { valid: true };
}
function parseConnectionError(e6, url, type) {
  return e6.message.includes("getaddrinfo ENOTFOUND") || e6.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${type} RPC url at ${url}`) : e6;
}

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/env.js
var env_exports = {};
__export(env_exports, {
  isNodeJs: () => isNodeJs
});
var import_environment = __toESM(require_cjs());
__reExport(env_exports, __toESM(require_cjs()));
var isNodeJs = import_environment.isNode;

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js
__reExport(esm_exports, env_exports);

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/format.js
function payloadId() {
  const date = Date.now() * Math.pow(10, 3);
  const extra = Math.floor(Math.random() * Math.pow(10, 3));
  return date + extra;
}
function formatJsonRpcRequest(method2, params, id2) {
  return {
    id: id2 || payloadId(),
    jsonrpc: "2.0",
    method: method2,
    params
  };
}
function formatJsonRpcResult(id2, result) {
  return {
    id: id2,
    jsonrpc: "2.0",
    result
  };
}
function formatJsonRpcError(id2, error) {
  return {
    id: id2,
    jsonrpc: "2.0",
    error: formatErrorMessage(error)
  };
}
function formatErrorMessage(error) {
  if (typeof error === "undefined") {
    return getError(INTERNAL_ERROR);
  }
  if (typeof error === "string") {
    error = Object.assign(Object.assign({}, getError(SERVER_ERROR)), { message: error });
  }
  if (isReservedErrorCode(error.code)) {
    error = getErrorByCode(error.code);
  }
  return error;
}

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/routing.js
function isValidRoute(route) {
  if (route.includes("*")) {
    return isValidWildcardRoute(route);
  }
  if (/\W/g.test(route)) {
    return false;
  }
  return true;
}
function isValidDefaultRoute(route) {
  return route === "*";
}
function isValidWildcardRoute(route) {
  if (isValidDefaultRoute(route)) {
    return true;
  }
  if (!route.includes("*")) {
    return false;
  }
  if (route.split("*").length !== 2) {
    return false;
  }
  if (route.split("*").filter((x6) => x6.trim() === "").length !== 1) {
    return false;
  }
  return true;
}
function isValidLeadingWildcardRoute(route) {
  return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[0].trim();
}
function isValidTrailingWildcardRoute(route) {
  return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[1].trim();
}

// node_modules/@walletconnect/jsonrpc-types/dist/esm/misc.js
var IEvents = class {
};

// node_modules/@walletconnect/jsonrpc-types/dist/esm/provider.js
var IJsonRpcConnection = class extends IEvents {
  constructor(opts) {
    super();
  }
};
var IBaseJsonRpcProvider = class extends IEvents {
  constructor() {
    super();
  }
};
var IJsonRpcProvider = class extends IBaseJsonRpcProvider {
  constructor(connection) {
    super();
  }
};

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/url.js
var HTTP_REGEX = "^https?:";
var WS_REGEX = "^wss?:";
function getUrlProtocol(url) {
  const matches = url.match(new RegExp(/^\w+:/, "gi"));
  if (!matches || !matches.length)
    return;
  return matches[0];
}
function matchRegexProtocol(url, regex) {
  const protocol = getUrlProtocol(url);
  if (typeof protocol === "undefined")
    return false;
  return new RegExp(regex).test(protocol);
}
function isHttpUrl(url) {
  return matchRegexProtocol(url, HTTP_REGEX);
}
function isWsUrl(url) {
  return matchRegexProtocol(url, WS_REGEX);
}
function isLocalhostUrl(url) {
  return new RegExp("wss?://localhost(:d{2,5})?").test(url);
}

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/validators.js
function isJsonRpcPayload(payload) {
  return "id" in payload && "jsonrpc" in payload && payload.jsonrpc === "2.0";
}
function isJsonRpcRequest(payload) {
  return isJsonRpcPayload(payload) && "method" in payload;
}
function isJsonRpcResponse(payload) {
  return isJsonRpcPayload(payload) && (isJsonRpcResult(payload) || isJsonRpcError(payload));
}
function isJsonRpcResult(payload) {
  return "result" in payload;
}
function isJsonRpcError(payload) {
  return "error" in payload;
}
function isJsonRpcValidationInvalid(validation) {
  return "error" in validation && validation.valid === false;
}

// node_modules/@walletconnect/jsonrpc-provider/dist/esm/provider.js
var JsonRpcProvider2 = class extends IJsonRpcProvider {
  constructor(connection) {
    super(connection);
    this.events = new import_events.EventEmitter();
    this.hasRegisteredEventListeners = false;
    this.connection = this.setConnection(connection);
    if (this.connection.connected) {
      this.registerEventListeners();
    }
  }
  async connect(connection = this.connection) {
    await this.open(connection);
  }
  async disconnect() {
    await this.close();
  }
  on(event, listener) {
    this.events.on(event, listener);
  }
  once(event, listener) {
    this.events.once(event, listener);
  }
  off(event, listener) {
    this.events.off(event, listener);
  }
  removeListener(event, listener) {
    this.events.removeListener(event, listener);
  }
  async request(request, context) {
    return this.requestStrict(formatJsonRpcRequest(request.method, request.params || []), context);
  }
  async requestStrict(request, context) {
    return new Promise(async (resolve, reject) => {
      if (!this.connection.connected) {
        try {
          await this.open();
        } catch (e6) {
          reject(e6);
        }
      }
      this.events.on(`${request.id}`, (response) => {
        if (isJsonRpcError(response)) {
          reject(response.error.message);
        } else {
          resolve(response.result);
        }
      });
      try {
        await this.connection.send(request, context);
      } catch (e6) {
        reject(e6);
      }
    });
  }
  setConnection(connection = this.connection) {
    return connection;
  }
  onPayload(payload) {
    this.events.emit("payload", payload);
    if (isJsonRpcResponse(payload)) {
      this.events.emit(`${payload.id}`, payload);
    } else {
      this.events.emit("message", {
        type: payload.method,
        data: payload.params
      });
    }
  }
  async open(connection = this.connection) {
    if (this.connection === connection && this.connection.connected)
      return;
    if (this.connection.connected)
      this.close();
    if (typeof connection === "string") {
      await this.connection.open(connection);
      connection = this.connection;
    }
    this.connection = this.setConnection(connection);
    await this.connection.open();
    this.registerEventListeners();
    this.events.emit("connect");
  }
  async close() {
    await this.connection.close();
  }
  registerEventListeners() {
    if (this.hasRegisteredEventListeners)
      return;
    this.connection.on("payload", (payload) => this.onPayload(payload));
    this.connection.on("close", () => this.events.emit("disconnect"));
    this.connection.on("error", (error) => this.events.emit("error", error));
    this.hasRegisteredEventListeners = true;
  }
};

// node_modules/@walletconnect/jsonrpc-http-connection/dist/esm/http.js
var import_events2 = __toESM(require_events());
var import_cross_fetch = __toESM(require_browser_ponyfill());
init_esm();
var DEFAULT_HTTP_HEADERS = {
  Accept: "application/json",
  "Content-Type": "application/json"
};
var DEFAULT_HTTP_METHOD = "POST";
var DEFAULT_FETCH_OPTS = {
  headers: DEFAULT_HTTP_HEADERS,
  method: DEFAULT_HTTP_METHOD
};
var HttpConnection = class {
  constructor(url) {
    this.url = url;
    this.events = new import_events2.EventEmitter();
    this.isAvailable = false;
    this.registering = false;
    if (!isHttpUrl(url)) {
      throw new Error(`Provided URL is not compatible with HTTP connection: ${url}`);
    }
    this.url = url;
  }
  get connected() {
    return this.isAvailable;
  }
  get connecting() {
    return this.registering;
  }
  on(event, listener) {
    this.events.on(event, listener);
  }
  once(event, listener) {
    this.events.once(event, listener);
  }
  off(event, listener) {
    this.events.off(event, listener);
  }
  removeListener(event, listener) {
    this.events.removeListener(event, listener);
  }
  async open(url = this.url) {
    await this.register(url);
  }
  async close() {
    if (!this.isAvailable) {
      throw new Error("Connection already closed");
    }
    this.onClose();
  }
  async send(payload, context) {
    if (!this.isAvailable) {
      await this.register();
    }
    try {
      const body = safeJsonStringify(payload);
      const res = await (0, import_cross_fetch.default)(this.url, Object.assign(Object.assign({}, DEFAULT_FETCH_OPTS), { body }));
      const data = await res.json();
      this.onPayload({ data });
    } catch (e6) {
      this.onError(payload.id, e6);
    }
  }
  async register(url = this.url) {
    if (!isHttpUrl(url)) {
      throw new Error(`Provided URL is not compatible with HTTP connection: ${url}`);
    }
    if (this.registering) {
      return new Promise((resolve, reject) => {
        this.events.once("register_error", (error) => {
          reject(error);
        });
        this.events.once("open", () => {
          if (typeof this.isAvailable === "undefined") {
            return reject(new Error("HTTP connection is missing or invalid"));
          }
          resolve();
        });
      });
    }
    this.url = url;
    this.registering = true;
    try {
      const body = safeJsonStringify({ id: 1, jsonrpc: "2.0", method: "test", params: [] });
      await (0, import_cross_fetch.default)(url, Object.assign(Object.assign({}, DEFAULT_FETCH_OPTS), { body }));
      this.onOpen();
    } catch (e6) {
      const error = this.parseError(e6);
      this.events.emit("register_error", error);
      this.onClose();
      throw error;
    }
  }
  onOpen() {
    this.isAvailable = true;
    this.registering = false;
    this.events.emit("open");
  }
  onClose() {
    this.isAvailable = false;
    this.registering = false;
    this.events.emit("close");
  }
  onPayload(e6) {
    if (typeof e6.data === "undefined")
      return;
    const payload = typeof e6.data === "string" ? safeJsonParse(e6.data) : e6.data;
    this.events.emit("payload", payload);
  }
  onError(id2, e6) {
    const error = this.parseError(e6);
    const message = error.message || error.toString();
    const payload = formatJsonRpcError(id2, message);
    this.events.emit("payload", payload);
  }
  parseError(e6, url = this.url) {
    return parseConnectionError(e6, url, "HTTP");
  }
};

// node_modules/@walletconnect/utils/dist/esm/index.js
init_esm2();

// node_modules/@walletconnect/utils/dist/esm/constants.js
var reservedEvents = [
  "session_request",
  "session_update",
  "exchange_key",
  "connect",
  "disconnect",
  "display_uri",
  "modal_closed",
  "transport_open",
  "transport_close",
  "transport_error"
];
var signingMethods = [
  "eth_sendTransaction",
  "eth_signTransaction",
  "eth_sign",
  "eth_signTypedData",
  "eth_signTypedData_v1",
  "eth_signTypedData_v2",
  "eth_signTypedData_v3",
  "eth_signTypedData_v4",
  "personal_sign",
  "wallet_addEthereumChain",
  "wallet_switchEthereumChain",
  "wallet_getPermissions",
  "wallet_requestPermissions",
  "wallet_registerOnboarding",
  "wallet_watchAsset",
  "wallet_scanQRCode"
];
var infuraNetworks = {
  1: "mainnet",
  3: "ropsten",
  4: "rinkeby",
  5: "goerli",
  42: "kovan"
};

// node_modules/@walletconnect/utils/dist/esm/encoding.js
var import_bn3 = __toESM(require_bn4());

// node_modules/@walletconnect/encoding/dist/esm/index.js
var import_is_typedarray = __toESM(require_is_typedarray());
var import_typedarray_to_buffer = __toESM(require_typedarray_to_buffer());
var ENC_HEX = "hex";
var ENC_UTF8 = "utf8";
var STRING_ZERO = "0";
function bufferToArray(buf) {
  return new Uint8Array(buf);
}
function bufferToHex(buf, prefixed = false) {
  const hex = buf.toString(ENC_HEX);
  return prefixed ? addHexPrefix(hex) : hex;
}
function bufferToUtf8(buf) {
  return buf.toString(ENC_UTF8);
}
function arrayToBuffer(arr) {
  return (0, import_typedarray_to_buffer.default)(arr);
}
function arrayToHex(arr, prefixed = false) {
  return bufferToHex(arrayToBuffer(arr), prefixed);
}
function arrayToUtf8(arr) {
  return bufferToUtf8(arrayToBuffer(arr));
}
function hexToBuffer(hex) {
  return Buffer.from(removeHexPrefix(hex), ENC_HEX);
}
function hexToArray(hex) {
  return bufferToArray(hexToBuffer(hex));
}
function utf8ToBuffer(utf8) {
  return Buffer.from(utf8, ENC_UTF8);
}
function utf8ToArray(utf8) {
  return bufferToArray(utf8ToBuffer(utf8));
}
function utf8ToHex(utf8, prefixed = false) {
  return bufferToHex(utf8ToBuffer(utf8), prefixed);
}
function isHexString2(str, length) {
  if (typeof str !== "string" || !str.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && str.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
function concatArrays(...args) {
  let result = [];
  args.forEach((arg) => result = result.concat(Array.from(arg)));
  return new Uint8Array([...result]);
}
function calcByteLength(length, byteSize = 8) {
  const remainder = length % byteSize;
  return remainder ? (length - remainder) / byteSize * byteSize + byteSize : length;
}
function sanitizeBytes(str, byteSize = 8, padding2 = STRING_ZERO) {
  return padLeft(str, calcByteLength(str.length, byteSize), padding2);
}
function padLeft(str, length, padding2 = STRING_ZERO) {
  return padString(str, length, true, padding2);
}
function removeHexPrefix(hex) {
  return hex.replace(/^0x/, "");
}
function addHexPrefix(hex) {
  return hex.startsWith("0x") ? hex : `0x${hex}`;
}
function sanitizeHex(hex) {
  hex = removeHexPrefix(hex);
  hex = sanitizeBytes(hex, 2);
  if (hex) {
    hex = addHexPrefix(hex);
  }
  return hex;
}
function removeHexLeadingZeros(hex) {
  const prefixed = hex.startsWith("0x");
  hex = removeHexPrefix(hex);
  hex = hex.startsWith(STRING_ZERO) ? hex.substring(1) : hex;
  return prefixed ? addHexPrefix(hex) : hex;
}
function padString(str, length, left, padding2 = STRING_ZERO) {
  const diff = length - str.length;
  let result = str;
  if (diff > 0) {
    const pad = padding2.repeat(diff);
    result = left ? pad + str : str + pad;
  }
  return result;
}

// node_modules/@walletconnect/utils/dist/esm/encoding.js
function convertArrayBufferToBuffer(arrBuf) {
  return arrayToBuffer(new Uint8Array(arrBuf));
}
function convertArrayBufferToHex(arrBuf, noPrefix) {
  return arrayToHex(new Uint8Array(arrBuf), !noPrefix);
}
function convertBufferToArrayBuffer(buf) {
  return bufferToArray(buf).buffer;
}
function convertUtf8ToBuffer(utf8) {
  return utf8ToBuffer(utf8);
}
function convertUtf8ToHex(utf8, noPrefix) {
  return utf8ToHex(utf8, !noPrefix);
}
function convertHexToArrayBuffer(hex) {
  return hexToArray(hex).buffer;
}
function convertNumberToHex(num, noPrefix) {
  const hex = removeHexPrefix(sanitizeHex(new import_bn3.default(num).toString(16)));
  return noPrefix ? hex : addHexPrefix(hex);
}

// node_modules/@walletconnect/utils/dist/esm/ethereum.js
var import_js_sha32 = __toESM(require_sha3());

// node_modules/@walletconnect/utils/dist/esm/misc.js
function sanitizeHex2(hex) {
  return sanitizeHex(hex);
}
function removeHexLeadingZeros2(hex) {
  return removeHexLeadingZeros(addHexPrefix(hex));
}
var payloadId2 = payloadId;
function uuid() {
  const result = ((a5, b4) => {
    for (b4 = a5 = ""; a5++ < 36; b4 += a5 * 51 & 52 ? (a5 ^ 15 ? 8 ^ Math.random() * (a5 ^ 20 ? 16 : 4) : 4).toString(16) : "-") {
    }
    return b4;
  })();
  return result;
}
function getInfuraRpcUrl(chainId, infuraId) {
  let rpcUrl;
  const network = infuraNetworks[chainId];
  if (network) {
    rpcUrl = `https://${network}.infura.io/v3/${infuraId}`;
  }
  return rpcUrl;
}
function getRpcUrl(chainId, rpc) {
  let rpcUrl;
  const infuraUrl = getInfuraRpcUrl(chainId, rpc.infuraId);
  if (rpc.custom && rpc.custom[chainId]) {
    rpcUrl = rpc.custom[chainId];
  } else if (infuraUrl) {
    rpcUrl = infuraUrl;
  }
  return rpcUrl;
}

// node_modules/@walletconnect/utils/dist/esm/validators.js
function isEmptyString(value2) {
  return value2 === "" || typeof value2 === "string" && value2.trim() === "";
}
function isEmptyArray(array) {
  return !(array && array.length);
}
function isHexString3(value2, length) {
  return isHexString2(value2, length);
}
function isJsonRpcRequest2(object) {
  return typeof object.method !== "undefined";
}
function isJsonRpcResponseSuccess(object) {
  return typeof object.result !== "undefined";
}
function isJsonRpcResponseError(object) {
  return typeof object.error !== "undefined";
}
function isInternalEvent(object) {
  return typeof object.event !== "undefined";
}
function isReservedEvent(event) {
  return reservedEvents.includes(event) || event.startsWith("wc_");
}
function isSilentPayload(request) {
  if (request.method.startsWith("wc_")) {
    return true;
  }
  if (signingMethods.includes(request.method)) {
    return false;
  }
  return true;
}

// node_modules/@walletconnect/utils/dist/esm/ethereum.js
function toChecksumAddress(address) {
  address = removeHexPrefix(address.toLowerCase());
  const hash3 = removeHexPrefix((0, import_js_sha32.keccak_256)(convertUtf8ToBuffer(address)));
  let checksum = "";
  for (let i6 = 0; i6 < address.length; i6++) {
    if (parseInt(hash3[i6], 16) > 7) {
      checksum += address[i6].toUpperCase();
    } else {
      checksum += address[i6];
    }
  }
  return addHexPrefix(checksum);
}
var isValidAddress = (address) => {
  if (!address) {
    return false;
  } else if (address.toLowerCase().substring(0, 2) !== "0x") {
    return false;
  } else if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {
    return false;
  } else if (/^(0x)?[0-9a-f]{40}$/.test(address) || /^(0x)?[0-9A-F]{40}$/.test(address)) {
    return true;
  } else {
    return address === toChecksumAddress(address);
  }
};
function parsePersonalSign(params) {
  if (!isEmptyArray(params) && !isHexString3(params[0])) {
    params[0] = convertUtf8ToHex(params[0]);
  }
  return params;
}
function parseTransactionData(txData) {
  if (typeof txData.type !== "undefined" && txData.type !== "0")
    return txData;
  if (typeof txData.from === "undefined" || !isValidAddress(txData.from)) {
    throw new Error(`Transaction object must include a valid 'from' value.`);
  }
  function parseHexValues(value2) {
    let result = value2;
    if (typeof value2 === "number" || typeof value2 === "string" && !isEmptyString(value2)) {
      if (!isHexString3(value2)) {
        result = convertNumberToHex(value2);
      } else if (typeof value2 === "string") {
        result = sanitizeHex2(value2);
      }
    }
    if (typeof result === "string") {
      result = removeHexLeadingZeros2(result);
    }
    return result;
  }
  const txDataRPC = {
    from: sanitizeHex2(txData.from),
    to: typeof txData.to === "undefined" ? void 0 : sanitizeHex2(txData.to),
    gasPrice: typeof txData.gasPrice === "undefined" ? "" : parseHexValues(txData.gasPrice),
    gas: typeof txData.gas === "undefined" ? typeof txData.gasLimit === "undefined" ? "" : parseHexValues(txData.gasLimit) : parseHexValues(txData.gas),
    value: typeof txData.value === "undefined" ? "" : parseHexValues(txData.value),
    nonce: typeof txData.nonce === "undefined" ? "" : parseHexValues(txData.nonce),
    data: typeof txData.data === "undefined" ? "" : sanitizeHex2(txData.data) || "0x"
  };
  const prunable = ["gasPrice", "gas", "value", "nonce"];
  Object.keys(txDataRPC).forEach((key2) => {
    if ((typeof txDataRPC[key2] === "undefined" || typeof txDataRPC[key2] === "string" && !txDataRPC[key2].trim().length) && prunable.includes(key2)) {
      delete txDataRPC[key2];
    }
  });
  return txDataRPC;
}

// node_modules/@walletconnect/utils/dist/esm/payload.js
function formatRpcError(error) {
  const message = error.message || "Failed or Rejected Request";
  let code = -32e3;
  if (error && !error.code) {
    switch (message) {
      case "Parse error":
        code = -32700;
        break;
      case "Invalid request":
        code = -32600;
        break;
      case "Method not found":
        code = -32601;
        break;
      case "Invalid params":
        code = -32602;
        break;
      case "Internal error":
        code = -32603;
        break;
      default:
        code = -32e3;
        break;
    }
  }
  const result = {
    code,
    message
  };
  return result;
}

// node_modules/@walletconnect/utils/dist/esm/url.js
var queryStringUtils = __toESM(require_query_string());
function getQueryString(url) {
  const pathEnd = url.indexOf("?") !== -1 ? url.indexOf("?") : void 0;
  const queryString = typeof pathEnd !== "undefined" ? url.substr(pathEnd) : "";
  return queryString;
}
function appendToQueryString(queryString, newQueryParams) {
  let queryParams = parseQueryString(queryString);
  queryParams = Object.assign(Object.assign({}, queryParams), newQueryParams);
  queryString = formatQueryString(queryParams);
  return queryString;
}
function parseQueryString(queryString) {
  return queryStringUtils.parse(queryString);
}
function formatQueryString(queryParams) {
  return queryStringUtils.stringify(queryParams);
}

// node_modules/@walletconnect/utils/dist/esm/session.js
function isWalletConnectSession(object) {
  return typeof object.bridge !== "undefined";
}
function parseWalletConnectUri(str) {
  const pathStart = str.indexOf(":");
  const pathEnd = str.indexOf("?") !== -1 ? str.indexOf("?") : void 0;
  const protocol = str.substring(0, pathStart);
  const path = str.substring(pathStart + 1, pathEnd);
  function parseRequiredParams(path2) {
    const separator = "@";
    const values = path2.split(separator);
    const requiredParams2 = {
      handshakeTopic: values[0],
      version: parseInt(values[1], 10)
    };
    return requiredParams2;
  }
  const requiredParams = parseRequiredParams(path);
  const queryString = typeof pathEnd !== "undefined" ? str.substr(pathEnd) : "";
  function parseQueryParams(queryString2) {
    const result2 = parseQueryString(queryString2);
    const parameters = {
      key: result2.key || "",
      bridge: result2.bridge || ""
    };
    return parameters;
  }
  const queryParams = parseQueryParams(queryString);
  const result = Object.assign(Object.assign({ protocol }, requiredParams), queryParams);
  return result;
}

// node_modules/@walletconnect/signer-connection/dist/esm/index.js
var import_eventemitter34 = __toESM(require_eventemitter3());

// node_modules/@walletconnect/socket-transport/dist/esm/network.js
var NetworkMonitor = class {
  constructor() {
    this._eventEmitters = [];
    if (typeof window !== "undefined" && typeof window.addEventListener !== "undefined") {
      window.addEventListener("online", () => this.trigger("online"));
      window.addEventListener("offline", () => this.trigger("offline"));
    }
  }
  on(event, callback) {
    this._eventEmitters.push({
      event,
      callback
    });
  }
  trigger(event) {
    let eventEmitters = [];
    if (event) {
      eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === event);
    }
    eventEmitters.forEach((eventEmitter) => {
      eventEmitter.callback();
    });
  }
};
var network_default = NetworkMonitor;

// node_modules/@walletconnect/socket-transport/dist/esm/index.js
var WS2 = typeof global.WebSocket !== "undefined" ? global.WebSocket : require_browser2();
var SocketTransport = class {
  constructor(opts) {
    this.opts = opts;
    this._queue = [];
    this._events = [];
    this._subscriptions = [];
    this._protocol = opts.protocol;
    this._version = opts.version;
    this._url = "";
    this._netMonitor = null;
    this._socket = null;
    this._nextSocket = null;
    this._subscriptions = opts.subscriptions || [];
    this._netMonitor = opts.netMonitor || new network_default();
    if (!opts.url || typeof opts.url !== "string") {
      throw new Error("Missing or invalid WebSocket url");
    }
    this._url = opts.url;
    this._netMonitor.on("online", () => this._socketCreate());
  }
  set readyState(value2) {
  }
  get readyState() {
    return this._socket ? this._socket.readyState : -1;
  }
  set connecting(value2) {
  }
  get connecting() {
    return this.readyState === 0;
  }
  set connected(value2) {
  }
  get connected() {
    return this.readyState === 1;
  }
  set closing(value2) {
  }
  get closing() {
    return this.readyState === 2;
  }
  set closed(value2) {
  }
  get closed() {
    return this.readyState === 3;
  }
  open() {
    this._socketCreate();
  }
  close() {
    this._socketClose();
  }
  send(message, topic, silent) {
    if (!topic || typeof topic !== "string") {
      throw new Error("Missing or invalid topic field");
    }
    this._socketSend({
      topic,
      type: "pub",
      payload: message,
      silent: !!silent
    });
  }
  subscribe(topic) {
    this._socketSend({
      topic,
      type: "sub",
      payload: "",
      silent: true
    });
  }
  on(event, callback) {
    this._events.push({ event, callback });
  }
  _socketCreate() {
    if (this._nextSocket) {
      return;
    }
    const url = getWebSocketUrl(this._url, this._protocol, this._version);
    this._nextSocket = new WS2(url);
    if (!this._nextSocket) {
      throw new Error("Failed to create socket");
    }
    this._nextSocket.onmessage = (event) => this._socketReceive(event);
    this._nextSocket.onopen = () => this._socketOpen();
    this._nextSocket.onerror = (event) => this._socketError(event);
    this._nextSocket.onclose = () => {
      setTimeout(() => {
        this._nextSocket = null;
        this._socketCreate();
      }, 1e3);
    };
  }
  _socketOpen() {
    this._socketClose();
    this._socket = this._nextSocket;
    this._nextSocket = null;
    this._queueSubscriptions();
    this._pushQueue();
  }
  _socketClose() {
    if (this._socket) {
      this._socket.onclose = () => {
      };
      this._socket.close();
    }
  }
  _socketSend(socketMessage) {
    const message = JSON.stringify(socketMessage);
    if (this._socket && this._socket.readyState === 1) {
      this._socket.send(message);
    } else {
      this._setToQueue(socketMessage);
      this._socketCreate();
    }
  }
  async _socketReceive(event) {
    let socketMessage;
    try {
      socketMessage = JSON.parse(event.data);
    } catch (error) {
      return;
    }
    this._socketSend({
      topic: socketMessage.topic,
      type: "ack",
      payload: "",
      silent: true
    });
    if (this._socket && this._socket.readyState === 1) {
      const events = this._events.filter((event2) => event2.event === "message");
      if (events && events.length) {
        events.forEach((event2) => event2.callback(socketMessage));
      }
    }
  }
  _socketError(e6) {
    const events = this._events.filter((event) => event.event === "error");
    if (events && events.length) {
      events.forEach((event) => event.callback(e6));
    }
  }
  _queueSubscriptions() {
    const subscriptions = this._subscriptions;
    subscriptions.forEach((topic) => this._queue.push({
      topic,
      type: "sub",
      payload: "",
      silent: true
    }));
    this._subscriptions = this.opts.subscriptions || [];
  }
  _setToQueue(socketMessage) {
    this._queue.push(socketMessage);
  }
  _pushQueue() {
    const queue2 = this._queue;
    queue2.forEach((socketMessage) => this._socketSend(socketMessage));
    this._queue = [];
  }
};
function getWebSocketUrl(_url, protocol, version27) {
  var _a2, _b;
  const url = _url.startsWith("https") ? _url.replace("https", "wss") : _url.startsWith("http") ? _url.replace("http", "ws") : _url;
  const splitUrl = url.split("?");
  const params = isBrowser() ? {
    protocol,
    version: version27,
    env: "browser",
    host: ((_a2 = getLocation2()) === null || _a2 === void 0 ? void 0 : _a2.host) || ""
  } : {
    protocol,
    version: version27,
    env: ((_b = detectEnv()) === null || _b === void 0 ? void 0 : _b.name) || ""
  };
  const queryString = appendToQueryString(getQueryString(splitUrl[1] || ""), params);
  return splitUrl[0] + "?" + queryString;
}
var esm_default = SocketTransport;

// node_modules/@walletconnect/core/dist/esm/errors.js
var ERROR_SESSION_CONNECTED = "Session currently connected";
var ERROR_SESSION_DISCONNECTED = "Session currently disconnected";
var ERROR_SESSION_REJECTED = "Session Rejected";
var ERROR_MISSING_JSON_RPC = "Missing JSON RPC response";
var ERROR_MISSING_RESULT = `JSON-RPC success response must include "result" field`;
var ERROR_MISSING_ERROR = `JSON-RPC error response must include "error" field`;
var ERROR_MISSING_METHOD = `JSON RPC request must have valid "method" value`;
var ERROR_MISSING_ID = `JSON RPC request must have valid "id" value`;
var ERROR_MISSING_REQUIRED = "Missing one of the required parameters: bridge / uri / session";
var ERROR_INVALID_RESPONSE = "JSON RPC response format is invalid";
var ERROR_INVALID_URI = "URI format is invalid";
var ERROR_QRCODE_MODAL_NOT_PROVIDED = "QRCode Modal not provided";
var ERROR_QRCODE_MODAL_USER_CLOSED = "User close QRCode Modal";

// node_modules/@walletconnect/core/dist/esm/events.js
var EventManager = class {
  constructor() {
    this._eventEmitters = [];
  }
  subscribe(eventEmitter) {
    this._eventEmitters.push(eventEmitter);
  }
  unsubscribe(event) {
    this._eventEmitters = this._eventEmitters.filter((x6) => x6.event !== event);
  }
  trigger(payload) {
    let eventEmitters = [];
    let event;
    if (isJsonRpcRequest2(payload)) {
      event = payload.method;
    } else if (isJsonRpcResponseSuccess(payload) || isJsonRpcResponseError(payload)) {
      event = `response:${payload.id}`;
    } else if (isInternalEvent(payload)) {
      event = payload.event;
    } else {
      event = "";
    }
    if (event) {
      eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === event);
    }
    if ((!eventEmitters || !eventEmitters.length) && !isReservedEvent(event) && !isInternalEvent(event)) {
      eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === "call_request");
    }
    eventEmitters.forEach((eventEmitter) => {
      if (isJsonRpcResponseError(payload)) {
        const error = new Error(payload.error.message);
        eventEmitter.callback(error, null);
      } else {
        eventEmitter.callback(null, payload);
      }
    });
  }
};
var events_default = EventManager;

// node_modules/@walletconnect/core/dist/esm/storage.js
var SessionStorage = class {
  constructor(storageId = "walletconnect") {
    this.storageId = storageId;
  }
  getSession() {
    let session = null;
    const json = getLocal(this.storageId);
    if (json && isWalletConnectSession(json)) {
      session = json;
    }
    return session;
  }
  setSession(session) {
    setLocal(this.storageId, session);
    return session;
  }
  removeSession() {
    removeLocal(this.storageId);
  }
};
var storage_default = SessionStorage;

// node_modules/@walletconnect/core/dist/esm/url.js
var domain = "walletconnect.org";
var alphanumerical = "abcdefghijklmnopqrstuvwxyz0123456789";
var bridges = alphanumerical.split("").map((char) => `https://${char}.bridge.walletconnect.org`);
function extractHostname(url) {
  let hostname = url.indexOf("//") > -1 ? url.split("/")[2] : url.split("/")[0];
  hostname = hostname.split(":")[0];
  hostname = hostname.split("?")[0];
  return hostname;
}
function extractRootDomain(url) {
  return extractHostname(url).split(".").slice(-2).join(".");
}
function randomBridgeIndex() {
  return Math.floor(Math.random() * bridges.length);
}
function selectRandomBridgeUrl() {
  return bridges[randomBridgeIndex()];
}
function shouldSelectRandomly(url) {
  return extractRootDomain(url) === domain;
}
function getBridgeUrl(url) {
  if (shouldSelectRandomly(url)) {
    return selectRandomBridgeUrl();
  }
  return url;
}

// node_modules/@walletconnect/core/dist/esm/index.js
var Connector2 = class {
  constructor(opts) {
    this.protocol = "wc";
    this.version = 1;
    this._bridge = "";
    this._key = null;
    this._clientId = "";
    this._clientMeta = null;
    this._peerId = "";
    this._peerMeta = null;
    this._handshakeId = 0;
    this._handshakeTopic = "";
    this._connected = false;
    this._accounts = [];
    this._chainId = 0;
    this._networkId = 0;
    this._rpcUrl = "";
    this._eventManager = new events_default();
    this._clientMeta = getClientMeta() || opts.connectorOpts.clientMeta || null;
    this._cryptoLib = opts.cryptoLib;
    this._sessionStorage = opts.sessionStorage || new storage_default(opts.connectorOpts.storageId);
    this._qrcodeModal = opts.connectorOpts.qrcodeModal;
    this._qrcodeModalOptions = opts.connectorOpts.qrcodeModalOptions;
    this._signingMethods = [...signingMethods, ...opts.connectorOpts.signingMethods || []];
    if (!opts.connectorOpts.bridge && !opts.connectorOpts.uri && !opts.connectorOpts.session) {
      throw new Error(ERROR_MISSING_REQUIRED);
    }
    if (opts.connectorOpts.bridge) {
      this.bridge = getBridgeUrl(opts.connectorOpts.bridge);
    }
    if (opts.connectorOpts.uri) {
      this.uri = opts.connectorOpts.uri;
    }
    const session = opts.connectorOpts.session || this._getStorageSession();
    if (session) {
      this.session = session;
    }
    if (this.handshakeId) {
      this._subscribeToSessionResponse(this.handshakeId, "Session request rejected");
    }
    this._transport = opts.transport || new esm_default({
      protocol: this.protocol,
      version: this.version,
      url: this.bridge,
      subscriptions: [this.clientId]
    });
    this._subscribeToInternalEvents();
    this._initTransport();
    if (opts.connectorOpts.uri) {
      this._subscribeToSessionRequest();
    }
    if (opts.pushServerOpts) {
      this._registerPushServer(opts.pushServerOpts);
    }
  }
  set bridge(value2) {
    if (!value2) {
      return;
    }
    this._bridge = value2;
  }
  get bridge() {
    return this._bridge;
  }
  set key(value2) {
    if (!value2) {
      return;
    }
    const key2 = convertHexToArrayBuffer(value2);
    this._key = key2;
  }
  get key() {
    if (this._key) {
      const key2 = convertArrayBufferToHex(this._key, true);
      return key2;
    }
    return "";
  }
  set clientId(value2) {
    if (!value2) {
      return;
    }
    this._clientId = value2;
  }
  get clientId() {
    let clientId = this._clientId;
    if (!clientId) {
      clientId = this._clientId = uuid();
    }
    return this._clientId;
  }
  set peerId(value2) {
    if (!value2) {
      return;
    }
    this._peerId = value2;
  }
  get peerId() {
    return this._peerId;
  }
  set clientMeta(value2) {
  }
  get clientMeta() {
    let clientMeta = this._clientMeta;
    if (!clientMeta) {
      clientMeta = this._clientMeta = getClientMeta();
    }
    return clientMeta;
  }
  set peerMeta(value2) {
    this._peerMeta = value2;
  }
  get peerMeta() {
    const peerMeta = this._peerMeta;
    return peerMeta;
  }
  set handshakeTopic(value2) {
    if (!value2) {
      return;
    }
    this._handshakeTopic = value2;
  }
  get handshakeTopic() {
    return this._handshakeTopic;
  }
  set handshakeId(value2) {
    if (!value2) {
      return;
    }
    this._handshakeId = value2;
  }
  get handshakeId() {
    return this._handshakeId;
  }
  get uri() {
    const _uri = this._formatUri();
    return _uri;
  }
  set uri(value2) {
    if (!value2) {
      return;
    }
    const { handshakeTopic, bridge, key: key2 } = this._parseUri(value2);
    this.handshakeTopic = handshakeTopic;
    this.bridge = bridge;
    this.key = key2;
  }
  set chainId(value2) {
    this._chainId = value2;
  }
  get chainId() {
    const chainId = this._chainId;
    return chainId;
  }
  set networkId(value2) {
    this._networkId = value2;
  }
  get networkId() {
    const networkId = this._networkId;
    return networkId;
  }
  set accounts(value2) {
    this._accounts = value2;
  }
  get accounts() {
    const accounts = this._accounts;
    return accounts;
  }
  set rpcUrl(value2) {
    this._rpcUrl = value2;
  }
  get rpcUrl() {
    const rpcUrl = this._rpcUrl;
    return rpcUrl;
  }
  set connected(value2) {
  }
  get connected() {
    return this._connected;
  }
  set pending(value2) {
  }
  get pending() {
    return !!this._handshakeTopic;
  }
  get session() {
    return {
      connected: this.connected,
      accounts: this.accounts,
      chainId: this.chainId,
      bridge: this.bridge,
      key: this.key,
      clientId: this.clientId,
      clientMeta: this.clientMeta,
      peerId: this.peerId,
      peerMeta: this.peerMeta,
      handshakeId: this.handshakeId,
      handshakeTopic: this.handshakeTopic
    };
  }
  set session(value2) {
    if (!value2) {
      return;
    }
    this._connected = value2.connected;
    this.accounts = value2.accounts;
    this.chainId = value2.chainId;
    this.bridge = value2.bridge;
    this.key = value2.key;
    this.clientId = value2.clientId;
    this.clientMeta = value2.clientMeta;
    this.peerId = value2.peerId;
    this.peerMeta = value2.peerMeta;
    this.handshakeId = value2.handshakeId;
    this.handshakeTopic = value2.handshakeTopic;
  }
  on(event, callback) {
    const eventEmitter = {
      event,
      callback
    };
    this._eventManager.subscribe(eventEmitter);
  }
  off(event) {
    this._eventManager.unsubscribe(event);
  }
  async createInstantRequest(instantRequest) {
    this._key = await this._generateKey();
    const request = this._formatRequest({
      method: "wc_instantRequest",
      params: [
        {
          peerId: this.clientId,
          peerMeta: this.clientMeta,
          request: this._formatRequest(instantRequest)
        }
      ]
    });
    this.handshakeId = request.id;
    this.handshakeTopic = uuid();
    this._eventManager.trigger({
      event: "display_uri",
      params: [this.uri]
    });
    this.on("modal_closed", () => {
      throw new Error(ERROR_QRCODE_MODAL_USER_CLOSED);
    });
    const endInstantRequest = () => {
      this.killSession();
    };
    try {
      const result = await this._sendCallRequest(request);
      if (result) {
        endInstantRequest();
      }
      return result;
    } catch (error) {
      endInstantRequest();
      throw error;
    }
  }
  async connect(opts) {
    if (!this._qrcodeModal) {
      throw new Error(ERROR_QRCODE_MODAL_NOT_PROVIDED);
    }
    if (this.connected) {
      return {
        chainId: this.chainId,
        accounts: this.accounts
      };
    }
    await this.createSession(opts);
    return new Promise(async (resolve, reject) => {
      this.on("modal_closed", () => reject(new Error(ERROR_QRCODE_MODAL_USER_CLOSED)));
      this.on("connect", (error, payload) => {
        if (error) {
          return reject(error);
        }
        resolve(payload.params[0]);
      });
    });
  }
  async createSession(opts) {
    if (this._connected) {
      throw new Error(ERROR_SESSION_CONNECTED);
    }
    if (this.pending) {
      return;
    }
    this._key = await this._generateKey();
    const request = this._formatRequest({
      method: "wc_sessionRequest",
      params: [
        {
          peerId: this.clientId,
          peerMeta: this.clientMeta,
          chainId: opts && opts.chainId ? opts.chainId : null
        }
      ]
    });
    this.handshakeId = request.id;
    this.handshakeTopic = uuid();
    this._sendSessionRequest(request, "Session update rejected", {
      topic: this.handshakeTopic
    });
    this._eventManager.trigger({
      event: "display_uri",
      params: [this.uri]
    });
  }
  approveSession(sessionStatus) {
    if (this._connected) {
      throw new Error(ERROR_SESSION_CONNECTED);
    }
    this.chainId = sessionStatus.chainId;
    this.accounts = sessionStatus.accounts;
    this.networkId = sessionStatus.networkId || 0;
    this.rpcUrl = sessionStatus.rpcUrl || "";
    const sessionParams = {
      approved: true,
      chainId: this.chainId,
      networkId: this.networkId,
      accounts: this.accounts,
      rpcUrl: this.rpcUrl,
      peerId: this.clientId,
      peerMeta: this.clientMeta
    };
    const response = {
      id: this.handshakeId,
      jsonrpc: "2.0",
      result: sessionParams
    };
    this._sendResponse(response);
    this._connected = true;
    this._setStorageSession();
    this._eventManager.trigger({
      event: "connect",
      params: [
        {
          peerId: this.peerId,
          peerMeta: this.peerMeta,
          chainId: this.chainId,
          accounts: this.accounts
        }
      ]
    });
  }
  rejectSession(sessionError) {
    if (this._connected) {
      throw new Error(ERROR_SESSION_CONNECTED);
    }
    const message = sessionError && sessionError.message ? sessionError.message : ERROR_SESSION_REJECTED;
    const response = this._formatResponse({
      id: this.handshakeId,
      error: { message }
    });
    this._sendResponse(response);
    this._connected = false;
    this._eventManager.trigger({
      event: "disconnect",
      params: [{ message }]
    });
    this._removeStorageSession();
  }
  updateSession(sessionStatus) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    this.chainId = sessionStatus.chainId;
    this.accounts = sessionStatus.accounts;
    this.networkId = sessionStatus.networkId || 0;
    this.rpcUrl = sessionStatus.rpcUrl || "";
    const sessionParams = {
      approved: true,
      chainId: this.chainId,
      networkId: this.networkId,
      accounts: this.accounts,
      rpcUrl: this.rpcUrl
    };
    const request = this._formatRequest({
      method: "wc_sessionUpdate",
      params: [sessionParams]
    });
    this._sendSessionRequest(request, "Session update rejected");
    this._eventManager.trigger({
      event: "session_update",
      params: [
        {
          chainId: this.chainId,
          accounts: this.accounts
        }
      ]
    });
    this._manageStorageSession();
  }
  async killSession(sessionError) {
    const message = sessionError ? sessionError.message : "Session Disconnected";
    const sessionParams = {
      approved: false,
      chainId: null,
      networkId: null,
      accounts: null
    };
    const request = this._formatRequest({
      method: "wc_sessionUpdate",
      params: [sessionParams]
    });
    await this._sendRequest(request);
    this._handleSessionDisconnect(message);
  }
  async sendTransaction(tx) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const parsedTx = parseTransactionData(tx);
    const request = this._formatRequest({
      method: "eth_sendTransaction",
      params: [parsedTx]
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  async signTransaction(tx) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const parsedTx = parseTransactionData(tx);
    const request = this._formatRequest({
      method: "eth_signTransaction",
      params: [parsedTx]
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  async signMessage(params) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const request = this._formatRequest({
      method: "eth_sign",
      params
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  async signPersonalMessage(params) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    params = parsePersonalSign(params);
    const request = this._formatRequest({
      method: "personal_sign",
      params
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  async signTypedData(params) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const request = this._formatRequest({
      method: "eth_signTypedData",
      params
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  async updateChain(chainParams) {
    if (!this._connected) {
      throw new Error("Session currently disconnected");
    }
    const request = this._formatRequest({
      method: "wallet_updateChain",
      params: [chainParams]
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  unsafeSend(request, options) {
    this._sendRequest(request, options);
    this._eventManager.trigger({
      event: "call_request_sent",
      params: [{ request, options }]
    });
    return new Promise((resolve, reject) => {
      this._subscribeToResponse(request.id, (error, payload) => {
        if (error) {
          reject(error);
          return;
        }
        if (!payload) {
          throw new Error(ERROR_MISSING_JSON_RPC);
        }
        resolve(payload);
      });
    });
  }
  async sendCustomRequest(request, options) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    switch (request.method) {
      case "eth_accounts":
        return this.accounts;
      case "eth_chainId":
        return convertNumberToHex(this.chainId);
      case "eth_sendTransaction":
      case "eth_signTransaction":
        if (request.params) {
          request.params[0] = parseTransactionData(request.params[0]);
        }
        break;
      case "personal_sign":
        if (request.params) {
          request.params = parsePersonalSign(request.params);
        }
        break;
      default:
        break;
    }
    const formattedRequest = this._formatRequest(request);
    const result = await this._sendCallRequest(formattedRequest, options);
    return result;
  }
  approveRequest(response) {
    if (isJsonRpcResponseSuccess(response)) {
      const formattedResponse = this._formatResponse(response);
      this._sendResponse(formattedResponse);
    } else {
      throw new Error(ERROR_MISSING_RESULT);
    }
  }
  rejectRequest(response) {
    if (isJsonRpcResponseError(response)) {
      const formattedResponse = this._formatResponse(response);
      this._sendResponse(formattedResponse);
    } else {
      throw new Error(ERROR_MISSING_ERROR);
    }
  }
  transportClose() {
    this._transport.close();
  }
  async _sendRequest(request, options) {
    const callRequest = this._formatRequest(request);
    const encryptionPayload = await this._encrypt(callRequest);
    const topic = typeof (options === null || options === void 0 ? void 0 : options.topic) !== "undefined" ? options.topic : this.peerId;
    const payload = JSON.stringify(encryptionPayload);
    const silent = typeof (options === null || options === void 0 ? void 0 : options.forcePushNotification) !== "undefined" ? !options.forcePushNotification : isSilentPayload(callRequest);
    this._transport.send(payload, topic, silent);
  }
  async _sendResponse(response) {
    const encryptionPayload = await this._encrypt(response);
    const topic = this.peerId;
    const payload = JSON.stringify(encryptionPayload);
    const silent = true;
    this._transport.send(payload, topic, silent);
  }
  async _sendSessionRequest(request, errorMsg, options) {
    this._sendRequest(request, options);
    this._subscribeToSessionResponse(request.id, errorMsg);
  }
  _sendCallRequest(request, options) {
    this._sendRequest(request, options);
    this._eventManager.trigger({
      event: "call_request_sent",
      params: [{ request, options }]
    });
    return this._subscribeToCallResponse(request.id);
  }
  _formatRequest(request) {
    if (typeof request.method === "undefined") {
      throw new Error(ERROR_MISSING_METHOD);
    }
    const formattedRequest = {
      id: typeof request.id === "undefined" ? payloadId2() : request.id,
      jsonrpc: "2.0",
      method: request.method,
      params: typeof request.params === "undefined" ? [] : request.params
    };
    return formattedRequest;
  }
  _formatResponse(response) {
    if (typeof response.id === "undefined") {
      throw new Error(ERROR_MISSING_ID);
    }
    const baseResponse = { id: response.id, jsonrpc: "2.0" };
    if (isJsonRpcResponseError(response)) {
      const error = formatRpcError(response.error);
      const errorResponse = Object.assign(Object.assign(Object.assign({}, baseResponse), response), { error });
      return errorResponse;
    } else if (isJsonRpcResponseSuccess(response)) {
      const successResponse = Object.assign(Object.assign({}, baseResponse), response);
      return successResponse;
    }
    throw new Error(ERROR_INVALID_RESPONSE);
  }
  _handleSessionDisconnect(errorMsg) {
    const message = errorMsg || "Session Disconnected";
    if (!this._connected) {
      if (this._qrcodeModal) {
        this._qrcodeModal.close();
      }
      removeLocal(mobileLinkChoiceKey);
    }
    if (this._connected) {
      this._connected = false;
    }
    if (this._handshakeId) {
      this._handshakeId = 0;
    }
    if (this._handshakeTopic) {
      this._handshakeTopic = "";
    }
    if (this._peerId) {
      this._peerId = "";
    }
    this._eventManager.trigger({
      event: "disconnect",
      params: [{ message }]
    });
    this._removeStorageSession();
    this.transportClose();
  }
  _handleSessionResponse(errorMsg, sessionParams) {
    if (sessionParams) {
      if (sessionParams.approved) {
        if (!this._connected) {
          this._connected = true;
          if (sessionParams.chainId) {
            this.chainId = sessionParams.chainId;
          }
          if (sessionParams.accounts) {
            this.accounts = sessionParams.accounts;
          }
          if (sessionParams.peerId && !this.peerId) {
            this.peerId = sessionParams.peerId;
          }
          if (sessionParams.peerMeta && !this.peerMeta) {
            this.peerMeta = sessionParams.peerMeta;
          }
          this._eventManager.trigger({
            event: "connect",
            params: [
              {
                peerId: this.peerId,
                peerMeta: this.peerMeta,
                chainId: this.chainId,
                accounts: this.accounts
              }
            ]
          });
        } else {
          if (sessionParams.chainId) {
            this.chainId = sessionParams.chainId;
          }
          if (sessionParams.accounts) {
            this.accounts = sessionParams.accounts;
          }
          this._eventManager.trigger({
            event: "session_update",
            params: [
              {
                chainId: this.chainId,
                accounts: this.accounts
              }
            ]
          });
        }
        this._manageStorageSession();
      } else {
        this._handleSessionDisconnect(errorMsg);
      }
    } else {
      this._handleSessionDisconnect(errorMsg);
    }
  }
  async _handleIncomingMessages(socketMessage) {
    const activeTopics = [this.clientId, this.handshakeTopic];
    if (!activeTopics.includes(socketMessage.topic)) {
      return;
    }
    let encryptionPayload;
    try {
      encryptionPayload = JSON.parse(socketMessage.payload);
    } catch (error) {
      return;
    }
    const payload = await this._decrypt(encryptionPayload);
    if (payload) {
      this._eventManager.trigger(payload);
    }
  }
  _subscribeToSessionRequest() {
    this._transport.subscribe(this.handshakeTopic);
  }
  _subscribeToResponse(id2, callback) {
    this.on(`response:${id2}`, callback);
  }
  _subscribeToSessionResponse(id2, errorMsg) {
    this._subscribeToResponse(id2, (error, payload) => {
      if (error) {
        this._handleSessionResponse(error.message);
        return;
      }
      if (isJsonRpcResponseSuccess(payload)) {
        this._handleSessionResponse(errorMsg, payload.result);
      } else if (payload.error && payload.error.message) {
        this._handleSessionResponse(payload.error.message);
      } else {
        this._handleSessionResponse(errorMsg);
      }
    });
  }
  _subscribeToCallResponse(id2) {
    return new Promise((resolve, reject) => {
      this._subscribeToResponse(id2, (error, payload) => {
        if (error) {
          reject(error);
          return;
        }
        if (isJsonRpcResponseSuccess(payload)) {
          resolve(payload.result);
        } else if (payload.error && payload.error.message) {
          reject(new Error(payload.error.message));
        } else {
          reject(new Error(ERROR_INVALID_RESPONSE));
        }
      });
    });
  }
  _subscribeToInternalEvents() {
    this.on("display_uri", () => {
      if (this._qrcodeModal) {
        this._qrcodeModal.open(this.uri, () => {
          this._eventManager.trigger({
            event: "modal_closed",
            params: []
          });
        }, this._qrcodeModalOptions);
      }
    });
    this.on("connect", () => {
      if (this._qrcodeModal) {
        this._qrcodeModal.close();
      }
    });
    this.on("call_request_sent", (error, payload) => {
      const { request } = payload.params[0];
      if (isMobile() && this._signingMethods.includes(request.method)) {
        const mobileLinkUrl = getLocal(mobileLinkChoiceKey);
        if (mobileLinkUrl) {
          window.location.href = mobileLinkUrl.href;
        }
      }
    });
    this.on("wc_sessionRequest", (error, payload) => {
      if (error) {
        this._eventManager.trigger({
          event: "error",
          params: [
            {
              code: "SESSION_REQUEST_ERROR",
              message: error.toString()
            }
          ]
        });
      }
      this.handshakeId = payload.id;
      this.peerId = payload.params[0].peerId;
      this.peerMeta = payload.params[0].peerMeta;
      const internalPayload = Object.assign(Object.assign({}, payload), { method: "session_request" });
      this._eventManager.trigger(internalPayload);
    });
    this.on("wc_sessionUpdate", (error, payload) => {
      if (error) {
        this._handleSessionResponse(error.message);
      }
      this._handleSessionResponse("Session disconnected", payload.params[0]);
    });
  }
  _initTransport() {
    this._transport.on("message", (socketMessage) => this._handleIncomingMessages(socketMessage));
    this._transport.on("open", () => this._eventManager.trigger({ event: "transport_open", params: [] }));
    this._transport.on("close", () => this._eventManager.trigger({ event: "transport_close", params: [] }));
    this._transport.on("error", () => this._eventManager.trigger({
      event: "transport_error",
      params: ["Websocket connection failed"]
    }));
    this._transport.open();
  }
  _formatUri() {
    const protocol = this.protocol;
    const handshakeTopic = this.handshakeTopic;
    const version27 = this.version;
    const bridge = encodeURIComponent(this.bridge);
    const key2 = this.key;
    const uri = `${protocol}:${handshakeTopic}@${version27}?bridge=${bridge}&key=${key2}`;
    return uri;
  }
  _parseUri(uri) {
    const result = parseWalletConnectUri(uri);
    if (result.protocol === this.protocol) {
      if (!result.handshakeTopic) {
        throw Error("Invalid or missing handshakeTopic parameter value");
      }
      const handshakeTopic = result.handshakeTopic;
      if (!result.bridge) {
        throw Error("Invalid or missing bridge url parameter value");
      }
      const bridge = decodeURIComponent(result.bridge);
      if (!result.key) {
        throw Error("Invalid or missing key parameter value");
      }
      const key2 = result.key;
      return { handshakeTopic, bridge, key: key2 };
    } else {
      throw new Error(ERROR_INVALID_URI);
    }
  }
  async _generateKey() {
    if (this._cryptoLib) {
      const result = await this._cryptoLib.generateKey();
      return result;
    }
    return null;
  }
  async _encrypt(data) {
    const key2 = this._key;
    if (this._cryptoLib && key2) {
      const result = await this._cryptoLib.encrypt(data, key2);
      return result;
    }
    return null;
  }
  async _decrypt(payload) {
    const key2 = this._key;
    if (this._cryptoLib && key2) {
      const result = await this._cryptoLib.decrypt(payload, key2);
      return result;
    }
    return null;
  }
  _getStorageSession() {
    let result = null;
    if (this._sessionStorage) {
      result = this._sessionStorage.getSession();
    }
    return result;
  }
  _setStorageSession() {
    if (this._sessionStorage) {
      this._sessionStorage.setSession(this.session);
    }
  }
  _removeStorageSession() {
    if (this._sessionStorage) {
      this._sessionStorage.removeSession();
    }
  }
  _manageStorageSession() {
    if (this._connected) {
      this._setStorageSession();
    } else {
      this._removeStorageSession();
    }
  }
  _registerPushServer(pushServerOpts) {
    if (!pushServerOpts.url || typeof pushServerOpts.url !== "string") {
      throw Error("Invalid or missing pushServerOpts.url parameter value");
    }
    if (!pushServerOpts.type || typeof pushServerOpts.type !== "string") {
      throw Error("Invalid or missing pushServerOpts.type parameter value");
    }
    if (!pushServerOpts.token || typeof pushServerOpts.token !== "string") {
      throw Error("Invalid or missing pushServerOpts.token parameter value");
    }
    const pushSubscription = {
      bridge: this.bridge,
      topic: this.clientId,
      type: pushServerOpts.type,
      token: pushServerOpts.token,
      peerName: "",
      language: pushServerOpts.language || ""
    };
    this.on("connect", async (error, payload) => {
      if (error) {
        throw error;
      }
      if (pushServerOpts.peerMeta) {
        const peerName = payload.params[0].peerMeta.name;
        pushSubscription.peerName = peerName;
      }
      try {
        const response = await fetch(`${pushServerOpts.url}/new`, {
          method: "POST",
          headers: {
            Accept: "application/json",
            "Content-Type": "application/json"
          },
          body: JSON.stringify(pushSubscription)
        });
        const json = await response.json();
        if (!json.success) {
          throw Error("Failed to register in Push Server");
        }
      } catch (error2) {
        throw Error("Failed to register in Push Server");
      }
    });
  }
};
var esm_default2 = Connector2;

// node_modules/@walletconnect/iso-crypto/dist/esm/index.js
var esm_exports5 = {};
__export(esm_exports5, {
  decrypt: () => decrypt3,
  encrypt: () => encrypt2,
  generateKey: () => generateKey,
  verifyHmac: () => verifyHmac
});

// node_modules/@walletconnect/crypto/dist/esm/browser/index.js
var browser_exports = {};
__export(browser_exports, {
  AES_BROWSER_ALGO: () => AES_BROWSER_ALGO,
  AES_LENGTH: () => AES_LENGTH,
  AES_NODE_ALGO: () => AES_NODE_ALGO,
  DECRYPT_OP: () => DECRYPT_OP,
  ENCRYPT_OP: () => ENCRYPT_OP,
  ERROR_BAD_MAC: () => ERROR_BAD_MAC,
  HEX_ENC: () => HEX_ENC,
  HMAC_BROWSER: () => HMAC_BROWSER,
  HMAC_BROWSER_ALGO: () => HMAC_BROWSER_ALGO,
  HMAC_LENGTH: () => HMAC_LENGTH,
  HMAC_NODE_ALGO: () => HMAC_NODE_ALGO,
  IV_LENGTH: () => IV_LENGTH,
  KEY_LENGTH: () => KEY_LENGTH,
  LENGTH_0: () => LENGTH_0,
  LENGTH_1: () => LENGTH_1,
  LENGTH_1024: () => LENGTH_1024,
  LENGTH_128: () => LENGTH_128,
  LENGTH_16: () => LENGTH_16,
  LENGTH_256: () => LENGTH_256,
  LENGTH_32: () => LENGTH_32,
  LENGTH_512: () => LENGTH_512,
  LENGTH_64: () => LENGTH_64,
  MAC_LENGTH: () => MAC_LENGTH,
  PREFIX_LENGTH: () => PREFIX_LENGTH,
  RIPEMD160_NODE_ALGO: () => RIPEMD160_NODE_ALGO,
  SHA256_BROWSER_ALGO: () => SHA256_BROWSER_ALGO,
  SHA256_NODE_ALGO: () => SHA256_NODE_ALGO,
  SHA512_BROWSER_ALGO: () => SHA512_BROWSER_ALGO,
  SHA512_NODE_ALGO: () => SHA512_NODE_ALGO,
  SIGN_OP: () => SIGN_OP,
  UTF8_ENC: () => UTF8_ENC,
  VERIFY_OP: () => VERIFY_OP,
  aesCbcDecrypt: () => aesCbcDecrypt,
  aesCbcEncrypt: () => aesCbcEncrypt,
  assert: () => assert2,
  hmacSha256Sign: () => hmacSha256Sign,
  hmacSha256Verify: () => hmacSha256Verify,
  hmacSha512Sign: () => hmacSha512Sign,
  hmacSha512Verify: () => hmacSha512Verify,
  isConstantTime: () => isConstantTime,
  pkcs7: () => pkcs7,
  randomBytes: () => randomBytes2,
  ripemd160: () => ripemd1602,
  sha256: () => sha2563,
  sha512: () => sha5122
});

// node_modules/@walletconnect/randombytes/dist/esm/browser/index.js
var env = __toESM(require_cjs());
function randomBytes2(length) {
  const browserCrypto = env.getBrowerCrypto();
  return browserCrypto.getRandomValues(new Uint8Array(length));
}

// node_modules/@walletconnect/crypto/dist/esm/lib/browser.js
var env2 = __toESM(require_cjs());

// node_modules/@walletconnect/crypto/dist/esm/constants/length.js
var LENGTH_0 = 0;
var LENGTH_1 = 1;
var LENGTH_16 = 16;
var LENGTH_32 = 32;
var LENGTH_64 = 64;
var LENGTH_128 = 128;
var LENGTH_256 = 256;
var LENGTH_512 = 512;
var LENGTH_1024 = 1024;

// node_modules/@walletconnect/crypto/dist/esm/constants/default.js
var AES_LENGTH = LENGTH_256;
var HMAC_LENGTH = LENGTH_256;
var AES_BROWSER_ALGO = "AES-CBC";
var HMAC_BROWSER_ALGO = `SHA-${AES_LENGTH}`;
var HMAC_BROWSER = "HMAC";
var SHA256_BROWSER_ALGO = "SHA-256";
var SHA512_BROWSER_ALGO = "SHA-512";
var AES_NODE_ALGO = `aes-${AES_LENGTH}-cbc`;
var HMAC_NODE_ALGO = `sha${HMAC_LENGTH}`;
var SHA256_NODE_ALGO = "sha256";
var SHA512_NODE_ALGO = "sha512";
var RIPEMD160_NODE_ALGO = "ripemd160";
var PREFIX_LENGTH = LENGTH_1;
var KEY_LENGTH = LENGTH_32;
var IV_LENGTH = LENGTH_16;
var MAC_LENGTH = LENGTH_32;

// node_modules/@walletconnect/crypto/dist/esm/constants/encoding.js
var HEX_ENC = "hex";
var UTF8_ENC = "utf8";

// node_modules/@walletconnect/crypto/dist/esm/constants/error.js
var ERROR_BAD_MAC = "Bad MAC";

// node_modules/@walletconnect/crypto/dist/esm/constants/operations.js
var ENCRYPT_OP = "encrypt";
var DECRYPT_OP = "decrypt";
var SIGN_OP = "sign";
var VERIFY_OP = "verify";

// node_modules/@walletconnect/crypto/dist/esm/lib/browser.js
function getAlgo(type) {
  return type === AES_BROWSER_ALGO ? { length: AES_LENGTH, name: AES_BROWSER_ALGO } : {
    hash: { name: HMAC_BROWSER_ALGO },
    name: HMAC_BROWSER
  };
}
function getOps(type) {
  return type === AES_BROWSER_ALGO ? [ENCRYPT_OP, DECRYPT_OP] : [SIGN_OP, VERIFY_OP];
}
async function browserImportKey(buffer2, type = AES_BROWSER_ALGO) {
  return env2.getSubtleCrypto().importKey("raw", buffer2, getAlgo(type), true, getOps(type));
}
async function browserAesEncrypt(iv, key2, data) {
  const subtle = env2.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key2, AES_BROWSER_ALGO);
  const result = await subtle.encrypt({
    iv,
    name: AES_BROWSER_ALGO
  }, cryptoKey, data);
  return new Uint8Array(result);
}
async function browserAesDecrypt(iv, key2, data) {
  const subtle = env2.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key2, AES_BROWSER_ALGO);
  const result = await subtle.decrypt({
    iv,
    name: AES_BROWSER_ALGO
  }, cryptoKey, data);
  return new Uint8Array(result);
}
async function browserHmacSha256Sign(key2, data) {
  const subtle = env2.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key2, HMAC_BROWSER);
  const signature2 = await subtle.sign({
    length: HMAC_LENGTH,
    name: HMAC_BROWSER
  }, cryptoKey, data);
  return new Uint8Array(signature2);
}
async function browserHmacSha512Sign(key2, data) {
  const subtle = env2.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key2, HMAC_BROWSER);
  const signature2 = await subtle.sign({
    length: LENGTH_512,
    name: HMAC_BROWSER
  }, cryptoKey, data);
  return new Uint8Array(signature2);
}
async function browserSha256(data) {
  const subtle = env2.getSubtleCrypto();
  const result = await subtle.digest({
    name: SHA256_BROWSER_ALGO
  }, data);
  return new Uint8Array(result);
}
async function browserSha512(data) {
  const subtle = env2.getSubtleCrypto();
  const result = await subtle.digest({
    name: SHA512_BROWSER_ALGO
  }, data);
  return new Uint8Array(result);
}

// node_modules/@walletconnect/crypto/dist/esm/browser/aes.js
function aesCbcEncrypt(iv, key2, data) {
  return browserAesEncrypt(iv, key2, data);
}
function aesCbcDecrypt(iv, key2, data) {
  return browserAesDecrypt(iv, key2, data);
}

// node_modules/@walletconnect/crypto/dist/esm/helpers/index.js
var helpers_exports = {};
__export(helpers_exports, {
  assert: () => assert2,
  isConstantTime: () => isConstantTime,
  pkcs7: () => pkcs7
});

// node_modules/@walletconnect/crypto/dist/esm/helpers/env.js
var env_exports2 = {};
__reExport(env_exports2, __toESM(require_cjs()));

// node_modules/@walletconnect/crypto/dist/esm/helpers/index.js
__reExport(helpers_exports, env_exports2);

// node_modules/@walletconnect/crypto/dist/esm/helpers/pkcs7.js
var PADDING = [
  [16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16],
  [15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15],
  [14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14],
  [13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13],
  [12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12],
  [11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11],
  [10, 10, 10, 10, 10, 10, 10, 10, 10, 10],
  [9, 9, 9, 9, 9, 9, 9, 9, 9],
  [8, 8, 8, 8, 8, 8, 8, 8],
  [7, 7, 7, 7, 7, 7, 7],
  [6, 6, 6, 6, 6, 6],
  [5, 5, 5, 5, 5],
  [4, 4, 4, 4],
  [3, 3, 3],
  [2, 2],
  [1]
];
var pkcs7 = {
  pad(plaintext) {
    const padding2 = PADDING[plaintext.byteLength % 16 || 0];
    const result = new Uint8Array(plaintext.byteLength + padding2.length);
    result.set(plaintext);
    result.set(padding2, plaintext.byteLength);
    return result;
  },
  unpad(padded) {
    return padded.subarray(0, padded.byteLength - padded[padded.byteLength - 1]);
  }
};

// node_modules/@walletconnect/crypto/dist/esm/helpers/validators.js
function assert2(condition, message) {
  if (!condition) {
    throw new Error(message || "Assertion failed");
  }
}
function isConstantTime(arr1, arr2) {
  if (arr1.length !== arr2.length) {
    return false;
  }
  let res = 0;
  for (let i6 = 0; i6 < arr1.length; i6++) {
    res |= arr1[i6] ^ arr2[i6];
  }
  return res === 0;
}

// node_modules/@walletconnect/crypto/dist/esm/browser/hmac.js
async function hmacSha256Sign(key2, msg) {
  const result = await browserHmacSha256Sign(key2, msg);
  return result;
}
async function hmacSha256Verify(key2, msg, sig) {
  const expectedSig = await browserHmacSha256Sign(key2, msg);
  const result = isConstantTime(expectedSig, sig);
  return result;
}
async function hmacSha512Sign(key2, msg) {
  const result = await browserHmacSha512Sign(key2, msg);
  return result;
}
async function hmacSha512Verify(key2, msg, sig) {
  const expectedSig = await browserHmacSha512Sign(key2, msg);
  const result = isConstantTime(expectedSig, sig);
  return result;
}

// node_modules/@walletconnect/crypto/dist/esm/browser/sha2.js
async function sha2563(msg) {
  const result = await browserSha256(msg);
  return result;
}
async function sha5122(msg) {
  const result = await browserSha512(msg);
  return result;
}
async function ripemd1602(msg) {
  throw new Error("Not supported for Browser async methods, use sync instead!");
}

// node_modules/@walletconnect/crypto/dist/esm/browser/index.js
__reExport(browser_exports, helpers_exports);

// node_modules/@walletconnect/iso-crypto/dist/esm/index.js
async function generateKey(length) {
  const _length = (length || 256) / 8;
  const bytes = randomBytes2(_length);
  const result = convertBufferToArrayBuffer(arrayToBuffer(bytes));
  return result;
}
async function verifyHmac(payload, key2) {
  const cipherText = hexToArray(payload.data);
  const iv = hexToArray(payload.iv);
  const hmac2 = hexToArray(payload.hmac);
  const hmacHex = arrayToHex(hmac2, false);
  const unsigned = concatArrays(cipherText, iv);
  const chmac = await hmacSha256Sign(key2, unsigned);
  const chmacHex = arrayToHex(chmac, false);
  if (removeHexPrefix(hmacHex) === removeHexPrefix(chmacHex)) {
    return true;
  }
  return false;
}
async function encrypt2(data, key2, providedIv) {
  const _key = bufferToArray(convertArrayBufferToBuffer(key2));
  const ivArrayBuffer = providedIv || await generateKey(128);
  const iv = bufferToArray(convertArrayBufferToBuffer(ivArrayBuffer));
  const ivHex = arrayToHex(iv, false);
  const contentString = JSON.stringify(data);
  const content = utf8ToArray(contentString);
  const cipherText = await aesCbcEncrypt(iv, _key, content);
  const cipherTextHex = arrayToHex(cipherText, false);
  const unsigned = concatArrays(cipherText, iv);
  const hmac2 = await hmacSha256Sign(_key, unsigned);
  const hmacHex = arrayToHex(hmac2, false);
  return {
    data: cipherTextHex,
    hmac: hmacHex,
    iv: ivHex
  };
}
async function decrypt3(payload, key2) {
  const _key = bufferToArray(convertArrayBufferToBuffer(key2));
  if (!_key) {
    throw new Error("Missing key: required for decryption");
  }
  const verified = await verifyHmac(payload, _key);
  if (!verified) {
    return null;
  }
  const cipherText = hexToArray(payload.data);
  const iv = hexToArray(payload.iv);
  const buffer2 = await aesCbcDecrypt(iv, _key, cipherText);
  const utf8 = arrayToUtf8(buffer2);
  let data;
  try {
    data = JSON.parse(utf8);
  } catch (error) {
    return null;
  }
  return data;
}

// node_modules/@walletconnect/client/dist/esm/index.js
var WalletConnect = class extends esm_default2 {
  constructor(connectorOpts, pushServerOpts) {
    super({
      cryptoLib: esm_exports5,
      connectorOpts,
      pushServerOpts
    });
  }
};
var esm_default3 = WalletConnect;

// node_modules/@walletconnect/signer-connection/dist/esm/index.js
var import_qrcode_modal = __toESM(require_cjs4());
var SignerConnection = class extends IJsonRpcConnection {
  constructor(opts) {
    super();
    this.events = new import_eventemitter34.default();
    this.accounts = [];
    this.chainId = 1;
    this.pending = false;
    this.bridge = "https://bridge.walletconnect.org";
    this.qrcode = true;
    this.qrcodeModalOptions = void 0;
    this.opts = opts;
    this.chainId = (opts === null || opts === void 0 ? void 0 : opts.chainId) || this.chainId;
    this.wc = this.register(opts);
  }
  get connected() {
    return typeof this.wc !== "undefined" && this.wc.connected;
  }
  get connecting() {
    return this.pending;
  }
  get connector() {
    this.wc = this.register(this.opts);
    return this.wc;
  }
  on(event, listener) {
    this.events.on(event, listener);
  }
  once(event, listener) {
    this.events.once(event, listener);
  }
  off(event, listener) {
    this.events.off(event, listener);
  }
  removeListener(event, listener) {
    this.events.removeListener(event, listener);
  }
  async open(chainId) {
    if (this.connected) {
      this.onOpen();
      return;
    }
    return new Promise((resolve, reject) => {
      this.on("error", (err) => {
        reject(err);
      });
      this.on("open", () => {
        resolve();
      });
      this.create(chainId);
    });
  }
  async close() {
    if (typeof this.wc === "undefined")
      return;
    if (this.wc.connected) {
      this.wc.killSession();
    }
    this.onClose();
  }
  async send(payload) {
    this.wc = this.register(this.opts);
    if (!this.connected)
      await this.open();
    this.sendPayload(payload).then((res) => this.events.emit("payload", res)).catch((e6) => this.events.emit("payload", formatJsonRpcError(payload.id, e6.message)));
  }
  register(opts) {
    if (this.wc)
      return this.wc;
    this.opts = opts || this.opts;
    this.bridge = (opts === null || opts === void 0 ? void 0 : opts.connector) ? opts.connector.bridge : (opts === null || opts === void 0 ? void 0 : opts.bridge) || "https://bridge.walletconnect.org";
    this.qrcode = typeof (opts === null || opts === void 0 ? void 0 : opts.qrcode) === "undefined" || opts.qrcode !== false;
    this.chainId = typeof (opts === null || opts === void 0 ? void 0 : opts.chainId) !== "undefined" ? opts.chainId : this.chainId;
    this.qrcodeModalOptions = opts === null || opts === void 0 ? void 0 : opts.qrcodeModalOptions;
    const connectorOpts = {
      bridge: this.bridge,
      qrcodeModal: this.qrcode ? import_qrcode_modal.default : void 0,
      qrcodeModalOptions: this.qrcodeModalOptions,
      storageId: opts === null || opts === void 0 ? void 0 : opts.storageId,
      signingMethods: opts === null || opts === void 0 ? void 0 : opts.signingMethods,
      clientMeta: opts === null || opts === void 0 ? void 0 : opts.clientMeta
    };
    this.wc = typeof (opts === null || opts === void 0 ? void 0 : opts.connector) !== "undefined" ? opts.connector : new esm_default3(connectorOpts);
    if (typeof this.wc === "undefined") {
      throw new Error("Failed to register WalletConnect connector");
    }
    if (this.wc.accounts.length) {
      this.accounts = this.wc.accounts;
    }
    if (this.wc.chainId) {
      this.chainId = this.wc.chainId;
    }
    this.registerConnectorEvents();
    return this.wc;
  }
  onOpen(wc) {
    this.pending = false;
    if (wc) {
      this.wc = wc;
    }
    this.events.emit("open");
  }
  onClose() {
    this.pending = false;
    if (this.wc) {
      this.wc = void 0;
    }
    this.events.emit("close");
  }
  onError(payload, message = "Failed or Rejected Request", code = -32e3) {
    const errorPayload = {
      id: payload.id,
      jsonrpc: payload.jsonrpc,
      error: { code, message }
    };
    this.events.emit("payload", errorPayload);
    return errorPayload;
  }
  create(chainId) {
    this.wc = this.register(this.opts);
    this.chainId = chainId || this.chainId;
    if (this.connected || this.pending)
      return;
    this.pending = true;
    this.registerConnectorEvents();
    this.wc.createSession({ chainId: this.chainId }).then(() => this.events.emit("created")).catch((e6) => this.events.emit("error", e6));
  }
  registerConnectorEvents() {
    this.wc = this.register(this.opts);
    this.wc.on("connect", (err) => {
      var _a2, _b;
      if (err) {
        this.events.emit("error", err);
        return;
      }
      this.accounts = ((_a2 = this.wc) === null || _a2 === void 0 ? void 0 : _a2.accounts) || [];
      this.chainId = ((_b = this.wc) === null || _b === void 0 ? void 0 : _b.chainId) || this.chainId;
      this.onOpen();
    });
    this.wc.on("disconnect", (err) => {
      if (err) {
        this.events.emit("error", err);
        return;
      }
      this.onClose();
    });
    this.wc.on("modal_closed", () => {
      this.events.emit("error", new Error("User closed modal"));
    });
    this.wc.on("session_update", (error, payload) => {
      const { accounts, chainId } = payload.params[0];
      if (!this.accounts || accounts && this.accounts !== accounts) {
        this.accounts = accounts;
        this.events.emit("accountsChanged", accounts);
      }
      if (!this.chainId || chainId && this.chainId !== chainId) {
        this.chainId = chainId;
        this.events.emit("chainChanged", chainId);
      }
    });
  }
  async sendPayload(payload) {
    this.wc = this.register(this.opts);
    try {
      const response = await this.wc.unsafeSend(payload);
      return this.sanitizeResponse(response);
    } catch (error) {
      return this.onError(payload, error.message);
    }
  }
  sanitizeResponse(response) {
    return typeof response.error !== "undefined" && typeof response.error.code === "undefined" ? formatJsonRpcError(response.id, response.error.message) : response;
  }
};

// node_modules/@walletconnect/ethereum-provider/dist/esm/index.js
var WalletConnectProvider = class {
  constructor(opts) {
    this.events = new import_eventemitter35.default();
    this.rpc = { infuraId: opts === null || opts === void 0 ? void 0 : opts.infuraId, custom: opts === null || opts === void 0 ? void 0 : opts.rpc };
    this.signer = new JsonRpcProvider2(new SignerConnection(opts));
    const chainId = this.signer.connection.chainId || (opts === null || opts === void 0 ? void 0 : opts.chainId) || 1;
    this.http = this.setHttpProvider(chainId);
    this.registerEventListeners();
  }
  get connected() {
    return this.signer.connection.connected;
  }
  get connector() {
    return this.signer.connection.connector;
  }
  get accounts() {
    return this.signer.connection.accounts;
  }
  get chainId() {
    return this.signer.connection.chainId;
  }
  get rpcUrl() {
    var _a2;
    return ((_a2 = this.http) === null || _a2 === void 0 ? void 0 : _a2.connection).url || "";
  }
  async request(args) {
    switch (args.method) {
      case "eth_requestAccounts":
        await this.connect();
        return this.signer.connection.accounts;
      case "eth_accounts":
        return this.signer.connection.accounts;
      case "eth_chainId":
        return this.signer.connection.chainId;
      default:
        break;
    }
    if (signingMethods.includes(args.method)) {
      return this.signer.request(args);
    }
    if (typeof this.http === "undefined") {
      throw new Error(`Cannot request JSON-RPC method (${args.method}) without provided rpc url`);
    }
    return this.http.request(args);
  }
  sendAsync(args, callback) {
    this.request(args).then((response) => callback(null, response)).catch((error) => callback(error, void 0));
  }
  async enable() {
    const accounts = await this.request({ method: "eth_requestAccounts" });
    return accounts;
  }
  async connect() {
    if (!this.signer.connection.connected) {
      await this.signer.connect();
    }
  }
  async disconnect() {
    if (this.signer.connection.connected) {
      await this.signer.disconnect();
    }
  }
  on(event, listener) {
    this.events.on(event, listener);
  }
  once(event, listener) {
    this.events.once(event, listener);
  }
  removeListener(event, listener) {
    this.events.removeListener(event, listener);
  }
  off(event, listener) {
    this.events.off(event, listener);
  }
  get isWalletConnect() {
    return true;
  }
  registerEventListeners() {
    this.signer.connection.on("accountsChanged", (accounts) => {
      this.events.emit("accountsChanged", accounts);
    });
    this.signer.connection.on("chainChanged", (chainId) => {
      this.http = this.setHttpProvider(chainId);
      this.events.emit("chainChanged", chainId);
    });
    this.signer.on("disconnect", () => {
      this.events.emit("disconnect");
    });
  }
  setHttpProvider(chainId) {
    const rpcUrl = getRpcUrl(chainId, this.rpc);
    if (typeof rpcUrl === "undefined")
      return void 0;
    const http = new JsonRpcProvider2(new HttpConnection(rpcUrl));
    return http;
  }
};
var esm_default4 = WalletConnectProvider;

// node_modules/wagmi-core/connectors/walletConnect/dist/wagmi-core-connectors-walletConnect.esm.js
var import_utils31 = __toESM(require_utils2());
var import_eventemitter36 = __toESM(require_eventemitter3());
function _classPrivateMethodInitSpec(obj, privateSet) {
  _checkPrivateRedeclaration(obj, privateSet);
  privateSet.add(obj);
}
function _classPrivateMethodGet(receiver, privateSet, fn2) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn2;
}
var switchChainAllowedRegex = /(rainbow)/i;
var _provider3 = /* @__PURE__ */ new WeakMap();
var _switchChain = /* @__PURE__ */ new WeakSet();
var WalletConnectConnector = class extends Connector {
  constructor(config2) {
    super(config2);
    _classPrivateMethodInitSpec(this, _switchChain);
    _defineProperty(this, "id", "walletConnect");
    _defineProperty(this, "name", "WalletConnect");
    _defineProperty(this, "ready", true);
    _classPrivateFieldInitSpec(this, _provider3, {
      writable: true,
      value: void 0
    });
    _defineProperty(this, "onAccountsChanged", (accounts) => {
      if (accounts.length === 0)
        this.emit("disconnect");
      else
        this.emit("change", {
          account: (0, import_utils31.getAddress)(accounts[0])
        });
    });
    _defineProperty(this, "onChainChanged", (chainId) => {
      const id2 = normalizeChainId(chainId);
      const unsupported = this.isChainUnsupported(id2);
      this.emit("change", {
        chain: {
          id: id2,
          unsupported
        }
      });
    });
    _defineProperty(this, "onDisconnect", () => {
      this.emit("disconnect");
    });
  }
  async connect() {
    try {
      var _provider$connector$p, _provider$connector, _provider$connector$p2;
      const provider = this.getProvider(true);
      provider.on("accountsChanged", this.onAccountsChanged);
      provider.on("chainChanged", this.onChainChanged);
      provider.on("disconnect", this.onDisconnect);
      const accounts = await provider.enable();
      const account = (0, import_utils31.getAddress)(accounts[0]);
      const id2 = await this.getChainId();
      const unsupported = this.isChainUnsupported(id2);
      const walletName = (_provider$connector$p = (_provider$connector = provider.connector) === null || _provider$connector === void 0 ? void 0 : (_provider$connector$p2 = _provider$connector.peerMeta) === null || _provider$connector$p2 === void 0 ? void 0 : _provider$connector$p2.name) !== null && _provider$connector$p !== void 0 ? _provider$connector$p : "";
      if (switchChainAllowedRegex.test(walletName))
        this.switchChain = _classPrivateMethodGet(this, _switchChain, _switchChain2);
      return {
        account,
        chain: {
          id: id2,
          unsupported
        },
        provider: new Web3Provider(provider)
      };
    } catch (error) {
      if (/user closed modal/i.test(error.message))
        throw new UserRejectedRequestError();
      throw error;
    }
  }
  async disconnect() {
    const provider = this.getProvider();
    await provider.disconnect();
    provider.removeListener("accountsChanged", this.onAccountsChanged);
    provider.removeListener("chainChanged", this.onChainChanged);
    provider.removeListener("disconnect", this.onDisconnect);
    typeof localStorage !== "undefined" && localStorage.removeItem("walletconnect");
  }
  async getAccount() {
    const provider = this.getProvider();
    const accounts = provider.accounts;
    return (0, import_utils31.getAddress)(accounts[0]);
  }
  async getChainId() {
    const provider = this.getProvider();
    const chainId = normalizeChainId(provider.chainId);
    return chainId;
  }
  getProvider(create) {
    if (!_classPrivateFieldGet(this, _provider3) || create)
      _classPrivateFieldSet(this, _provider3, new esm_default4(this.options));
    return _classPrivateFieldGet(this, _provider3);
  }
  async getSigner() {
    const provider = this.getProvider();
    const account = await this.getAccount();
    return new Web3Provider(provider).getSigner(account);
  }
  async isAuthorized() {
    try {
      const account = await this.getAccount();
      return !!account;
    } catch {
      return false;
    }
  }
};
async function _switchChain2(chainId) {
  const provider = this.getProvider();
  const id2 = (0, import_utils31.hexValue)(chainId);
  try {
    await provider.request({
      method: "wallet_switchEthereumChain",
      params: [{
        chainId: id2
      }]
    });
    const chains = [...this.chains, ...allChains];
    return chains.find((x6) => x6.id === chainId);
  } catch (error) {
    const message = typeof error === "string" ? error : error === null || error === void 0 ? void 0 : error.message;
    if (/user rejected request/i.test(message))
      throw new UserRejectedRequestError();
    else
      throw new SwitchChainError();
  }
}

// node_modules/@thirdweb-dev/react/dist/index.mjs
var import_react13 = __toESM(require_react(), 1);

// node_modules/detect-browser/es/index.js
var __spreadArray = function(to2, from2, pack3) {
  if (pack3 || arguments.length === 2)
    for (var i6 = 0, l6 = from2.length, ar3; i6 < l6; i6++) {
      if (ar3 || !(i6 in from2)) {
        if (!ar3)
          ar3 = Array.prototype.slice.call(from2, 0, i6);
        ar3[i6] = from2[i6];
      }
    }
  return to2.concat(ar3 || Array.prototype.slice.call(from2));
};
var BrowserInfo2 = function() {
  function BrowserInfo3(name2, version27, os) {
    this.name = name2;
    this.version = version27;
    this.os = os;
    this.type = "browser";
  }
  return BrowserInfo3;
}();
var NodeInfo2 = function() {
  function NodeInfo3(version27) {
    this.version = version27;
    this.type = "node";
    this.name = "node";
    this.os = process.platform;
  }
  return NodeInfo3;
}();
var SearchBotDeviceInfo2 = function() {
  function SearchBotDeviceInfo3(name2, version27, os, bot) {
    this.name = name2;
    this.version = version27;
    this.os = os;
    this.bot = bot;
    this.type = "bot-device";
  }
  return SearchBotDeviceInfo3;
}();
var BotInfo2 = function() {
  function BotInfo3() {
    this.type = "bot";
    this.bot = true;
    this.name = "bot";
    this.version = null;
    this.os = null;
  }
  return BotInfo3;
}();
var ReactNativeInfo2 = function() {
  function ReactNativeInfo3() {
    this.type = "react-native";
    this.name = "react-native";
    this.version = null;
    this.os = null;
  }
  return ReactNativeInfo3;
}();
var SEARCHBOX_UA_REGEX2 = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX2 = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS2 = 3;
var userAgentRules2 = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", SEARCHBOX_UA_REGEX2]
];
var operatingSystemRules2 = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function detect2(userAgent) {
  if (!!userAgent) {
    return parseUserAgent2(userAgent);
  }
  if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return new ReactNativeInfo2();
  }
  if (typeof navigator !== "undefined") {
    return parseUserAgent2(navigator.userAgent);
  }
  return getNodeVersion2();
}
function matchUserAgent2(ua2) {
  return ua2 !== "" && userAgentRules2.reduce(function(matched, _a2) {
    var browser = _a2[0], regex = _a2[1];
    if (matched) {
      return matched;
    }
    var uaMatch = regex.exec(ua2);
    return !!uaMatch && [browser, uaMatch];
  }, false);
}
function parseUserAgent2(ua2) {
  var matchedRule = matchUserAgent2(ua2);
  if (!matchedRule) {
    return null;
  }
  var name2 = matchedRule[0], match = matchedRule[1];
  if (name2 === "searchbot") {
    return new BotInfo2();
  }
  var versionParts = match[1] && match[1].split(".").join("_").split("_").slice(0, 3);
  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS2) {
      versionParts = __spreadArray(__spreadArray([], versionParts, true), createVersionParts2(REQUIRED_VERSION_PARTS2 - versionParts.length), true);
    }
  } else {
    versionParts = [];
  }
  var version27 = versionParts.join(".");
  var os = detectOS3(ua2);
  var searchBotMatch = SEARCHBOT_OS_REGEX2.exec(ua2);
  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo2(name2, version27, os, searchBotMatch[1]);
  }
  return new BrowserInfo2(name2, version27, os);
}
function detectOS3(ua2) {
  for (var ii3 = 0, count2 = operatingSystemRules2.length; ii3 < count2; ii3++) {
    var _a2 = operatingSystemRules2[ii3], os = _a2[0], regex = _a2[1];
    var match = regex.exec(ua2);
    if (match) {
      return os;
    }
  }
  return null;
}
function getNodeVersion2() {
  var isNode3 = typeof process !== "undefined" && process.version;
  return isNode3 ? new NodeInfo2(process.version.slice(1)) : null;
}
function createVersionParts2(count2) {
  var output = [];
  for (var ii3 = 0; ii3 < count2; ii3++) {
    output.push("0");
  }
  return output;
}

// node_modules/@thirdweb-dev/react/dist/index.mjs
var import_lite = __toESM(require_lite(), 1);
var import_react14 = __toESM(require_react(), 1);
var import_react15 = __toESM(require_react(), 1);

// node_modules/react-cool-dimensions/dist/index.esm.js
var import_react10 = __toESM(require_react());
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var useLatest = function(val) {
  var ref = (0, import_react10.useRef)(val);
  ref.current = val;
  return ref;
};
var observerErr = "\u{1F4A1} react-cool-dimensions: the browser doesn't support Resize Observer, please use polyfill: https://github.com/wellyshen/react-cool-dimensions#resizeobserver-polyfill";
var borderBoxWarn = "\u{1F4A1} react-cool-dimensions: the browser doesn't support border-box size, fallback to content-box size. Please see: https://github.com/wellyshen/react-cool-dimensions#border-box-size-measurement";
var getCurrentBreakpoint = function getCurrentBreakpoint2(bps, w8) {
  var curBp = "";
  var max2 = -1;
  Object.keys(bps).forEach(function(key2) {
    var val = bps[key2];
    if (w8 >= val && val > max2) {
      curBp = key2;
      max2 = val;
    }
  });
  return curBp;
};
var useDimensions = function useDimensions2(_temp) {
  var _ref = _temp === void 0 ? {} : _temp, useBorderBoxSize = _ref.useBorderBoxSize, breakpoints = _ref.breakpoints, updateOnBreakpointChange = _ref.updateOnBreakpointChange, shouldUpdate = _ref.shouldUpdate, onResize = _ref.onResize, polyfill = _ref.polyfill;
  var _useState = (0, import_react10.useState)({
    currentBreakpoint: "",
    width: 0,
    height: 0
  }), state = _useState[0], setState = _useState[1];
  var prevSizeRef = (0, import_react10.useRef)({});
  var prevBreakpointRef = (0, import_react10.useRef)();
  var observerRef = (0, import_react10.useRef)();
  var warnedRef = (0, import_react10.useRef)(false);
  var ref = (0, import_react10.useRef)();
  var onResizeRef = useLatest(onResize);
  var shouldUpdateRef = useLatest(shouldUpdate);
  var unobserve = (0, import_react10.useCallback)(function() {
    if (observerRef.current)
      observerRef.current.disconnect();
  }, []);
  var observe = (0, import_react10.useCallback)(function(element) {
    if (element && element !== ref.current) {
      unobserve();
      ref.current = element;
    }
    if (observerRef.current && ref.current)
      observerRef.current.observe(ref.current);
  }, [unobserve]);
  (0, import_react10.useEffect)(function() {
    if ((!("ResizeObserver" in window) || !("ResizeObserverEntry" in window)) && !polyfill) {
      console.error(observerErr);
      return function() {
        return null;
      };
    }
    var raf = null;
    observerRef.current = new (polyfill || ResizeObserver)(function(_ref2) {
      var entry = _ref2[0];
      raf = requestAnimationFrame(function() {
        var contentBoxSize = entry.contentBoxSize, borderBoxSize = entry.borderBoxSize, contentRect = entry.contentRect;
        var boxSize = contentBoxSize;
        if (useBorderBoxSize) {
          if (borderBoxSize) {
            boxSize = borderBoxSize;
          } else if (!warnedRef.current) {
            console.warn(borderBoxWarn);
            warnedRef.current = true;
          }
        }
        boxSize = Array.isArray(boxSize) ? boxSize[0] : boxSize;
        var width = boxSize ? boxSize.inlineSize : contentRect.width;
        var height = boxSize ? boxSize.blockSize : contentRect.height;
        if (width === prevSizeRef.current.width && height === prevSizeRef.current.height)
          return;
        prevSizeRef.current = {
          width,
          height
        };
        var e6 = {
          currentBreakpoint: "",
          width,
          height,
          entry,
          observe,
          unobserve
        };
        if (breakpoints) {
          e6.currentBreakpoint = getCurrentBreakpoint(breakpoints, width);
          if (e6.currentBreakpoint !== prevBreakpointRef.current) {
            if (onResizeRef.current)
              onResizeRef.current(e6);
            prevBreakpointRef.current = e6.currentBreakpoint;
          }
        } else if (onResizeRef.current) {
          onResizeRef.current(e6);
        }
        var next = {
          currentBreakpoint: e6.currentBreakpoint,
          width,
          height,
          entry
        };
        if (shouldUpdateRef.current && !shouldUpdateRef.current(next))
          return;
        if (!shouldUpdateRef.current && breakpoints && updateOnBreakpointChange) {
          setState(function(prev) {
            return prev.currentBreakpoint !== next.currentBreakpoint ? next : prev;
          });
          return;
        }
        setState(next);
      });
    });
    observe();
    return function() {
      unobserve();
      if (raf)
        cancelAnimationFrame(raf);
    };
  }, [
    JSON.stringify(breakpoints),
    useBorderBoxSize,
    observe,
    unobserve,
    updateOnBreakpointChange
  ]);
  return _extends({}, state, {
    observe,
    unobserve
  });
};
var index_esm_default = useDimensions;

// node_modules/@thirdweb-dev/react/dist/index.mjs
var import_react16 = __toESM(require_react(), 1);
var ve = { [T.Mainnet]: "https://safe-transaction.mainnet.gnosis.io", [T.Avalanche]: "https://safe-transaction.avalanche.gnosis.io", [T.Polygon]: "https://safe-transaction.polygon.gnosis.io", [T.Goerli]: "https://safe-transaction.goerli.gnosis.io", [T.Rinkeby]: "https://safe-transaction.rinkeby.gnosis.io" };
var we2 = typeof window > "u";
var q7 = class extends Connector {
  constructor(t6) {
    var n4;
    t6.chains = (n4 = t6.chains) == null ? void 0 : n4.filter((r6) => r6.id in ve);
    super(s(r({}, t6), { options: void 0 }));
    __publicField(this, "id", "gnosis");
    __publicField(this, "ready", we2);
    __publicField(this, "name", "Gnosis Safe");
    we2 || (this.ready = true);
  }
  async connect() {
    this.safeSigner = await this.createSafeSigner();
    let t6 = await this.getAccount(), n4 = await this.getProvider(), r6 = await this.getChainId();
    return { account: t6, provider: n4, chain: { id: r6, unsupported: this.isChainUnsupported(r6) } };
  }
  async createSafeSigner() {
    var w8, v9, P5;
    let t6 = await ((w8 = this.previousConnector) == null ? void 0 : w8.getSigner()), n4 = (v9 = this.config) == null ? void 0 : v9.safeAddress, r6 = (P5 = this.config) == null ? void 0 : P5.safeChainId;
    invariant(t6, "cannot create Gnosis Safe signer without a personal signer");
    let o6 = await t6.getChainId();
    invariant(o6 === r6, "chainId of personal signer has to match safe chainId"), invariant(n4, "safeConfig.safeAddress is required, did you forget to call setSafeConfig?"), invariant(r6, "safeConfig.safeChainId is required, did you forget to call setSafeConfig?");
    let a5 = ve[r6];
    invariant(a5, "Chain not supported");
    let [s6, c5, m6] = await Promise.all([Promise.resolve().then(() => z(u("./src-L46Y4LGI.mjs"))), Promise.resolve().then(() => z(u("./src-3LIBNX6X.mjs"))), Promise.resolve().then(() => z(u("./src-W6GGQ235.mjs")))]), g7 = new m6.default({ ethers: ethers_exports, signer: t6 }), p7 = await c5.default.create({ ethAdapter: g7, safeAddress: n4 }), h6 = new s6.SafeService(a5);
    return new s6.SafeEthersSigner(p7, h6, t6.provider);
  }
  async disconnect() {
    this.config = void 0, this.safeSigner = void 0, this.previousConnector = void 0;
  }
  async getAccount() {
    return await (await this.getSigner()).getAddress();
  }
  async getChainId() {
    return (await this.getSigner()).getChainId();
  }
  async getProvider() {
    return (await this.getSigner()).provider;
  }
  async getSigner() {
    return this.safeSigner || (this.safeSigner = await this.createSafeSigner()), this.safeSigner;
  }
  async isAuthorized() {
    try {
      return !!await this.getAccount();
    } catch {
      return false;
    }
  }
  onAccountsChanged(t6) {
    t6.length === 0 ? this.emit("disconnect") : this.emit("change", { account: utils_exports.getAddress(t6[0]) });
  }
  isChainUnsupported(t6) {
    var n4;
    return (n4 = this.config) != null && n4.safeChainId ? t6 === this.config.safeChainId : false;
  }
  onChainChanged(t6) {
    let n4 = normalizeChainId(t6), r6 = this.isChainUnsupported(n4);
    this.emit("change", { chain: { id: n4, unsupported: r6 } });
  }
  onDisconnect() {
    this.emit("disconnect");
  }
  setConfiguration(t6, n4) {
    this.previousConnector = t6, this.config = n4;
  }
};
t(q7, "GnosisSafeConnector");
var oe2 = typeof window > "u";
var G2 = class extends Connector {
  constructor(t6) {
    super(s(r({}, t6), { options: t6 == null ? void 0 : t6.options }));
    __publicField(this, "id", "magic");
    __publicField(this, "name", "Magic");
    __publicField(this, "ready", oe2);
    if (this.options = t6.options, !oe2) {
      if (this.ready = true, this.options.doNotAutoConnect || !this.getConfiguration())
        return;
      this.connect(true);
    }
  }
  getConfiguration() {
    if (oe2)
      return;
    let t6 = window.localStorage.getItem("-magic-link:configuration");
    return t6 && (this.configuration = JSON.parse(t6)), this.configuration;
  }
  async connect(t6) {
    let c5 = this.options, { apiKey: n4, doNotAutoConnect: r6, rpcUrls: o6 } = c5, a5 = v(c5, ["apiKey", "doNotAutoConnect", "rpcUrls"]), s6 = this.getConfiguration();
    try {
      return invariant(s6, "did you forget to set the configuration via: setConfiguration()?"), t6 && (s6.showUI = false), Promise.resolve().then(() => z(u("./es-4ZYHO6WY.mjs"))).then(async (m6) => {
        this.magic = new m6.Magic(n4, a5), await this.magic.auth.loginWithMagicLink(s6);
        let g7 = this.getProvider();
        g7.on && (g7.on("accountsChanged", this.onAccountsChanged), g7.on("chainChanged", this.onChainChanged), g7.on("disconnect", this.onDisconnect));
        let p7 = await this.getAccount(), h6 = await this.getChainId();
        return { account: p7, provider: g7, chain: { id: h6, unsupported: this.isChainUnsupported(h6) } };
      });
    } catch (m6) {
      if (!t6)
        throw m6;
      return { account: void 0, provider: void 0, chain: void 0 };
    }
  }
  async disconnect() {
    let t6 = this.getProvider();
    t6 != null && t6.removeListener && (t6.removeListener("accountsChanged", this.onAccountsChanged), t6.removeListener("chainChanged", this.onChainChanged), t6.removeListener("disconnect", this.onDisconnect)), this.setConfiguration(void 0);
  }
  async switchChain(t6) {
    invariant(!this.isChainUnsupported(t6), "chain is not supported");
    let n4 = this.getProvider();
    return n4 != null && n4.removeListener && (n4.removeListener("accountsChanged", this.onAccountsChanged), n4.removeListener("chainChanged", this.onChainChanged), n4.removeListener("disconnect", this.onDisconnect)), this.options.network = { chainId: t6, rpcUrl: this.options.rpcUrls[t6] }, await this.connect(), this.onChainChanged(t6), this.chains.find((r6) => r6.id === t6);
  }
  async getAccount() {
    return await (await this.getSigner()).getAddress();
  }
  async getChainId() {
    return await (await this.getSigner()).getChainId();
  }
  getProvider() {
    return invariant(this.magic, "connector is not initialized"), new lib_exports21.Web3Provider(this.magic.rpcProvider);
  }
  async getSigner() {
    return this.magic || await this.connect(), this.getProvider().getSigner();
  }
  async isAuthorized() {
    try {
      return !!await this.getAccount();
    } catch {
      return false;
    }
  }
  onAccountsChanged(t6) {
    t6.length === 0 ? this.emit("disconnect") : this.emit("change", { account: utils_exports.getAddress(t6[0]) });
  }
  isChainUnsupported(t6) {
    return !this.chains.some((n4) => n4.id === t6);
  }
  onChainChanged(t6) {
    let n4 = normalizeChainId(t6), r6 = this.isChainUnsupported(n4);
    this.emit("change", { chain: { id: n4, unsupported: r6 } });
  }
  onDisconnect() {
    this.emit("disconnect");
  }
  setConfiguration(t6) {
    t6 ? (this.configuration = t6, window.localStorage.setItem("-magic-link:configuration", JSON.stringify(t6))) : (this.configuration = void 0, window.localStorage.removeItem("-magic-link:configuration"));
  }
};
t(G2, "MagicConnector");
var ut2 = { mainnet: { id: T.Mainnet, name: "Mainnet", nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 }, rpcUrls: ["https://mainnet.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161"], blockExplorers: [{ name: "Etherscan", url: "https://etherscan.io" }] }, rinkeby: { id: T.Rinkeby, name: "Rinkeby", nativeCurrency: { name: "Rinkeby Ether", symbol: "rETH", decimals: 18 }, rpcUrls: ["https://rinkeby.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161"], blockExplorers: [{ name: "Etherscan", url: "https://rinkeby.etherscan.io" }], testnet: true }, goerli: { id: T.Goerli, name: "Goerli", nativeCurrency: { name: "Goerli Ether", symbol: "gETH", decimals: 18 }, rpcUrls: ["https://goerli.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161"], blockExplorers: [{ name: "Etherscan", url: "https://goerli.etherscan.io" }], testnet: true }, polygonMainnet: { id: T.Polygon, name: "Polygon Mainnet", nativeCurrency: { name: "Matic", symbol: "MATIC", decimals: 18 }, rpcUrls: ["https://polygon-rpc.com", "https://rpc-mainnet.matic.network", "https://matic-mainnet.chainstacklabs.com", "https://rpc-mainnet.maticvigil.com", "https://rpc-mainnet.matic.quiknode.pro", "https://matic-mainnet-full-rpc.bwarelabs.com"], blockExplorers: [{ name: "Polygonscan", url: "https://polygonscan.com" }] }, polygonTestnetMumbai: { id: T.Mumbai, name: "Polygon Testnet Mumbai", nativeCurrency: { name: "Matic", symbol: "MATIC", decimals: 18 }, rpcUrls: ["https://matic-mumbai.chainstacklabs.com", "https://rpc-mumbai.maticvigil.com", "https://matic-testnet-archive-rpc.bwarelabs.com"], blockExplorers: [{ name: "Polygonscan", url: "https://mumbai.polygonscan.com" }], testnet: true }, avalanche: { id: T.Avalanche, name: "Avalanche", nativeCurrency: { name: "AVAX", symbol: "AVAX", decimals: 18 }, rpcUrls: ["https://api.avax.network/ext/bc/C/rpc", "https://rpc.ankr.com/avalanche"], blockExplorers: [{ name: "SnowTrace", url: "https://snowtrace.io/" }], testnet: false }, fantom: { id: T.Fantom, name: "Fantom Opera", nativeCurrency: { name: "Fantom", symbol: "FTM", decimals: 18 }, rpcUrls: ["https://rpc.ftm.tools"], blockExplorerUrls: [{ name: "FTMScan", url: "https://ftmscan.com/" }], testnet: false } };
var J3 = Object.values(ut2);
function Se() {
  var g7, p7, h6, w8, v9;
  let [e6, t6] = useSigner(), [n4] = useAccount(), [r6] = useNetwork(), o6 = (0, import_react11.useRef)(null), a5 = (g7 = n4.data) == null ? void 0 : g7.address, s6 = (p7 = r6.data.chain) == null ? void 0 : p7.id, c5 = be2((h6 = n4.data) == null ? void 0 : h6.address), m6 = be2((v9 = (w8 = r6.data) == null ? void 0 : w8.chain) == null ? void 0 : v9.id);
  return (0, import_react11.useEffect)(() => {
    if (a5 !== c5 || s6 !== m6)
      if (o6.current)
        o6.current = t6().finally(() => {
          o6.current = null;
        });
      else
        return;
  }, [a5, s6, c5, m6]), Signer.isSigner(e6.data) ? e6.data : void 0;
}
t(Se, "useSigner");
function be2(e6) {
  let t6 = (0, import_react11.useRef)();
  return (0, import_react11.useEffect)(() => {
    t6.current = e6;
  }, [e6]), t6.current;
}
t(be2, "usePrevious");
function Y3() {
  return Y3 = Object.assign || function(e6) {
    for (var t6 = 1; t6 < arguments.length; t6++) {
      var n4 = arguments[t6];
      for (var r6 in n4)
        Object.prototype.hasOwnProperty.call(n4, r6) && (e6[r6] = n4[r6]);
    }
    return e6;
  }, Y3.apply(this, arguments);
}
t(Y3, "_extends");
var At = J3.reduce((e6, t6) => s(r({}, e6), { [t6.id]: t6.rpcUrls[0] }), {});
var St = { name: "thirdweb powered dApp" };
var Et2 = ["metamask", "walletConnect", "walletLink"];
var Fn2 = t(({ sdkOptions: e6, chainRpc: t6 = At, supportedChains: n4 = J3.map((p7) => p7.id), walletConnectors: r6 = Et2, dAppMeta: o6 = St, desiredChainId: a5, storageInterface: s6, queryClient: c5, autoConnect: m6 = true, children: g7 }) => {
  let p7 = (0, import_react12.useMemo)(() => n4.map((y5) => typeof y5 == "number" ? J3.find((E5) => E5.id === y5) : y5).filter((y5) => y5 !== void 0), [n4]), h6 = (0, import_react12.useMemo)(() => p7.reduce((y5, E5) => (y5[E5.id] = E5.id in t6 && t6[E5.id] || E5.rpcUrls[0], y5), {}), [t6, p7]), w8 = (0, import_react12.useMemo)(() => {
    let y5 = { name: o6.name, url: o6.url || "", icons: [o6.logoUrl || ""], description: o6.description || "" }, E5 = { appName: o6.name, appLogoUrl: o6.logoUrl, darkMode: o6.isDarkMode };
    return { autoConnect: m6, connectorStorageKey: "tw:provider:connectors", connectors: ({ chainId: U3 }) => r6.map((f7) => {
      if (typeof f7 == "string" && (f7 === "injected" || f7 === "metamask") || typeof f7 == "object" && (f7.name === "injected" || f7.name === "metamask"))
        return new InjectedConnector({ options: typeof f7 == "string" ? { shimDisconnect: true, shimChainChangedDisconnect: true } : f7.options, chains: p7 });
      if (typeof f7 == "string" && f7 === "walletConnect" || typeof f7 == "object" && f7.name === "walletConnect")
        return new WalletConnectConnector({ options: typeof f7 == "string" ? { chainId: U3, rpc: h6, clientMeta: y5, qrcode: true } : r({ chainId: U3, rpc: h6, clientMeta: y5, qrcode: true }, f7.options), chains: p7 });
      if (typeof f7 == "string" && (f7 === "coinbase" || f7 === "walletLink") || typeof f7 == "object" && (f7.name === "coinbase" || f7.name === "walletLink")) {
        let Z3 = h6[U3 || a5 || 1];
        return new CoinbaseWalletConnector({ chains: p7, options: typeof f7 == "string" ? s(r({}, E5), { jsonRpcUrl: Z3 }) : r(s(r({}, E5), { jsonRpcUrl: Z3 }), f7.options) });
      }
      if (typeof f7 == "object" && f7.name === "magic") {
        let Z3 = h6[U3 || a5 || 1];
        return new G2({ chains: p7, options: s(r({}, f7.options), { network: { rpcUrl: Z3, chainId: a5 || 1 }, rpcUrls: h6 }) });
      }
      return typeof f7 == "string" && f7 === "gnosis" || typeof f7 == "object" && f7.name === "gnosis" ? new q7({ chains: p7 }) : null;
    }).filter((f7) => f7 !== null) };
  }, [r6, p7, o6]), v9 = h6[a5 || -1], P5 = (0, import_react12.useMemo)(() => {
    var E5;
    let y5 = e6;
    return s(r({}, y5), { readonlySettings: s(r({}, (y5 == null ? void 0 : y5.readonlySettings) || {}), { rpcUrl: (E5 = y5 == null ? void 0 : y5.readonlySettings) != null && E5.rpcUrl ? y5.readonlySettings.rpcUrl : v9 }) });
  }, [e6, v9]), L5 = (0, import_react12.useMemo)(() => c5 || new QueryClient(), [c5]);
  return import_react12.default.createElement(QueryClientProvider, { client: L5 }, import_react12.default.createElement(Provider2, Y3({}, w8), import_react12.default.createElement(Tt2, { desiredChainId: a5, sdkOptions: P5, storageInterface: s6 }, g7)));
}, "ThirdwebProvider");
var Tt2 = t((n4) => {
  var r6 = n4, { children: e6 } = r6, t6 = v(r6, ["children"]);
  let o6 = useProvider(), a5 = Se();
  return import_react12.default.createElement(Pt2, Y3({ signer: a5, provider: o6 }, t6), e6);
}, "ThirdwebSDKProviderWagmiWrapper");
var ee2 = (0, import_react12.createContext)({ desiredChainId: -1 });
var Pt2 = t(({ sdkOptions: e6, desiredChainId: t6, storageInterface: n4, provider: r6, signer: o6, children: a5 }) => {
  let s6 = (0, import_react12.useMemo)(() => {
    if (!t6 || typeof window > "u")
      return;
    let m6 = new g0(r6, e6, n4);
    return m6._chainId = t6, m6;
  }, [r6, e6, n4, t6]);
  (0, import_react12.useEffect)(() => {
    o6 && s6 && s6._chainId === t6 && s6.updateSignerOrProvider(o6);
  }, [o6, s6, t6]);
  let c5 = (0, import_react12.useMemo)(() => ({ sdk: s6, desiredChainId: t6 || -1, _inProvider: true }), [s6]);
  return import_react12.default.createElement(ee2.Provider, { value: c5 }, a5);
}, "ThirdwebSDKProvider");
function _7() {
  let e6 = import_react12.default.useContext(ee2);
  return invariant(e6._inProvider, "useSDK must be called from within a ThirdwebProvider, did you forget to wrap your app in a <ThirdwebProvider />?"), e6.sdk;
}
t(_7, "useSDK");
function Ee() {
  let e6 = import_react12.default.useContext(ee2);
  return invariant(e6._inProvider, "useDesiredChainId must be called from within a ThirdwebProvider, did you forget to wrap your app in a <ThirdwebProvider />?"), e6.desiredChainId;
}
t(Ee, "useDesiredChainId");
function M5() {
  var t6;
  let e6 = import_react12.default.useContext(ee2);
  return invariant(e6._inProvider, "useActiveChainId must be called from within a ThirdwebProvider, did you forget to wrap your app in a <ThirdwebProvider />?"), (t6 = e6.sdk) == null ? void 0 : t6._chainId;
}
t(M5, "useActiveChainId");
function A7(e6, t6) {
  let n4 = _7();
  if (!(!n4 || !t6 || !e6))
    return n4.getBuiltInContract(t6, e6);
}
t(A7, "useBuiltinContract");
function Kn2(e6) {
  return A7("edition-drop", e6);
}
t(Kn2, "useEditionDrop");
function Vn(e6) {
  return A7("edition", e6);
}
t(Vn, "useEdition");
function zn2(e6) {
  return A7("nft-drop", e6);
}
t(zn2, "useNFTDrop");
function $n2(e6) {
  return A7("marketplace", e6);
}
t($n2, "useMarketplace");
function ei(e6) {
  return A7("nft-collection", e6);
}
t(ei, "useNFTCollection");
function ii2(e6) {
  return A7("pack", e6);
}
t(ii2, "usePack");
function ai(e6) {
  return A7("token", e6);
}
t(ai, "useToken");
function ci2(e6) {
  return A7("token-drop", e6);
}
t(ci2, "useTokenDrop");
function pi2(e6) {
  return A7("vote", e6);
}
t(pi2, "useVote");
function hi(e6) {
  return A7("split", e6);
}
t(hi, "useSplit");
function N6() {
  return useConnect();
}
t(N6, "useConnect");
function Li(e6) {
  let t6 = r({ reconnectAfterGnosis: true }, e6), [, n4] = N6(), [r6, o6] = useAccount();
  return async () => {
    var s6;
    let a5 = ((s6 = r6.data) == null ? void 0 : s6.connector) instanceof q7 && r6.data.connector.previousConnector || void 0;
    if (t6.reconnectAfterGnosis && a5)
      try {
        return await n4(a5);
      } catch (c5) {
        return console.error("failed to re-connect to previous connector", c5), o6();
      }
    return o6();
  };
}
t(Li, "useDisconnect");
function se() {
  var t6;
  let [e6] = useAccount();
  return (t6 = e6.data) == null ? void 0 : t6.address;
}
t(se, "useAddress");
function Wi2(e6, t6, n4) {
  return (0, import_react13.useMemo)(() => new g0(e6, s(r({}, t6), { readonlySettings: s(r({}, t6 == null ? void 0 : t6.readonlySettings), { rpcUrl: e6 }) }), n4), [e6, t6]);
}
t(Wi2, "useReadonlySDK");
function Lt2(e6) {
  return detect2(e6);
}
t(Lt2, "detectEnv");
function ue2() {
  let e6 = ce();
  return e6 ? e6.toLowerCase().includes("android") : false;
}
t(ue2, "isAndroid");
function _t() {
  let e6 = ce();
  return e6 ? e6.toLowerCase().includes("ios") || e6.toLowerCase().includes("mac") && navigator.maxTouchPoints > 1 : false;
}
t(_t, "isIOS");
function ce() {
  let e6 = Lt2();
  return e6 != null && e6.os ? e6.os : void 0;
}
t(ce, "detectOS");
function Te2() {
  return ce() ? ue2() || _t() : false;
}
t(Te2, "isMobile");
function Gi() {
  var c5;
  let [e6, t6] = N6();
  if (e6.loading)
    return () => Promise.reject("Metamask connector not ready to be used, yet");
  let n4 = typeof window < "u" && ((c5 = window.ethereum) == null ? void 0 : c5.isMetaMask), r6 = Te2() && !n4, o6 = e6.data.connectors.find((m6) => m6.id === "injected"), a5 = e6.data.connectors.find((m6) => m6.id === "walletConnect"), s6 = (r6 ? a5 : o6) || o6;
  return invariant(s6, "No connector found, please make sure you provide the InjectedConnector to your <ThirdwebProvider />"), async () => {
    if (!n4) {
      let m6 = `https://metamask.app.link/dapp/${window.location.host + window.location.pathname + window.location.search}`;
      if (r6 && s6.id === "walletConnect")
        try {
          m6 = (await s6.getProvider()).connector.uri, m6 = ue2() ? m6 : `https://metamask.app.link/dapp/${window.location.host + window.location.pathname + window.location.search}`;
        } catch (g7) {
          console.warn("failed to get provider.connector.uri", g7);
        }
      return window.open(m6, "_blank"), Promise.resolve({ error: new Error("metamask not injected") });
    }
    return await t6(s6);
  };
}
t(Gi, "useMetamask");
function $i() {
  let [e6, t6] = N6();
  if (e6.loading)
    return () => Promise.reject("WalletConnect connector not ready to be used, yet");
  let n4 = e6.data.connectors.find((r6) => r6.id === "walletConnect");
  return invariant(n4, "WalletConnect connector not found, please make sure it is provided to your <ThirdwebProvider />"), () => t6(n4);
}
t($i, "useWalletConnect");
function Ot2() {
  let [e6, t6] = N6();
  if (e6.loading)
    return () => Promise.reject("Coinbase connector not ready to be used, yet");
  let n4 = e6.data.connectors.find((r6) => r6.id === "coinbasewallet");
  return invariant(n4, "Coinbase connector not found, please make sure it is provided to your <ThirdwebProvider />"), () => t6(n4);
}
t(Ot2, "useCoinbaseWallet");
function tr2() {
  return Ot2();
}
t(tr2, "useWalletLink");
function ar2() {
  let [e6, t6] = N6();
  if (e6.loading)
    return () => Promise.reject("Gnosis connector not ready to be used, yet");
  let n4 = e6.data.connectors.find((r6) => r6.id === "gnosis");
  return invariant(n4, "Gnosis connector not found, please make sure it is provided to your <ThirdwebProvider />"), async (r6) => {
    let o6 = e6.data.connector, a5 = await (o6 == null ? void 0 : o6.getChainId());
    return invariant(!!o6, "Cannot connect to Gnosis Safe without first being connected to a personal wallet."), invariant(a5 === r6.safeChainId, "Gnosis safe chain id must match personal wallet chain id."), invariant(utils_exports.isAddress(r6.safeAddress), "Gnosis safe address must be a valid address."), n4.setConfiguration(o6, r6), t6(n4);
  };
}
t(ar2, "useGnosis");
function lr() {
  let [e6, t6] = N6();
  if (e6.loading)
    return () => Promise.reject("Magic connector not ready to be used, yet");
  let n4 = e6.data.connectors.find((r6) => r6.id === "magic");
  return invariant(n4, "Magic connector not found, please make sure it is provided to your <ThirdwebProvider />"), (r6) => (n4.setConfiguration(r6), t6(n4));
}
t(lr, "useMagic");
function Pe2() {
  var e6;
  return (e6 = useNetwork()["0"].data.chain) == null ? void 0 : e6.id;
}
t(Pe2, "useChainId");
function gr2() {
  let e6 = Ee(), t6 = Pe2();
  return e6 === -1 || !t6 ? false : e6 !== t6;
}
t(gr2, "useNetworkMismatch");
function vr2() {
  return useNetwork();
}
t(vr2, "useNetwork");
var Bt2 = "https://gateway.ipfscdn.io/ipfs/";
var ke = { gatewayUrl: Bt2 };
function Ie2(e6, t6 = ke) {
  if (!!e6)
    return e6.startsWith("ipfs://") ? e6.replace("ipfs://", t6.gatewayUrl) : e6;
}
t(Ie2, "resolveIpfsUri");
async function Me2(e6) {
  var r6;
  if (!e6)
    return;
  let t6 = import_lite.default.getType(e6);
  if (t6)
    return t6;
  let n4 = await fetch(e6, { method: "HEAD" });
  if (n4.ok && n4.headers.has("content-type"))
    return (r6 = n4.headers.get("content-type")) != null ? r6 : void 0;
}
t(Me2, "resolveMimeType");
var le2;
function Ht2(e6) {
  return typeof window > "u" || !e6 || !e6.startsWith("video/") ? "" : (le2 || (le2 = document.createElement("video")), le2.canPlayType(e6));
}
t(Ht2, "supportsVideoType");
function Ne2(e6) {
  return !!Ht2(e6);
}
t(Ne2, "shouldRenderVideoTag");
var de2;
function Gt2(e6) {
  return typeof window > "u" || !e6 || !e6.startsWith("audio/") ? "" : (de2 || (de2 = document.createElement("audio")), de2.canPlayType(e6));
}
t(Gt2, "supportsAudioType");
function Ue2(e6) {
  return !!Gt2(e6);
}
t(Ue2, "shouldRenderAudioTag");
function pe(e6) {
  return (t6) => {
    e6.forEach((n4) => {
      typeof n4 == "function" ? n4(t6) : n4 != null && (n4.current = t6);
    });
  };
}
t(pe, "mergeRefs");
function j7() {
  return j7 = Object.assign || function(e6) {
    for (var t6 = 1; t6 < arguments.length; t6++) {
      var n4 = arguments[t6];
      for (var r6 in n4)
        Object.prototype.hasOwnProperty.call(n4, r6) && (e6[r6] = n4[r6]);
    }
    return e6;
  }, j7.apply(this, arguments);
}
t(j7, "_extends");
var Re2 = t((e6) => import_react14.default.createElement("svg", j7({ width: "1em", height: "1em", viewBox: "0 0 32 32" }, e6), import_react14.default.createElement("circle", { cx: "9", cy: "28.5", r: "1.5", fill: "currentColor" }), import_react14.default.createElement("path", { fill: "currentColor", d: "M10 25H8v-4h2a2 2 0 0 0 0-4H8a2.002 2.002 0 0 0-2 2v.5H4V19a4.005 4.005 0 0 1 4-4h2a4 4 0 0 1 0 8Z" }), import_react14.default.createElement("path", { fill: "currentColor", d: "m27.7 9.3l-7-7A.908.908 0 0 0 20 2H10a2.006 2.006 0 0 0-2 2v8h2V4h8v6a2.006 2.006 0 0 0 2 2h6v16H14v2h12a2.006 2.006 0 0 0 2-2V10a.91.91 0 0 0-.3-.7ZM20 10V4.4l5.6 5.6Z" })), "CarbonDocumentUnknown");
var Le2 = t((e6) => import_react14.default.createElement("svg", j7({ width: "1em", height: "1em", viewBox: "0 0 32 32" }, e6), import_react14.default.createElement("path", { fill: "currentColor", d: "M29 31a.999.999 0 0 1-.625-.22L23.65 27H20a1 1 0 0 1-1-1v-5a1 1 0 0 1 1-1h3.65l4.726-3.78A1 1 0 0 1 30 17v13a1 1 0 0 1-1 1Zm-8-6h3a1 1 0 0 1 .625.22L28 27.92v-8.84l-3.376 2.7A1 1 0 0 1 24 22h-3Z" }), import_react14.default.createElement("path", { fill: "currentColor", d: "M16 28H8V4h8v6a2.006 2.006 0 0 0 2 2h6v3h2v-5a.91.91 0 0 0-.3-.7l-7-7A.909.909 0 0 0 18 2H8a2.006 2.006 0 0 0-2 2v24a2.006 2.006 0 0 0 2 2h8Zm2-23.6l5.6 5.6H18Z" })), "CarbonDocumentAudio");
var _e2 = t((e6) => import_react14.default.createElement("svg", j7({ width: "1em", height: "1em", viewBox: "0 0 32 32" }, e6), import_react14.default.createElement("path", { fill: "currentColor", d: "M12 6h-2a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2zm10 0h-2a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2z" })), "CarbonPauseFilled");
var De2 = t((e6) => import_react14.default.createElement("svg", j7({ width: "1em", height: "1em", viewBox: "0 0 32 32" }, e6), import_react14.default.createElement("path", { fill: "currentColor", d: "M7 28a1 1 0 0 1-1-1V5a1 1 0 0 1 1.482-.876l20 11a1 1 0 0 1 0 1.752l-20 11A1 1 0 0 1 7 28Z" })), "CarbonPlayFilledAlt");
function k7() {
  return k7 = Object.assign || function(e6) {
    for (var t6 = 1; t6 < arguments.length; t6++) {
      var n4 = arguments[t6];
      for (var r6 in n4)
        Object.prototype.hasOwnProperty.call(n4, r6) && (e6[r6] = n4[r6]);
    }
    return e6;
  }, k7.apply(this, arguments);
}
t(k7, "_extends");
var fe2 = t(({ onClick: e6, isPlaying: t6 }) => {
  let [n4, r6] = (0, import_react15.useState)(false), o6 = t(() => r6(true), "onMouseEnter"), a5 = t(() => r6(false), "onMouseLeave"), s6 = t(() => r6(false), "onMouseDown"), c5 = t(() => r6(true), "onMouseUp");
  return import_react15.default.createElement("button", { style: r({ position: "absolute", bottom: 0, right: 0, transform: "translate(-25%, -25%)", maxWidth: "32px", width: "8%", minWidth: "24px", aspectRatio: "1", zIndex: 3, backgroundColor: "#fff", color: "rgb(138, 147, 155)", display: "grid", placeItems: "center", borderRadius: "50%", border: "1px solid rgb(229, 232, 235)", cursor: "pointer" }, n4 ? { color: "rgb(53, 56, 64)", boxShadow: "rgb(4 17 29 / 25%) 0px 0px 8px 0px" } : {}), onClick: e6, onMouseEnter: o6, onMouseLeave: a5, onMouseDown: s6, onMouseUp: c5 }, t6 ? import_react15.default.createElement(_e2, { style: { width: "66%", height: "66%" } }) : import_react15.default.createElement(De2, { style: { width: "66%", height: "66%" } }));
}, "PlayButton");
var $t2 = import_react15.default.forwardRef((h6, p7) => {
  var w8 = h6, { src: e6, alt: t6, poster: n4, requireInteraction: r6, children: o6, style: a5, width: s6, height: c5, controls: m6 } = w8, g7 = v(w8, ["src", "alt", "poster", "requireInteraction", "children", "style", "width", "height", "controls"]);
  let v9 = (0, import_react15.useRef)(null), [P5, L5] = (0, import_react15.useState)(!r6), [y5, E5] = (0, import_react15.useState)(true);
  return (0, import_react15.useEffect)(() => {
    v9.current && (P5 ? v9.current.play() : (v9.current.pause(), v9.current.currentTime = 0));
  }, [P5]), import_react15.default.createElement("div", k7({ style: r({ position: "relative" }, a5) }, g7), import_react15.default.createElement("video", { ref: pe([v9, p7]), src: e6 != null ? e6 : void 0, poster: n4 != null ? n4 : void 0, loop: true, playsInline: true, muted: y5, preload: n4 ? "metadata" : "auto", onCanPlay: () => {
    var U3;
    P5 && ((U3 = v9.current) == null || U3.play());
  }, width: s6, height: c5, controls: m6, style: { height: "100%", width: "100%", objectFit: "contain", zIndex: 1, transition: "opacity .5s", opacity: n4 ? P5 ? 1 : 0 : 1 } }), n4 && import_react15.default.createElement("img", { src: n4, style: { objectFit: "contain", pointerEvents: "none", position: "absolute", width: "100%", height: "100%", zIndex: 2, transition: "opacity .5s", opacity: P5 ? 0 : 1, top: 0, left: 0, right: 0, bottom: 0 } }), import_react15.default.createElement(fe2, { onClick: () => {
    L5((U3) => !U3), E5(false);
  }, isPlaying: P5 }));
});
var Jt2 = import_react15.default.forwardRef((h6, p7) => {
  var w8 = h6, { src: e6, alt: t6, poster: n4, requireInteraction: r6, children: o6, style: a5, height: s6, width: c5, controls: m6 } = w8, g7 = v(w8, ["src", "alt", "poster", "requireInteraction", "children", "style", "height", "width", "controls"]);
  let v9 = (0, import_react15.useRef)(null), [P5, L5] = (0, import_react15.useState)(false), [y5, E5] = (0, import_react15.useState)(true);
  return (0, import_react15.useEffect)(() => {
    v9.current && (P5 ? v9.current.play() : (v9.current.pause(), v9.current.currentTime = 0));
  }, [P5]), import_react15.default.createElement("div", k7({ style: r({ position: "relative" }, a5) }, g7), n4 ? import_react15.default.createElement("img", { height: s6, width: c5, src: n4, style: { height: "100%", width: "100%", pointerEvents: "none", objectFit: "contain" } }) : import_react15.default.createElement("div", { style: { width: "100%", height: "100%", display: "grid", placeItems: "center", pointerEvents: "none", backgroundColor: "#fff", color: "rgb(138, 147, 155)" } }, import_react15.default.createElement(Le2, { style: { height: "64px", width: "64px" } })), import_react15.default.createElement(fe2, { onClick: () => {
    L5((U3) => !U3), E5(false);
  }, isPlaying: P5 }), import_react15.default.createElement("audio", { ref: pe([v9, p7]), src: e6 != null ? e6 : void 0, loop: true, playsInline: true, muted: y5, style: { position: "absolute", opacity: 0, pointerEvents: "none", zIndex: -1, visibility: "hidden" } }));
});
var Yt = import_react15.default.forwardRef((h6, p7) => {
  var w8 = h6, { src: e6, alt: t6, poster: n4, requireInteraction: r6, children: o6, style: a5, height: s6, width: c5, controls: m6 } = w8, g7 = v(w8, ["src", "alt", "poster", "requireInteraction", "children", "style", "height", "width", "controls"]);
  let { observe: v9, width: P5 } = index_esm_default(), [L5, y5] = (0, import_react15.useState)(!r6);
  return P5 < 300 ? import_react15.default.createElement("div", { ref: v9 }, import_react15.default.createElement(We2, k7({ style: a5, src: e6, alt: t6 }, g7))) : import_react15.default.createElement("div", k7({ style: r({ position: "relative" }, a5) }, g7, { ref: v9 }), import_react15.default.createElement("iframe", { src: L5 && e6 != null ? e6 : void 0, ref: p7, style: { objectFit: "contain", zIndex: 1, height: "100%", width: "100%", transition: "opacity .5s", opacity: n4 ? L5 ? 1 : 0 : 1 } }), n4 && import_react15.default.createElement("img", { src: n4, style: { objectFit: "contain", pointerEvents: "none", position: "absolute", width: "100%", height: "100%", zIndex: 2, transition: "opacity .5s", opacity: L5 ? 0 : 1, top: 0, left: 0, right: 0, bottom: 0 } }), import_react15.default.createElement(fe2, { onClick: () => {
    y5((E5) => !E5);
  }, isPlaying: L5 }));
});
var We2 = import_react15.default.forwardRef((h6, p7) => {
  var w8 = h6, { src: e6, alt: t6, poster: n4, requireInteraction: r6, children: o6, style: a5, height: s6, width: c5, controls: m6 } = w8, g7 = v(w8, ["src", "alt", "poster", "requireInteraction", "children", "style", "height", "width", "controls"]);
  return import_react15.default.createElement("div", k7({ style: r({ position: "relative" }, a5) }, g7), import_react15.default.createElement("div", { style: { width: "100%", height: "100%", display: "grid", placeItems: "center", backgroundColor: "#fff", color: "rgb(138, 147, 155)" } }, import_react15.default.createElement("div", { style: { display: "flex", flexDirection: "column", gap: "8px", alignItems: "center", flexWrap: "nowrap" } }, import_react15.default.createElement(Re2, { style: { maxWidth: "128px", minWidth: "48px", width: "50%", aspectRatio: "1" } }), import_react15.default.createElement("a", { rel: "noopener noreferrer", style: { textDecoration: "underline", color: "rgb(138, 147, 155)" }, href: e6 != null ? e6 : void 0, target: "_blank", ref: p7 }, t6 || "File"))));
});
var je2 = import_react15.default.forwardRef((m6, c5) => {
  var g7 = m6, { children: e6, src: t6, poster: n4, alt: r6, requireInteraction: o6 = false, style: a5 } = g7, s6 = v(g7, ["children", "src", "poster", "alt", "requireInteraction", "style"]);
  let p7 = r({ objectFit: "contain" }, a5), h6 = Fe(t6 != null ? t6 : void 0), w8 = Fe(n4 != null ? n4 : void 0);
  if (h6.mimeType) {
    if (h6.mimeType === "text/html")
      return import_react15.default.createElement(Yt, k7({ style: p7, src: h6.url, poster: w8.url, requireInteraction: o6 }, s6));
    if (Ne2(h6.mimeType))
      return import_react15.default.createElement($t2, k7({ style: p7, src: h6.url, poster: w8.url, requireInteraction: o6 }, s6));
    if (Ue2(h6.mimeType))
      return import_react15.default.createElement(Jt2, k7({ style: p7, src: h6.url, poster: w8.url, requireInteraction: o6 }, s6));
    if (h6.mimeType.startsWith("image/"))
      return import_react15.default.createElement("img", k7({ style: p7, src: h6.url, alt: r6, ref: c5 }, s6));
  } else
    return import_react15.default.createElement("img", k7({ style: p7 }, s6, { ref: c5 }));
  return import_react15.default.createElement(We2, k7({ style: p7, src: h6.url, alt: r6, ref: c5 }, s6));
});
function Fe(e6) {
  let t6 = (0, import_react15.useMemo)(() => Ie2(e6), [e6]), n4 = useQuery(["mime-type", t6], () => Me2(t6), { enabled: !!t6 });
  return { url: t6, mimeType: n4.data };
}
t(Fe, "useResolvedMediaType");
function me() {
  return me = Object.assign || function(e6) {
    for (var t6 = 1; t6 < arguments.length; t6++) {
      var n4 = arguments[t6];
      for (var r6 in n4)
        Object.prototype.hasOwnProperty.call(n4, r6) && (e6[r6] = n4[r6]);
    }
    return e6;
  }, me.apply(this, arguments);
}
t(me, "_extends");
var Or2 = import_react16.default.forwardRef((r6, n4) => {
  var o6 = r6, { metadata: e6 } = o6, t6 = v(o6, ["metadata"]);
  return import_react16.default.createElement(je2, me({ src: e6.animation_url || e6.image, poster: e6.image, alt: e6.name, ref: n4 }, t6));
});
var Qe2 = "tw-cache";
function Be2(e6) {
  return e6[0] === Qe2 ? e6 : [Qe2, ...e6];
}
t(Be2, "createCachekey");
function S4(e6 = lib_exports7.AddressZero, t6) {
  return Be2(["contract", e6, ...t6]);
}
t(S4, "createContractCacheKey");
function T7(e6, t6) {
  return u6.network.active(t6).concat(e6);
}
t(T7, "createCacheKeyWithNetwork");
var u6 = { network: { active: (e6) => Be2(["chainId", e6]) }, contract: { type: (e6) => S4(e6, ["contract-type"]), publishMetadata: (e6) => S4(e6, ["publish-metadata"]), typeAndPublishMetadata: (e6) => S4(e6, ["contract-type-and-metadata"]), metadata: (e6) => S4(e6, ["metadata"]), extractFunctions: (e6) => S4(e6, ["extractFunctions"]), nft: { get: (e6, t6) => S4(e6, ["get", { tokenId: t6 }]), balanceOf: (e6, t6, n4) => S4(e6, ["balanceOf", { owner: t6, tokenId: n4 }]), query: { all: (e6, t6) => S4(e6, t6 ? ["query", "all", t6] : ["query", "all"]), totalCirculatingSupply: (e6) => S4(e6, ["query", "totalCirculatingSupply"]), owned: { all: (e6, t6) => S4(e6, ["query", "owned", "all", t6]) } }, drop: { getAllUnclaimed: (e6, t6) => S4(e6, t6 ? ["getAllUnclaimed", t6] : ["getAllUnclaimed"]), totalUnclaimedSupply: (e6) => S4(e6, ["totalUnclaimedSupply"]), totalClaimedSupply: (e6) => S4(e6, ["totalClaimedSupply"]) } }, token: { totalSupply: (e6) => S4(e6, ["totalSupply"]), balanceOf: (e6, t6) => S4(e6, ["balanceOf", { walletAddress: t6 }]) }, marketplace: { getAllListings: (e6, t6) => S4(e6, t6 ? ["getAllListings", t6] : ["getAllListings"]), getActiveListings: (e6, t6) => S4(e6, t6 ? ["getActiveListings", t6] : ["getActiveListings"]) } }, extensions: { claimConditions: { getActive: (e6, t6) => S4(e6, t6 ? ["claimConditions", "getActive", { tokenId: t6 }] : ["claimConditions", "getActive"]), getAll: (e6, t6) => S4(e6, t6 ? ["claimConditions", "getActive", { tokenId: t6 }] : ["claimConditions", "getActive"]), getClaimIneligibilityReasons: (e6, t6, n4) => S4(e6, n4 ? ["claimConditions", "getActive", { tokenId: n4 }, t6] : ["claimConditions", "getActive", t6]) } } };
function C4(e6, t6, n4) {
  let r6 = M5(), o6 = s(r({}, n4), { enabled: !!(r6 && (n4 == null ? void 0 : n4.enabled)) });
  return useQuery(T7(e6, r6), t6, o6);
}
t(C4, "useQueryWithNetwork");
async function He2(e6, t6) {
  if (!(!e6 || !t6))
    try {
      return await t6.resolveContractType(e6);
    } catch {
      return "custom";
    }
}
t(He2, "fetchContractType");
async function Ge2(e6, t6) {
  if (!(!e6 || !t6))
    return await (await t6.getPublisher()).fetchContractMetadataFromAddress(e6);
}
t(Ge2, "fetchContractPublishMetadata");
async function ge(e6, t6, n4) {
  if (!t6 || !n4)
    return;
  let r6 = await e6.fetchQuery(T7(u6.contract.type(t6), n4._chainId), () => He2(t6, n4), { staleTime: 1 / 0 });
  if (r6 !== "custom")
    return { contractType: r6, publishMetadata: null };
  let o6 = await e6.fetchQuery(T7(u6.contract.publishMetadata(t6), n4._chainId), () => Ge2(t6, n4), { staleTime: 1 / 0 });
  return { contractType: r6, publishMetadata: o6 };
}
t(ge, "fetchContractTypeAndPublishMetadata");
function ze2(e6) {
  var n4;
  if (!e6 || !e6.contractType)
    return null;
  let t6 = null;
  return e6.contractType !== "custom" && (t6 = Oi[e6.contractType].contractAbi), e6.contractType === "custom" && e6.publishMetadata && (t6 = (n4 = e6.publishMetadata) == null ? void 0 : n4.abi), t6;
}
t(ze2, "getContractAbi");
function ye2(e6, t6, n4) {
  if (!t6 || !n4 || !e6 || !t6.contractType)
    return null;
  let r6 = ze2(t6);
  return invariant(r6, `could not resolve any ABI for contract${e6}`), n4.getContractFromAbi(e6, r6);
}
t(ye2, "getContractFromCombinedTypeAndPublishMetadata");
function Yr2(e6) {
  var o6;
  let t6 = _7(), n4 = Ze2(e6);
  if (!e6 || !t6 || !((o6 = n4.data) != null && o6.contractType))
    return s(r({}, n4), { abi: null });
  let r6 = ze2(n4.data);
  return s(r({}, n4), { abi: r6 });
}
t(Yr2, "useContractAbi");
function eo2(e6) {
  let t6 = _7();
  return C4(u6.contract.type(e6), () => He2(e6, t6), { enabled: !!t6 && !!e6, staleTime: 1 / 0 });
}
t(eo2, "useContractType");
function to(e6) {
  let t6 = _7();
  return C4(u6.contract.publishMetadata(e6), () => Ge2(e6, t6), { enabled: !!t6 && !!e6, staleTime: 1 / 0 });
}
t(to, "useContractPublishMetadata");
function Ze2(e6) {
  let t6 = _7(), n4 = useQueryClient();
  return C4(u6.contract.typeAndPublishMetadata(e6), () => ge(n4, e6, t6), { enabled: !!t6 && !!e6, staleTime: 1 / 0 });
}
t(Ze2, "useContractTypeAndPublishMetadata");
function no2(e6) {
  var o6;
  let t6 = _7(), n4 = Ze2(e6);
  if (!e6 || !t6 || !((o6 = n4.data) != null && o6.contractType))
    return s(r({}, n4), { contract: null });
  let r6 = ye2(e6, n4.data, t6);
  return s(r({}, n4), { contract: r6 });
}
t(no2, "useContract");
function io2(e6) {
  let t6 = _7(), n4 = useQueryClient(), r6 = M5();
  return C4(u6.contract.metadata(e6), async () => {
    var s6;
    let o6 = await n4.fetchQuery(T7(u6.contract.typeAndPublishMetadata(e6), r6), () => ge(n4, e6, t6), { staleTime: 1 / 0 }), a5 = ye2(e6, o6, t6);
    return invariant((s6 = a5 == null ? void 0 : a5.metadata) == null ? void 0 : s6.get, "contract metadata is not available"), await a5.metadata.get();
  }, { enabled: !!e6 || !!t6 });
}
t(io2, "useContractMetadata");
function ro2(e6) {
  let t6 = _7(), n4 = useQueryClient(), r6 = M5();
  return C4(u6.contract.extractFunctions(e6), async () => {
    let o6 = await n4.fetchQuery(T7(u6.contract.typeAndPublishMetadata(e6), r6), () => ge(n4, e6, t6), { staleTime: 1 / 0 }), a5 = ye2(e6, o6, t6);
    return a5 instanceof Pe ? a5.publishedMetadata.extractFunctions() : null;
  }, { enabled: !!e6 || !!t6, staleTime: 1 / 0 });
}
t(ro2, "useContractFunctions");
function mo(e6) {
  if (!!e6) {
    if (e6 instanceof Ve)
      return e6;
    if ("nft" in e6 && e6.nft instanceof Ve)
      return e6.nft;
  }
}
t(mo, "detectErc721Instance");
function ho2(e6) {
  if (!!e6) {
    if (e6 instanceof qe)
      return e6;
    if ("nft" in e6 && e6.nft instanceof qe)
      return e6.nft;
  }
}
t(ho2, "detectErc1155Instance");
function $e2(e6, t6) {
  return e6 instanceof Ve ? r({ type: "ERC721", supply: 1, owner: "" }, t6) : r({ type: "ERC1155", supply: 0, owner: "" }, t6);
}
t($e2, "convertResponseToNFTType");
function Ce2(e6, t6) {
  return t6.map((n4) => $e2(e6, n4));
}
t(Ce2, "convertResponseToNFTTypeArray");
function go2(e6, t6) {
  let n4 = e6 == null ? void 0 : e6.getAddress();
  return C4(u6.contract.nft.get(n4, t6), async () => (invariant(e6, "No Contract instance provided"), invariant(e6.get, "Contract instance does not support get"), $e2(e6, await e6.get(BigNumber.from(t6 || 0)))), { enabled: !!e6 && t6 !== void 0 });
}
t(go2, "useNFT");
function sn2(e6, t6) {
  let n4 = e6 == null ? void 0 : e6.getAddress();
  return C4(u6.contract.nft.query.all(n4, t6), async () => {
    var r6;
    return invariant(e6, "No Contract instance provided"), invariant((r6 = e6.query) == null ? void 0 : r6.all, "Contract instance does not support query.all"), Ce2(e6, await e6.query.all(t6));
  }, { enabled: !!e6 || !n4, keepPreviousData: true });
}
t(sn2, "useNFTs");
function yo(e6) {
  let t6 = e6 == null ? void 0 : e6.getAddress();
  return C4(u6.contract.nft.query.totalCirculatingSupply(t6), () => {
    var n4, r6;
    return invariant(e6, "No Contract instance provided"), e6 instanceof Ve ? (invariant((n4 = e6 == null ? void 0 : e6.query) == null ? void 0 : n4.totalCirculatingSupply, "Contract instance does not support query.totalCirculatingSupply"), e6.query.totalCirculatingSupply()) : (invariant((r6 = e6.query) == null ? void 0 : r6.getTotalCount, "Contract instance does not support query.getTotalCount"), e6.query.getTotalCount());
  }, { enabled: !!e6 });
}
t(yo, "useTotalCirculatingSupply");
function Co(e6, t6) {
  let n4 = e6 == null ? void 0 : e6.getAddress();
  return C4(u6.contract.nft.query.owned.all(n4, t6), async () => {
    var r6, o6, a5;
    return invariant(e6, "No Contract instance provided"), e6 instanceof Ve ? (invariant((o6 = (r6 = e6.query) == null ? void 0 : r6.owned) == null ? void 0 : o6.all, "Contract instance does not support query.owned.all"), Ce2(e6, await e6.query.owned.all(t6))) : (invariant((a5 = e6.query) == null ? void 0 : a5.owned, "Contract instance does not support query.owned"), Ce2(e6, await e6.query.owned(t6)));
  }, { enabled: !!e6 && !!t6 });
}
t(Co, "useOwnedNFTs");
function vo(...[e6, t6, n4]) {
  let r6 = e6 == null ? void 0 : e6.getAddress();
  return C4(u6.contract.nft.balanceOf(r6, t6, n4), () => (invariant(e6, "No Contract instance provided"), invariant(e6.balanceOf, "Contract instance does not support balanceOf"), invariant(t6, "No owner wallet address provided"), e6 instanceof qe ? (invariant(n4, "No tokenId provided"), e6.balanceOf(t6, n4)) : e6.balanceOf(t6)), { enabled: !!e6 && !!t6 });
}
t(vo, "useNFTBalance");
function wo2(e6, t6) {
  let n4 = e6 == null ? void 0 : e6.getAddress();
  return C4(u6.contract.nft.drop.getAllUnclaimed(n4, t6), () => (invariant(e6, "No Contract instance provided"), invariant(e6.getAllUnclaimed, "Contract instance does not support getAllUnclaimed"), e6.getAllUnclaimed(t6)), { enabled: !!e6 });
}
t(wo2, "useUnclaimedNFTs");
function bo(e6, t6) {
  return sn2(e6, t6);
}
t(bo, "useClaimedNFTs");
function xo(e6) {
  let t6 = e6 == null ? void 0 : e6.getAddress();
  return C4(u6.contract.nft.drop.totalUnclaimedSupply(t6), () => (invariant(e6, "No Contract instance provided"), invariant(e6.totalUnclaimedSupply, "Contract instance does not support totalUnclaimedSupply"), e6.totalUnclaimedSupply()), { enabled: !!e6 });
}
t(xo, "useUnclaimedNFTSupply");
function Ao2(e6) {
  let t6 = e6 == null ? void 0 : e6.getAddress();
  return C4(u6.contract.nft.drop.totalClaimedSupply(t6), () => (invariant(e6, "No Contract instance provided"), invariant(e6.totalClaimedSupply, "Contract instance does not support totalClaimedSupply"), e6.totalClaimedSupply()), { enabled: !!e6 });
}
t(Ao2, "useClaimedNFTSupply");
function So2(e6) {
  let t6 = M5(), n4 = e6 == null ? void 0 : e6.getAddress(), r6 = useQueryClient();
  return useMutation(async (o6) => {
    var a5;
    if (invariant(o6.to, 'No "to" address provided'), invariant((a5 = e6 == null ? void 0 : e6.mint) == null ? void 0 : a5.to, "contract does not support mint.to"), e6 instanceof qe) {
      invariant("supply" in o6, "supply not provided");
      let { to: s6, metadata: c5, supply: m6 } = o6;
      return await e6.mint.to(s6, { metadata: c5, supply: BigNumber.from(m6 || 1) });
    }
    return await e6.mint.to(o6.to, o6.metadata);
  }, { onSuccess: () => Promise.all([r6.invalidateQueries(T7(u6.contract.nft.query.all(n4), t6)), r6.invalidateQueries(T7(u6.contract.nft.query.totalCirculatingSupply(n4), t6))]) });
}
t(So2, "useMintNFT");
function Uo2(e6, t6) {
  let n4 = e6 == null ? void 0 : e6.getAddress();
  return C4(u6.contract.marketplace.getAllListings(n4, t6), () => (invariant(e6, "No Contract instance provided"), e6.getAllListings(t6)), { enabled: !!e6 || !n4, keepPreviousData: true });
}
t(Uo2, "useAllListings");
function Ro(e6, t6) {
  let n4 = e6 == null ? void 0 : e6.getAddress();
  return C4(u6.contract.marketplace.getActiveListings(n4, t6), () => (invariant(e6, "No Contract instance provided"), e6.getActiveListings(t6)), { enabled: !!e6 || !n4, keepPreviousData: true });
}
t(Ro, "useActiveListings");
function Lo2(e6) {
  let t6 = M5(), n4 = e6 == null ? void 0 : e6.getAddress(), r6 = useQueryClient(), o6 = se();
  return useMutation(async (a5) => {
    var s6;
    return invariant(o6, "no wallet connected, cannot create listing"), invariant((s6 = e6 == null ? void 0 : e6.direct) == null ? void 0 : s6.createListing, "contract does not support direct.createListing"), await e6.direct.createListing(a5);
  }, { onSuccess: () => Promise.all([r6.invalidateQueries(T7(u6.contract.marketplace.getAllListings(n4), t6)), r6.invalidateQueries(T7(u6.contract.marketplace.getActiveListings(n4), t6))]) });
}
t(Lo2, "useCreateDirectListing");
function _o2(e6) {
  let t6 = M5(), n4 = e6 == null ? void 0 : e6.getAddress(), r6 = useQueryClient(), o6 = se();
  return useMutation(async (a5) => {
    var s6;
    return invariant(o6, "no wallet connected, cannot create listing"), invariant((s6 = e6 == null ? void 0 : e6.direct) == null ? void 0 : s6.createListing, "contract does not support auction.createListing"), await e6.auction.createListing(a5);
  }, { onSuccess: () => Promise.all([r6.invalidateQueries(T7(u6.contract.marketplace.getAllListings(n4), t6)), r6.invalidateQueries(T7(u6.contract.marketplace.getActiveListings(n4), t6))]) });
}
t(_o2, "useCreateAuctionListing");
function Ko2(e6) {
  let t6 = e6 == null ? void 0 : e6.getAddress();
  return C4(u6.contract.token.totalSupply(t6), () => (invariant(e6, "No Contract instance provided"), e6.totalSupply()), { enabled: !!e6 || !!t6 });
}
t(Ko2, "useTokenSupply");
function Qo(e6, t6) {
  let n4 = e6 == null ? void 0 : e6.getAddress();
  return C4(u6.contract.token.balanceOf(n4, t6), async () => (invariant(e6, "No Contract instance provided"), invariant(t6, "No address provided"), await e6.balanceOf(t6)), { enabled: !!t6 && !!e6 });
}
t(Qo, "useTokenBalance");
function Bo2(e6) {
  let t6 = M5(), n4 = e6 == null ? void 0 : e6.getAddress(), r6 = useQueryClient();
  return useMutation((o6) => {
    var c5;
    let { to: a5, amount: s6 } = o6;
    return invariant((c5 = e6 == null ? void 0 : e6.mint) == null ? void 0 : c5.to, "contract does not support mint.to"), e6.mint.to(a5, s6);
  }, { onSuccess: (o6, a5) => Promise.all([r6.invalidateQueries(T7(u6.contract.token.totalSupply(n4), t6)), r6.invalidateQueries(T7(u6.contract.token.balanceOf(n4, a5.to), t6))]) });
}
t(Bo2, "useMintToken");
function Xo(...[e6, t6]) {
  let n4 = e6 == null ? void 0 : e6.getAddress();
  return C4(u6.extensions.claimConditions.getActive(n4, t6), () => (invariant(e6, "No Contract instance provided"), invariant(e6.claimConditions.getActive, "Contract instance does not support claimConditions.getActive"), e6 instanceof qe ? (invariant(t6, "tokenId is required for ERC1155 claim conditions"), e6.claimConditions.getActive(t6)) : e6.claimConditions.getActive()), { enabled: e6 instanceof qe ? t6 !== void 0 : !!e6 });
}
t(Xo, "useActiveClaimCondition");
function $o2(...[e6, t6]) {
  let n4 = e6 == null ? void 0 : e6.getAddress();
  return C4(u6.extensions.claimConditions.getAll(n4, t6), () => (invariant(e6, "No Contract instance provided"), invariant(e6.claimConditions.getAll, "Contract instance does not support claimConditions.getAll"), e6 instanceof qe ? (invariant(t6, "tokenId is required for ERC1155 claim conditions"), e6.claimConditions.getAll(t6)) : e6.claimConditions.getAll()), { enabled: e6 instanceof qe ? t6 !== void 0 : !!e6 });
}
t($o2, "useClaimConditions");
function Jo(...[e6, t6, n4]) {
  let r6 = e6 == null ? void 0 : e6.getAddress();
  return C4(u6.extensions.claimConditions.getClaimIneligibilityReasons(r6, t6, n4), () => (invariant(e6, "No Contract instance provided"), invariant(e6.claimConditions.getClaimIneligibilityReasons, "Contract instance does not support claimConditions.getClaimIneligibilityReasons"), e6 instanceof qe ? (invariant(n4, "tokenId is required for ERC1155 claim ineligibility reasons"), e6.claimConditions.getClaimIneligibilityReasons(n4, t6.quantity, t6.walletAddress)) : e6.claimConditions.getClaimIneligibilityReasons(t6.quantity, t6.walletAddress)), { enabled: (e6 instanceof qe ? n4 !== void 0 : !!e6) && !!t6 });
}
t(Jo, "useClaimIneligibilityReasons");
export {
  T as ChainId,
  Vt as IpfsStorage,
  je2 as MediaRenderer,
  Or2 as ThirdwebNftMedia,
  Fn2 as ThirdwebProvider,
  Pt2 as ThirdwebSDKProvider,
  defaultChains,
  defaultL2Chains,
  ho2 as detectErc1155Instance,
  mo as detectErc721Instance,
  useAccount,
  M5 as useActiveChainId,
  Xo as useActiveClaimCondition,
  Ro as useActiveListings,
  se as useAddress,
  Uo2 as useAllListings,
  A7 as useBuiltinContract,
  Pe2 as useChainId,
  $o2 as useClaimConditions,
  Jo as useClaimIneligibilityReasons,
  Ao2 as useClaimedNFTSupply,
  bo as useClaimedNFTs,
  Ot2 as useCoinbaseWallet,
  N6 as useConnect,
  no2 as useContract,
  Yr2 as useContractAbi,
  ro2 as useContractFunctions,
  io2 as useContractMetadata,
  to as useContractPublishMetadata,
  eo2 as useContractType,
  _o2 as useCreateAuctionListing,
  Lo2 as useCreateDirectListing,
  Ee as useDesiredChainId,
  Li as useDisconnect,
  Vn as useEdition,
  Kn2 as useEditionDrop,
  ar2 as useGnosis,
  lr as useMagic,
  $n2 as useMarketplace,
  Gi as useMetamask,
  So2 as useMintNFT,
  Bo2 as useMintToken,
  go2 as useNFT,
  vo as useNFTBalance,
  ei as useNFTCollection,
  zn2 as useNFTDrop,
  sn2 as useNFTs,
  vr2 as useNetwork,
  gr2 as useNetworkMismatch,
  Co as useOwnedNFTs,
  ii2 as usePack,
  Wi2 as useReadonlySDK,
  Fe as useResolvedMediaType,
  _7 as useSDK,
  Se as useSigner,
  hi as useSplit,
  ai as useToken,
  Qo as useTokenBalance,
  ci2 as useTokenDrop,
  Ko2 as useTokenSupply,
  yo as useTotalCirculatingSupply,
  xo as useUnclaimedNFTSupply,
  wo2 as useUnclaimedNFTs,
  pi2 as useVote,
  $i as useWalletConnect,
  tr2 as useWalletLink
};
/*!
 * EventEmitter2
 * https://github.com/hij1nx/EventEmitter2
 *
 * Copyright (c) 2013 hij1nx
 * Licensed under the MIT license.
 */
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * [js-sha256]{@link https://github.com/emn178/js-sha256}
 *
 * @version 0.9.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2017
 * @license MIT
 */
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
/** @preserve
	(c) 2012 by Cdric Mesnil. All rights reserved.

	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
/** @preserve
 * Counter block mode compatible with  Dr Brian Gladman fileenc.c
 * derived from CryptoJS.mode.CTR
 * Jan Hruby jhruby.web@gmail.com
 */
//# sourceMappingURL=@thirdweb-dev_react.js.map
